<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F05%2F19%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx安装及配置 本文参考： Nginx安装配置_菜鸟教程 Nginx中文文档 Nginx简易教程 概述什么是nginx? Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 什么是反向代理？ 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用安装 nginx官网下载地址：http://nginx.org，发布版本分为 Linux 和 windows 版本。 也可以下载源码，编译后运行。 从源代码编译 Nginx 把源码解压缩之后，在终端里运行如下命令： 123$ ./configure$ make$ sudo make install 默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。 Windows 安装 为了安装 Nginx / Win32，需先下载它(Nginx官方下载)。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： 1nginx-0.8.54 start nginx Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。 使用nginx 的使用比较简单，就是几条命令。 常用到的命令如下： nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen ：重新打开日志文件。 nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v：显示 nginx 的版本。 nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下： 123456789101112@echo offrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程nginx.exe -s stoprem 测试配置文件语法正确性nginx.exe -t -c conf/nginx.confrem 显示版本信息nginx.exe -vrem 按照指定配置去启动nginxnginx.exe -c conf/nginx.conf 如果是运行在 Linux 下，写一个 shell 脚本，大同小异。 配置nginx 配置实战我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。 http反向代理配置我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下：注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#运行用户#user somebody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志error_log D:/Tools/nginx-1.10.1/logs/error.log;error_log D:/Tools/nginx-1.10.1/logs/notice.log notice;error_log D:/Tools/nginx-1.10.1/logs/info.log info;#PID文件，记录当前启动的nginx的进程IDpid D:/Tools/nginx-1.10.1/logs/nginx.pid;#工作模式及连接数上限events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型(邮件支持类型),类型由mime.types文件定义 include D:/Tools/nginx-1.10.1/conf/mime.types; default_type application/octet-stream; #设定日志 log_format main &apos;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log D:/Tools/nginx-1.10.1/logs/access.log main; rewrite_log on; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 120; tcp_nodelay on; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream zp_server1&#123; server 127.0.0.1:8089; &#125; #HTTP服务器 server &#123; #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #首页 index index.html #指向webapp的目录 root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp; #编码格式 charset utf-8; #代理配置参数 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 location / &#123; proxy_pass http://zp_server1; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappiews; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; # root html; #&#125; &#125;&#125; 好了，让我们来试试吧： 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host：在 C:WindowsSystem32driversetc 目录下的host文件中添加一条DNS 记录127.0.0.1 http://www.helloworld.com 启动前文中 startup.bat 的命令 在浏览器中访问 http://www.helloworld.com，不出意外，已经可以访问了。 负载均衡配置上一个例子中，代理仅仅指向一个服务器。 但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。 nginx也可以实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 http://www.helloworld.com，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。 nginx.conf 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #设定负载均衡的服务器列表 upstream load_balance_server &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; #HTTP服务器 server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #对所有请求进行负载均衡请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.html index.htm; #定义首页索引文件的名称 proxy_pass http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表 #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $remote_addr; proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125; &#125;&#125; 网站有多个webapp的配置当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。 举个例子：假如 http://www.helloworld.com 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分: http://www.helloworld.com/finance/ http://www.helloworld.com/product/ http://www.helloworld.com/admin/ 我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。 那么，问题来了，用户在实际访问 http://www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。 配置也不难，来看看怎么做吧： 1234567891011121314151617181920212223242526272829303132333435http &#123; #此处省略一些基本配置 upstream product_server&#123; server www.helloworld.com:8081; &#125; upstream admin_server&#123; server www.helloworld.com:8082; &#125; upstream finance_server&#123; server www.helloworld.com:8083; &#125; server &#123; #此处省略一些基本配置 #默认指向product的server location / &#123; proxy_pass http://product_server; &#125; location /product/&#123; proxy_pass http://product_server; &#125; location /admin/ &#123; proxy_pass http://admin_server; &#125; location /finance/ &#123; proxy_pass http://finance_server; &#125; &#125;&#125; https反向代理配置一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点： HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key 其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 12345678910111213141516171819202122232425#HTTP服务器 server &#123; #监听443端口。443为知名端口号，主要用于HTTPS协议 listen 443 ssl; #定义使用www.xx.com访问 server_name www.helloworld.com; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate cert.pem; #ssl证书key位置 ssl_certificate_key cert.key; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #数字签名，此处使用MD5 ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /root; index index.html index.htm; &#125; &#125; 静态站点配置有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。 举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。 配置如下： 123456789101112131415161718192021222324252627worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png; gzip_vary on; server &#123; listen 80; server_name static.zp.cn; location / &#123; root /app/dist; index index.html; #转发任何请求到 index.html &#125; &#125;&#125; 然后，添加 HOST：127.0.0.1 http://static.zp.cn，此时，在本地浏览器访问 http://static.zp.cn ，就可以访问静态站点了。 跨域解决方案web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。 各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路： CORS在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。 jsonp把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。 这两种思路，本文不展开讨论。 需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。 举例：http://www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。 前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧： 首先，在 enable-cors.conf 文件中设置 cors ： 1234567891011121314151617181920212223242526# allow origin listset $ACAO &apos;*&apos;;# set single originif ($http_origin ~* (www.helloworld.com)$) &#123; set $ACAO $http_origin;&#125;if ($cors = &quot;trueget&quot;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;;&#125;if ($request_method = &apos;OPTIONS&apos;) &#123; set $cors &quot;$&#123;cors&#125;options&quot;;&#125;if ($request_method = &apos;GET&apos;) &#123; set $cors &quot;$&#123;cors&#125;get&quot;;&#125;if ($request_method = &apos;POST&apos;) &#123; set $cors &quot;$&#123;cors&#125;post&quot;;&#125; 接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置： 12345678910111213141516171819202122232425262728# ----------------------------------------------------# 此文件为项目 nginx 配置片段# 可以直接在 nginx config 中 include（推荐）# 或者 copy 到现有 nginx 中，自行配置# www.helloworld.com 域名需配合 dns hosts 进行配置# 其中，api 开启了 cors，需配合本目录下另一份配置文件# ----------------------------------------------------upstream front_server&#123; server www.helloworld.com:9000;&#125;upstream api_server&#123; server www.helloworld.com:8080;&#125;server &#123; listen 80; server_name www.helloworld.com; location ~ ^/api/ &#123; include enable-cors.conf; proxy_pass http://api_server; rewrite &quot;^/api/(.*)$&quot; /$1 break; &#125; location ~ ^/ &#123; proxy_pass http://front_server; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+rtmp]]></title>
    <url>%2F2019%2F05%2F17%2Fnginx-rtmp%2F</url>
    <content type="text"><![CDATA[nginx+rtmp 搭建视频直播服务器服务器安装配置pass windows安装包(已编译好的版本)参考： nginx for windows windows下搭建基于nginx的rtmp服务器 在Windows下搭建基于nginx的视频直播和点播系统 搬运源码（未编译） Car-eye-RTMP-server(github) car-eye-http-flv-module nginx+rtmp在windows下编译 Windows下编译nginx-rtmp-module windows下编译nginx+nginx_rtmp_modue(vs2013) CentOS搭建nginx+rtmp服务器 nginx+rtmp直播流服务搭建 centos7 centos7 Nginx+rtmp 搭建流媒体服务器 linux下建议将nginx.conf中的http端口改为1024以上，好像是80端口每次运行都需要su权限。 nginx服务器常用命令12345678910./nginx -v//查看nginx版本号./nginx -V //查看nginx详细的版本信息start ./nginx -c conf/nginx.conf //以nginx.conf的配置启动nginx./nginx -s stop//停止nginx服务器./nginx -s quit//停止nginx服务器./nginx -s reload//重启nginx服务器service nginx reload//重启nginx服务器./nginx -t (-c conf/nginx.conf)//检查配置文件是否正确./nginx -h//显示帮助信息./nginx -?//显示帮助信息 nginx+rtmp加入权限控制 本文参考： *rtmp-module官方wiki *视频直播点播nginx-rtmp开发手册中文版(参考wiki版本粗译) 如何给 nginx rtmp 服务加入鉴权机制(改源码) *「自己开发直播」实现nginx-rtmp-module多频道输入输出与权限控制 nginx-rtmp-module授权机制实现直播推流多房间授权认证 nginx-rtmp-module 权限控制 nginx-rtmp加入权限验证的简单方法 视频直播点播nginx-rtmp开发手册中文版 *nginx.conf中关于nginx-rtmp-module配置指令详解 *nginx-rtmp多房间和授权实现 *博客比较有用 nginx的rtmp-module默认不限制推流权限、播放权限。 想加入权限验证有很多种方法。 其中一个是改源码，一个是利用nginx+rtmp的配置文件调用后台接口进行验证。 第一种方法没成功过，第二种方法比较简单。此文介绍第二种方法，第一种方法可见博客-&gt;如何给 nginx rtmp 服务加入鉴权机制(改源码) 原理主要是利用on_publish跳转到当前配置的一个“location”，在这里进行验证。关键点在于rtmp application节点下面要配置“notify_method get;”为什么呢？因为跳转的时候，默认以POST方式传输参数，修改成GET方式，nginx配置里就可以轻松处理了。（当然nginx通过配置文件也可以处理post，只是复杂一些）。 我们在此使用python的后台框架flask处理on_publish的post请求。 后台返回http200即为通过验证，返回http500即为验证失败，服务器拒绝连接。 nginx的配置文件（位于nginx安装目录下：…/nginx/conf/nginx.conf）修改如下: 12345678910111213141516171819202122rtmp &#123; server &#123; #listen 1935; listen 10077; chunk_size 4000; application live &#123; live on; on_publish http://localhost:10078/user/auth;//后面的url即flask监听的地址 &#125; application hls &#123; live on; hls on; #hls_path ../nginx-1.7.11.3-Gryphon/html/hls; hls_path ../hls; hls_fragment 5s; on_publish http://localhost:10078/user/auth; &#125; &#125;&#125; python的flask后台代码如下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding:utf-8 -*-#https://www.jianshu.com/p/0d14ae8f081c#https://blog.csdn.net/wei389083222/article/details/78721074/#https://blog.csdn.net/weixin_34368949/article/details/85991563#验证只能用post方法#虽然流密钥的格式像是get类型，但是必须使用POST获取参数。from flask import Flask, request, Responseapp = Flask(__name__)#传入url格式为: xx.xx.xx.xx:10078/user/auth?usr=xxx&amp;passWord=xxx@app.route('/user/auth',methods=['POST'])def auth(): usr = request.form['usr']#从url后获取的数据 passWord = request.form['passWord'] print(usr,'\t',passWord) #此处可改为从数据库获取数据 auth_user='abc' auth_passWord='123' if auth_user == usr and auth_passWord ==passWord: return Response(response='success',status=200)#返回200状态码 else: return Response(status=500)#返回500状态码 #Flask.abort(404) return passWordif __name__ == '__main__': app.run(host='0.0.0.0',port=10078,debug=True) 播放权限也可用类似on_publish的验证方法进行控制。 on_play和on_publish 一样，只接受post方法，若需要接受get方法需要在rtmp中application的配置中添加notify_method get;，然后可在http{}部分中处理调用（这部分语法我不太清楚，不详细展开）。 以下是nginx.conf关于on_play的用法 on_play语法：on_play url上下文：rtmp, server, application描述：设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。 HTTP 2XX 返回码的话继续 RTMP 会话。 HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。 其他返回码的话 RTMP 连接丢弃。重定向例子： 123456789101112131415161718192021222324252627 http &#123; location /local_redirect &#123; rewrite ^.*$ newname? permanent; &#125; location /remote_redirect &#123; # no domain name here, only ip rewrite ^.*$ rtmp://192.168.1.123/someapp/somename? permanent; &#125; &#125; rtmp &#123; application myapp1 &#123; live on; # stream will be redirected to &apos;newname&apos; on_play http://localhost:8080/local_redirect; &#125; application myapp2 &#123; live on; # stream will be pulled from remote location # requires nginx &gt;= 1.3.10 on_play http://localhost:8080/remote_redirect; &#125;&#125; HTTP 请求接收到一些个参数。在 application/x-www-form-urlencoded MIME 类型下使用 POST 方法。以下参数会被传送给调用者： call=play。 addr - 客户端 IP 地址。 app - application 名。 flashVer - 客户端 flash 版本。 swfUrl - 客户端 swf url。 tcUrl - tcUrl。 pageUrl - 客户端页面 url。 name - 流名。出了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100&amp;b=face&amp;foo=bar 访问，然后呢 a,b 和 foo 发送回调。on_play http://example.com/my_callback; 过程中使用到的额外软件 obs 手机端:快直播 ffmpeg推流（没用过）]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPages Synchronization]]></title>
    <url>%2F2019%2F05%2F16%2Fhexo-gitPages-Synchronization%2F</url>
    <content type="text"><![CDATA[Hexo+gitPages 的博客多端同步管理及迁移 本文参考 如何解决github+Hexo的博客多终端同步问题 利用Hexo在多台电脑上提交和更新github pages博客 搭建hexo博客并简单的实现多终端同步 hexo博客同步管理及迁移 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件(包括博客内容主题等等)放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。 同步的首次操作在创建了博客的目录下操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上。 只托管部分用于多终端的同步的文件 注意：使用第三方主题时，要删除第三方主题的.git文件夹删除，不然无法push到远程仓库 1234567git init //初始化本地仓库git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示,其实也可以用'git add .'命令，在.gitignore文件中加入不需要同步的文件即可git commit -m "Blog Source Hexo"git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上 多出来的hexo的分支，用于文件同步，原有的master分支用于部署静态博客页面 在新终端进行更新博客先从github中把文件clone到本地，然后安装相应组件。然后通过git的提交同步内容，用hexo的命令部署博客到gitPages里。 12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地cd yourname.github.io //切换到刚刚clone的文件夹内npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再inithexo new post "new blog name" //新建一个.md文件，并编辑完成自己的博客内容git add source //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客，如果更改了主题样式的话还是建议用'git add .'git commit -m "XX"git push origin hexo //更新分支hexo d -g //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master 已有博客的终端更新博客进入相应的文件夹，更新博客直行命令即可。 123456git pull origin hexo//先pull完成本地和远端的融合hexo new post "new blog"git add .git commit -m "Blog update"git push origin hexohexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2019%2F05%2F14%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown Syntax 本文参考 Markdown基本语法(简书) Markdown官方文档 Markdown语法html支持 Markdown部分详细用法 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 12345678Atx形式# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题1234567Setext形式This is an H1=============This is an H2------------- This is an H1This is an H2根据标题生成目录1[TOC] 根据标题自动生成目录 [TOC] 字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 加粗测试 倾斜测试 斜体加粗测试 删除线测试 引用1234&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;多重引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 引用测试一 引用测试二 多重引用 引用测试 分割线1234-------******** 只要三个以上就可以 图片引用1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 插入带有链接的图片1234[[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com)&#123;:target="_blank"&#125; // 内链式[[图片上传失败...(image-4dc956-1542510791300)]][5]&#123;:target="_blank"&#125; // 引用式[5]: http://www.baidu.com [图片上传失败…(image-f83b77-1542510791300)]{:target=”_blank”} 内链式 [图片上传失败…(image-f83b77-1542510791300)]{:target=”blank”} 外链式 超链接引用12[超链接名](超链接地址 "超链接title")title可加可不加 12[简书](http://jianshu.com)[百度](http://baidu.com) baidu 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 简书 视频插入注：Markdown 语法是不支持直接插入视频的 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注：多数第三方平台不支持插入&lt;iframe&gt;视频 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 代码2 1[[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction)&#123;:target="_blank"&#125; 列表1234567无序列表用任一种皆可- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表（-） 列表（-） 列表（+） 列表（*） 1234567有序列表内容1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 第一点 第二点 第三点 12345678910111213141516171819**上一级和下一级之间敲三个空格即可**- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 Typora编辑器中可以直接使用crtl+T，或者在菜单段落中找到表格生成 代码引用单行代码 1`代码内容` int main(){return 0;} 代码块 12345(```)language 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt; "hello markdown"; return 0;&#125; 格式化代码html版123&lt;pre&gt;## 这是一个不起作用的标题&lt;/pre&gt; ## 这是一个不起作用的标题 流程图注： st=&gt;start: 开始 的：后面保持空格 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 6种类型 含义 start 启动 end 结束 operation 程序 subroutine 子程序 condition 条件 inputoutput 输出 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件 (布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 12345678910111213## 选项框```markdown- [x] 选项一- [ ] 选项二 需要注意的是：-、[x]、和选择一之间都要有空格，如果不下x[ ]中也要有空格 选项一 选项二 数学公式支持LaTex的数学公式，参考https://www.jianshu.com/p/2bbec51d756f 数学公式（MathJax)，参考https://www.jianshu.com/p/a0aa94ef8ab2 注：1个$左对齐，2个居中 12$$ x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1 $$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $ $$x \href{why-equal.html}{=} y^2 +1$$ 使用Typora的时候可以直接使用 $$+回车，或者用crtl+shift+M生成公式块（在段落菜单中的公式块） 参考https://blog.csdn.net/mingzhuo_126/article/details/82722455 脚注12Markdown[^1][^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注 Markdown^1 锚点注：只有标题支持锚点， 跳转目录方括号后 保持空格 123[公式标题锚点](#1)### [需要跳转的目录] &#123;#1&#125; // 方括号后保持空格 脚注标题锚点 123由于&#123;# 是hexo的标注语言hexo 中 &#123;# 属于保留字段 &#123;# ... #&#125;属于注释字段把```以外的&#123;#改成&#123;&#123; '&#123;#' &#125;&#125;即可解决 自动邮箱链接1&lt;xxx@outlook.com&gt; &#x78;&#120;&#120;&#64;&#111;&#x75;&#116;&#108;&#111;&#111;&#107;&#46;&#x63;&#111;&#109; 时序图代码1 123456​```sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B--&gt;A: 很高兴认识你​ 12345678910111213141516171819202122**演示**![img](https:////upload-images.jianshu.io/upload_images/6912209-784ce9bb7beb6672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)**代码详解**注：`A-&gt;&gt;B: 你好` 后面可以不写文字，但是一定要在最后加上`：` Note left of A 代表注释在A的左边| 符号 | 含义 || ---- | -------- || `-` | 实线 || `&gt;` | 实心箭头 || `--` | 虚线 || `&gt;&gt;` | 空心箭头 |**代码2** 123456789起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天 演示]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpages]]></title>
    <url>%2F2019%2F05%2F14%2Fhexo-gitpages%2F</url>
    <content type="text"><![CDATA[hexo+gitPages搭建个人博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
