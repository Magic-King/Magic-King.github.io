<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F09%2F04%2FCompiler%2F</url>
    <content type="text"><![CDATA[引论编译原理是良好的数学基础和好的工程结构功能的结合。 Compiler：编译，述而不作，忠于编写的东西 编译器从逻辑上可以分成若干阶段，每个阶段把源程序从一种表示变换成另一种表示 1.1什么叫编译程序翻译器（翻译程序）：Translater 能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序） 编译器（编译程序）：Compiler 能将一种计算机高级语言程序（源语言程序）转换成另一种等价的计算机低级语言程序（目标语言程序） 解释器（解释程序）：Interpreter 也是一种翻译程序，以一种语言写的源程序作为输入，但不产生目标代码，而是边解释边执行 解释器和编译器的区别： ①编译分成两步完成：先翻译，在运行 ②解释只用一步就完成：边解释边执行 可变目标编译程序（Retargetable Compiler） 交叉编译程序（Cross Compiler） 1.2编译程序的组成 词法分析器：读入组成源程序的字符流，并将它们组织成为有意义的词素的序列 语法分析器：使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示，该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法便是语法树，树中的每个内部节点表示一个运算 语义分析器：使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中键代码生成过程中使用。 中间代码生成器：在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。比如语法树是一种中间表示形式，通常在语法分析和语义分析中使用。 代码优化器：机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码 代码生成器：代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。 符号表管理器：记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息。 Tips: 如何学习构造编译程序 （1）源语言，对被编译的源程序深刻理解其结构和含义 （2）目标语言，假定目标语言是机器语言，就必须搞清楚硬件的系统结构和操作系统的功能 （3）编译方法，把一种语言翻译成另一种语言的方法很多，重点 高级语言及其语法描述2.1程序语言的语法和语义2.1.1语法任何语言均可作一个集合。这个集合中的每个元素都是在一定符号集（字母表）上的一个符号串。 对于自然语言来说，他们是定义在某个字母表上的句子的集合 对于程序语言来说，他们也是定义在某个字母表上的句子的集合。这里的句子，就是一个源程序。 词法规则：单词符号是语言中具有独立意义的最基本单位。语言的单词符号是由词法规则所确定的，即词法规则规定了单词符号的形成规则。 语法规则：上下文无关文法或BNF（Backus-Naur范式） 2.1.2语义语义，定义程序的意义 没有公认的形式系统描述语义 2.2程序语言的一般特征高级语言的分类 强制性语言（Imperative Language）|过程式语言：Fortran，C，Pascal 应用式语言（Applicative Language）|函数式语言：LISP 基于规则的语言（Ruled-based Language）：Prolog 面向对象语言（Object-oriented Language）：JAVA，c++ 2.3程序语言的语法描述一、字母表和符号串 字母表：符号的非空有限集合 例：∑ ={a，b，c} 符号：字母表中的元素 例： a，b，c 符号串：符号的有穷序列 例：a, aa, ac, abc，.. 空符号串：无任何符号的符号串( ε ) 符号串的形式定义 有字母表å，定义： （1）ε是å上的符号串； （2）若x是å上的符号串，且aÎ å，则ax或xa是å上的符号串； （3）y是å上的符号串，iff（当且仅当）y可由（1）和（2）产生。 符号串集合：由符号串构成的集合。 二、符号串和符号串集合的运算符号串相等：若x、y是集合上的两个符号串，则x＝y，iff（当且仅当）组成x的每一个符号和组成y的每一个符号依次相等。 符号串的长度：若x为符号串，其长度|x|等于组成该符 号串的符号个数。（例：x＝STV， |x|=3） 符号串的连接：若x、y是定义在Σ是上的符号串，且x＝XY，y＝YX，则x和y的连接 xy＝XYYX也是Σ上的符号串。（注意：一般xy ≠ yx，但是εx = xε） 符号串集合的乘积运算：令A、B为符号串集合，定义AB＝{ xy | x∈A, y∈B} 符号串集合的幂运算：有符号串集合A，定义A0 ={ε}, A1=A, A2=AA, A3=AAA,…… ……, An＝An-1A=AAn-1 ，n&gt;0 符号串集合的闭包运算：设A是符号串集合，定义 A＋＝ A1 ∪ A2 ∪ A3 ∪……∪ An ∪…… 称为集合A的正则闭包。A*＝ A0 ∪A＋ 称为集合A的闭包。（A0 = { ε } ） 为什么对符号、符号串、符号串集合以及它们的运算感兴趣？ 若A为某语言的基本字符集 ​ A＝{a,b,……z,0,1,……,9, +,－,×,_/, ( , ), =……} B为单词集 ​ B ={begin, end, if, then,else,for,……,&lt;标识符&gt;,&lt;常量&gt;,……} 则B ⊂ A* 。 语言的句子是定义在B上的符号串。 若令C为句子集合，则C ⊂ B* , 程序 ⊂ C 三、文法的直观理解1.什么是文法：文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）。 2.语法规则：我们通过建立一组规则（产生式），来描述句子的语法结构。规定用“::=”表示“由……组成“。 例如： &lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt; &lt;代词&gt; ::=你|我|他 &lt;名词&gt;::= 王民|大学生|工人|英语 &lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt; &lt;动词&gt;::=是|学习 &lt;直接宾语&gt;::=&lt;代词&gt;|&lt;名词&gt; 3.由产生式推导句子：3.有了一组产生式之后，可以按照一定的方式用它们去推导或产生句子。 ​ 推导方法：从一个要识别的符号开始推导，即用相应产生式的右部来替代产生式的左部，每次仅用一条产生式去进行推导。 &lt;句子&gt; =&gt; &lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt; …… …… 这种推导一直进行下去，直到所有带&lt; &gt;的符号都由终结符号替代为止。]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>Compilier</tag>
        <tag>StudyNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Note]]></title>
    <url>%2F2019%2F08%2F22%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[Linux Study Note 参考： 黑马程序员-linux从入门到精通 Linux系统的文件linux一切皆文件 文件操作种类：创建文件、编辑文件、保存文件、关闭文件、重命名文件、删除文件、恢复文件 文件目录结构Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。 Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符。 Etc：该目录主要存储一些配置文件。 Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。 Proc：process，表示进程，该目录中存储的是Linux运行时候的进程。 Root：该目录是root用户自己的家目录。 Sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。 Tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。 Usr：全称是User Software Resource，注意不是user的缩写。存放的是用户自己安装的软件。类似于windows下的program files。 Var：存放的程序/系统的日志文件的目录。 Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。 Linux的基本指令linux指令指在linux终端（命令行）中输入的内容。 一个完整的指令的标准格式：Linux通用的格式 1#指令主体 (空格) [选项] (空格) [操作对象] 一个指令可以包含多个选项，操作对象也可以是多个。 1.ls指令含义：ls（list） 用法1：#ls含义：列出当前工作目录下的所有文件/文件夹的名称 用法2：#ls 路径含义：列出指定路径下的所有文件/文件夹的名称 路径分为相对路径和绝对路径 用法3：#ls 选项 路径含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。 常见的语法： 12#ls -l 路径#ls -la 路径 选项解释： ​ -l：表示list，表示以详细列表的形式进行展示 ​ -a：表示all，显示所有的文件/文件夹（包含了隐藏文件/文件夹） 上述列表中的第一列表示文档类型，其中 “ - ” 表示改行对应的文档类型为文件，“ d ” 表示文档类型为文件夹。 在Linux中，隐藏文档一般以 “ . ” 开头。 用法4：#ls -lh 路径含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示 ls列出的结果颜色说明，其中蓝色的名称表示文件夹，黑色的表示文件，绿色的其权限为拥有所有权限 2.pwd指令用法：#pwd （print working directory，打印当前工作目录） 3.cd指令命令：#cd （change directory，改变目录） 作用：用于切换当前的工作目录 语法：#cd 路径P.S. 在linux中有一个特殊符号~，用于表示当前用户的家目录 4.mkdir指令指令：mkdir （make directory，创建目录） 语法1：#mkdir 路径路径，可以是文件夹名称也可以是包含名称的一个完整路径 假如是文件夹名称，则在当前目录下创建该文件夹 语法2：#mkdir -p 路径含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错 语法3：#mkdir 路径1 路径2 路径3 …表示一次性创建多个目录 5.touch指令作用：创建文件 语法：#touch 文件路径 路径可以是直接的文件名也可以是路径 一次性创建多个文件 6.cp指令指令含义：cp （copy，复制） 作用：复制文件/文件夹到指定位置 语法：#cp 被复制的文档路径 文档被复制到的路径简单来说就是#cp 源地址 目的地址 注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。 当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”（-r表示递归复制），否则目录将被忽略 7.mv指令指令含义：mv （move，移动，剪切） 作用：移动文档到新的位置 语法：#mv 需要移动的文件路径 需要保存的位置路径 注：在Linux中重命名的命令也是mv，语法和移动语法一样。 8.rm指令指令含义：rm （remove，移除，删除） 语法：#rm 选项 需要移除的文件路径选项： -f：force，强制删除，不提示是否删除 ​ -r：表示递归 在删除的时候如果不带选项，会提示是否删除，如果需要确认则输入“y/yes”，否则输入 注意：如果在删除的时候不想频繁的确认，则可以在指令中添加选项“-f”，表示force（强制）。 删除一个文件夹： 注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项。 删除多个文件： 删除一个目录下具有公共特性的文件，例如都以Linux开头 其中*称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管。 9.vim指令指令：vim （Vim是一款文本编辑器，号称编辑器之神） 语法：#vim 文件路径作用：可以打开一个文件，文件不存在时，可以创建该文件 vim其他用法参考本文后续。 10.输出重定向一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 >：覆输出，会覆盖掉原先的文件内容 >&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加 语法：#正常执行的指令 &gt; / &gt;&gt;文件的路径注意：文件可以不存在，不存在则新建 11.cat指令作用1：cat有直接打开一个文件的功能。 语法1：#cat 文件的路径 作用2：cat还可以对文件惊醒合并 语法2：#cat 待合并的文件路径1 待合并的文件路径2 … 文件路径n &gt; 合并之后的文件路径 12.df指令作用：查看磁盘空间 语法：#df -h-h表示以较高可读性的形式展示大小 13.free指令作用：查看内存使用情况 语法：#free -m-m表示以mb为单位查看 剩余的真实可用的内存为1665mb。 Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。 14.head指令作用：查看一个文件的前n行，若不指定n，则默认显示前10行。 语法：#head -n 文件路径n表示数字 15.tail指令作用1：查看一个文件的末n行，如果n不指定，则默认显示后10行 语法：#tail -n 文件路径n表示数字 作用2：可以通过tail指令来查看一个文件的动态变化内容（变化的内容不能是用户手动添加的） 语法：#tail -f 文件路径该命令一般用于查看系统的日志比较多 16.less指令作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车，空格键+上下方向键）查看更多 语法：#less 需要查看的文件路径 退出的时候只需要按下q键 17.wc指令作用：统计文件内容信息（包含行数、单词数、字节数） 语法：#wc -lwc 需要统计的文件路径-l：表示lines，行数 -w：表示words，单词数，依照空格来判断单词数量 -c：表示bytes，字节数 18.date指令作用：表示操作时间日期（读取、设置） 语法1：#date输出的形式：2019年8月24日 星期六 20:13:14 语法2：#date +%F （等价于 #date “+%Y-%m-%d”）输出形式：2019-08-24 语法3：#date “+%F %T” （等价于 #date “+%Y-%m-%d %H:%M:%S”）引号表示让“年月日与时分秒”成为一个不可分割的整体 输出的形式：2019-08-24 20:13:14 语法4：#date -d “-1 day” “+%Y-%m-%d %H:%M:%S”用于获取之前或者之后的某个时间（备份） 符号的可选值：+（之后）、-（之前） 单位的可选值：day（天）、month（月份）、year（年）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162%F：表示完整的年月日%T：表示完整的时分秒%Y：表示四位年份%m：表示两位月份（带前导0）%d：表示日期（带前导0）%H：表示小时（带前导0）%M：表示分钟（带前导0）%S：表示秒数（带前导0）(以下摘自#date --help) %% 一个文字的 % %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n 换行 %N 纳秒(000000000-999999999) %p 当前locale 下的"上午"或者"下午"，未知时输出为空 %P 与%p 类似，但是输出小写字母 %r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R 24 小时时间的时和分，等价于 %H:%M %s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT) 19.cal指令作用：用来操作日历的 语法1：#cal （等价于#cal -l）直接输出当前月份日历 语法2：#cal -3表示输出上一个月+本月+下个月的日历 语法3：#cal -y 年份表示输出某一个年份的日历 20.clear | (ctrl+L) 指令作用：清除终端中已经存在的命令和结果（信息） 语法：#clear 或 快捷键 ctrl + L注意：该命令并不是真的清除了之前的信息，而是把之前的信息都隐藏到了最上面，可以通过滚动条继续查看以前的信息。 21.管道pipe管道符： |作用：管道一般可以用于“过滤”，“特殊”，“扩展处理” 语法：管道不能单独使用，必须需要配合前面的指令一起使用，起作用主要是辅助作用①过滤案例（高频率使用）：需要通过管道查询出根目录下包含“y”字母的文档名称。 12345#ls | grep y针对上面这个命令说明：①以管道作为分界线，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入；②grep指令：主要用于过滤 ②特殊用法案例：通过管道的操作方法来实现less的等价效果（了解） 之前通过less查看一个文件，可以#less 路径 现在通过管道还可以这么：#cat 路径|less ③扩展处理：统计某个目录下的文档的总个数？ 答：#ls / | wc -l 22.hostname指令作用：操作服务器的主机名（读取or设置） 语法1：#hostname含义：表示输出完整的主机名 语法2：#hostname -f 含义：表示输出当前主机名中的FQDN（全限定域名） 23.id指令作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。 语法1：#id默认显示当前执行该命令的用户的基本信息 语法2：#id username显示指定账户（username）的基本信息 验证用户信息可通过文件（/etc/passwd） 验证用户组信息可通过文件（/etv/group） 24.whoami指令作用：“我是谁？”，显示当前登录的用户名，一般用于shell脚本，用于获取当前操作系统的用户名方便记录日志。 语法：#whoami 25.ps -ef指令指令：ps 作用：用于查看服务器进程信息 选项含义： ​ -e：等价于“-A”，表示列出全部的进程 ​ -f：显示全部的列（显示全字段） 12345678910各列的含义：UID：该进程执行的用户id；PID：进程id；PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）；C：Cpu的占用率，其形式是百分数；STIME：进行的启动时间；TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；TIME：进程的执行时间；CMD：该进程的名称或者对应的路径 #ps -ef | grep “进程名称”用于查看特定进程的状态 26.top指令作用：查看服务器的进程占用的资源 语法：进入命令：#top（动态显示）退出命令：按下q键 12345678910111213表头含义：PID：进程id；USER：该进程对应的用户；PR：优先级；VIRT：虚拟内存；RES：常驻内存；SHR：共享内存； 计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR）S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）；%CPU：表示CPU的占用百分比；%MEM：表示内存的占用百分比；TIME+：执行的时间；COMMAND：进程的名称或者路径 在运行top命令时，可以有如下快捷键： M：表示将结果按照内存（MEM）从高到低进行降序排列 P：表示将结果按照CPU使用率从高到低进行降序排列 1：当服务器拥有多个CPU的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息 27.du -sh指令作用：查看目录的真实大小 语法：#du -sh 目录路径选项含义： ​ -s：summaries，只显示汇总的大小 ​ -h：表示以高可读性的形式进行显示 28.find指令作用：用于查找文件（参数贼多，55个） 语法：#find 路径范围 选项 选项的值选项： ​ -name：按照文件名称进行搜索（支持模糊搜索） ​ -type：按照文件的类型进行搜索（文件类型：“-”表示文件，在使用find的使用需要用f来替换；“d”表示文件夹） 注：*为通配符，匹配所有字符 29.service指令作用：用于控制一些软件的服务启动、停止、重启 语法：#service 服务名 start/stop/restart例：启动本机安装的Apache，其服务名为httpd 其服务启动规则可自己编写，后续将会专门开一篇讲述 30.kill指令作用：表示杀死进程（当遇到僵尸进程或者处于某些原因需要关闭进程的时候） 语法：#kill 进程的PID（需要配合ps一起使用） 与kill相似的命令：#killall 语法：#killall 进程名称 31.ifconfig指令作用：用于操作网卡相关的指令 语法：#ifconfig（获取网卡信息） 注意该命令在windows环境下为ipconfig Eth0表示Linux中的一个网卡，eth0是其名称。Lo（loop，本地回还网卡，其ip地址一般都是127.0.0.1）也是一个网卡名称。注意：inet addr就是网卡的ip地址。 32.reboot指令作用：重启计算机 语法1：#reboot重启 语法2：#reboot -w模拟重启，但是不重启（只写关机与开机的日志信息） 33.shutdown指令作用：关机（慎用） 语法1：#shutdown -h now “关机提示”#shutdown -h time(14:41) “关机提示” 如果想要取消关机计划的话，则可以按照以下方式去尝试： ①针对于centos7.x之前的版本：ctrl+c ②针对于centos7.x（包含）之后的版本：#shutdown -c 除了shutdown关机以外，还有以下几个关机命令 #init 0 #halt #poweroff 34.uptime指令作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间） 语法：#uptime 35.uname指令作用：获取计算机操作系统的相关信息 语法1：#uname获取操作系统类型 语法2：#uname -a-a：表示all，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划） 36.netstat -tnlp指令作用：查看网络连接状态 语法：#netstat -tnlp 12345选项说明： -t：表示只列出tcp协议的连接； -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示； -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接； -p：表示显示发起连接的进程pid和进程名称； 37.man指令作用：manual，手册（包含了Linux中全部的命令手册，英文） 语法：#man 命令退出按下q键 例：#man cp 编辑器之神——Vim编辑器]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url]]></title>
    <url>%2F2019%2F08%2F19%2Furl%2F</url>
    <content type="text"><![CDATA[URL 引用： url_Wiki) 短链接原理分析 短链接的算法 统一资源定位符（英语：Uniform Resource Locator）统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被[万维网联盟4编制为因特网标准RFC 1738。 在互联网的历史上，统一资源定位符的发明是一个非常基础的步骤。统一资源定位符的语法是一般的，可扩展的，它使用美国信息交换标准代码的一部分来表示因特网的地址。统一资源定位符的开始，一般会标志着一个计算机网络所使用的网络协议。 统一资源定位符的标准格式如下： 12[协议类型]: //服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID[protocol]://server_address:port/path_and_filename?search#fragmentID 统一资源定位符的完整格式如下： 1[协议类型]: //访问资源需要的凭证信息@服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID 其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。 语法超文本传输协议（http）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为默认值可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点 以http://zh.wikipedia.org:80/w/index.php?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2 为例, 其中： http，是协议； zh.wikipedia.org，是服务器； 80，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2，是询问。 大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（zh.wikipedia.org/wiki/Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2）就可以了。 由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务 短链接短链接本质上是http协议中的重定向内容，一般为http301和http302 短链接的优势：简短、美观、便于传播 原理例如短链接 http://qnr.io/j6Dcss DNS解析qnr.io域名，发送GET请求 /j6Dcss 服务器会通过短码获取对应的原URL 然后通过 HTTP 302 （或HTTP 301）转到对应的原URL 常见算法实现自增序列算法短址的长度一般设为 6 位，而每一位是由 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合，一般肯定是够用了。将原网址分配一个从1位到6位的随机短码，存数据库记录，对返回的id进行62进制转码。 即可使用发号策略。发号策略是这样的，当一个新的链接过来时，发号器发一个号与之对应。往后只要有新链接过来，发号器不停发号就好。举个例子，第一个进来的链接发号器发0号，对应的短链接为 xx.xxx/0，第二个进来的链接发号器发1号，对应的短链接为 xx.xxx/1，以此类推。发号器发出的10进制号需要转换成62进制，这样可以大大缩短号码转换成字符串后的长度。比如发号器发出 10,000,000,000 这个号码，如果不转换成62进制，直接拼接在域名后面，得到这样一个链接 xx.xxx/10000000000。将上面的号码转换成62进制，结果为AOYKUa，长度只有6位，拼接得到的链接为 xx.xxx/AOYKUa。可以看得出，进制转换后得到的短链接长度变短了一些。6位62进制数，对应的号码空间为626，约等于568亿。也就是说发号器可以发568亿个号，这个号码空间应该能够满足多数项目的需求了，所以基本上不用担心发号器无号可发的情况。上述是发号策略压缩URL的原理，在实际写代码的过程中还需要考虑很多细节，比如缓存，存储等。 摘要算法将原网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理 这 30 位分成 6 段, 每 5位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串总的 md5 串可以获得 4 个 6位串,取里面的任意一个就可作为这个长 url 的短 url 地址 这种算法,虽然会生成4个,但是仍然存在重复几率 算法比较第一种算法的好处就是简单好理解，永不重复。但是短码的长度不固定，随着 id 变大从一位长度开始递增。如果非要让短码长度固定也可以就是让 id 从指定的数字开始递增就可以了。 第二种算法，虽然几率很小，但是存在碰撞（重复）的可能性。短码位数是比较固定的。 Q：同一长链接，每次转成的短链接是否一样A：同一长链接，每次转成的短链接不一定一样，原因在于如果查询缓存时，如果未命中，发号器会发新号给这个链接。需要说明的是，缓存应该缓存经常转换的热门链接，假设设定缓存过期时间为一小时，如果某个链接很活跃的话，缓存查询命中后，缓存会刷新这个链接的存活时间，重新计时，这个链接就会长久存在缓存中。对于一些生僻链接，从存入缓存开始，在存活时间内很可能不会被再次访问，存活时间结束缓存会删除记录。下一次转换这个生僻链接，缓存不命中，发号器会重新发号。这样一来会导致一条长链接对应多条短链接的情况出现，不仅浪费存储空间，又浪费发号器资源。那么是否有办法解决这个问题呢？是不是可以考虑建立一个长链接-短链接的key-value表，将所有的长链接和对应的短链接都存入其中，这样一来就实现了长短链接一一对应的了。但是想法是美好的，现实是不行的，原因在于，将所有的长链接-短链接对存入这样的表中，本身就需要耗费大量的存储空间，相对于生僻链接可能会对应多条短链接浪费的那点空间，这样做显然就得不偿失了。 HTTP 301与 302的区别301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。用户第一次访问某个短链接后，如果服务器返回301状态码，则这个用户在后续多次访问统一短链接，浏览器会直接请求跳转地址，而不是短链接地址，这样一来服务器端就无法收到用户的请求。如果服务器返回302状态码，且告知浏览器不缓存短链接请求，那么用户每次访问短链接，都会先去短链接服务端取回长链接地址，然后在跳转。从语义上来说，301跳转更为合适，因为是永久跳转，不会每次都访问服务端，还可以减小服务端压力。但如果使用301跳转，服务端就无法精确搜集用户的访问行为了。相反302跳转会导致服务端压力增大，但服务端此时就可精确搜集用户的访问行为。但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而点收集击次数的意义那就不言而喻了，关键是现在服务器硬件设备都很好，还有支持高并发的NGINX，所以对服务器的压力几乎可以忽略，最终也就选择302。]]></content>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F06%2F06%2FMakefile%2F</url>
    <content type="text"><![CDATA[Make 本文参考： GNU+make中文手册 GNU+make原版官方手册 make wiki Makefile由浅入深 跟我一起写Makefile 序​ 最初了解到Makefile，还是从很久很久以前说起。当时在老师底下做项目，要配置一个nginx服务器，当初给出教程是直接make&amp;&amp;make install就完事了，打完代码一行行执行下来看起来非常有成就感233333 ​ 但是之后在做计算机系统的实验时，才发现Makefile是如此的有用万能，无论是windows还是linux(ubuntu 16.04)下，只需要一个make就能解决编译链接安装问题，make完就能立即使用，实属好用。在之后的操作系统实验中，真正接触到了Makefile这东西，基本每个实验都要写Makefile，因此对Makefile的格式有了一个大概印象，但不过想深入了解一波，便去找了许多资料看。 概述在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。 许多现代软件的开发中（如Microsoft Visual Studio（他其实有提供一个vs 2017 交叉工具命令提示符，可以进行make，但不过一般在IDE中直接编译生成独有的工程配置文件）），集成开发环境已经取代make，但是在Unix环境中，仍然有许多任务程师采用make来协助软件开发。 Makefile介绍make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。 Makefile规则12345678#Makefile中，用#表示注释target ...: prerequisites ... command 1 #注意命令前要用Tab command 2 ... ...#可以使用“\”表示续行，但是“\”之后不能有空格 target 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对 于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites 生成该target所依赖的文件和/或target command 该target要执行的命令（任意的shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件， 其生成规则定义在command中。说白一点就是说: prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 这就是Makefile中最核心的规则。 实例采用GNU make 手册中的例子 123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 该工程有3个头文件和8个c文件 其中反斜杠(“\”)是换行符，注意换行符之后不能用空格。换行符又利用Makefile的阅读。 把Makefile放在处于工程下的，然后在该目录下输入make命令，就可以生成可执行文件了。如果要删除执行文件和所有的中间目标文件，那么只需要执行make clean就可以了。 在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ *.o ），依赖文 件（prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有 一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目 标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。 这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一 样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。 要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一 个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 make的执行过程如下： 依次读取变量“MAKEFILES”定义的makefile文件列表 读取工作目录下的makefile文件（GNU make的顺序：缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个（假如是MAKEFILE，需要用make -f）） 依次读取工作目录makefile文件中使用指示符“include”包含的文件 查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行） 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表 执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件） 执行“终极目标”所在的规则 一上面那个工程为示例： 1234567891011在默认的方式下，也就是我们只输入 make 命令。那么，1.make会在当前目录下找名字叫“Makefile”或“makefile”的文件。2.如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个 文件，并把这个文件作为最终的目标文件。3.如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个 文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。4.如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件 的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）5.当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生 成make的终极任务，也就是执行文件 edit 了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在 找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性。 像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命 令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有 的目标文件，以便重编译。 如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ， 那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令）， 于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所 以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。比如我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都 会被重编译，并且， edit 会被重链接。 Makefile中使用变量总所周知，变量是个好东西0.0 在Makefile中使用变量有利于我们对其有更好的维护性。 跟通常编程一样，变量名最好简(jian)洁(dan)易(cu)懂(bao)，有利于人们明白其代表的含义。 在上面例子中，edit后面的一串便可以进行替代了。 1234edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 当我们需要添加文件时，需要修改多个地方，使用变量能很好地为我们节省时间。 只需在前面声明变量就好，比如objects，objs，obj等等，只要能很好明白其代表的含义就行 1234567891011121314151617181920212223objs = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o edit : $(objs) cc -o edit $(objs)main.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit $(objs) 比如这样，当我们需要添加新的 .o 文件的时候，只需要修改objs = ...就行了 Makefile的自动推导GNU的make可以自动推到文件及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的 新makefile又出炉了。 123456789101112131415161718objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : rm edit $(objects) 这种方法，也就是make的“隐晦规则”。 .PHONY 表示 clean 是个伪目标 文件。 另类风格的Makefile既然我们的make可以自动推导命令，那么我看到那堆 .o 和 .h 的依赖就有点不爽，那么多的 重复的 .h ，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动 推导命令和文件的功能呢？来看看最新风格的makefile吧。 12345678910111213objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : rm edit $(objects) 清空目标文件的规则每个Makefile中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很 利于保持文件的清洁。 12clean: rm edit $(objects) 更为稳健的做法是： 123.PHONY : cleanclean : -rm edit $(objects) 前面说过， .PHONY 表示 clean 是一个“伪目标”。而在 rm 命令前面加了一个小减号的 意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件 的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放 在文件的最后”。 Makefile里有什么？Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的 文件、文件的依赖文件和生成的命令。 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的 宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中 的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一 样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符，这个就 像C/C++中的 // 一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行转义，如： \# 。 还有的就是在Makefile中的命令，必须要以 Tab 键开始。 Makefile的文件名因为make程序已被用户多次重/改写，其中包括几次用相同的文件格式和算法原理重新编写，并且依照不同需要添加了一些不常见的改良。 现在的版本，大致是 GNU make，BSD make，Microsoft nmake。 默认的情况下，gnu的make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、 “makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”， 这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说， 大多数的make都支持“makefile”和“Makefile”这两种默认文件名。 当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris” ，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的 -f 和 --file 参数， 如： make -f Make.Linux 或 make --file Make.AIX 。 引用其他的Makefile在Makefile使用 include 关键字可以把别的Makefile包含进来，这很像C语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是： 1include &lt;filename&gt; filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。 在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 &lt;filename&gt; 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含 了 e.mk 和 f.mk ，那么，下面的语句： 12bar = e.mk f.mkinclude foo.make *.mk $(bar) 等价于： 1include foo.make a.mk b.mk c.mk e.mk f.mk make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置。就好 像C/C++的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目 录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目 录下去寻找。 如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的 文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是 不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以 在include前加一个减号“-”。如： 1-include &lt;filename&gt; 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令 是sinclude，其作用和这一个是一样的。 环境变量MAKEFILES如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不 同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现 错误，make也会不理。 但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时， 所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许 有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 make的工作流程GNU的make工作时的执行步骤如下：（想来其它的make也是类似） 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展 开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则 中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分 也就容易看懂了。 书写规则]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS]]></title>
    <url>%2F2019%2F05%2F30%2FIPFS%2F</url>
    <content type="text"></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM]]></title>
    <url>%2F2019%2F05%2F28%2FARM%2F</url>
    <content type="text"><![CDATA[ARM指令集详解 引用： ARM指令集详解 1. 汇编1.1. 通用寄存器 寄存器类别 寄存器在汇编中的名称 各模式下实际访问的寄存器 用户 系统 管理 中止 未定义 中断 快中断 通用寄存器和程序计数器 R0(a1) R0 R1(a2) R1 R2(a3) R2 R3(a4) R3 R4(v1) R4 R5(v2) R5 R6(v3) R6 R7(v4) R7 R8(v5) R8 R8_fiq R9(SB,v6) R9 R9_fiq R10(SL,v7) R10 R10_fiq R11(FP,v8) R11 R11_fiq R12(IP) R12 R12_fiq R13(SP) R13 R13_svc R13_abt R13_und R13_irq R13_fiq R14(LR) R14 R14_svc R14_abt R14_und R14_irq R14_fiq * R15(PC) R15 状态寄存器 R16(CPSR) CPSR SPSR 无 SPSR_svc SPSR_abt SPSR_und SPSR_irq SPSR_fiq 通用寄存器 37个寄存器，31个通用寄存器，6个状态寄存器。 R12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 R13堆栈指针sp，R14返回指针，R15为PC指针, cpsr_c代表的是这32位中的低8位，也就是控制位 CPSR有4个8位区域：标志域（F）、状态域（S）、扩展域（X）、控制域（C）MSR - Load specified fields of the CPSR or SPSR with an immediate constant, orfrom the contents of a general-purpose register. Syntax: MSR{cond} _, #immed_8rMSR{cond} _, Rm where: cond is an optional condition code. is either CPSR orSPSR. specifies the field or fields to be moved. can be one or more of: ccontrol field mask byte (PSR[7:0]) x extension field mask byte (PSR[15:8]) sstatus field mask byte (PSR[23:16) f flags field mask byte (PSR[31:24]).immed_8r is an expression evaluating to a numeric constant. The constant mustcorrespond to an 8-bit pattern rotated by an even number of bits within a32-bit word. Rm is the source register. C 控制域屏蔽字节(psr[7:0]) X 扩展域屏蔽字节(psr[15:8]) S 状态域屏蔽字节(psr[23:16]) F 标志域屏蔽字节(psr[31:24]) CPSR寄存器 FIQ和IRQ的区别？ MODE(以下为二进制) 可见的ARM状态寄存器 10000 用户模式 PC,CPSR,R0~R14 10001 FIQ PC,CPSR,SPSR_fiq，R14_fiq~R8_fiq,R7~R0 10010 IRQ PC,CPSR,SPSR_irq，R14_irq~R13_irq,R12~R0 10011 管理模式(svc) PC,CPSR,SPSR_svc，R14_svc~R13_svc,R12~R0 10111 终止模式 PC,CPSR,SPSR_abt，R14_abt~R13_abt,R12~R0 11011 未定义 PC,CPSR,SPSR_und，R14_und~R13_und,R2~R0 11111 系统模式(sys) PC,CPSR，R14 ~R0 1.2. 指令格式1) 基本格式 ​ &lt;opcode&gt;{&lt;cond&gt;}{S} &lt;Rd&gt;,&lt;Rn&gt;{,&lt;opcode2&gt;} ​ 其中，&lt;&gt;内的项是必须的，{}内的项是可选的，如是指令助记符，是必须的，而{}为指令执行条件，是可选的，如果不写则使用默认条件AL(无条件执行)。 ​ opcode 指令助记符，如LDR，STR 等 ​ cond 执行条件，如EQ，NE 等 ​ S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响 ​ Rd 目标寄存器 ​ Rn 第一个操作数的寄存器 ​ operand2 第二个操作数 ​ 指令格式举例如下： ​ LDREX–这条指令主要是从memory中取一个数，然后放到register中，但是相比普通的LDR指令，在于其内在的原子操作特性, 信号量和spin lock这些东西最核心的事情基本上就是load-update-store序列，为了防止并发，必须保证这个序列是原子的，所谓原子，即处理器在执行这个指令序列时，得绝对占有处理器而不能够被切换出去。在ARM上，从V6开始，指令LDREX和STREX就是用来干这事的 ​ LDR R0,[R1] ;读取R1 地址上的存储器单元内容，执行条件AL​ BEQ DATAEVEN ;跳转指令，执行条件EQ，即相等跳转到DATAEVEN​ ADDS R1,R1,#1 ;加法指令，R1＋1＝R1 影响CPSR 寄存器，带有S​ SUBNES R1,R1,#0xD;条件执行减法运算(NE)，R1-0xD=&gt;R1，影响CPSR 寄存器，带有S 2) 第2个操作数 ​ 在ARM 指令中，灵活的使用第2个操作数能提高代码效率，第2个操作数的形式如下： ​ ＃immed_8r ​ 常数表达式： ​ 该常数必须对应8 位位图，即常数是由一个8 位的常数循环移位偶数位得到。 ​ 合法常量： ​ 0x3FC、0、0xF0000000、200、0xF0000001等都是合法常量。 ​ 非法常量： ​ 0x1FE、511、0xFFFF、0x1010、0xF0000010等都是非法常量。 ​ 常数表达式应用举例如下： ​ MOV R0,#1 ;R0=1 ​ AND R1,R2,#0x0F ;R2 与0x0F，结果保存在R1 ​ LDR R0，[R1],#-4 ;读取R1 地址上的存储器单元内容，且R1＝R1－4 ​ Rm ​ 寄存器方式，在寄存器方式下操作数即为寄存器的数值。 ​ 寄存器方式应用举例： ​ SUB R1，R1，R2 ；R1-R2=＞R1 ​ MOV PC，R0 ；PC=R0，程序跳转到指定地址 ​ LDR R0，[R1]，-R2 ；读取R1 地址上的存储器单元内容并存入R0，且R1=R1-R2 ​ Rm， shift ​ 寄存器移位方式。将寄存器的移位结果作为操作数，但RM 值保存不变，移位方法如下： ​ ASR #n 算术右移n 位（1≤n≤32） ​ LSL #n 逻辑左移n 位（1≤n≤31） ​ LSR #n 逻辑左移n 位（1≤n≤32） ​ ROR #n 循环右移n 位（1≤n≤31） ​ RRX 带扩展的循环右移1位 ​ type Rs 其中，type 为ASR，LSL，和ROR 中的一种；Rs 偏移量寄存器，低8位有效，若其值大于或等于32，则第2 个操作数的结果为0（ASR、ROR例外）。​ 寄存器偏移方式应用举例： ​ ADD R1，R1，R1，LSL #3 ；R1=R1*9 ​ SUB R1，R1，R2，LSR#2 ；R1=R1-R2*4 ​ R15 为处理器的程序计数器PC，一般不要对其进行操作，而且有些指令是不允许使用R15，如UMULL 指令。​ （3）条件码​ 使用指令条件码，可实现高效的逻辑操作，提高代码效率。表A-1给出条件码表。 表A-1 条件码表 ​ 对于Thumb指令集，只有B 指令具有条件码执行功能，此指令条件码同表A-?，但如果为无条件执行时，条件码助记符“AL”不在指令中书写。 ​ 条件码应用举例如下： ​ 比较两个值大小，并进行相应加1 处理，C 代码为：​ if（a＞b）a++ ;​ else b++ ;​ 对应的ARM 指令如下。其中R0为a，R1为b。​ CMP R0，R1 ; R0 与R1 比较​ ADDHI R0，R0，#1 ; 若R0＞R1，则R0=R0+1​ ADDLS R1，R1，#1 ;若R0＜=R1，则R1=R1+1​ 若两个条件均成立，则将这两个数值相加，C代码为： ​ If(（a!=10）&amp;&amp;(b!=20))a=a+b; ​ 对应的ARM 指令如下，其中R0 为a，R1为b。​ CMP R0,#10 ; 比较R0 是否为10​ CMPNE R1,#20 ; 若R0 不为10，则比较R1 是否20​ ADDNE R0,R0,R1 ; 若R0 不为10 且R1 不为20，指令执行，R0=R0+R1 1.3. 指令集1.3.1. ARM 存储器访问指令​ ARM 处理是加载/存储体系结构的典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。ARM 处理器是冯?诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载/存储指令进行。表A-2给出ARM存储访问指令表。 表A-2 ARM 存储访问指令表 LDR 和STR​ 加载/存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从/到内存。LDR指令用于从内存中读取数据放入寄存器中；STR 指令用于将寄存器中的数据保存到内存。指令格式如下：​ LDR{cond}{T} Rd,&lt;地址&gt;; 加载指定地址上的数据(字)，放入Rd中​ STR{cond}{T} Rd,&lt;地址&gt;; 存储数据(字)到指定地址的存储单元，要存储的数据在Rd中​ LDR{cond}B{T} Rd,&lt;地址&gt;; 加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零​ STR{cond}B{T} Rd,&lt;地址&gt;; 存储字节数据，要存储的数据在Rd，最低字节有效​ 其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T。​ LDR/STR 指令寻址是非常灵活的，由两部分组成，一部分为一个基址寄存器，可以为任一个通用寄存器，另一部分为一个地址偏移量。地址偏移量有以下3种格式：​ (1) 立即数。立即数可以是一个无符号数值，这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：​ LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)​ LDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)​ LDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移)​ (2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下：​ LDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)​ LDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)​ (3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：​ LDR R1,[R0,R2,LSL #2] ;将R0+R24地址处的数据读出，保存到R1中（R0，R2的值不变）​ LDR R1,[R0,-R2,LSL #2];将R0-R24地址处的数据计读出，保存到R1中(R0，R2的值不变)​ 从寻址方式的地址计算方法分，加载/存储指令有以下4 种形式：​ (1)零偏移。Rn 的值作为传送数据的地址，即地址偏移量为0。指令举例如下：​ LDR Rd,[Rn]​ (2)前索引偏移。在数据传送之前，将偏移量加到Rn 中，其结果作为传送数据的存储地址。若使用后缀“！”，则结果写回到Rn中，且Rn 值不允许为R15。指令举例如下：​ LDR Rd,[Rn,#0x04]!​ LDR Rd,[Rn,#-0x04]​ (3)程序相对偏移。程序相对偏移是索引形式的另一个版本。汇编器由PC 寄存器计算偏移量，并将PC寄存器作为Rn 生成前索引指令。不能使用后缀“！”。指令举例如下：​ LDR Rd,label ;label 为程序标号，label 必须是在当前指令的±4KB范围内​ (4) 后索引偏移。Rn 的值用做传送数据的存储地址。在数据传送后，将偏移量与Rn相加，结果写回到Rn中。Rn 不允许是R15。指令举例如下：​ LDR Rd,[Rn],#0x04​ 地址对准–大多数情况下，必须保证用于32 位传送的地址是32 位对准的。​ 加载/存储字和无符号字节指令举例如下：​ LDR R2,[R5] ;加载R5 指定地址上的数据(字)，放入R2 中​ STR R1,[R0,#0x04] ;将R1 的数据存储到R0+0x04存储单元，R0 值不变​ LDRB R3,[R2],#1 ;读取R2 地址上的一字节数据，并保存到R3中，R2=R3+1​ STRB R6,[R7] ;读R6 的数据保存到R7 指定的地址中，只存储一字节数据​ 加载/存储半字和带符号字节。这类LDR/STR 指令可能加载带符字节\加载带符号半字、加载/存储无符号半字。偏移量格式、寻址方式与加载/存储字和无符号字节指令相同。指令格式如下：​ LDR{cond}SB Rd,&lt;地址&gt; ;加载指定地址上的数据(带符号字节)，放入Rd中​ LDR{cond}SH Rd,&lt;地址&gt; ;加载指定地址上的数据(带符号字节)，放入Rd中​ LDR{cond}H Rd,&lt;地址&gt; ;加载半字数据，放入Rd中，即Rd最低16位有效,高16位清零​ STR{cond}H Rd,&lt;地址&gt; ;存储半字数据，要存储的数据在Rd，最低16位有效​ 说明：带符号位半字/字节加载是指带符号位加载扩展到32 位;无符号位半字加载是指零扩展到32位。​ 地址对准–对半字传送的地址必须为偶数。非半字对准的半字加载将使Rd 内容不可靠，非半字对准的半字存储将使指定地址的2字节存储内容不可靠。 ​ 加载/存储半字和带符号字节指令举例如下： ​ LDRSB R1[R0,R3] ;将R0+R3地址上的字节数据读出到R1，高24 位用符号位扩展​ LDRSH R1,[R9] ;将R9 地址上的半字数据读出到R1，高16位用符号位扩展​ LDRH R6,[R2],#2 ;将R2 地址上的半字数据读出到R6，高16位用零扩展，R2=R2+1​ SHRH R1,[R0,#2]!;将R1 的数据保存到R2+2 地址中，只存储低2字节数据，R0=R0+2​ LDR/STR 指令用于对内存变量的访问，内存缓冲区数据的访问、查表、外设的控制操作等等，若使用LDR 指令加载数据到PC 寄存器，则实现程序跳转功能，这样也就实现了程序散转。​ 变量的访问​ NumCount EQU 0x40003000 ;定义变量NumCount​ …​ LDR R0,=NumCount ;使用LDR 伪指令装载NumCount的地址到R0​ LDR R1,[R0] ;取出变量值​ ADD R1,R1,#1 ;NumCount=NumCount+1​ STR R1,[R0] ;保存变量值​ …​ GPIO 设置​ GPIO-BASE EQU 0Xe0028000 ;定义GPIO 寄存器的基地址​ …​ LDR R0,=GPIO-BASE​ LDR R1,=0x00FFFF00 ;装载32 位立即数，即设置值​ STR R1,[R0,#0x0C] ;IODIR=0x00FFFF00， IODIR 的地址为0xE002800C​ MOV R1,#0x00F00000​ STR R1,[R0,#0x04] ;IOSET=0x00F00000，IOSET 的地址为0xE0028004​ …​ 程序散转​ …​ MOV R2,R2,LSL #2 ;功能号乘上4，以便查表​ LDR PC,[PC,R2] ;查表取得对应功能子程序地址，并跳转​ NOP​ FUN-TAB DCD FUN-SUB0​ DCD FUN-SUB1​ DCD FUN-SUB2​ … LDM和STM​ 批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器，STM 为存储多个寄存器。允许一条指令传送16 个寄存器的任何子集或所有寄存器。指令格式如下：​ LDM{cond}&lt;模式&gt; Rn{!},reglist{^}​ STM{cond}&lt;模式&gt; Rn{!},reglist{^}​ LDM /STM 的主要用途是现场保护、数据复制、参数传送等。其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作)。​ (1) IA：每次传送后地址加4​ (2) IB：每次传送前地址加4​ (3) DA：每次传送后地址减4​ (4) DB：每次传送前地址减4​ (5) FD：满递减堆栈​ (6) ED：空递增堆栈​ (7) FA：满递增堆栈​ (8) EA：空递增堆栈​ 其中，寄存器Rn 为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15;后缀“！”表示最后的地址写回到Rn中;寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如{R1,R2,R6-R9},寄存器排列由小到大排列；“＾”后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回；使用“＾”后缀进行数据传送且寄存器列表不包含PC时，加载/存储的是用户模式的寄存器，而不是当前模式的寄存器。​ 地址对准――这些指令忽略地址的位[1：0]。​ 批量加载/存储指令举例如下：​ LDMIA R0!,{R3-R9} ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新​ STMIA R1!,{R3-R9} ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新​ STMFD SP!,{R0-R7,LR} ;现场保存，将R0～R7、LR入栈​ LDMFD SP!,{R0-R7,PC}^;恢复现场，异常处理返回​ 在进行数据复制时，先设置好源数据指针，然后使用块拷贝寻址指令LDMIA/STMIA、LDMIB/STMIB、LDMDA/STMDA、LDMDB/STMDB 进行读取和存储。而进行堆栈操作时，则要先设置堆栈指针，一般使用SP 然后使用堆栈寻址指令STMFD/LDMFD、STMED。LDMED、STMFA/LDMFA、STMEA/LDMEA实现堆栈操作。​ 多寄存器传送指令示意图如图A-1所示，其中R1为指令执行前的基址寄存器，R1’则为指令执行完后的基址寄存器。 （a）指令STMIA R1!,{R5-R7} （b）指令STMIB R1!,{R5-R7} （c）指令STMDA R1!, {R5-R7} （d）指令STMDB R1!,{R5-R7}图A-1 多寄存器传送指令示意图 ​ 数据是存储在基址寄存器的地址之上还是之下，地址是在存储第一个值之前还是之后增加还是减少。表A-3给出多寄存器传送指令映射示意表。 表A-3 多寄存器传送指令映射示意表 123456使用LDM/STM 进行数据复制例程如下：…LDR R0,=SrcData ;//设置源数据地址LDR R1,=DstData ;//设置目标地址LDMIA R0,&#123;R2-R9&#125; ;//加载8 字数据到寄存器R2～R9STMIA R1,&#123;R2-R9&#125; ;//存储寄存器R2～R9 到目标地址 ​ 使用LDM/STM 进行现场寄存器保护，常在子程序中或异常处理使用：​ SENDBYTE​ STMFD SP!,{R0-R7,LR} ;寄存器入堆​ …​ BL DELAY ;调用DELAY 子程序​ …​ LDMFD SP!,{R0-R7,PC} ;恢复寄存器，并返回 SWP​ 寄存器和存储器交换指令。SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中。使用SWP 可实现信号量操作。​ 指令格式如下：​ SWP{cond}{B} Rd,Rm,[Rn]​ 其中，B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同。​ SWP 指令举例如下：​ SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换​ SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零)​ ; 并将R2 的内容写入到该内存单元中(最低字节有效)​ 使用SWP 指令可以方便地进行信号量的操作：​ 12C_SEM EQU 0x40003000​ …​ 12C_SEM_WAIT​ MOV R0,#0​ LDR R0,=12C_SEM​ SWP R1,R1,[R0] ;取出信号量，并设置其为0​ CMP R1,#0 ;判断是否有信号​ BEQ 12C_SEM_WAIT ;若没有信号，则等待 1.3.2. ARM 数据处理指令​ 数据处理指令大致可分为3 类： （1） 数据传送指令（如MOV、MVN） （2） 算术逻辑运算指令（如ADD,SUM,AND） （3） 比较指令（如CMP、TST）。 数据处理指令只能对寄存器的内容进行操作。 所有ARM 数据处理指令均可选择使用S 后缀，以影响状态标志。比较指令CMP、CMN、TST和TEQ不需要后缀S，它们会直接影响状态标志。ARM数据处理指令列于表A-4中。 表A-4 ARM 数据处理指令 123456789 （1）数据传送指令**MOV** 数据传送指令。将8 位图立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作。指令格式如下： MOV&#123;cond&#125;&#123;S&#125; Rd,operand2 MOV 指令举例如下： MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2，并影响标志位 MOV PC,LR ;PC=LR ，子程序返回 MVN​ 数据非传送指令。将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。指令格式如下：​ MVN{cond}{S} Rd,operand2​ MVN 指令举例如下：​ MVN R1,#0xFF ;R1=0xFFFFFF00​ MVN R1,R2 ;将R2 取反，结果存到R1 ​ （2）算术逻辑运算指令 ADD​ 加法运算指令。将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器。指令格式如下：​ ADD{cond}{S} Rd,Rn,operand2​ ADD 指令举例如下：​ ADDS R1,R1,#1 ;R1=R1+1​ ADD R1,R1,R2 ;R1=R1+R2​ ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 SUB​ 减法运算指令。用寄存器Rn 减去operand2。结果保存到Rd 中。指令格式如下：​ SUB{cond}{S} Rd,Rn,operand2​ SUB 指令举例如下：​ SUBS R0,R0,#1 ;R0=R0-1​ SUBS R2,R1,R2 ;R2=R1-R2​ SUB R6,R7,#0x10 ;R6=R7-0x10 RSB​ 逆向减法指令。用寄存器operand2 减法Rn，结果保存到Rd 中。指令格式如下：​ RSB{cond}{S} Rd,Rn,operand2​ SUB 指令举例如下：​ RSB R3,R1,#0xFF00 ;R3=0xFF00-R1​ RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3​ RSB R0,R1,#0 ;R0=-R1 ADC​ 带进位加法指令。将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位。结果保存到Rd 寄存器。指令格式如下：​ ADC{cond}{S} Rd,Rn,operand2​ ADC 指令举例如下：​ ADDS R0,R0,R2​ ADC R1,R1,R3 ;使用ADC 实现64 位加法，(R1、R0)=(R1、R0)+（R3、R2） SBC​ 带进位减法指令。用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中。指令格式如下：​ SCB{cond}{S}Rd,Rn,operand2​ SBC 指令举例如下：​ SUBS R0，R0，R2​ SBC R1，R1，R3 ;使用SBC 实现64 位减法，(R1,R0)-(R3,R2) RSC​ 带进位逆向减法指令。用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中。指令格式如下：​ RSC{cond}{S} Rd,Rn,operand2​ RSC 指令举例如下：​ RSBS R2,R0,#0​ RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数 AND​ 逻辑与操作指令。将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中。指令格式如下：​ AND{cond}{S} Rd,Rn,operand2​ AND 指令举例如下：​ ANDS R0,R0,#x01 ;R0=R0&amp;0x01，取出最低位数据​ AND R2,R1,R3 ;R2=R1&amp;R3 ORR​ 逻辑或操作指令。将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。指令格式如下：​ ORR{cond}{S} Rd,Rn,operand2​ ORR 指令举例如下：​ ORR R0,R0,#x0F ;将R0 的低4 位置1​ MOV R1,R2,LSR #4​ ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中 EOR​ 逻辑异或操作指令。将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中。指令格式如下：​ EOR{cond}{S}Rd,Rn,operand2​ EOR 指令举例如下：​ EOR R1,R1,#0x0F ;将R1 的低4 位取反​ EOR R2,R1,R0 ;R2=R1^R0​ EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位 BIC​ 位清除指令。将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。指令格式如下：​ BIC{cond}{S}Rd,Rn,operand2​ BIC 指令举例如下：​ BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变​ BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1 ​ （3）比较指令 CMP​ 比较指令。指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下：​ CMP{cond} Rn,operand2​ CMP 指令举例如下：​ CMP R1,#10 ;R1 与10 比较，设置相关标志位​ CMP R1,R2 ;R1 与R2 比较，设置相关标志位​ CMP 指令与SUBS 指令的区别在于CMP 指令不保存运算结果。在进行两个数据大小判断时，常用CMP指令及相应的条件码来操作。 CMN​ 负数比较指令。指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行，指令格式如下：​ CMN{cond} Rn,operand2​ CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位​ CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。 TST​ 位测试指令。指令将寄存器Rn 的值与operand2 的值按位作逻辑与操作，根据操作的结果更新CPSR中相应的条件标志位(当结果为0时，EQ位被设置)，以便后面指令根据相应的条件标志来判断是否执行。指令格式如下：​ TST{cond} Rn,operand2​ TST 指令举例如下：​ TST R0,#0x01 ;判断R0 的最低位是否为0​ TST R1,#0x0F ;判断R1 的低4 位是否为0​ TST 指令与ANDS 指令的区别在于TST4 指令不保存运算结果。TST指令通常于EQ、NE条件码配合使用，当所有测试位均为0 时，EQ 有效，而只要有一个测试为不为0，则NE 有效。 TEQ​ 相等测试指令。指令寄存器Rn 的值与operand2 的值按位作逻辑异或操作，根据操作的结果更新CPSR中相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下：​ TEQ{cond} Rn,operand2​ TEQ 指令举例如下：​ TEQ R0,R1 ;比较R0 与R1 是否相等(不影响V 位和C 位)​ TST 指令与EORS 指令的区别在于TST 指令不保存运算结果。使用TEQ进行相等测试，常与EQNE 条件码配合使用，当两个数据相等时，EQ 有效，否则NE 有效。 （4）乘法指令​ ARM7TDMI(-S)具有32×32 乘法指令、32×32 乘加指令、32×32结果为64 位的乘法指令。表A-5给出全部的ARM 乘法指令。 表A-5 全部的ARM 乘法指令 MUL1234532 位乘法指令。指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中。指令格式如下：MUL&#123;cond&#125;&#123;S&#125; Rd,Rm,RsMUL 指令举例如下：MUL R1,R2,R3 ;R1=R2×R3MULS R0,R3,R7 ;R0=R3×R7，同时设置CPSR 中的N位和Z 位 MLA​ 32 位乘加指令。指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中。指令格式如下：​ MLA{cond}{S} Rd,Rm,Rs,Rn​ MLA 指令举例如下：​ MLA R1,R2,R3,R0 ;R1=R2×R3+10 UMULL​ 64 位无符号乘法指令。指令将Rm 和Rs 中的值作无符号数相乘，结果的低32位保存到RsLo 中，而高32 位保存到RdHi 中。指令格式如下：​ UMULL{cond}{S} RdLo,RdHi,Rm,Rs​ UMULL 指令举例如下：​ UMULL R0,R1,R5,R8 ;(R1、R0)=R5×R8 UMLAL​ 64 位无符号乘加指令。指令将Rm 和Rs 中的值作无符号数相乘，64 位乘积与RdHi、RdLo相加，结果的低32 位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ UMLAL{cond}{S} RdLo,RdHi,Rm,Rs​ UMLAL 指令举例如下：​ UMLAL R0,R1,R5,R8;(R1,R0)=R5×R8+(R1,R0) SMULL​ 64 位有符号乘法指令。指令将Rm 和Rs 中的值作有符号数相乘，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ SMULL{cond}{S} RdLo,RdHi,Rm,Rs​ SMULL 指令举例如下：​ SMULL R2,R3,R7,R6 ;(R3,R2)=R7×R6 SMLAL​ 64 位有符号乘加指令。指令将Rm 和Rs 中的值作有符号数相乘，64 位乘积与RdHi、RdLo，相加，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ SMLAL{cond}{S} RdLo,RdHi,Rm,Rs​ SMLAL 指令举例如下：​ SMLAL R2,R3,R7,R6;(R3,R2)=R7×R6+(R3,R2) 1.3.3. ARM 跳转指令​ 两种方式可以实现程序的跳转： （1） 使用跳转指令直接跳转，跳转指令有跳转指令B，带链接的跳转指令BL ，带状态切换的跳转指令BX。 （2） 直接向PC 寄存器赋值实现跳转。 表A-6给出全部的ARM跳转指令。 表A-6 ARM跳转指令 B​ 跳转指令，跳转到指定的地址执行程序。 `B{cond} label` 举例如下： ​ B WAITA ;跳转到WAITA 标号处 ​ B 0x1234 ;跳转到绝对地址0x1234 处 ​ 跳转到指令B 限制在当前指令的±32Mb 的范围内。 BL带链接的跳转指令。指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序。 ​ BL{cond} label ​ 举例如下： ​ BL DELAY ​ 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用。 BX带状态切换的跳转指令。跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码。指令格式如下：​ BX{cond} Rm​ 举例如下：​ ADRL R0,ThumbFun+1​ BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态 BLX​ BLX目标地址：跳转，改变状态及保存PC值 1.3.4. ARM 协处理器指令5 ARM 支持协处理器操作，协处理器的控制要通过协处理器命令实现。表A-7给出全部的ARM协处理器指令。 表A-7 ARM 协处理器指令 CDP​ 协处理器数据操作指令。ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ CDP{cond}coproc,opcodel,CRd,CRn,CRm{,opcode2}​ 其中： coproc 指令操作的协处理器名。标准名为pn,n 为0～15。​ opcodel 协处理器的特定操作码。​ CRd 作为目标寄存器的协处理器寄存器。​ CRN 存放第1 个操作数的协处理器寄存器。​ CRm 存放第2 个操作数的协处理器寄存器。​ Opcode2 可选的协处理器特定操作码。​ CDP 指令举例如下：​ CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0​ CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为1 LDC​ 协处理器数据读取指令。LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ LDC{cond}{L} coproc,CRd,&lt;地址&gt;​ 其中： L 可选后缀，指明是长整数传送。​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15​ CRd 作为目标寄存的协处理器寄存器。​ &lt;地址&gt; 指定的内存地址​ LDC 指令举例如下：​ LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中​ LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中 STC​ 协处理器数据写入指令。STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ STC{cond}{L} coproc,CRd,&lt;地址&gt;​ 其中： L 可选后缀，指明是长整数传送。​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15​ CRd 作为目标寄存的协处理器寄存器。​ &lt;地址&gt; 指定的内存地址​ STC 指令举例如下：​ STC p5,c1,[R0]​ STC p5,c1,[Ro,#-0x04] MCR​ ARM寄存器到协处理器寄存器的数据传送指令。MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ MCR{cond}coproc,opcodel,Rd,CRn,CRm{,opcode2}​ 其中：coproc 指令操作的协处理器名。标准名为pn，n 为0～15。​ cpcodel 协处理器的特定操作码。​ RD 作为目标寄存器。​ CRn 存放第1 个操作数的协处理器寄存器​ CRm 存放第2 个操作数的协处理器寄存器。​ Opcode2 可选的协处理器特定操作码。​ MCR 指令举例如下：​ MCR p6,2,R7,c1,c2,​ MCR P7,0,R1,c3,c2,1, MRC​ 协处理器寄存器到ARM寄存器到的数据传送指令。MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断。指令格式如下：​ MRC {cond}coproc,opcodel,Rd,CRn,CRm{,opcode2}​ 其中：coproc 指令操作的协处理器名。标准名为pn，n为0～15。​ opcodel 协处理器的特定操作码。​ Rd 作为目标寄存器。​ CRn 存放第1 个操作数的协处理器寄存器。​ CRm 存放第2 个操作数的协处理器寄存器。​ opcode2 可选的协处理器特定操作码。​ MRC 指令举例如下：​ MRC p5,2,R2,c3,c2​ MRC p7,0,R0,c1,c2,1 1.3.5. ARM 杂项指令​ 表A-8给出全部的ARM协处理器指令。 表A-8 ARM杂项指令 SWI ​ 软中断指令。SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式。指令格式如下：​ SWI{cond} immed_24​ 其中：immed_24 24 位立即数，值为0～16777215 之间的整数。​ SWI 指令举例如下：​ SWI 0 ;软中断，中断立即数为0​ SWI 0x123456 ;软中断，中断立即数为0x123456​ 使用SWI 指令时，通常使用以下两种方法进行传递参数，SWI 异常中断处理程序就可以提供相关的服务，这两种方法均是用户软件协定。SWI异常中断处理程序要通过读取引起软中断的SWI 指令，以取得24 位立即数。​ （A）指令24 位的立即数指定了用户请求的服务类型，参数通过用寄存器传递。​ MOV R0,#34 ;设置了功能号为34​ SWI 12 ;调用12 号软中断​ （B）指令中的24 位立即数被忽略，用户请求的服务类型由寄存器R0 的值决定，参数通过其它的通用寄存器传递。​ MOV R0,#12 ;调用12 号软中断​ MOV R1,#34 ;设置子功能号为34​ SWI 0 ;​ 在SWI 异常中断处理程序中，取出SWI 立即数的步骤为：首先确定引起软中断的SWI指令是ARM指令还时Thumb 指令，这可通过对SPSR 访问得到：然后要取得该SWI 指令的地址，这可通过访问LR 寄存器得到：接着读出指令，分解出立即数。​ 读出SWI 立即数：​ T_bit EQU 0x20​ SWI_Hander​ STMFD SP!,{R0_R3,R12,LR} ;现场保护​ MRS R0,SPSR ;读取SPSR​ STMFD SP!,{R0} ;保存SPSR​ TST R0,#T_bit ;测试T标志位​ LDRNEH R0,[LR,#-2] ;若是Thumb指令，读取指令码(16 位)​ BICNE R0,R0,#0xFF00 ;取得Thumb 指令的8 位立即数​ LDREQ R0,[LR,#-4] ;若是ARM 指令，读取指令码(32 位)​ BICNQ R0,R0,#0xFF00000 ;取得ARM 指令的24 位立即数​ …​ LDMFD SP!,{R0-R3,R12,PC}^ ;SWI 异常中断返回 MRS​ 读状态寄存器指令。在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中。指令格式如下：​ MRS{cond} Rd ,psr​ 其中： Rd 目标寄存器。Rd 不允许为R15。​ psr CPSR 或SPSR​ MRS指令举例如下：​ MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中​ MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中​ MRS 指令读取CPSR，可用来判断ALU 的状态标志，或IRQ、FIQ中断是否允许等；在异常处理程序中，读SPSR 可知道进行异常前的处理器状态等。MRS 与MSR 配合使用，实现CPSR 或SPSR 寄存器的读—修改—写操作，可用来进行处理器模式切换()，允许/禁止IRQ/FIQ中断等设置。另外，进程切换或允许异常中断嵌套时，也需要使用MRS 指令读取SPSR 状态值。保存起来。​ 使能IRQ 中断例程：​ ENABLE_IRQ​ MRS R0,CPSR​ BIC R0。R0,#0x80​ MSR CPSR_c,R0​ MOV PC,LR​ 禁能IRQ 中断例程：​ DISABLE_IRQ​ MRS R0,CPSR​ ORR R0,R0,#0x80​ MSR CPSR_c,R0​ MOV PC,LR MSR​ 写状态寄存器指令。在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR。指令格式如下：​ MSR{cond} psr_fields,#immed_8r​ MSR{cond} psr_fields,Rm​ 其中： psr CPSR 或SPSR​ fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)：​ c 控制域屏蔽字节(psr[7…0])​ x 扩展域屏蔽字节(psr[15…8])​ s 状态域屏蔽字节(psr[23。…16])​ f 标志域屏蔽字节(psr[31…24])​ immed_8r 要传送到状态寄存器指定域的立即数，8 位。​ Rm 要传送到状态寄存器指定域的数据的源寄存器。​ MSR 指令举例如下：​ MSR CPSR_c,#0xD3 ;CPSR[7…0]=0xD3，即切换到管理模式。​ MSR CPSR_cxsf,R3 ;CPSR=R3​ 只有在特权模式下才能修改状态寄存器。​ 程序中不能通过MSR 指令直接修改CPSR 中的T 控制位来实现ARM 状态/Thumb状态的切换，必须使用BX 指令完成处理器状态的切换(因为BX 指令属转移指令，它会打断流水线状态，实现处理器状态切换)。MRS 与MSR 配合使用，实现CPSR或SPSR 寄存器的读-修改-写操作，可用来进行处理器模式切换、允许/禁止IRQ/FIQ 中断等设置。​ 堆栈指令实始化例程：​ INITSTACK​ MOV R0,LR ;保存返回地址​ ;设置管理模式堆栈​ MSR CPSR_c,#0xD3​ LDR SP,StackSvc​ ;设置中断模式堆栈​ MSR CPSR_c,#0xD2​ LDR SP,StackIrq​ … 1.3.6. ARM 伪指令​ ARM 伪指令不是ARM 指令集中的指令，只是为了编程方便编译器定义了伪指令，使用时可以像其它ARM 指令一样使用，但在编译时这些指令将被等效的ARM 指令代替。ARM伪指令有四条，分别为ADR 伪指令、ADRL 伪指令、LDR 伪指令和NOP 伪指令。 ADR​ 小范围的地址读取伪指令。ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。​ ADR 伪指令格式如下：​ ADR{cond} register,exper​ 其中：register 加载的目标寄存器。​ exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。​ 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。​ ADR 伪指令举例如下：​ LOOP MOV R1, #0xF0​ …​ ADR R2, LOOP ;将LOOP 的地址放入R2​ ADR R3, LOOP+4​ 可以用ADR 加载地址，实现查表：​ …​ ADR R0,DISP_TAB ;加载转换表地址​ LDRB R1,[R0,R2] ;使用R2作为参数，进行查表​ …​ DISP_TAB​ DCB0Xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90 ADRL​ 中等范围的地址读取伪指令。ADRL 指令将基于PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现ADRL 伪指令功能，则产生错误，编译失败。ADRL伪指令格式如下：​ ADR{cond} register,exper​ 其中：register 加载的目标寄存器。​ expr 地址表达式。当地址值是非字对齐时，取范围-64K～64K 字节之间；当地址值是字对齐时，取值范围-256K～256K字节之间。​ ADRL 伪指令举例如下：​ ADRL R0,DATA_BUF​ …​ ADRL R1 DATA_BUF+80​ …​ DATA_BUF​ SPACE 100 ;定义100 字节缓冲区​ 可以且用ADRL 加载地址，实现程序跳转，中等范围地址的加载：​ …​ ADR LR,RETURNI ;设置返回地址​ ADRL R1Thumb_Sub+1 ;取得了Thumb 子程序入口地址，且R1 的0 位置1​ BX R1 ;调用Thumb子程序，并切换处理器状态​ RETURNI​ …​ CODE16​ Thumb_Sub​ MOV R1,#10​ … LDR​ 大范围的地址读取伪指令。LDR 伪指令用于加载32 位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV 或MVN 的范围，则使用MOV 或MVN 指令代替该LDR 伪指令，否则汇编器将常量放入字池，并使用一条程序相对偏移的LDR指令从文字池读出常量。LDR 伪指令格式如下：​ LDR{cond} register,=expr/label_expr​ 其中：register 加载的目标寄存器​ expr 32 位立即数。​ label_expr 基于PC 的地址表达式或外部表达式。​ LADR 伪指令举例如下：。​ LDR R0,=0x123456 ;加载32 位立即数0x12345678​ LDR R0,=DATA_BUF+60 ;加载DATA_BUF 地址+60​ …​ LTORG ;声明文字池​ 伪指令LDR 常用于加载芯片外围功能部件的寄存器地址(32 位立即数)，以实现各种控制操作加载32位立即数：​ …​ LDR R0,=IOPIN ;加载GPIO 寄存器IOPIN 的地址​ LDR R1,[R0] ;读取IOPIN 寄存器的值​ …​ LDR R0,=IOSET​ LDR R1,=0x00500500​ STR R1,[R0] ;IOSET=0x00500500​ …​ 从PC 到文字池的偏移量必须小于4KB。与ARM 指令的LDR 相比，伪指令的LDR的参数有“=”号 NOP​ 空操作伪指令。NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等，NOP 伪指令格式如下：​ NOP​ NOP​ NOP​ NOP​ SUBS R1, R1, #1​ BNE DELAY1​ … 1.4. 寻址方式1.4.1. 立即数寻址立即数前面有“#”号，并且如果是十六进制数则在“#”后添加“0x”或“&amp;”，二进制数“#”后面加“%”。 1.4.2. 寄存器寻址1.4.3. 寄存器间接寻址以寄存器中的值作为操作数的地址，而操作数本身放在存储器中。 例如： 1ADD R0，R1，[R2] 1.4.4. 基址变址寻址将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。 例如：LDR R0，[R1，#4] R0&lt;-[R1+4] 1.4.5. 多寄存器寻址一条指令可以完成多个寄存器值得传递，一条指令传送最多16个通用寄存器的值。 LDMIA R0，{R1，R2，R3，R4} 1.4.6. 相对寻址以程序计数器PC的值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到的操作数的有效地址。 例如：BL NEXT; 1.4.7. 堆栈寻址使用一个堆栈指针的专用寄存器指示当前操作位置 递增堆栈：向高地址方向生长 递减堆栈：向低地址方向生长 满堆栈：堆栈指针指向最后压入堆栈的有效数据 空堆栈：堆栈指针指向下一个要放入数据的空位置 2. GNU ARM混编​ 汇编源程序一般用于系统最基本的初始化：初始化堆栈指针、设置页表、操作 ARM的协处理器等。这些初始化工作完成后就可以跳转到C代码main函数中执行。 1.1. GNU汇编语言语句格式​ 任何Linux汇编行都是如下结构：[:][} @comment l instruction为指令 l directive为伪操作 l pseudo-instruction为伪指令 l :为标号, GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号，而不一定非要在一行的开始。 l comment为语句的注释 下面定义一个”add”的函数，最终返回两个参数的和： .section.text, “x” .globaladd @ give the symbol “add” externallinkage add: ​ ADD r0, r0, r1 @ add input arguments ​ MOV pc, lr @ return from subroutine @ endof program 注意： l ARM指令，伪指令，伪操作，寄存器名可以全部为大写字母，也可全部为小写字母，但不可大小写混用。 l 如果语句太长，可以将一条语句分几行来书写，在行末用“\”表示换行（即下一行与本行为同一语句）。“\”后不能有任何字符，包含空格和制表符（Tab)。 1.2. GNU汇编程序中的标号symbol（或label）​ 标号只能由a～z，A～Z，0～9，“.”，_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成。 Symbol的本质：代表它所在的地址,因此也可以当作变量或者函数来使用。 l 段内标号的地址值在汇编时确定； l 段外标号的地址值在连接时确定。 Symbol的分类：3类（依据标号的生成方式）。 基于PC的标号。基于PC的标号是位于目标指令前的标号或者程序中数据定义伪操作前的标号。这种标号在汇编时将被处理成PC值加上（或减去）一个数字常量，常用于表示跳转指令”b”等的目标地址，或者代码段中所嵌入的少量数据。 基于寄存器的标号。基于寄存器的标号常用MAP和FIELD来定义，也可以用EQU来定义。这种标号在汇编时将被处理成寄存器的值加上（或减去）一个数字常量，常用于访问数据段中的数据。 绝对地址。绝对地址是一个32位数据。它可以寻址的范围为[0，232-1]即可以直接寻址整个内存空间。 特别说明：局部标号Symbol ​ 局部标号主要在局部范围内使用，而且局部标号可以重复出现。它由两部组成：开头是一个0-99直接的数字，后面紧接一个通常表示该局部变量作用范围的符号。局部变量的作用范围通常为当前段，也可以用ROUT来定义局部变量的作用范围。 ​ 局部变量定义的语法格式：N{routname} l N：为0~99之间的数字。 l routname：当前局部范围的名称（为符号），通常为该变量作用范围的名称（用ROUT伪操作定义的）。 ​ 局部变量引用的语法格式：%{F|B}{A|T}N{routname} l %：表示引用操作 l N：为局部变量的数字号 l routname：为当前作用范围的名称（用ROUT伪操作定义的） l F：指示编译器只向前搜索 l B：指示编译器只向后搜索 l A：指示编译器搜索宏的所有嵌套层次 l T：指示编译器搜索宏的当前层次 例：使用局部符号的例子，一段循环程序 subs r0, r0, #1 @每次循环使r0=r0-1 bne 1F @跳转到1标号去执行 注意： l 如果F和B都没有指定，编译器先向前搜索，再向后搜索 l 如果A和T都没有指定，编译器搜索所有从当前层次到宏的最高层次，比当前层次低的层次不再搜索。 l 如果指定了routname，编译器向前搜索最近的ROUT伪操作，若routname与该ROUT伪操作定义的名称不匹配，编译器报告错误，汇编失败。 1.3. GNU汇编程序中的分段 .section伪操作 .section &lt;section_name&gt; {,””} Startsa new code or data section. Sections in GNU are called .text, a code section, .data, an initializeddata section, and .bss, an uninitialized data section. Thesesections have default flags, and the linker understands the default names(similardirective to the armasm directive AREA).The following are allowable .section flags for ELF format files: Meaning a allowable section w writable section x executable section 中文解释： 用户可以通过.section伪操作来自定义一个段,格式如下： .section section_name [,”flags”[, %type[,flag_specific_arguments]]] 每一个段以段名为开始, 以下一个段名或者文件结尾为结束。这些段都有缺省的标志（flags），连接器可以识别这些标志。(与arm asm中的AREA相同)。下面是ELF格式允许的段标志flags： &lt;标志&gt; 含义 a 允许段 w 可写段 x 执行段 例：定义一个“段” .section.mysection @自定义数据段，段名为 “.mysection” .align 2 strtemp: ​ .ascii “Temp string \n\0” @对这一句的理解，我觉得应该是：将”Temp string \n\0”这个字符串存储在以标号strtemp为起始地址的一段内存空间里 汇编系统预定义的段名 l .text @代码段 l .data @初始化数据段.data Read-write initialized long data. l .bss @未初始化数据段 l .sdata @ .sdata Read-write initialized short data. l .sbss @ 注意：源程序中.bss段应该在.text段之前。 1.4. GNU汇编语言定义入口点汇编程序的缺省入口是_start标号，用户也可以在连接脚本文件中用ENTRY标志指明其它入口点。 例：定义入口点 .section .data &lt; initialized data here&gt; .section .bss &lt; uninitialized data here&gt; .section .text .globl _start _start: 1.5. GNU汇编程序中的宏定义格式如下： .macro 宏名参数名列表 @伪指令.macro定义一个宏 宏体 .endm @.endm表示宏结束 ​ 如果宏使用参数,那么在宏体中使用该参数时添加前缀“\”。宏定义时的参数还可以使用默认值。可以使用.exitm伪指令来退出宏。 例：宏定义 .macroSHIFTLEFT a, b .if \b&lt; 0 MOV \a,\a, ASR #-\b .exitm .endif MOV \a,\a, LSL #\b .endm 1.6. GNU汇编程序中的常数 十进制数以非0数字开头,如:123和9876； 二进制数以0b开头,其中字母也可以为大写； 八进制数以0开始,如:0456,0123； 十六进制数以0x开头,如:0xabcd,0X123f； 字符串常量需要用引号括起来,中间也可以使用转义字符,如: “You are welcome!\n”； 当前地址以“.”表示,在GNU汇编程序中可以使用这个符号代表当前指令的地址； 表达式：在汇编程序中的表达式可以使用常数或者数值, “-”表示取负数, “~”表示取补,“&lt;&gt;”表示不相等,其他的符号如:+、-、*、/、%、&lt;、&lt;&lt;、&gt;、&gt;&gt;、|、&amp;、^、!、==、&gt;=、&lt;=、&amp;&amp;、|| 跟C语言中的用法相似。 1.7. GNU ARM汇编的常用伪操作​ 在前面已经提到过了一些为操作，还有下面一些为操作： l 数据定义伪操作： .byte，.short，.long，.quad，.float，.string/.asciz/.ascii，重复定义伪操作.rept，赋值语句.equ/.set ； l 函数的定义； l 对齐方式伪操作 .align； l 源文件结束伪操作.end； l .include伪操作； l if伪操作； l .global/ .globl 伪操作； l .type伪操作； l 列表控制语句； 别于GNU AS汇编的通用伪操作,下面是ARM特有的伪操作： .reg ，.unreq ，.code ，.thumb ，.thumb_func ，.thumb_set， .ltorg ，.pool 数据定义伪操作 l .byte:单字节定义，如：.byte 1,2,0b01,0x34,072,’s’ ； l .short:定义双字节数据，如:.short 0x1234,60000 ； l .long:定义4字节数据，如:.long 0x12345678,23876565 l .quad:定义8字节，如:.quad 0x1234567890abcd l .float：定义浮点数，如：.float 0f-314159265358979323846264338327\ ​ 95028841971.693993751E-40 @ - pi l .string/.asciz/.ascii：定义多个字符串，如: .string “abcd”,”efgh”, “hello!” .asciz “qwer”,”sun”, “world!” .ascii “welcome\0” ​ 注意：ascii伪操作定义的字符串需要自行添加结尾字符’\0’。 l .rept:重复定义伪操作, 格式如下： .rept 重复次数 数据定义 .endr @结束重复定义 例： .rept 3 .byte 0x23 .endr l .equ/.set: 赋值语句, 格式如下： .equ(.set)变量名，表达式 例： .equ abc, 3 @让abc=3 函数的定义伪操作 l 函数的定义,格式如下： 函数名: 函数体 返回语句 ​ 一般的,函数如果需要在其他文件中调用, 需要用到.global伪操作将函数声明为全局函数。为了不至于在其他程序在调用某个C函数时发生混乱,对寄存器的使用我们需要遵循APCS准则。函数编译器将处理函数代码为一段.global的汇编码。 l 函数的编写应当遵循如下规则： a. a1-a4寄存器（参数、结果或暂存寄存器，r0到r3 的同义字）以及浮点寄存器f0-f3(如果存在浮点协处理器)在函数中是不必保存的； b. 如果函数返回一个不大于一个字大小的值，则在函数结束时应该把这个值送到 r0 中； c. 如果函数返回一个浮点数，则在函数结束时把它放入浮点寄存器f0中； d. 如果函数的过程改动了sp（堆栈指针，r13）、fp（框架指针，r11）、sl（堆栈限制，r10）、lr（连接寄存器，r14）、v1-v8（变量寄存器，r4 到 r11）和 f4-f7,那么函数结束时这些寄存器应当被恢复为包含在进入函数时它所持有的值。 .align .end .include .incbin伪操作 l .align:用来指定数据的对齐方式,格式如下: ​ .align [absexpr1, absexpr2] ​ 以某种对齐方式,在未使用的存储区域填充值. 第一个值表示对齐方式,4, 8,16或 32.第二个表达式值表示填充的值。 l .end:表明源文件的结束。 l .include:可以将指定的文件在使用.include 的地方展开,一般是头文件,例如: ​ .include “myarmasm.h” l .incbin伪操作可以将原封不动的一个二进制文件编译到当前文件中,使用方法如下: ​ .incbin”file”[,skip[,count]] ​ skip表明是从文件开始跳过skip个字节开始读取文件,count是读取的字数. ..if伪操作 ​ 根据一个表达式的值来决定是否要编译下面的代码, 用.endif伪操作来表示条件判断的结束,中间可以使用.else来决定.if的条件不满足的情况下应该编译哪一部分代码。 .if有多个变种: .ifdefsymbol @判断symbol是否定义 .ifcstring1,string2 @字符串string1和string2是否相等,字符串可以用单引号括起来 .ifeqexpression @判断expression的值是否为0 .ifeqsstring1,string2 @判断string1和string2是否相等,字符串必须用双引号括起来 .ifgeexpression @判断expression的值是否大于等于0 .ifgtabsolute expression @判断expression的值是否大于0 .ifleexpression @判断expression的值是否小于等于0 .ifltabsolute expression @判断expression的值是否小于0 .ifncstring1,string2 @判断string1和string2是否不相等, 其用法跟.ifc恰好相反。 .ifndefsymbol, .ifnotdef symbol @判断是否没有定义symbol, 跟.ifdef恰好相反 .ifneexpression @如果expression的值不是0, 那么编译器将编译下面的代码 .ifnesstring1,string2 @如果字符串string1和string2不相等, 那么编译器将编译下面的代码. .global .type .title .list l .global/ .globl ：用来定义一个全局的符号，格式如下: ​ .global symbol 或者 .globl symbol l .type：用来指定一个符号的类型是函数类型或者是对象类型, 对象类型一般是数据, 格式如下: ​ .type 符号, 类型描述 例： .globla .data .align4 .typea, @object .sizea, 4 a: .long10 例： .section.text .typeasmfunc, @function .globlasmfunc asmfunc: mov pc,lr 列表控制语句: .title：用来指定汇编列表的标题,例如: .title “my program” .list：用来输出列表文件. ARM特有的伪操作 l .reg: 用来给寄存器赋予别名,格式如下: ​ 别名 .req 寄存器名 l .unreq: 用来取消一个寄存器的别名,格式如下: .unreq 寄存器别名 ​ 注意被取消的别名必须事先定义过,否则编译器就会报错,这个伪操作也可以用来取消系统预制的别名, 例如r0, 但如果没有必要的话不推荐那样做。 l .code伪操作用来选择ARM或者Thumb指令集,格式如下: .code 表达式 如果表达式的值为16则表明下面的指令为Thumb指令,如果表达式的值为32则表明下面的指令为ARM指令. l .thumb伪操作等同于.code 16, 表明使用Thumb指令, 类似的.arm等同于.code 32 l .force_thumb伪操作用来强制目标处理器选择thumb的指令集而不管处理器是否支持 l .thumb_func伪操作用来指明一个函数是thumb指令集的函数 l .thumb_set伪操作的作用类似于.set, 可以用来给一个标志起一个别名, 比.set功能增加的一点是可以把一个标志标记为thumb函数的入口, 这点功能等同于.thumb_func l .ltorg用于声明一个数据缓冲池(literal pool)的开始,它可以分配很大的空间。 l .pool的作用等同.ltorg l .space&lt;number_of_bytes&gt; {,&lt;fill_byte&gt;} ​ 分配number_of_bytes字节的数据空间，并填充其值为fill_byte，若未指定该值，缺省填充0。（与armasm中的SPACE功能相同） l .word {,} …插入一个32-bit的数据队列。（与armasm中的DCD功能相同）可以使用.word把标识符作为常量使用。 例： Start: valueOfStart: ​ .word Start 这样程序的开头Start便被存入了内存变量valueOfStart中。 l .hword {,} … 插入一个16-bit的数据队列。（与armasm中的DCW相同） 1.8. GNU ARM汇编特殊字符和语法 代码行中的注释符号: ‘@’ 整行注释符号: ‘#’ 语句分离符号: ‘;’ 立即数前缀: ‘#’ 或 ‘$’ 3. ARM GCC 内嵌汇编对于基于ARM的RISC处理器，GNUC编译器提供了在C代码中内嵌汇编的功能。这种非常酷的特性提供了C代码没有的功能，比如手动优化软件关键部分的代码、使用相关的处理器指令。这里设想了读者是熟练编写ARM汇编程序读者，因为该片文档不是ARM汇编手册。同样也不是C语言手册。这篇文档假设使用的是GCC 4 的版本，但是对于早期的版本也有效。 GCCasm 声明 让我们以一个简单的例子开始。就像C中的声明一样，下面的声明代码可能出现在你的代码中。 /NOP 例子 / asm(“movr0,r0”); 该语句的作用是将r0移动到r0中。换句话讲他并不干任何事。典型的就是NOP指令，作用就是短时的延时。 请接着阅读和学习这篇文档，因为该声明并不像你想象的和其他的C语句一样。内嵌汇编使用汇编指令就像在纯汇编程序中使用的方法一样。可以在一个asm声明中写多个汇编指令。但是为了增加程序的可读性，最好将每一个汇编指令单独放一行。 asm( “mov r0, r0\n\t” “mov r0, r0\n\t” “mov r0, r0\n\t” “mov r0, r0” ); 换行符和制表符的使用可以使得指令列表看起来变得美观。你第一次看起来可能有点怪异，但是当C编译器编译C语句的是候，它就是按照上面（换行和制表）生成汇编的。到目前为止，汇编指令和你写的纯汇编程序中的代码没什么区别。但是对比其它的C声明，asm的常量和寄存器的处理是不一样的。通用的内嵌汇编模版是这样的。 asm(code : output operand list : input operand list : clobberlist); 汇编和C语句这间的联系是通过上面asm声明中可选的outputoperand list和input operand list。Clobber list后面再讲。 下面是将c语言的一个整型变量传递给汇编，逻辑左移一位后在传递给C语言的另外一个整型变量。 / Rotating bits example / asm(“mov %[result], %[value], ror #1” :[result] “=r” (y) : [value] “r” (x)); 每一个asm语句被冒号（:）分成了四个部分。 汇编指令放在第一部分中的“”中间。 “mov %[result], %[value], ror #1” 接下来是冒号后的可选择的output operand list，每一个条目是由一对[]（方括号）和被他包括的符号名组成，它后面跟着限制性字符串，再后面是圆括号和它括着的C变量。这个例子中只有一个条目。 [result] “=r” (y) 接着冒号后面是输入操作符列表，它的语法和输入操作列表一样 [value] “r” (x) 破坏符列表，在本例中没有使用 就像上面的NOP例子，asm声明的4个部分中，只要最尾部没有使用的部分都可以省略。但是有有一点要注意的是，上面的4个部分中只要后面的还要使用，前面的部分没有使用也不能省略，必须空但是保留冒号。下面的一个例子就是设置ARMSoc的CPSR寄存器，它有input但是没有output operand。 asm(“msr cpsr,%[ps]” : : [ps]”r”(status)) 即使汇编代码没有使用，代码部分也要保留空字符串。下面的例子使用了一个特别的破坏符，目的就是告诉编译器内存被修改过了。这里的破坏符在下面的优化部分在讲解。 asm(“”:::”memory”); 为了增加代码的可读性，你可以使用换行，空格，还有C风格的注释。 asm(“mov %[result], %[value], ror#1” ​ : [result]”=r” (y) /Rotation result. / ​ : [value]”r” (x) /Rotated value. / ​ : / No clobbers / ); 在代码部分%后面跟着的是后面两个部分方括号中的符号，它指的是相同符号操作列表中的一个条目。 %[result]表示第二部分的C变量y，%[value]表示三部分的C变量x； 符号操作符的名字使用了独立的命名空间。这就意味着它使用的是其他的符号表。简单一点就是说你不必关心使用的符号名在C代码中已经使用了。在早期的C代码中，循环移位的例子必须要这么写： asm(“mov %0, %1, ror #1” :”=r” (result) : “r” (value)) 在汇编代码中操作数的引用使用的是%后面跟一个数字，%1代表第一个操作数，%2代码第二个操作数，往后的类推。这个方法目前最新的编译器还是支持的。但是它不便于维护代码。试想一下，你写了大量的汇编指令的代码，要是你想插入一个操作数，那么你就不得不从新修改操作数编号。 优化C代码 有两种情况决定了你必须使用汇编。1st，C限制了你更加贴近底层操作硬件，比如，C中没有直接修改程序状态寄存器（PSR）的声明。2nd就是要写出更加优化的代码。毫无疑问GNUC代码优化器做的很好，但是他的结果和我们手工写的汇编代码相差很远。 这一部分有一点很重要，也是被别人忽视最多的就是：我们在C代码中通过内嵌汇编指令添加的汇编代码，也是要被C编译器的优化器处理的。让我们下面做个试验来看看吧。 下面是代码实例。 bigtree@just:~/embedded/basic-C$ arm-linux-gcc -c test.c bigtree@just:~/embedded/basic-C$ arm-linux-objdump -D test.o 编译器选择r3作为循环移位使用。它也完全可以选择为每一个C变量分配寄存器。Load或者store一个值并不显式的进行。下面是其它编译器的编译结果。 E420A0E1 mov r2, r4, ror #1 @ y, x 编译器为每一个操作数选择一个相应的寄存器，将操作过的值cache到r4中，然后传递该值到r2中。这个过程你能理解不？ 有的时候这个过程变得更加糟糕。有时候编译器甚至完全抛弃你嵌入的汇编代码。C编译器的这种行为，取决于代码优化器的策略和嵌入汇编所处的上下文。如果在内嵌汇编语句中不使用任何输出部分，那么C代码优化器很有可能将该内嵌语句完全删除。比如NOP例子，我们可以使用它作为延时操作，但是对于编译器认为这影响了程序的执行速速，认为它是没有任何意义的。 上面的解决方法还是有的。那就是使用volatile关键字。它的作用就是禁止优化器优化。将NOP例子修改过后如下： / NOP example, revised / asm volatile(“movr0, r0”); 下面还有更多的烦恼等着我们。一个设计精细的优化器可能重新排列代码。看下面的代码： i++; if (j == 1) x += 3; i++; 优化器肯定是要从新组织代码的，两个i++并没有对if的条件产生影响。更进一步的来讲，i的值增加2，仅仅使用一条ARM汇编指令。因而代码要重新组织如下： if (j == 1) x += 3; i += 2; 这样节省了一条ARM指令。结果是：这些操作并没有得到许可。 这些将对你的代码产生很到的影响，这将在下面介绍。下面的代码是c乘b，其中c和b中的一个或者两个可能会被中断处理程序修改。进入该代码前先禁止中断，执行完该代码后再开启中断。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” ::: “r12”, “cc”); c = b; / This may fail. */ asm volatile(“mrs r12, cpsr\n” “bic r12, r12, #0xC0\n” “msr cpsr_c, r12” ::: “r12”, “cc”); 但是不幸的是针对上面的代码，优化器决定先执行乘法然后执行两个内嵌汇编，或相反。这样将会使得我们的代码变得毫无意义。 我们可以使用clobberlist帮忙。上面例子中的clobber list如下： “r12”,”cc” 上面的clobber list将会将向编译器传达如下信息，修改了r12和程序状态寄存器的标志位。Btw，直接指明使用的寄存器，将有可能阻止了最好的优化结果。通常你只要传递一个变量，然后让编译器自己选择适合的寄存器。另外寄存器名，cc（condition registor 状态寄存器标志位），memory都是在clobber list上有效的关键字。它用来向编译器指明，内嵌汇编指令改变了内存中的值。这将强迫编译器在执行汇编代码前存储所有缓存的值，然后在执行完汇编代码后重新加载该值。这将保留程序的执行顺序，因为在使用了带有memory clobber的asm声明后，所有变量的内容都是不可预测的。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” :: : “r12”, “cc”,”memory”); c = b; / This is safe. */ asm volatile(“mrs r12, cpsr\n” “bic r12, r12, #0xC0\n” “msr cpsr_c, r12” ::: “r12”, “cc”,”memory”); 使所有的缓存的值都无效，只是局部最优（suboptimal）。你可以有选择性的添加dummyoperand 来人工添加依赖。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” : “=X” (b) :: “r12”,”cc”); c = b; / This is safe. */ asm volatile(“mrs r12 上面的第一个asm试图修改变量先b，第二个asm试图修改c。这将保留三个语句的执行顺序，而不要使缓存的变量无效。 理解优化器对内嵌汇编的影响很重要。如果你读到这里还是云里雾里，最好是在看下个主题之前再把这段文章读几遍^_^。 Input and output operands 前面我们学到，每一个input和output operand，由被方括号[]中的符号名，限制字符串，圆括号中的C表达式构成。 这些限制性字符串有哪些，为什么我们需要他们？你应该知道每一条汇编指令只接受特定类型的操作数。例如：跳转指令期望的跳转目标地址。不是所有的内存地址都是有效的。因为最后的opcode只接受24位偏移。但矛盾的是跳转指令和数据交换指令都希望寄存器中存储的是32位的目标地址。在所有的例子中，C传给operand的可能是函数指针。所以面对传给内嵌汇编的常量、指针、变量，编译器必须要知道怎样组织到汇编代码中。 对于ARM核的处理器，GCC 4 提供了一下的限制。 Constraint Usage in ARM state Usage in Thumb state f Floating point registers f0 .. f7 Not available G Immediate floating point constant Not available H Same a G, but negated Not available I Immediate value in data processing instructionse.g. ORR R0, R0, #operand Constant in the range 0 .. 255e.g. SWI operand J Indexing constants -4095 .. 4095e.g. LDR R1, [PC, #operand] Constant in the range -255 .. -1e.g. SUB R0, R0, #operand K Same as I, but inverted Same as I, but shifted L Same as I, but negated Constant in the range -7 .. 7e.g. SUB R0, R1, #operand l Same as r Registers r0..r7e.g. PUSH operand M Constant in the range of 0 .. 32 or a power of 2e.g. MOV R2, R1, ROR #operand Constant that is a multiple of 4 in the range of 0 .. 1020e.g. ADD R0, SP, #operand m Any valid memory address N Not available Constant in the range of 0 .. 31e.g. LSL R0, R1, #operand o Not available Constant that is a multiple of 4 in the range of -508 .. 508e.g. ADD SP, #operand r General register r0 .. r15e.g. SUB operand1, operand2, operand3 Not available W Vector floating point registers s0 .. s31 Not available X Any operand = ：Write-only operand, usually used for all output operands+ ：Read-write operand, must be listed as an output operand&amp; ：A register that should be used for output only Output operands必须为write-only，相应C表达式的值必须是左值。Input operands必须为read-only。C编译器是没有能力做这个检查。 比较严格的规则是：不要试图向input operand写。但是如果你想要使用相同的operand作为input和output。限制性modifier（+）可以达到效果。例子如下： asm(“mov %[value], %[value], ror #1” : [value]”+r” (y)) 和上面例子不一样的是，最后的结果存储在input variable中。 可能modifier + 不支持早期的编译器版本。庆幸的是这里提供了其他解决办法，该方法在最新的编译器中依然有效。对于input operators有可能使用单一的数字n在限制字符串中。使用数字n可以告诉编译器使用的第n个operand，operand都是以0开始计数。下面是例子： asm(“mov %0, %0, ror #1” : “=r” (value) :”0” (value)) 限制性字符串“0”告诉编译器，使用和第一个output operand使用同样input register。 请注意，在相反的情况下不会自动实现。如果我没告诉编译器那样做，编译器也有可能为input和output选择相同的寄存器。第一个例子中就为input和output选择了r3。 在多数情况下这没有什么，但是如果在input使用前output已经被修改过了，这将是致命的。在input和output使用不同寄存器的情况下，你必须使用&amp;modifier来限制outputoperand。下面是代码示例： asm volatile(“ldr %0, [%1]””\n\t” ​ “str %2, [%1, #4]””\n\t” ​ : “=&amp;r” (rdv) ​ : “r”(&amp;table), “r” (wdv) ​ : “memory”); 在以张表中读取一个值然后在写到该表的另一个位置。 其他 内嵌汇编作为预处理宏 要是经常使用使用部分汇编，最好的方法是将它以宏的形式定义在头文件中。使用该头文件在严格的ANSI模式下会出现警告。为了避免该类问题，可以使用asm代替asm，volatile代替volatile。这可以等同于别名。下面就是个例程： #define BYTESWAP(val) \ asm volatile ( \ ​ “eor r3, %1, %1, ror #16\n\t” \ ​ “bic r3, r3, #0x00FF0000\n\t” \ ​ “mov %0, %1, ror #8\n\t” \ ​ “eor %0, %0, r3, lsr #8” \ ​ : “=r” (val) \ ​ : “0”(val) \ ​ : “r3”, “cc” \ ); C 桩函数 宏定义包含的是相同的代码。这在大型routine中是不可以接受的。这种情况下最好定义个桩函数。 unsigned long ByteSwap(unsigned longval) { asm volatile ( ​ “eor r3, %1, %1, ror #16\n\t” ​ “bic r3, r3, #0x00FF0000\n\t” ​ “mov %0, %1, ror #8\n\t” ​ “eor %0, %0, r3, lsr #8” ​ : “=r” (val) ​ : “0”(val) ​ : “r3” ); return val; } 替换C变量的符号名 默认的情况下，GCC使用同函数或者变量相同的符号名。你可以使用asm声明，为汇编代码指定一个不同的符号名 unsigned long value asm(“clock”) = 3686400 这个声明告诉编译器使用了符号名clock代替了具体的值。 替换C函数的符号名 为了改变函数名，你需要一个原型声明，因为编译器不接受在函数定义中出现asm关键字。 extern long Calc(void) asm (“CALCULATE”) 调用函数calc()将会创建调用函数CALCULATE的汇编指令。 强制使用特定的寄存器 局部变量可能存储在一个寄存器中。你可以利用内嵌汇编为该变量指定一个特定的寄存器。 void Count(void) { register unsigned char counterasm(“r3”); … some code… asm volatile(“eor r3, r3,r3”); … more code… } 汇编指令“eor r3, r3, r3”，会将r3清零。Waring：该例子在到多数情况下是有问题的，因为这将和优化器相冲突。因为GCC不会预留其它寄存器。要是优化器认为该变量在以后一段时间没有使用，那么该寄存器将会被再次使用。但是编译器并没有能力去检查是否和编译器预先定义的寄存器有冲突。如果你用这种方式指定了太多的寄存器，编译器将会在代码生成的时候耗尽寄存器的。 临时使用寄存器 如果你使用了寄存器，而你没有在input或output operand传递，那么你就必须向编译器指明这些。下面的例子中使用r3作为scratch 寄存器，通过在clobber list中写r3，来让编译器得知使用该寄存器。由于ands指令跟新了状态寄存器的标志位，使用cc在clobber list中指明。 asm volatile( “ands r3, %1, #3” “\n\t” “eor %0, %0, r3” “\n\t” “addne %0, #4” : “=r” (len) : “0” (len) : “cc”, “r3” ); 最好的方法是使用桩函数并且使用局部临时变量 寄存器的用途 比较好的方法是分析编译后的汇编列表，并且学习C 编译器生成的代码。下面的列表是编译器将ARM核寄存器的典型用途，知道这些将有助于理解代码。 Register Alt. Name Usage r0 a1 First function argumentInteger function resultScratch register r1 a2 Second function argumentScratch register r2 a3 Third function argumentScratch register r3 a4 Fourth function argumentScratch register r4 v1 Register variable r5 v2 Register variable r6 v3 Register variable r7 v4 Register variable r8 v5 Register variable= r9 v6 rfpRegister variableReal frame pointer r10 sl Stack limit r11 fp Argument pointer r12 ip Temporary workspace r13 sp Stack pointer r14 lr Link register Workspace r15 pc Program counter]]></content>
  </entry>
  <entry>
    <title><![CDATA[LOVE]]></title>
    <url>%2F2019%2F05%2F27%2FLOVE%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. Incorrect Password! No content to display! U2FsdGVkX1/HtKsGPHpb70aH9N5X6jn2ysXiuhf2x4jOdVhb+5rwGfnzGxRK7muUCdvTKQT7rMrkoXlSUp63MZd2tSdCeilbVld5vn6G4hDCuh+JNQ2yQdmmi9j3PQG1NoYBQW/sUnZqPkPNP5fc9qhcP433vLASzaXVBP0PAOK3c1uYswiZpk9zVrZi9BE3AhLUr9FYHl5I6c8ihEa/A2hdgOVIrNGSctWYuXaC7bsA3av7ZW504BsSBH6elVvo078AyqOwZx0l4hJ4QpHQNc1hTY0IF5CB5i2NBeH+sLsIalwCwSQyMeNNFKz1+vF0Bs05ghfR7NWFGEupT8OJ9EBYgQdUo09mLbjSf36EJbXViCaHMFq6Im9c6WBjcY4wJHvA/wlhXAO3Nz+5MdF+Y7gWUzzL1+LJX8EFA3+fuYS41bb4Pl94B4ZXRxcsroueHgTFlgxJLlRKzM2EN5Fpq5jNzDAVKdS1tC1+1dD9v02oKQU4SHqwuI1LHyZc0p+MnrhdctLr9XswN1D+MV9WuPLuU9fq2r0uZl+X8eIql80Q8zmx1NzEedfw2HsU+HRmYAcEJ2zwpyQLECeJIJ1ZCpg6V+kk6ATb22qGW192yGLvMYKYkpasjsSt00xqPyCWKHfoNwGMMLnMgH6C2L8C8BMR+aCgNdQYBXyiknGo9q0CkgJ1El44ISGkhZzIggSCZL8z4nFXJFq6/5/UzBWDRoqGHPuITlK5spiEl+/FLu0sf7Nuk5pX3aCeeJMgOuyyWljKq8UnIzhBJpI/z4qfzhutb8M0FHh8DWXhgUNUfRLRrVZ/thTo8/81AJfJgB6thP4/7A3rWqselC825qHz7lCoebWEGvd4I2jPQoyvCYiqA/vzwEvd83WNa5s+ugW3jPyVhTXxhvTA/E4mvz5S2nJ5eHzJANQBCreJJsFO/PLN15We2lyPoyWsRC7pcIgjlbWItf+WGwIgM+yazdDVhztR8WYstwOHVyEfcw+itmaxSWZ2wUASY4gNPuJq3wkxVUvigs7vTO85xlMxsQ0yWUy3RjEEMkBjc5E8lqd/4JMRBYvwdKWW7WtTp6iw0iQv3mgw5XeEIbVLtR73OX4aguvx8pIXmz7DS9uyYpaNOJvFK9w3CYVnk+/ZfXFMdIPwthhVBUC4lv7GwJ2Si/M3ir9nVzY4Veaxbi0hLDxSSJu3XtH9s9F0nH1mBm9jCR2ZxR3TAI3aJMjbtwfKgOhSpmjtAwmb28itbSfzynz8X3I9XQhqu1kZZGOOJs4D8io4RxAaUCXkOA0DfIh9HevMFye8NcGaU8u/Zr9CjLry+4evgRZZFPDHj8JdNRfh+MCvBvrO1eUAcqDD+SUlUZg3qkhQ+47ZN1s9DKz1upMhIRXMyh5aojeTNSJIFFEL5deuLrPUJDWPkoH/Zb7kG5nvZFDRoCVcfUIMHpEZfUell6wC08QRSE0cQYLy0KjfWQLArYHZT7e4mkUFiCDQHfqo9SRj1Hm2IFaO+LinCC87+uf3gYluxIS/r3pq8aDp0Ck/aFoFU3HRF2FxnvPc/HzkSn5vwNFPpgqHFnAnM7EZqog7fNi6svf84uugKye8wro7PKM6UpuzBnfVYawXRXr/UDdzUS3rDS/SAE6wVo3krPcf9J/QSAsHbByzurSLO9hQbMbc819RaDOMkQ4lMTgdDkOWeaX+IxWPYGvD4CyypPK+oNNHWFfQeBzlZXmr5KjDnA4kCuYDJX5jJBmTgTXxWA4xy7h8+AwX84aYWLU9no0=]]></content>
  </entry>
  <entry>
    <title><![CDATA[Movie]]></title>
    <url>%2F2019%2F05%2F27%2FMovie%2F</url>
    <content type="text"><![CDATA[To the movieIn the wanda 战狼2 空天猎 极致追击 英伦对决 看不见的客人 羞羞的铁拳 天才枪手 王牌特工2：黄金圈 银翼杀手2049 全球风暴 雷神3：诸神黄昏 精灵宝可梦： 波尔凯尼恩与机巧的马机雅娜 正义联盟 恐袭波士顿 推理笔记 烟花 寻梦环游记 巨额来电 帕丁顿熊2 鲨海 奇门遁甲 心理罪之城市之光 芳华 疯狂特警队 妖猫传 机器之血 妖铃铃 前任3： 再见前任 二代妖精之今生有幸 星球大战：最后的绝地武士 勇敢者游戏： 决战丛林 无问西东 谜巢 英雄本色2018 神秘巨星 移动迷宫3： 死亡解药 绝命时钟2：22 24小时：末路重生 忌日快乐 南极之恋 唐人街探案2 红海行动 捉妖记2 小萝莉的猴神大叔 黑豹 解忧杂货店 古墓丽影：起源之战 环太平洋：雷霆再起 头号玩家 通勤营救 起跑线 湮灭 脱单告急 幕后玩家 后来的我们 哆啦A梦：大雄的金银岛 复仇者联盟3：无限战争 超时空同居 游侠索罗：星球大战外传 深海越狱 侏罗纪世界2 超人总动员2 龙虾刑警 金蝉脱壳2 我不是药神 动物世界 邪不压正 摩天营救 西虹市首富 解码游戏 爱情公寓 一出好戏 快把我哥带走 欧洲攻略 蚁人2：黄蜂女现身 碟中谍6：全面瓦解 阿尔法：狼伴归途 反贪风暴3 影 无双 李茶的姑妈 我的间谍前男友 铁血战士 昨日青空 毒液：致命守护者 你好，之华 冰封侠：时空行者 飓风奇劫 名侦探柯南： 零的执行人 神奇动物： 格林德沃之罪 无敌破坏王2：大闹互联网 憨豆特工3 无名之辈 海王 龙猫 网络迷踪 天气预爆 来电狂响 蜘蛛侠：平行宇宙 地球最后的夜晚 大黄蜂 “大”人物 命运之夜——天之杯：恶兆之花 白蛇：缘起 密室逃生 死侍2：我爱我家 掠食城市 廉政风云4 流浪地球 疯狂外星人 飞驰人生 一吻定情 阿丽塔：战斗天使 驯龙高手3 惊奇队长 过春天 比悲伤更悲伤的故事 波西米亚狂想曲 乐高大电影2 海市蜃楼 反贪风暴4 风中有朵雨做的云 雷霆沙赞！ 复仇者联盟4： 终局之战 祈祷落幕时 调音师 何以为家 大侦探皮卡丘 阿拉丁 哥斯拉2：怪兽之王 哆啦A梦：大雄的月球探险 X战警：黑凤凰 追龙II 绝杀慕尼黑 秦明·生死语者 黑衣人：全球追缉 玩具总动员4 千与千寻 蜘蛛侠：英雄远征 扫毒2：天地对决 爱宠大机密2 哪吒之魔童降世 烈火英雄 使徒行者2：碟影行动 沉默的证人 全职高手之巅峰荣耀 愤怒的小鸟2 铤而走险 罗小黑战记 检察方的罪人 宝莱坞机器人2.0：重生归来 罗小黑战记 名侦探柯南：绀青之拳 诛仙I 小Q 友情以上]]></content>
  </entry>
  <entry>
    <title><![CDATA[Magic]]></title>
    <url>%2F2019%2F05%2F20%2FMagic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Magic</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpMV]]></title>
    <url>%2F2019%2F05%2F19%2FSpMV%2F</url>
    <content type="text"><![CDATA[稀疏矩阵向量乘 本文参考: FPGA矩阵计算并行算法与结构(知网) 稀疏矩阵向量乘法xFPGA 稀疏矩阵向量乘法x并行编程方法 稀疏矩阵存储格式总结 深度学习FPGA加速器设计 在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。SpMV即 Sparse Matrix Vector Multiplication 稀疏矩阵向量乘法的优化稀疏矩阵向量乘法（SPMV）可在很多情况下代替稠密矩阵运算，可以大量节省内存占用，减少计算开销。矩阵向量乘法不同于矩阵和矩阵的乘法，这是完全访存密集型的计算，我们主要的优化方向是提升访存效率或减少访存开销。 稀疏矩阵一般只存储非零元的信息，非零元的存储格式决定了访存的模式，这需要根据非零元的分布模式和要做的计算类型来设计。我们假设分布模式并非对角线分布，整体分布较均匀，局部可能会有聚集，计算类型是稀疏矩阵乘以稠密向量，结果为稠密向量。 标准的稀疏矩阵存储格式主要有：COO（Coordinate Format）和CSR（Compressed Sparse Row）等。COO很简单，就是使用3个数组，分别存储全部非零元的行下标（row index）、列下标（column index）和值（value）；CSR稍复杂，对行下标进行了压缩，假设矩阵行数是m，则压缩后的数组长度为m+1，记作（row ptr），其中第i个元素（0-base）表示矩阵前i行的非零元个数。 图1-1和图1-2展示了COO和CSR格式存储稀疏矩阵的一个例子。 我们来考虑矩阵向量乘法计算y=Ax，其中A是稀疏矩阵，维度是m和n，非零元个数是k；x和y是稠密向量，维度分别是n和m，m×n &gt;&gt; k &gt;&gt; max(m, n)。做这个稀疏矩阵向量乘法就要遍历A的每一行，和x对应位置相乘，把结果累加到y的对应位置。这个过程对A的k个非零元全部访问了一遍，对x也访问了k个元素（重叠），对y访问了一遍，所以优化重点在于减少访问A的冗余，并提升访问x的效率。下面这几个优化标准稀疏矩阵存储格式的方法，可以提升访存效率，减少冗余。 （1）对矩阵A做行列分块处理 对x的访问每次总是从左到右进行稀疏的遍历，如果n很大（比如上百万甚至更多），则访问x的空间局部性较差。所以我们首先改进矩阵A的访问顺序，将矩阵A分解成多个方形的子矩阵。子矩阵的维度适应较高层CPU硬件cache的大小，这样在遍历每一个子矩阵时，对x的访问相对集中于一个较小的区间，这个区间内的x会被cache缓存，这样能够大大提高访问效率。分块方式如图1-3所示。 （2）自适应分块存储结构 由于稀疏矩阵的非零元分布不一定均匀，有的分块会非常稀疏，有的则会相对稠密。对于极稀疏的分块（非零元数量远小于行数），如果用和CSR相似的压缩行存储策略，则会浪费空间，所以用COO的方式反而更能节省存储空间，提高访问效率。 对于哪些分块使用CSR，哪些使用COO方式，可以通过实验的方式确定一个非零元的数量和分块大小的比值。高于该值的用CSR方式存储，否则用COO方式存储。 如图1-4所示，一共使用5个数组存储自适应分块信息的稀疏矩阵，灰色的部分是CSR的相关信息，白色的部分是COO的相关信息。col_idx和vals的意义不变；types存储分块类型，标识当前分块是CSR还是COO；如果当前分块是CSR，则row_info存储类似row_ptr的信息（第k个元素表示分块内第k行的非零元个数），否则存储COO的row_idx的信息；row_id存储每个分块在row_info上的起始地址。 （3）减少下标存储的冗余 矩阵分块后，分块内间址的下标并不需要4字节int型整数存储，比如分块维度在64K以内，可以用2字节的unsigned short来存储。这样，无论是CSR或COO的row_idx、row_ptr，还是col_idx，都可以减少50%的存储空间，并同时提升访存效率。 （4）多线程和NUMA特性 单处理器多核多线程并行计算稀疏矩阵向量乘的过程比较简单，只需把矩阵划分成线程数量的子矩阵。这里采用横切的方法，计算结果不用合并。 但是对于多处理器非一致内存访问（NUMA），就需要对数据在内存中的分布做特殊处理，才能最大程度地利用全部的内存带宽。 一个典型的Intel X86双路服务器的拓扑架构如图1-5所示。 Memory #0是CPU #0的本地内存，Memory #1是CPU #1的本地内存，它们有各自独立的内存带宽。CPU #0访问Memory #1需要经过内部总线（在Intel的架构中叫QPI总线），这个总线的带宽一般小于内存带宽。另外如果要访问的数据只集中在一颗CPU的本地内存中，那么只能利用一个NUMA node的内存带宽，这就限制了系统的总体吞吐。 所以需要把稀疏矩阵的存储均匀地分配到两颗处理器各自的本地内存中。对于一个双CPU，每颗CPU一共4核的系统，需要开8个线程，并把这8个线程分别绑定到8颗CPU核上，使线程的上下文不会在核间迁移。对于每个线程要处理的稀疏矩阵数据，也通过系统调用（在Linux中是mbind），绑定到所在CPU核的本地内存中。这样每个核处理的数据一定是从本地内存中获得的，不会经过QPI总线。这就最大程度地利用了系统内存的带宽。经过实测，这个优化方法可以提升70%左右的内存带宽。 对于我们测试的一个维度大约1M、稀疏度0.0001的稀疏矩阵来说，所有优化加起来，相对Intel MKL库中CSR矩阵的SpMV API加速了2.5x左右。学术界还有很多针对稀疏矩阵存储格式的讨论和研究，其中有些还利用了SIMD向量指令，这里介绍的稀疏矩阵乘法方法，更多是为了讨论内存和cache优化的一些基本原理。稀疏矩阵根据稀疏度和非零元分布的不同，需要使用不同的存储策略，所以遇到实际的稀疏矩阵问题，需要根据实际情况开发不同的存储格式。 FPGA上的稀疏矩阵向量乘稀疏矩阵向量乘法稀疏矩阵向量乘（SpMV）把一个稀疏矩阵与一个向量相乘。稀疏矩阵是指矩阵中大部分元素为0的矩阵。这里的向量本身也可是稀疏的，但通常情况下是密集的。作为一种通用的运算，在科学应用、经济模型、数据挖掘、信息检索中广泛应用。例如，在利用迭代法求解稀疏线性方程组和特征值的问题。同时，也被应用于网页搜索排名和计算机视觉（图像重构等）。 本章会引入几个与HLS相关的新概念，并进一步深入之前讨论过的优化。本章的目标之一是引入一种更复杂的数据结构。我们用压缩行存储（CRS）来保存稀疏矩阵。另一个目标是演示如何进行性能测试。我们编写了简单的激励用来检验设计是否正确。这在硬件设计中十分重要，Vivado®HLS 工具采用HLS C编写激励，并能轻松的对工具生成的RTL代码进行多方面的验证。这是基于HLS设计比基于RTL设计的巨大优势之一。章节中也会讲解如何采用Vivado®HLS工具进行C/RTL联合仿真。不同SpMV设计会带来性能上差异，因为执行时间和稀疏矩阵是密切相关的，所以我们必须通过输入数据来确定任务执行之间的间隔以及任务延迟。 6.1 背景图6.1显示了一个4x4的矩阵M表示的2种方式。其中图6.1-a采用通用的二维方式16个元素来表示矩阵，每个元素存储在自己对应的位置上。图6.1-b采用CRS的方式表示相同的矩阵。CRS 作为一种数据结构，由3个数组组成。值(values)数组保存矩阵中非零元素的值。列索引(columnIndex)数组和行指针（rowPtr）数组对非零元素的位置信息进行编码。列索引存储每一列的元素，行指针包含每一行第一个元素的值。CRS 结构避免存储矩阵中的0值，确实在数值数组中确实没有存储0。但是在这个例子中，虽然数值数组不保存0，但是列索引数组和行指针数组作为标记信息，表示了矩阵的形态。CRS 广泛用于大型的矩阵但是仅仅有少量的非零元素（少于10%或者更低），这样可以简化这类矩阵的存储以及相关的运算。 图 6.1: M是一个4x4矩阵，用两种方式表示：同”密集”矩阵一样存在二维数组之中；作为稀疏矩阵，以行压缩存储的形式保存，行压缩存储是一种由3个数组组成的数据结构。 但是，CRS对矩阵的稀疏性没有要求，可以适用于任何矩阵。作为一种针对矩阵的通用方法，但不见得是最高效的。CRS结构也不见得是表示稀疏矩阵最高效的方式，其他稀疏矩阵表示方法也在被使用。 更准确的讲，CRS作为一种数据结构由3个数组构成：值(values)、列索引(colIndex)、行索引（rowPtr）。值数组和列索引表示稀疏矩阵M中的每一个非零元素，这些数组表示矩阵M采用行的方式，从左到右，从上到下。矩阵中的数据保存在值数组中，列索引数组保存数据在数组中水平方向的位置，如果 values[k] 表示 M_{ij}Mij 其中collndex[k]= jcollnde**x[k]=j。数组rowPtr用n+1n+1的长度来表示n行矩阵。rowPtr[k] 表示在行k之前，矩阵中所有元素的数目，其中rowPtr[0]=0rowPt**r[0]=0且最后一个元素rowPtr[k] 总是表示当前矩阵k行之前所有非零元素的个数M_{ij}Mij ,其中rowPtr[i] \leq k \leq rowPtr[i+1]rowPt**r[i]≤k≤rowPt**r[i+1]。如果行k包含任何非0元素，那么rowPtr[k] 将包含当前行的第一个元素。注意，如果当前行没有非0元素，那么 rowPtr 数组中的值将会重复出现。 从图6.1 a）中，我们可以行优先的方式遍历矩阵，从而确定值（values）数组在CRS中的形式。只要发现一个非0元素，它的值会被保存在下一个索引 ii 中，同时，它的列号columnIndex[i] 会被保存在列数组中。另外，在我们访问一个新行的时候，我们保存下一个值的索引 ii 在rowPtr数组中。所以，rowPtr 数组的第一个元素总是0。从图 6.1 b)中，我们可以把矩阵转换为二位数组表示的方式。第一步是根据rowPtr数组，确定每一行中非0 元素的个数。对行 ii 而言，该行中元素的数目为rowPtr[i]-rowPtr[i+1]rowPt**r[i]−rowPt**r[i+1]的差值。所以当前行的值可以从values数组values[rowPtr[i]] 开始，通过递归得到。在我们的示例矩阵中，因为前 rowPtr 数组前2个元素是0和2，所以我们知道第一行有2个非0元素，即value[0] 和value[1] 。第一个非0元素在values数组中,value[0] 是3。该值所对应的列号为1，因为columnIndex[0]=0columnIndex[0]=0。以此类推，矩阵中第二行元素的个数为k\in[2,4)k∈[2,4),第三行的元素个数为k \in [4,7)k∈[4,7)。最后，共有9个非0元素在矩阵中，所以rowPtr最后一个值是9。 1234567891011121314#include "spmv.h"void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123;L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k++) &#123; #pragma HLS unroll factor=8 #pragma HLS pipeline y0 += values[k] * x[columnIndex[k]]; &#125; y[i] = y0; &#125;&#125; 图6.2: 主体代码演示了系数矩阵向量乘（SpMV）y=M.x的计算。采用CRS的方式，通过rowPt*、columnIndex 和 value 保存矩阵M。第一个for循环通过迭代访问每一行，第二个for循环访问每一列，实现矩阵M中非0元素和向量中对应的元素相乘并保存值在向量y中。 给定一个二维数组表示一个矩阵，通过C代码实现矩阵CRS格式。编写对应的C代码实现将矩阵从CRS格式转化为二维数组的形式。 结果表明，通过采用CRS的方式，我们能高效的实现稀疏矩阵乘法，不需要将矩阵转化为二维形式。实际上， 对于大型的矩阵仅仅只有一小部分非0元素，稀疏矩阵向量乘法会比第四章中讨论的密集矩阵向量乘高效很多。因为我们直接找到非0元素，并执行非0元素对应的运算。 6.2 基本实现图6.2 提供了基本代码对系数矩阵乘法的实现。函数spmv函数有5个参数，分别是rowPtr、columnIndex ，以及 values 对应矩阵 M 的 CRS 格式中包含的3个参数，这和图6.1中描述的数据结构等价。参数 yy 用于保存输出的结果，参数x表示输入的被乘向量xx。变量NUM_ROWS表示矩阵M中行号。变量NNZ表示矩阵中非0元素的个数。最后，变量SIZE表示数组x和数组y中元素的个数。 外层for循环标签为L1，对矩阵的行进行遍历。将矩阵当前的行与向量x相乘，得到输出的结果yy。内层循环标签为L2，实现对矩阵M中每列元素的遍历。L2循环迭代计算rowPtr[i+1]-rowPtr[i]rowPt**r[i+1]−rowPt**r[i]计算每一行非0元素的个数。每次循环计算，能从value数组中读取矩阵M的非0元素然后对应的从x数组中取得被乘向量x的值，对应相乘。cloumnIndex[k] 中的值保存了对应的列号k。 1234567891011#ifndef __SPMV_H__#define __SPMV_H__const static int SIZE = 4; // SIZE of square matrixconst static int NNZ = 9; //Number of non-zero elementsconst static int NUM_ROWS = 4;// SIZE;typedef float DTYPE;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]);#endif // __MATRIXMUL_H__ not defined 图6.3： spmv函数和激励的头文件 6.3 测试平台图6.4 展示了一个针对spmv函数测试平台。测试平台通过定义matrixvector函数，直接实现矩阵向量乘法，它不考虑矩阵是否为稀疏矩阵以及矩阵是否采用CRS方式表示。我们比较matrixvector函数输出和spmv函数的输出。 在通常的测试平台中，需要实现的函数都会有个“黄金”参考，作为用户期望综合的结果。测试平台会比较黄金用例的输出和通过Vivado®HLS综合的代码执行结果。最好的实践方式是，测试平台既可以用于黄金用例，也可用于被综合的代码。这样就保证了两者实现的正确性。 测试平台在主函数main中执行。这里我们通过设置fail变量初始化为0，当spmv函数的输出成结果与matrixvector函数输出结果不相同是时，变量置1。定义与矩阵M相关的变量、被乘向量xx 和输出结果yy。对于矩阵M，即有普通模式，也有CSR模式（保存为values、columnIndex、rowPtr）。矩阵M 的value如图6.1中所示，输出向量yy有两种，其中y_sw数组保存matrixvector函数输出的结果，y数组保存spmv函数输出的结果。 在定义好所有的输入变量和输出变量之后，分别调用spmv函数和matrixvector函数并输入合适的数据。 接下来的for循环用于比较y_sw和y中的每一个对应的结果。如果其中一个不相同，则将fail 标志置1。最后，程序会打印测试的结果并返回fail变量。 12345678910111213141516171819202122232425262728293031323334353637#include "spmv.h"#include &lt;stdio.h&gt;void matrixvector(DTYPE A[SIZE][SIZE], DTYPE *y, DTYPE *x)&#123; for (int i = 0; i &lt; SIZE; i++) &#123; DTYPE y0 = 0; for (int j = 0; j &lt; SIZE; j++) y0 += A[i][j] * x[j]; y[i] = y0; &#125;&#125;int main()&#123; int fail = 0; DTYPE M[SIZE][SIZE] = &#123;&#123;3,4,0,0&#125;,&#123;0,5,9,0&#125;,&#123;2,0,3,1&#125;,&#123;0,4,0,6&#125;&#125;; DTYPE x[SIZE] = &#123;1,2,3,4&#125;; DTYPE y_sw[SIZE]; DTYPE values[] = &#123;3,4,5,9,2,3,1,4,6&#125;; int columnIndex[] = &#123;0,1,1,2,0,2,3,1,3&#125;; int rowPtr[] = &#123;0,2,4,7,9&#125;; DTYPE y[SIZE]; spmv(rowPtr, columnIndex, values, y, x); matrixvector(M, y_sw, x); for(int i = 0; i &lt; SIZE; i++) if(y_sw[i] != y[i]) fail = 1; if(fail == 1) printf("FAILED\n"); else printf("PASS\n"); return fail;&#125; 图6.4 ： 一个简单spmv函数的简单测试平台。测试平台生成了一个用例，并且计算矩阵的向量乘法通过稀疏矩阵乘法（spmv）和非系数矩阵乘法(matrixvector)。 这个测试平台相对简单并且可能无法充分验证所有的输入都能正常输出。最主要的原因是，它仅仅只用了一个矩阵作为例子，相反，一个好的激励会测试许多矩阵。通常，会通过随机的方式产生输入的测试用例，并且重点测试边界用例。在这个例子中，我们不仅要保证值正确计算，同时保证通过加速器正确的被执行了，而且编译时间相关的parameter改变会在实现不同加速单元值折中。最关键的是，在相同的parameter上，我们能通过随机产生很多输入数据来进行测试。编译时间相关的参数每次发生变化，都需要我们重新编译代码。 创建一个复杂的激励来，通过随机数方式生成许多组测试数据。稀疏矩阵编译时间参数应该是可以修改的（例如，SIZE，NNZ 等）。创建一个HLS综合脚本，在编译时间参数合理范围改变时，能执行代码很多次。 6.4 指定循环的属性如果直接将上述代码进行综合，我们可以得到函数运行的时钟周期及资源占用率。但是，我们不能得到模块执行所需的时钟周期、任务执行的延迟和任务执行之间的间隔。因为这些都取依赖于输入数据，由spmv函数外部因素决定。最主要的因素是，内层循环执行的次数是由矩阵M中非0元素个数决定的。非0元素的个数在代码中是由常量NNZ决定的，虽然可以调用函数计算不同大小的矩阵，但是实际迭代次数是和输入数据相关的。另外，性能也会因为非0元素的分布、综合优化的约束产生不同。更复杂的是，迭代的次数由输入决定，许多可能的输入并没有被遍历。所以，对于工具而言，不通过复杂的分析和额外的信息，工具是不能知道spmv函数执行需要多少时钟周期。Vivado®HLS 工具也不能进行上述的分析。 spmv函数能正常工作的前提条件是什么？证明给定的前提条件，矩阵中每个非0元素实是不是在对应一次内层循的执行？ 有几种方式能帮助工具进行性能的分析，其中一种方式就是想Vivado®HLS提供循环边界的额外信息。这可以通过使用loop_tripcount directive实现，它能让设计者指定最小、最大和平均迭代次数针对特定的循环。通过提供这些值， Vivado®HLS 能提供时钟周期级别的评估。 使用loop_tripcount directive 用变量指定循环的最小，最大和平均迭代次数，这样Vivado®HLS 工具能对当前设计时钟周期数目进行估计。这些不影响最后综合的结果，只会影响综合报告。 对spmv函数使用loop_tripcount directive，语法格式 # pragma HLS loop_tripcount min=X, max=Y, avg=Z 其中X，Y，Z正的常量。哪个循环需要使用directive?当改变参数（min、max和avg）以后，综合报告有什么不同？这对时钟周期有影响吗？这对资源占用有影响吗？ loop_tripcount 引导能帮助设计者对函数的性能有个原始的估计。这样能比较相同的函数通过使用不同的directives或者对代码本身重构。但是，这不能确定min、max和 avg 参数。这也很难确定边界条件min和max的值。如果有测试平台，就有一种更准确的方式用于计算spmv函数执行的时钟周期数，那就是C/RTL协同仿真。 6.5 C/RTL 协同仿真C/RTL 协同仿真能自动化测试Vivado®HLS工具生成的RTL代码，只需要在综合的时候提供测试平台。每次执行综合以后的代码和提供的测试平台，记录输入和输出结果。输入的值按照时钟转换成输入向量。这里的输入向量用于针对生成的RTL代码进行仿真，同时记录输出向量。更新综合后的代码， 再次运行测试平台并保存输入和输出数据。测试平台如果返回值是0，则表示成功；若激励返回非0值，则表示失败。 C/RTL 协同仿真流程将VIvado®HLS 生成的RTL代码，通过C 测试平台，实现时钟周期级别的仿真。这样，就能准确对生成的RTL代码进行性能评估，即使性能与输入数据有关。被综合的函数运行周期最小值，最大值，平均值以及间隔在仿真完成以后都能准确的得到。 注意这些和时钟周期相关的参数是通过激励中测试数据得到的。所以，结果的质量和测试平台的质量息息相关。如果测试平台没有很好的对函数执行测试，那么结果将不准确。另外，输入测试向量都是基于理想的时序，不能反映模型实际工作时，外部接口对函数的影响。实际的性能可能会比仿真的要低，如果执行过程中阻塞在输入数据或对外部存储的访问上。不过，对于循环边界调试时变量的情况，设计者可以通过协同仿真的方式确定时钟周期个数。 C/RTL协同仿真能提供循环边界是变量的函数的延迟。它反馈函数运行时延迟的最小值、最大值和平均值以及函数运行间隔。这些延迟和测试平台输入的数据是强相关的。 图6.5 spmv函数内部循环流水执行过程和结构 当采用图6,4提供的测试平台时，函数运行的最小值、最大值和平均值以及函数间隔是多少个时钟周期？ 6.6 循环的优化与数组的分块我们可以通过Vivado®HLS 工具得到当前函数的性能和面积的评估结果，然后可以考虑如何对函数进行优化。流水线、循环展开、数组分块是第一类最常用的优化方法。最典型的方式是从最内层的循环，然后根据需要向外层循环进行。 在这个例子中， 对最内层的L2循环进行流水线化也许是我们最先和最容易想到的优化方式。这个连续迭代的循环在执行上流水以后，总体运行会加快。如果不采用流水，L2 循环将按照串行执行。注意，L1 循环此时还是按照串行的方式执行。 图6.5演示了spmv函数在L2循环采用流水方式时运行的步骤。每次L2的循环都被II=3I**I=3流水化。流水线允许在外层循环执行一次迭代时，内层循环执行多次循环迭代。此时，内层循环II受限于递归（recurrence ）操作。II=3I**I=3是因为我们认为加法器有3个时钟周期的延迟。外部循环没有采用流水的方式，所以内层的循环必须在下外层L2循环开始执行前，计算完成并输出结果。 对最内层的L2 for 循环进行流水化，通过在spmv函数中增加流水directive如图6.2所示。II(initiation interval)最后是多少？在你指定II的值以后，最终目标的II值是增大了还是减少了？ 观察执行步骤，我们可以发现有几个因素限制了循环执行性能。第一个因素，递归（recurrence ）操作限制了循环的 II。第二个因素，外层的循环没有采用流水的方式。一种高效计算稀疏矩阵向量乘法的方式，每个时钟周期把乘法器和加法器使用起来。当前的设计离这个目标还很远。 在章节4.3中，我们探究了几种设计优化技术，其中包括对不同的循环进行流水，循环展开，数组分割。掌握在这些技术之间进行权衡是一项挑战，因为它们之间经常相互依赖。我们通常联合使用这些技术，为了得到好的性能谨慎的选择其中一种而不选择另一种也许结果会更糟糕。例如，在我们使用循环展开是，设计者需要明白它对数据访问的影响。增加了对数据访问的操作但是设计性能又受限于数据访问时，优化毫无益处。同样，如果提供了冗余的存储端口，实际中使用率不高，这样对提高性能毫无帮助反而增加了资源的消耗。 仔细思考一下上述优化技术组合后复杂多变的样式，我们建议你尝试下面的练习： 对spmv设计进行综合，采用表6.1提供的10种directives，每种都有不同的流水，展开和分割针对不同的循环和数组。这些分割在不同的数组（values、columnIndex、x）上使用。你看到结果的趋势是如何的？增加了展开和分割，是有利于还是不利于面积？性能如何？为什么？ 表6.1 稀疏矩阵向量乘法可优化的方式 L1 L2 case1 - - case2 - pipeline case3 pipeline - case4 unroll=2 - case5 - pipeline,unroll=2 case6 - pipeline,unroll=2,cyclic=2 case7 - pipeline,unroll=4 case8 - pipeline,unroll=4,cyclic=4 case9 - pipeline,unroll=8 case10 - pipeline,unroll=8,cyclic=8 case11 - pipeline,unroll=8,block=8 如果你完成了上述练习，你会发现盲目的使用优化directives，可能不会得到你期望的结果。通常在设计时， 在思考下考虑应用的特性，选择针对设计的特定优化方式。当然，这也需要一些直觉能力和一些专用工具投入使用。虽然，搞清楚像Vivado®HLS这样复杂工具中每一个细节是困难乃至不可能的，但是我们能基于关键的方面建立思考模型。 上面我们在用例3和4中考虑对外层循环L1进行流水化操作而不是对内层循环。这种变化针对一个任务，可以提高潜在的并行程度。为了完成优化，Vivado®HLS 工具必须展开代码中所有的内层循环L2 。如果循环能全部展开，这样能减少计算循环边界的时间，同时也能消除递归（recurrences）。但是代码中的内层循环Vivado HLS是无法完全展开的，因为循环边界不是常量。 例如在实现上面提到的例子3，在最外层的循环L1使用流水化directive。在不设定目标II时，II值是多少？资源占用率发生了什么变化？增加了II后资源占用率结果如何？这与之前采对L2循环进行流水化，结果有什么不同？这和最基本的设计（无 directives）相比有什么不同？当你对外层循环进行展开时，结果到底如何？（提示：检查综合后的日志信息） 另外一种增加并行化的方式是对内层循环进行局部循环展开，就像之前例子5到10。这种变化实现更多的并行化，通过在相同的循环迭代中，执行更多的操作。有些情况，Vivado HLS 工具在对内层循环进行流水化时，通过实现更多操作来提高性能。但是，这还是很难提高内层循环的II，由于内层循环的递归操作。但是，在II大于1的情况下， 许多操作可以共享同一个计算单元。 图6.6展示了一个局部展开的代码。在这段代码中，L2 循环被分成2个循环，分别为L2_1和L2_2。最内层的循环L2_2执行的次数由参数S确定。内部循环包含了最原始的L2循环，其中循环边界是由最原始的L2循环确定的。代码中，L2_1 循环包含了不确定次数的乘法和加法操作，运算次数由参数S确定，和一次递归完成累加y0 += yty0+=y**t。 注意图6.6中的代码和自动循环展开的代码是由一点点区别的。自动循环展开复制计算，但是保留每次计算先后顺序（除了当前的例子）。这就导致了计算顺序由内层循环决定，如图6.7左所示。对计算顺序进行调整后，操作上的依赖关系如图6.7 左边所示。在当前的代码中，最后累加求和是一个递归（recurrence ）。当使用浮点数据类型时，这种调整计算顺序的操作可能对程序产生改变，所以Vivado HLS对这种类型的代码不进行操作顺序自动调整。 这个设计可能会被综合、实现如图6.8所示的结果。在这个例子中，S=3S=3与III**I最匹配，乘法器的延迟正好是3。所有的运算过程都是在一个乘法器和加法器上执行。比较这个例子与图6.5中的例子，我们可以发现一些缺点。最明显的是，内层循环的流水线长度很长，实现的时候需要多个更多的周期刷新流水线的输出，才能执行下一次外层L1循环。处理一行中非零元素和执行块S 相同。一行有个3个元素和一行有一个元素计算的时间是相同的。剩下的运算也需要在循环流水线中执行，即使他们的结果没有用。为了严格的比较两个设计的特性，我们需要了解设计对矩阵每行非零元素个数的预期。 12345678910111213141516171819202122#include "spmv.h"const static int S = 7;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123; L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2_1: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k += S) &#123;#pragma HLS pipeline II=S DTYPE yt = values[k] * x[columnIndex[k]]; L2_2: for(int j = 1; j &lt; S; j++) &#123; if(k+j &lt; rowPtr[i+1]) &#123; yt += values[k+j] * x[columnIndex[k+j]]; &#125; &#125; y0 += yt; &#125; y[i] = y0; &#125;&#125; 图6.6 局部展开图6.2中smpv函数 图6.7 针对累加的两种不同方式的局部展开。左边的版本有3个加法器进行递归操作，相反右边的版本只有1个加法器进行递归累加 图6.8 图6.6中 spmv函数基于部分展开和内部流水线处理后执行过程 如果矩阵每行非零元素很少，则采用第一种实现方式较优；如果矩阵中每行非零元素较多，则第二种实现方式更好。 需要注意，这里存在一个关于先有鸡还是先有蛋的问题。我们需要知道目标器件和时钟周期，这样才能确定流水线中加法器能不能满足时序要求。只有在我们知道流水线的级数之后（也许S=1时，Vivado HLS才能识别到加法递归），我们才能选择合适版本的参数S，来满足II=1I**I=1。一旦我们确定了S，我们能通过C/RTL协同仿真来，通过一组测试数据，确定是不是达到了性能上的要求。因为循环边界是可变的，所以得到的性能参数是依赖于数据的，所以我们需要设定不同的S，来找到性能的最大值。改变器件的类型和工作频率会影响之前所有的设计！尽管看来去高层次综合（HLS）对解决问题提供的帮助不多，相比于RTL开发新版本然后进行验证，它开发起来快（代码编写方便）。 图6.8可以实现时，S 与加法器流水线等级相同。如果S设定较大，结果会怎样？如果S 设定较小，结果会怎样？如果目标II小于S会怎样？如果目标II大于S会怎样？ 6.7小结在本章节中，我们介绍了系数矩阵向量乘法（SpMV），这延续了之前对矩阵运算的研究。SpMV 显得很有趣，因为它采用了一种特别的数据结构。为了减少大量的存储，矩阵采用行压缩的方式存储，这样就要求我们以一种非直接的方式对矩阵进行访问。 这一章节首先我们了Vivado®HLS工具测试和仿真的能力。我们采用一个基于SpMV简单的激励文件，讲解HLS工作流程。另外，我们对Vivado®HLS工具中C/RTL 协同仿真进行了讲解。这对我们得到设计准确性能结果是十分重要。矩阵越不稀疏，则更多的计算需要执行。在测试平台确定以后，协同仿真可以提供程序运行的精确仿真。这样就可以达到执行周期和性能结果。最后，我们讨论了采用循环优化和数组分块对代码进行优化。 fpga并行编程]]></content>
      <categories>
        <category>SpMV</category>
      </categories>
      <tags>
        <tag>SpMV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F05%2F19%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx安装及配置 本文参考： Nginx安装配置_菜鸟教程 Nginx中文文档 Nginx简易教程 概述什么是nginx? Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 什么是反向代理？ 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用安装 nginx官网下载地址：http://nginx.org，发布版本分为 Linux 和 windows 版本。 也可以下载源码，编译后运行。 从源代码编译 Nginx 把源码解压缩之后，在终端里运行如下命令： 123$ ./configure$ make$ sudo make install 默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。 Windows 安装 为了安装 Nginx / Win32，需先下载它(Nginx官方下载)。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： 1nginx-0.8.54 start nginx Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。 使用nginx 的使用比较简单，就是几条命令。 常用到的命令如下： nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen ：重新打开日志文件。 nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v：显示 nginx 的版本。 nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下： 123456789101112@echo offrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程nginx.exe -s stoprem 测试配置文件语法正确性nginx.exe -t -c conf/nginx.confrem 显示版本信息nginx.exe -vrem 按照指定配置去启动nginxnginx.exe -c conf/nginx.conf 如果是运行在 Linux 下，写一个 shell 脚本，大同小异。 配置nginx 配置实战我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。 http反向代理配置我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下：注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#运行用户#user somebody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志error_log D:/Tools/nginx-1.10.1/logs/error.log;error_log D:/Tools/nginx-1.10.1/logs/notice.log notice;error_log D:/Tools/nginx-1.10.1/logs/info.log info;#PID文件，记录当前启动的nginx的进程IDpid D:/Tools/nginx-1.10.1/logs/nginx.pid;#工作模式及连接数上限events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型(邮件支持类型),类型由mime.types文件定义 include D:/Tools/nginx-1.10.1/conf/mime.types; default_type application/octet-stream; #设定日志 log_format main &apos;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log D:/Tools/nginx-1.10.1/logs/access.log main; rewrite_log on; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 120; tcp_nodelay on; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream zp_server1&#123; server 127.0.0.1:8089; &#125; #HTTP服务器 server &#123; #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #首页 index index.html #指向webapp的目录 root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp; #编码格式 charset utf-8; #代理配置参数 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 location / &#123; proxy_pass http://zp_server1; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappiews; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; # root html; #&#125; &#125;&#125; 好了，让我们来试试吧： 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host：在 C:WindowsSystem32driversetc 目录下的host文件中添加一条DNS 记录127.0.0.1 http://www.helloworld.com 启动前文中 startup.bat 的命令 在浏览器中访问 http://www.helloworld.com，不出意外，已经可以访问了。 负载均衡配置上一个例子中，代理仅仅指向一个服务器。 但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。 nginx也可以实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 http://www.helloworld.com，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。 nginx.conf 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #设定负载均衡的服务器列表 upstream load_balance_server &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; #HTTP服务器 server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #对所有请求进行负载均衡请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.html index.htm; #定义首页索引文件的名称 proxy_pass http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表 #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $remote_addr; proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125; &#125;&#125; 网站有多个webapp的配置当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。 举个例子：假如 http://www.helloworld.com 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分: http://www.helloworld.com/finance/ http://www.helloworld.com/product/ http://www.helloworld.com/admin/ 我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。 那么，问题来了，用户在实际访问 http://www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。 配置也不难，来看看怎么做吧： 1234567891011121314151617181920212223242526272829303132333435http &#123; #此处省略一些基本配置 upstream product_server&#123; server www.helloworld.com:8081; &#125; upstream admin_server&#123; server www.helloworld.com:8082; &#125; upstream finance_server&#123; server www.helloworld.com:8083; &#125; server &#123; #此处省略一些基本配置 #默认指向product的server location / &#123; proxy_pass http://product_server; &#125; location /product/&#123; proxy_pass http://product_server; &#125; location /admin/ &#123; proxy_pass http://admin_server; &#125; location /finance/ &#123; proxy_pass http://finance_server; &#125; &#125;&#125; https反向代理配置一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点： HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key 其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 12345678910111213141516171819202122232425#HTTP服务器 server &#123; #监听443端口。443为知名端口号，主要用于HTTPS协议 listen 443 ssl; #定义使用www.xx.com访问 server_name www.helloworld.com; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate cert.pem; #ssl证书key位置 ssl_certificate_key cert.key; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #数字签名，此处使用MD5 ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /root; index index.html index.htm; &#125; &#125; 静态站点配置有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。 举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。 配置如下： 123456789101112131415161718192021222324252627worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png; gzip_vary on; server &#123; listen 80; server_name static.zp.cn; location / &#123; root /app/dist; index index.html; #转发任何请求到 index.html &#125; &#125;&#125; 然后，添加 HOST：127.0.0.1 http://static.zp.cn，此时，在本地浏览器访问 http://static.zp.cn ，就可以访问静态站点了。 跨域解决方案web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。 各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路： CORS在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。 jsonp把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。 这两种思路，本文不展开讨论。 需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。 举例：http://www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。 前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧： 首先，在 enable-cors.conf 文件中设置 cors ： 1234567891011121314151617181920212223242526# allow origin listset $ACAO &apos;*&apos;;# set single originif ($http_origin ~* (www.helloworld.com)$) &#123; set $ACAO $http_origin;&#125;if ($cors = &quot;trueget&quot;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;;&#125;if ($request_method = &apos;OPTIONS&apos;) &#123; set $cors &quot;$&#123;cors&#125;options&quot;;&#125;if ($request_method = &apos;GET&apos;) &#123; set $cors &quot;$&#123;cors&#125;get&quot;;&#125;if ($request_method = &apos;POST&apos;) &#123; set $cors &quot;$&#123;cors&#125;post&quot;;&#125; 接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置： 12345678910111213141516171819202122232425262728# ----------------------------------------------------# 此文件为项目 nginx 配置片段# 可以直接在 nginx config 中 include（推荐）# 或者 copy 到现有 nginx 中，自行配置# www.helloworld.com 域名需配合 dns hosts 进行配置# 其中，api 开启了 cors，需配合本目录下另一份配置文件# ----------------------------------------------------upstream front_server&#123; server www.helloworld.com:9000;&#125;upstream api_server&#123; server www.helloworld.com:8080;&#125;server &#123; listen 80; server_name www.helloworld.com; location ~ ^/api/ &#123; include enable-cors.conf; proxy_pass http://api_server; rewrite &quot;^/api/(.*)$&quot; /$1 break; &#125; location ~ ^/ &#123; proxy_pass http://front_server; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+rtmp]]></title>
    <url>%2F2019%2F05%2F17%2Fnginx-rtmp%2F</url>
    <content type="text"><![CDATA[nginx+rtmp 搭建视频直播服务器服务器安装配置 windows安装包(已编译好的版本)参考： nginx for windows windows下搭建基于nginx的rtmp服务器 在Windows下搭建基于nginx的视频直播和点播系统 搬运源码（未编译） Car-eye-RTMP-server(github) car-eye-http-flv-module nginx+rtmp在windows下编译 Windows下编译nginx-rtmp-module windows下编译nginx+nginx_rtmp_modue(vs2013) CentOS搭建nginx+rtmp服务器 nginx+rtmp直播流服务搭建 centos7 centos7 Nginx+rtmp 搭建流媒体服务器 linux下建议将nginx.conf中的http端口改为1024以上，好像是80端口每次运行都需要su权限。 Nginx搭建rtmp流媒体服务器 nginx服务器常用命令12345678910./nginx -v//查看nginx版本号./nginx -V //查看nginx详细的版本信息start ./nginx -c conf/nginx.conf //以nginx.conf的配置启动nginx./nginx -s stop//停止nginx服务器./nginx -s quit//停止nginx服务器./nginx -s reload//重启nginx服务器service nginx reload//重启nginx服务器./nginx -t (-c conf/nginx.conf)//检查配置文件是否正确./nginx -h//显示帮助信息./nginx -?//显示帮助信息 nginx+rtmp加入权限控制 本文参考： *rtmp-module官方wiki *视频直播点播nginx-rtmp开发手册中文版(参考wiki版本粗译) 如何给 nginx rtmp 服务加入鉴权机制(改源码) *「自己开发直播」实现nginx-rtmp-module多频道输入输出与权限控制 nginx-rtmp-module授权机制实现直播推流多房间授权认证 nginx-rtmp-module 权限控制 nginx-rtmp加入权限验证的简单方法 视频直播点播nginx-rtmp开发手册中文版 *nginx.conf中关于nginx-rtmp-module配置指令详解 *nginx-rtmp多房间和授权实现 *博客比较有用 nginx的rtmp-module默认不限制推流权限、播放权限。 想加入权限验证有很多种方法。 其中一个是改源码，一个是利用nginx+rtmp的配置文件调用后台接口进行验证。 第一种方法没成功过，第二种方法比较简单。此文介绍第二种方法，第一种方法可见博客-&gt;如何给 nginx rtmp 服务加入鉴权机制(改源码) 原理主要是利用on_publish跳转到当前配置的一个“location”，在这里进行验证。关键点在于rtmp application节点下面要配置“notify_method get;”为什么呢？因为跳转的时候，默认以POST方式传输参数，修改成GET方式，nginx配置里就可以轻松处理了。（当然nginx通过配置文件也可以处理post，只是复杂一些）。 我们在此使用python的后台框架flask处理on_publish的post请求。 后台返回http200即为通过验证，返回http500即为验证失败，服务器拒绝连接。 nginx的配置文件（位于nginx安装目录下：…/nginx/conf/nginx.conf）修改如下: 12345678910111213141516171819202122rtmp &#123; server &#123; #listen 1935; listen 10077; chunk_size 4000; application live &#123; live on; on_publish http://localhost:10078/user/auth;//后面的url即flask监听的地址 &#125; application hls &#123; live on; hls on; #hls_path ../nginx-1.7.11.3-Gryphon/html/hls; hls_path ../hls; hls_fragment 5s; on_publish http://localhost:10078/user/auth; &#125; &#125;&#125; python的flask后台代码如下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding:utf-8 -*-#https://www.jianshu.com/p/0d14ae8f081c#https://blog.csdn.net/wei389083222/article/details/78721074/#https://blog.csdn.net/weixin_34368949/article/details/85991563#验证只能用post方法#虽然流密钥的格式像是get类型，但是必须使用POST获取参数。from flask import Flask, request, Responseapp = Flask(__name__)#传入url格式为: xx.xx.xx.xx:10078/user/auth?usr=xxx&amp;passWord=xxx@app.route('/user/auth',methods=['POST'])def auth(): usr = request.form['usr']#从url后获取的数据 passWord = request.form['passWord'] print(usr,'\t',passWord) #此处可改为从数据库获取数据 auth_user='abc' auth_passWord='123' if auth_user == usr and auth_passWord ==passWord: return Response(response='success',status=200)#返回200状态码 else: return Response(status=500)#返回500状态码 #Flask.abort(404) return passWordif __name__ == '__main__': app.run(host='0.0.0.0',port=10078,debug=True) 播放权限也可用类似on_publish的验证方法进行控制。 on_play和on_publish 一样，只接受post方法，若需要接受get方法需要在rtmp中application的配置中添加notify_method get;，然后可在http{}部分中处理调用（这部分语法我不太清楚，不详细展开）。 以下是nginx.conf关于on_play的用法 on_play语法：on_play url上下文：rtmp, server, application描述：设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。 HTTP 2XX 返回码的话继续 RTMP 会话。 HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。 其他返回码的话 RTMP 连接丢弃。重定向例子： 123456789101112131415161718192021222324252627 http &#123; location /local_redirect &#123; rewrite ^.*$ newname? permanent; &#125; location /remote_redirect &#123; # no domain name here, only ip rewrite ^.*$ rtmp://192.168.1.123/someapp/somename? permanent; &#125; &#125; rtmp &#123; application myapp1 &#123; live on; # stream will be redirected to &apos;newname&apos; on_play http://localhost:8080/local_redirect; &#125; application myapp2 &#123; live on; # stream will be pulled from remote location # requires nginx &gt;= 1.3.10 on_play http://localhost:8080/remote_redirect; &#125;&#125; HTTP 请求接收到一些个参数。在 application/x-www-form-urlencoded MIME 类型下使用 POST 方法。以下参数会被传送给调用者： call=play。 addr - 客户端 IP 地址。 app - application 名。 flashVer - 客户端 flash 版本。 swfUrl - 客户端 swf url。 tcUrl - tcUrl。 pageUrl - 客户端页面 url。 name - 流名。出了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100&amp;b=face&amp;foo=bar 访问，然后呢 a,b 和 foo 发送回调。on_play http://example.com/my_callback; 过程中使用到的额外软件 obs 手机端:快直播 ffmpeg推流（没用过）]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPages Synchronization]]></title>
    <url>%2F2019%2F05%2F16%2Fhexo-gitPages-Synchronization%2F</url>
    <content type="text"><![CDATA[Hexo+gitPages 的博客多端同步管理及迁移 本文参考 如何解决github+Hexo的博客多终端同步问题 利用Hexo在多台电脑上提交和更新github pages博客 搭建hexo博客并简单的实现多终端同步 hexo博客同步管理及迁移 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件(包括博客内容主题等等)放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。 同步的首次操作在创建了博客的目录下操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上。 只托管部分用于多终端的同步的文件 注意：使用第三方主题时，要删除第三方主题的.git文件夹删除，不然无法push到远程仓库 1234567git init //初始化本地仓库git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示,其实也可以用'git add .'命令，在.gitignore文件中加入不需要同步的文件即可git commit -m "Blog Source Hexo"git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上 多出来的hexo的分支，用于文件同步，原有的master分支用于部署静态博客页面 在新终端进行更新博客先从github中把文件clone到本地，然后安装相应组件。然后通过git的提交同步内容，用hexo的命令部署博客到gitPages里。 12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地cd yourname.github.io //切换到刚刚clone的文件夹内npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再inithexo new post "new blog name" //新建一个.md文件，并编辑完成自己的博客内容git add source //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客，如果更改了主题样式的话还是建议用'git add .'git commit -m "XX"git push origin hexo //更新分支hexo d -g //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master 已有博客的终端更新博客进入相应的文件夹，更新博客直行命令即可。 123456git pull origin hexo//先pull完成本地和远端的融合hexo new post "new blog"git add .git commit -m "Blog update"git push origin hexohexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2019%2F05%2F14%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown Syntax 本文参考 Markdown基本语法(简书) Markdown官方文档 Markdown语法html支持 Markdown部分详细用法 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 12345678Atx形式# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题1234567Setext形式This is an H1=============This is an H2------------- This is an H1This is an H2根据标题生成目录1[TOC] 根据标题自动生成目录 [TOC] 字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 加粗测试 倾斜测试 斜体加粗测试 删除线测试 引用1234&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;多重引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 引用测试一 引用测试二 多重引用 引用测试 分割线1234-------******** 只要三个以上就可以 图片引用1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 插入带有链接的图片1234[[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com)&#123;:target="_blank"&#125; // 内链式[[图片上传失败...(image-4dc956-1542510791300)]][5]&#123;:target="_blank"&#125; // 引用式[5]: http://www.baidu.com [图片上传失败…(image-f83b77-1542510791300)]{:target=”_blank”} 内链式 [图片上传失败…(image-f83b77-1542510791300)]{:target=”blank”} 外链式 超链接引用12[超链接名](超链接地址 "超链接title")title可加可不加 12[简书](http://jianshu.com)[百度](http://baidu.com) baidu 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 简书 视频插入注：Markdown 语法是不支持直接插入视频的 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注：多数第三方平台不支持插入&lt;iframe&gt;视频 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 代码2 1[[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction)&#123;:target="_blank"&#125; 列表1234567无序列表用任一种皆可- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表（-） 列表（-） 列表（+） 列表（*） 1234567有序列表内容1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 第一点 第二点 第三点 12345678910111213141516171819**上一级和下一级之间敲三个空格即可**- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 Typora编辑器中可以直接使用crtl+T，或者在菜单段落中找到表格生成 代码引用单行代码 1`代码内容` int main(){return 0;} 代码块 12345(```)language 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt; "hello markdown"; return 0;&#125; 格式化代码html版123&lt;pre&gt;## 这是一个不起作用的标题&lt;/pre&gt; ## 这是一个不起作用的标题 流程图注： st=&gt;start: 开始 的：后面保持空格 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 6种类型 含义 start 启动 end 结束 operation 程序 subroutine 子程序 condition 条件 inputoutput 输出 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件 (布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 12345678910111213## 选项框```markdown- [x] 选项一- [ ] 选项二 需要注意的是：-、[x]、和选择一之间都要有空格，如果不下x[ ]中也要有空格 选项一 选项二 数学公式支持LaTex的数学公式，参考https://www.jianshu.com/p/2bbec51d756f 数学公式（MathJax)，参考https://www.jianshu.com/p/a0aa94ef8ab2 注：1个$左对齐，2个居中 12$$ x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1 $$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $ $$x \href{why-equal.html}{=} y^2 +1$$ 使用Typora的时候可以直接使用 $$+回车，或者用crtl+shift+M生成公式块（在段落菜单中的公式块） 参考https://blog.csdn.net/mingzhuo_126/article/details/82722455 脚注12Markdown[^1][^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注 Markdown^1 锚点注：只有标题支持锚点， 跳转目录方括号后 保持空格 123[公式标题锚点](#1)### [需要跳转的目录] &#123;#1&#125; // 方括号后保持空格 脚注标题锚点 123由于&#123;# 是hexo的标注语言hexo 中 &#123;# 属于保留字段 &#123;# ... #&#125;属于注释字段把```以外的&#123;#改成&#123;&#123; '&#123;#' &#125;&#125;即可解决 自动邮箱链接1&lt;xxx@outlook.com&gt; &#120;&#120;&#x78;&#x40;&#111;&#x75;&#116;&#x6c;&#x6f;&#111;&#107;&#46;&#99;&#111;&#109; 时序图代码1 123456​```sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B--&gt;A: 很高兴认识你​ 12345678910111213141516171819202122**演示**![img](https:////upload-images.jianshu.io/upload_images/6912209-784ce9bb7beb6672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)**代码详解**注：`A-&gt;&gt;B: 你好` 后面可以不写文字，但是一定要在最后加上`：` Note left of A 代表注释在A的左边| 符号 | 含义 || ---- | -------- || `-` | 实线 || `&gt;` | 实心箭头 || `--` | 虚线 || `&gt;&gt;` | 空心箭头 |**代码2** 123456789起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天 演示 转义字符由于markdown语法的原因，可以用\进行转义。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpages]]></title>
    <url>%2F2019%2F05%2F14%2Fhexo-gitpages%2F</url>
    <content type="text"><![CDATA[hexo+gitPages搭建个人博客 本文参考 hexo 博客搭建 hexo官方文档 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 手把手教你搭建自己的个人博客（图文教程） 搭建篇 –使用Github+hexo搭建个人博客教程—总结自己爬过的坑) GitHub+Hexo 搭建个人网站详细教程 史上最详细的Hexo博客搭建图文教程 hexo优化 hexo博客改装和一些细节优化) Hexo NexT 博客后台管理指南 Hexo主题更改以及小功能的添加 hexo-NexT主题配置 NexT官方展示 NexT官方中文文档ReadME NexT源码 NexT文档 Hexo的Next主题详细配置 hexo的next主题个性化教程:打造炫酷网站 hexo的next主题个性化教程：打造炫酷网站 【持续更新】hexo next主题优化手册 可参考博客嘤 yilia主题 yilia主题源码（GitHub） yilia主题展示 hexo博客搭建安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js (Should be at least nodejs 6.9) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 在安装的时候我用的是npm install hexo --save 关于npm命令回顾 npm install 命令最近在写Node程序的时候，突然对 npm install 的-save和-save-dev 这两个参数的使用比较混乱。其实博主在这之前对这两个参数的理解也是模糊的，各种查资料和实践后对它们之间的异同点略有理解。遂写下这篇文章避免自己忘记，同时也给node猿友一点指引。 我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式： 1234npm install moduleName # 安装模块到项目目录下`npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 那么问题来了，在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。 npm install moduleName 命令 安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令 安装模块到全局，不会在项目node_modules目录中保存模块包。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -save moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install -save-dev moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 &lt;folder&gt; 为hexo安装目录 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 12345678910111213141516171819package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 部署当执行完npm install之后即可通过hexo s或者hexo serve通过本地访问hexo博客。 此时博客已搭建在本地了。 方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 （可在github仓库中设置跳转至个人域名） 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 然后添加解析 包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 保存，命名为CNAME ，注意保存成所有文件而不是txt文件。 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 123hexo cleanhexo ghexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 方案四：云服务器 + 域名该方案需要先购买云服务器和域名。 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 12$ yum -y update$ yum install -y git nginx Nginx配置 2.1. 创建文件目录(用于博客站点文件存放) 123cd /usr/local/mkdir hexochmod 775 -R /usr/local/hexo/ 2.2. 添加 index.html(用于检测配置 Nginx 是否成功) 1vim /usr/local/hexo/index.html 添加以下代码，并保存。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 2.3. 配置 Nginx 服务器 1vim /etc/nginx/nginx.conf 修改server_name和root： 123456server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; &#125; 2.4. 启动nginx服务； 1service nginx start 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置 3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 123cd /usr/local/mkdir hexoRepochmod 775 -R /usr/local/hexoRepo/ 3.2. Git 初始化裸库。 12cd hexoRepo/git init --bare hexo.git 3.3. 创建 Git 钩子(hook)。 1vim /usr/local/hexoRepo/hexo.git/hooks/post-receive 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 123#!/bin/bashgit --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f 3.5. 保存并退出后, 给该文件添加可执行权限。 1chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive 本地博客推送到云服务器 4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 4.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 4.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。 Hexo常用命令123456789hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 注：当本地预览和远程部署的浏览结果不同的时候，不妨使用hexo clean &amp;&amp; hexo g -d试试。 创建文章命令： 123$ hexo new [layout] &lt;title&gt;复制代码 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 123$ hexo publish [layout] &lt;title&gt;复制代码 title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” ​ 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 主题配置hexo主题wiki 可以在此处寻找自己喜欢的主题下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~ 主题优化 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 添加个人联系方式 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 添加背景图 修改Logo字体 修改内容区域的宽度 网站标题栏背景颜色 自定义鼠标样式 文章加密访问 实现点击出现桃心效果 静态资源压缩（博文压缩） 修改访问url路径 博文置顶 在右上角或左上角实现fork me on github 主页文章添加边框阴影效果 显示当前浏览记录 常见分类页 加入广告 添加萌萌哒 搜索功能 网易云外链播放器 花里胡哨的玩意儿 修改作者头像并旋转 修改代码块自定义样式 点击爆炸效果 添加萌妹子动图 侧栏设置 透明背景设置 添加阅读全文 设置网站缩略图标 添加站点访问计数 前几个可参考next官方文档配置 （以下用到外部工具） 评论系统 数据统计与分析 内容分享服务 文章加密访问 hexo-blog-encrypt SEOHexo NexT 主题SEO优化指南 seo这东西是使自己的文章能被百度、谷歌搜录，能被搜索到。 因为暂时不想被搜到/doge，所有暂不配置]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
