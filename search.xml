<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Magic]]></title>
    <url>%2F2019%2F05%2F20%2FMagic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Magic</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpMV]]></title>
    <url>%2F2019%2F05%2F19%2FSpMV%2F</url>
    <content type="text"><![CDATA[稀疏矩阵向量乘 本文参考: FPGA矩阵计算并行算法与结构(知网) 稀疏矩阵向量乘法xFPGA 稀疏矩阵向量乘法x并行编程方法 稀疏矩阵存储格式总结 在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。SpMV即 Sparse Matrix Vector Multiplication 稀疏矩阵向量乘法的优化稀疏矩阵向量乘法（SPMV）可在很多情况下代替稠密矩阵运算，可以大量节省内存占用，减少计算开销。矩阵向量乘法不同于矩阵和矩阵的乘法，这是完全访存密集型的计算，我们主要的优化方向是提升访存效率或减少访存开销。 稀疏矩阵一般只存储非零元的信息，非零元的存储格式决定了访存的模式，这需要根据非零元的分布模式和要做的计算类型来设计。我们假设分布模式并非对角线分布，整体分布较均匀，局部可能会有聚集，计算类型是稀疏矩阵乘以稠密向量，结果为稠密向量。 标准的稀疏矩阵存储格式主要有：COO（Coordinate Format）和CSR（Compressed Sparse Row）等。COO很简单，就是使用3个数组，分别存储全部非零元的行下标（row index）、列下标（column index）和值（value）；CSR稍复杂，对行下标进行了压缩，假设矩阵行数是m，则压缩后的数组长度为m+1，记作（row ptr），其中第i个元素（0-base）表示矩阵前i行的非零元个数。 图1-1和图1-2展示了COO和CSR格式存储稀疏矩阵的一个例子。 我们来考虑矩阵向量乘法计算y=Ax，其中A是稀疏矩阵，维度是m和n，非零元个数是k；x和y是稠密向量，维度分别是n和m，m×n &gt;&gt; k &gt;&gt; max(m, n)。做这个稀疏矩阵向量乘法就要遍历A的每一行，和x对应位置相乘，把结果累加到y的对应位置。这个过程对A的k个非零元全部访问了一遍，对x也访问了k个元素（重叠），对y访问了一遍，所以优化重点在于减少访问A的冗余，并提升访问x的效率。下面这几个优化标准稀疏矩阵存储格式的方法，可以提升访存效率，减少冗余。 （1）对矩阵A做行列分块处理 对x的访问每次总是从左到右进行稀疏的遍历，如果n很大（比如上百万甚至更多），则访问x的空间局部性较差。所以我们首先改进矩阵A的访问顺序，将矩阵A分解成多个方形的子矩阵。子矩阵的维度适应较高层CPU硬件cache的大小，这样在遍历每一个子矩阵时，对x的访问相对集中于一个较小的区间，这个区间内的x会被cache缓存，这样能够大大提高访问效率。分块方式如图1-3所示。 （2）自适应分块存储结构 由于稀疏矩阵的非零元分布不一定均匀，有的分块会非常稀疏，有的则会相对稠密。对于极稀疏的分块（非零元数量远小于行数），如果用和CSR相似的压缩行存储策略，则会浪费空间，所以用COO的方式反而更能节省存储空间，提高访问效率。 对于哪些分块使用CSR，哪些使用COO方式，可以通过实验的方式确定一个非零元的数量和分块大小的比值。高于该值的用CSR方式存储，否则用COO方式存储。 如图1-4所示，一共使用5个数组存储自适应分块信息的稀疏矩阵，灰色的部分是CSR的相关信息，白色的部分是COO的相关信息。col_idx和vals的意义不变；types存储分块类型，标识当前分块是CSR还是COO；如果当前分块是CSR，则row_info存储类似row_ptr的信息（第k个元素表示分块内第k行的非零元个数），否则存储COO的row_idx的信息；row_id存储每个分块在row_info上的起始地址。 （3）减少下标存储的冗余 矩阵分块后，分块内间址的下标并不需要4字节int型整数存储，比如分块维度在64K以内，可以用2字节的unsigned short来存储。这样，无论是CSR或COO的row_idx、row_ptr，还是col_idx，都可以减少50%的存储空间，并同时提升访存效率。 （4）多线程和NUMA特性 单处理器多核多线程并行计算稀疏矩阵向量乘的过程比较简单，只需把矩阵划分成线程数量的子矩阵。这里采用横切的方法，计算结果不用合并。 但是对于多处理器非一致内存访问（NUMA），就需要对数据在内存中的分布做特殊处理，才能最大程度地利用全部的内存带宽。 一个典型的Intel X86双路服务器的拓扑架构如图1-5所示。 Memory #0是CPU #0的本地内存，Memory #1是CPU #1的本地内存，它们有各自独立的内存带宽。CPU #0访问Memory #1需要经过内部总线（在Intel的架构中叫QPI总线），这个总线的带宽一般小于内存带宽。另外如果要访问的数据只集中在一颗CPU的本地内存中，那么只能利用一个NUMA node的内存带宽，这就限制了系统的总体吞吐。 所以需要把稀疏矩阵的存储均匀地分配到两颗处理器各自的本地内存中。对于一个双CPU，每颗CPU一共4核的系统，需要开8个线程，并把这8个线程分别绑定到8颗CPU核上，使线程的上下文不会在核间迁移。对于每个线程要处理的稀疏矩阵数据，也通过系统调用（在Linux中是mbind），绑定到所在CPU核的本地内存中。这样每个核处理的数据一定是从本地内存中获得的，不会经过QPI总线。这就最大程度地利用了系统内存的带宽。经过实测，这个优化方法可以提升70%左右的内存带宽。 对于我们测试的一个维度大约1M、稀疏度0.0001的稀疏矩阵来说，所有优化加起来，相对Intel MKL库中CSR矩阵的SpMV API加速了2.5x左右。学术界还有很多针对稀疏矩阵存储格式的讨论和研究，其中有些还利用了SIMD向量指令，这里介绍的稀疏矩阵乘法方法，更多是为了讨论内存和cache优化的一些基本原理。稀疏矩阵根据稀疏度和非零元分布的不同，需要使用不同的存储策略，所以遇到实际的稀疏矩阵问题，需要根据实际情况开发不同的存储格式。 FPGA上的稀疏矩阵向量乘稀疏矩阵向量乘法稀疏矩阵向量乘（SpMV）把一个稀疏矩阵与一个向量相乘。稀疏矩阵是指矩阵中大部分元素为0的矩阵。这里的向量本身也可是稀疏的，但通常情况下是密集的。作为一种通用的运算，在科学应用、经济模型、数据挖掘、信息检索中广泛应用。例如，在利用迭代法求解稀疏线性方程组和特征值的问题。同时，也被应用于网页搜索排名和计算机视觉（图像重构等）。 本章会引入几个与HLS相关的新概念，并进一步深入之前讨论过的优化。本章的目标之一是引入一种更复杂的数据结构。我们用压缩行存储（CRS）来保存稀疏矩阵。另一个目标是演示如何进行性能测试。我们编写了简单的激励用来检验设计是否正确。这在硬件设计中十分重要，Vivado®HLS 工具采用HLS C编写激励，并能轻松的对工具生成的RTL代码进行多方面的验证。这是基于HLS设计比基于RTL设计的巨大优势之一。章节中也会讲解如何采用Vivado®HLS工具进行C/RTL联合仿真。不同SpMV设计会带来性能上差异，因为执行时间和稀疏矩阵是密切相关的，所以我们必须通过输入数据来确定任务执行之间的间隔以及任务延迟。 6.1 背景图6.1显示了一个4x4的矩阵M表示的2种方式。其中图6.1-a采用通用的二维方式16个元素来表示矩阵，每个元素存储在自己对应的位置上。图6.1-b采用CRS的方式表示相同的矩阵。CRS 作为一种数据结构，由3个数组组成。值(values)数组保存矩阵中非零元素的值。列索引(columnIndex)数组和行指针（rowPtr）数组对非零元素的位置信息进行编码。列索引存储每一列的元素，行指针包含每一行第一个元素的值。CRS 结构避免存储矩阵中的0值，确实在数值数组中确实没有存储0。但是在这个例子中，虽然数值数组不保存0，但是列索引数组和行指针数组作为标记信息，表示了矩阵的形态。CRS 广泛用于大型的矩阵但是仅仅有少量的非零元素（少于10%或者更低），这样可以简化这类矩阵的存储以及相关的运算。 图 6.1: M是一个4x4矩阵，用两种方式表示：同”密集”矩阵一样存在二维数组之中；作为稀疏矩阵，以行压缩存储的形式保存，行压缩存储是一种由3个数组组成的数据结构。 但是，CRS对矩阵的稀疏性没有要求，可以适用于任何矩阵。作为一种针对矩阵的通用方法，但不见得是最高效的。CRS结构也不见得是表示稀疏矩阵最高效的方式，其他稀疏矩阵表示方法也在被使用。 更准确的讲，CRS作为一种数据结构由3个数组构成：值(values)、列索引(colIndex)、行索引（rowPtr）。值数组和列索引表示稀疏矩阵M中的每一个非零元素，这些数组表示矩阵M采用行的方式，从左到右，从上到下。矩阵中的数据保存在值数组中，列索引数组保存数据在数组中水平方向的位置，如果 values[k] 表示 M_{ij}Mij 其中collndex[k]= jcollnde**x[k]=j。数组rowPtr用n+1n+1的长度来表示n行矩阵。rowPtr[k] 表示在行k之前，矩阵中所有元素的数目，其中rowPtr[0]=0rowPt**r[0]=0且最后一个元素rowPtr[k] 总是表示当前矩阵k行之前所有非零元素的个数M_{ij}Mij ,其中rowPtr[i] \leq k \leq rowPtr[i+1]rowPt**r[i]≤k≤rowPt**r[i+1]。如果行k包含任何非0元素，那么rowPtr[k] 将包含当前行的第一个元素。注意，如果当前行没有非0元素，那么 rowPtr 数组中的值将会重复出现。 从图6.1 a）中，我们可以行优先的方式遍历矩阵，从而确定值（values）数组在CRS中的形式。只要发现一个非0元素，它的值会被保存在下一个索引 ii 中，同时，它的列号columnIndex[i] 会被保存在列数组中。另外，在我们访问一个新行的时候，我们保存下一个值的索引 ii 在rowPtr数组中。所以，rowPtr 数组的第一个元素总是0。从图 6.1 b)中，我们可以把矩阵转换为二位数组表示的方式。第一步是根据rowPtr数组，确定每一行中非0 元素的个数。对行 ii 而言，该行中元素的数目为rowPtr[i]-rowPtr[i+1]rowPt**r[i]−rowPt**r[i+1]的差值。所以当前行的值可以从values数组values[rowPtr[i]] 开始，通过递归得到。在我们的示例矩阵中，因为前 rowPtr 数组前2个元素是0和2，所以我们知道第一行有2个非0元素，即value[0] 和value[1] 。第一个非0元素在values数组中,value[0] 是3。该值所对应的列号为1，因为columnIndex[0]=0columnIndex[0]=0。以此类推，矩阵中第二行元素的个数为k\in[2,4)k∈[2,4),第三行的元素个数为k \in [4,7)k∈[4,7)。最后，共有9个非0元素在矩阵中，所以rowPtr最后一个值是9。 1234567891011121314#include "spmv.h"void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123;L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k++) &#123; #pragma HLS unroll factor=8 #pragma HLS pipeline y0 += values[k] * x[columnIndex[k]]; &#125; y[i] = y0; &#125;&#125; 图6.2: 主体代码演示了系数矩阵向量乘（SpMV）y=M.x的计算。采用CRS的方式，通过rowPt*、columnIndex 和 value 保存矩阵M。第一个for循环通过迭代访问每一行，第二个for循环访问每一列，实现矩阵M中非0元素和向量中对应的元素相乘并保存值在向量y中。 给定一个二维数组表示一个矩阵，通过C代码实现矩阵CRS格式。编写对应的C代码实现将矩阵从CRS格式转化为二维数组的形式。 结果表明，通过采用CRS的方式，我们能高效的实现稀疏矩阵乘法，不需要将矩阵转化为二维形式。实际上， 对于大型的矩阵仅仅只有一小部分非0元素，稀疏矩阵向量乘法会比第四章中讨论的密集矩阵向量乘高效很多。因为我们直接找到非0元素，并执行非0元素对应的运算。 6.2 基本实现图6.2 提供了基本代码对系数矩阵乘法的实现。函数spmv函数有5个参数，分别是rowPtr、columnIndex ，以及 values 对应矩阵 M 的 CRS 格式中包含的3个参数，这和图6.1中描述的数据结构等价。参数 yy 用于保存输出的结果，参数x表示输入的被乘向量xx。变量NUM_ROWS表示矩阵M中行号。变量NNZ表示矩阵中非0元素的个数。最后，变量SIZE表示数组x和数组y中元素的个数。 外层for循环标签为L1，对矩阵的行进行遍历。将矩阵当前的行与向量x相乘，得到输出的结果yy。内层循环标签为L2，实现对矩阵M中每列元素的遍历。L2循环迭代计算rowPtr[i+1]-rowPtr[i]rowPt**r[i+1]−rowPt**r[i]计算每一行非0元素的个数。每次循环计算，能从value数组中读取矩阵M的非0元素然后对应的从x数组中取得被乘向量x的值，对应相乘。cloumnIndex[k] 中的值保存了对应的列号k。 1234567891011#ifndef __SPMV_H__#define __SPMV_H__const static int SIZE = 4; // SIZE of square matrixconst static int NNZ = 9; //Number of non-zero elementsconst static int NUM_ROWS = 4;// SIZE;typedef float DTYPE;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]);#endif // __MATRIXMUL_H__ not defined 图6.3： spmv函数和激励的头文件 6.3 测试平台图6.4 展示了一个针对spmv函数测试平台。测试平台通过定义matrixvector函数，直接实现矩阵向量乘法，它不考虑矩阵是否为稀疏矩阵以及矩阵是否采用CRS方式表示。我们比较matrixvector函数输出和spmv函数的输出。 在通常的测试平台中，需要实现的函数都会有个“黄金”参考，作为用户期望综合的结果。测试平台会比较黄金用例的输出和通过Vivado®HLS综合的代码执行结果。最好的实践方式是，测试平台既可以用于黄金用例，也可用于被综合的代码。这样就保证了两者实现的正确性。 测试平台在主函数main中执行。这里我们通过设置fail变量初始化为0，当spmv函数的输出成结果与matrixvector函数输出结果不相同是时，变量置1。定义与矩阵M相关的变量、被乘向量xx 和输出结果yy。对于矩阵M，即有普通模式，也有CSR模式（保存为values、columnIndex、rowPtr）。矩阵M 的value如图6.1中所示，输出向量yy有两种，其中y_sw数组保存matrixvector函数输出的结果，y数组保存spmv函数输出的结果。 在定义好所有的输入变量和输出变量之后，分别调用spmv函数和matrixvector函数并输入合适的数据。 接下来的for循环用于比较y_sw和y中的每一个对应的结果。如果其中一个不相同，则将fail 标志置1。最后，程序会打印测试的结果并返回fail变量。 12345678910111213141516171819202122232425262728293031323334353637#include "spmv.h"#include &lt;stdio.h&gt;void matrixvector(DTYPE A[SIZE][SIZE], DTYPE *y, DTYPE *x)&#123; for (int i = 0; i &lt; SIZE; i++) &#123; DTYPE y0 = 0; for (int j = 0; j &lt; SIZE; j++) y0 += A[i][j] * x[j]; y[i] = y0; &#125;&#125;int main()&#123; int fail = 0; DTYPE M[SIZE][SIZE] = &#123;&#123;3,4,0,0&#125;,&#123;0,5,9,0&#125;,&#123;2,0,3,1&#125;,&#123;0,4,0,6&#125;&#125;; DTYPE x[SIZE] = &#123;1,2,3,4&#125;; DTYPE y_sw[SIZE]; DTYPE values[] = &#123;3,4,5,9,2,3,1,4,6&#125;; int columnIndex[] = &#123;0,1,1,2,0,2,3,1,3&#125;; int rowPtr[] = &#123;0,2,4,7,9&#125;; DTYPE y[SIZE]; spmv(rowPtr, columnIndex, values, y, x); matrixvector(M, y_sw, x); for(int i = 0; i &lt; SIZE; i++) if(y_sw[i] != y[i]) fail = 1; if(fail == 1) printf("FAILED\n"); else printf("PASS\n"); return fail;&#125; 图6.4 ： 一个简单spmv函数的简单测试平台。测试平台生成了一个用例，并且计算矩阵的向量乘法通过稀疏矩阵乘法（spmv）和非系数矩阵乘法(matrixvector)。 这个测试平台相对简单并且可能无法充分验证所有的输入都能正常输出。最主要的原因是，它仅仅只用了一个矩阵作为例子，相反，一个好的激励会测试许多矩阵。通常，会通过随机的方式产生输入的测试用例，并且重点测试边界用例。在这个例子中，我们不仅要保证值正确计算，同时保证通过加速器正确的被执行了，而且编译时间相关的parameter改变会在实现不同加速单元值折中。最关键的是，在相同的parameter上，我们能通过随机产生很多输入数据来进行测试。编译时间相关的参数每次发生变化，都需要我们重新编译代码。 创建一个复杂的激励来，通过随机数方式生成许多组测试数据。稀疏矩阵编译时间参数应该是可以修改的（例如，SIZE，NNZ 等）。创建一个HLS综合脚本，在编译时间参数合理范围改变时，能执行代码很多次。 6.4 指定循环的属性如果直接将上述代码进行综合，我们可以得到函数运行的时钟周期及资源占用率。但是，我们不能得到模块执行所需的时钟周期、任务执行的延迟和任务执行之间的间隔。因为这些都取依赖于输入数据，由spmv函数外部因素决定。最主要的因素是，内层循环执行的次数是由矩阵M中非0元素个数决定的。非0元素的个数在代码中是由常量NNZ决定的，虽然可以调用函数计算不同大小的矩阵，但是实际迭代次数是和输入数据相关的。另外，性能也会因为非0元素的分布、综合优化的约束产生不同。更复杂的是，迭代的次数由输入决定，许多可能的输入并没有被遍历。所以，对于工具而言，不通过复杂的分析和额外的信息，工具是不能知道spmv函数执行需要多少时钟周期。Vivado®HLS 工具也不能进行上述的分析。 spmv函数能正常工作的前提条件是什么？证明给定的前提条件，矩阵中每个非0元素实是不是在对应一次内层循的执行？ 有几种方式能帮助工具进行性能的分析，其中一种方式就是想Vivado®HLS提供循环边界的额外信息。这可以通过使用loop_tripcount directive实现，它能让设计者指定最小、最大和平均迭代次数针对特定的循环。通过提供这些值， Vivado®HLS 能提供时钟周期级别的评估。 使用loop_tripcount directive 用变量指定循环的最小，最大和平均迭代次数，这样Vivado®HLS 工具能对当前设计时钟周期数目进行估计。这些不影响最后综合的结果，只会影响综合报告。 对spmv函数使用loop_tripcount directive，语法格式 # pragma HLS loop_tripcount min=X, max=Y, avg=Z 其中X，Y，Z正的常量。哪个循环需要使用directive?当改变参数（min、max和avg）以后，综合报告有什么不同？这对时钟周期有影响吗？这对资源占用有影响吗？ loop_tripcount 引导能帮助设计者对函数的性能有个原始的估计。这样能比较相同的函数通过使用不同的directives或者对代码本身重构。但是，这不能确定min、max和 avg 参数。这也很难确定边界条件min和max的值。如果有测试平台，就有一种更准确的方式用于计算spmv函数执行的时钟周期数，那就是C/RTL协同仿真。 6.5 C/RTL 协同仿真C/RTL 协同仿真能自动化测试Vivado®HLS工具生成的RTL代码，只需要在综合的时候提供测试平台。每次执行综合以后的代码和提供的测试平台，记录输入和输出结果。输入的值按照时钟转换成输入向量。这里的输入向量用于针对生成的RTL代码进行仿真，同时记录输出向量。更新综合后的代码， 再次运行测试平台并保存输入和输出数据。测试平台如果返回值是0，则表示成功；若激励返回非0值，则表示失败。 C/RTL 协同仿真流程将VIvado®HLS 生成的RTL代码，通过C 测试平台，实现时钟周期级别的仿真。这样，就能准确对生成的RTL代码进行性能评估，即使性能与输入数据有关。被综合的函数运行周期最小值，最大值，平均值以及间隔在仿真完成以后都能准确的得到。 注意这些和时钟周期相关的参数是通过激励中测试数据得到的。所以，结果的质量和测试平台的质量息息相关。如果测试平台没有很好的对函数执行测试，那么结果将不准确。另外，输入测试向量都是基于理想的时序，不能反映模型实际工作时，外部接口对函数的影响。实际的性能可能会比仿真的要低，如果执行过程中阻塞在输入数据或对外部存储的访问上。不过，对于循环边界调试时变量的情况，设计者可以通过协同仿真的方式确定时钟周期个数。 C/RTL协同仿真能提供循环边界是变量的函数的延迟。它反馈函数运行时延迟的最小值、最大值和平均值以及函数运行间隔。这些延迟和测试平台输入的数据是强相关的。 图6.5 spmv函数内部循环流水执行过程和结构 当采用图6,4提供的测试平台时，函数运行的最小值、最大值和平均值以及函数间隔是多少个时钟周期？ 6.6 循环的优化与数组的分块我们可以通过Vivado®HLS 工具得到当前函数的性能和面积的评估结果，然后可以考虑如何对函数进行优化。流水线、循环展开、数组分块是第一类最常用的优化方法。最典型的方式是从最内层的循环，然后根据需要向外层循环进行。 在这个例子中， 对最内层的L2循环进行流水线化也许是我们最先和最容易想到的优化方式。这个连续迭代的循环在执行上流水以后，总体运行会加快。如果不采用流水，L2 循环将按照串行执行。注意，L1 循环此时还是按照串行的方式执行。 图6.5演示了spmv函数在L2循环采用流水方式时运行的步骤。每次L2的循环都被II=3I**I=3流水化。流水线允许在外层循环执行一次迭代时，内层循环执行多次循环迭代。此时，内层循环II受限于递归（recurrence ）操作。II=3I**I=3是因为我们认为加法器有3个时钟周期的延迟。外部循环没有采用流水的方式，所以内层的循环必须在下外层L2循环开始执行前，计算完成并输出结果。 对最内层的L2 for 循环进行流水化，通过在spmv函数中增加流水directive如图6.2所示。II(initiation interval)最后是多少？在你指定II的值以后，最终目标的II值是增大了还是减少了？ 观察执行步骤，我们可以发现有几个因素限制了循环执行性能。第一个因素，递归（recurrence ）操作限制了循环的 II。第二个因素，外层的循环没有采用流水的方式。一种高效计算稀疏矩阵向量乘法的方式，每个时钟周期把乘法器和加法器使用起来。当前的设计离这个目标还很远。 在章节4.3中，我们探究了几种设计优化技术，其中包括对不同的循环进行流水，循环展开，数组分割。掌握在这些技术之间进行权衡是一项挑战，因为它们之间经常相互依赖。我们通常联合使用这些技术，为了得到好的性能谨慎的选择其中一种而不选择另一种也许结果会更糟糕。例如，在我们使用循环展开是，设计者需要明白它对数据访问的影响。增加了对数据访问的操作但是设计性能又受限于数据访问时，优化毫无益处。同样，如果提供了冗余的存储端口，实际中使用率不高，这样对提高性能毫无帮助反而增加了资源的消耗。 仔细思考一下上述优化技术组合后复杂多变的样式，我们建议你尝试下面的练习： 对spmv设计进行综合，采用表6.1提供的10种directives，每种都有不同的流水，展开和分割针对不同的循环和数组。这些分割在不同的数组（values、columnIndex、x）上使用。你看到结果的趋势是如何的？增加了展开和分割，是有利于还是不利于面积？性能如何？为什么？ 表6.1 稀疏矩阵向量乘法可优化的方式 L1 L2 case1 - - case2 - pipeline case3 pipeline - case4 unroll=2 - case5 - pipeline,unroll=2 case6 - pipeline,unroll=2,cyclic=2 case7 - pipeline,unroll=4 case8 - pipeline,unroll=4,cyclic=4 case9 - pipeline,unroll=8 case10 - pipeline,unroll=8,cyclic=8 case11 - pipeline,unroll=8,block=8 如果你完成了上述练习，你会发现盲目的使用优化directives，可能不会得到你期望的结果。通常在设计时， 在思考下考虑应用的特性，选择针对设计的特定优化方式。当然，这也需要一些直觉能力和一些专用工具投入使用。虽然，搞清楚像Vivado®HLS这样复杂工具中每一个细节是困难乃至不可能的，但是我们能基于关键的方面建立思考模型。 上面我们在用例3和4中考虑对外层循环L1进行流水化操作而不是对内层循环。这种变化针对一个任务，可以提高潜在的并行程度。为了完成优化，Vivado®HLS 工具必须展开代码中所有的内层循环L2 。如果循环能全部展开，这样能减少计算循环边界的时间，同时也能消除递归（recurrences）。但是代码中的内层循环Vivado HLS是无法完全展开的，因为循环边界不是常量。 例如在实现上面提到的例子3，在最外层的循环L1使用流水化directive。在不设定目标II时，II值是多少？资源占用率发生了什么变化？增加了II后资源占用率结果如何？这与之前采对L2循环进行流水化，结果有什么不同？这和最基本的设计（无 directives）相比有什么不同？当你对外层循环进行展开时，结果到底如何？（提示：检查综合后的日志信息） 另外一种增加并行化的方式是对内层循环进行局部循环展开，就像之前例子5到10。这种变化实现更多的并行化，通过在相同的循环迭代中，执行更多的操作。有些情况，Vivado HLS 工具在对内层循环进行流水化时，通过实现更多操作来提高性能。但是，这还是很难提高内层循环的II，由于内层循环的递归操作。但是，在II大于1的情况下， 许多操作可以共享同一个计算单元。 图6.6展示了一个局部展开的代码。在这段代码中，L2 循环被分成2个循环，分别为L2_1和L2_2。最内层的循环L2_2执行的次数由参数S确定。内部循环包含了最原始的L2循环，其中循环边界是由最原始的L2循环确定的。代码中，L2_1 循环包含了不确定次数的乘法和加法操作，运算次数由参数S确定，和一次递归完成累加y0 += yty0+=y**t。 注意图6.6中的代码和自动循环展开的代码是由一点点区别的。自动循环展开复制计算，但是保留每次计算先后顺序（除了当前的例子）。这就导致了计算顺序由内层循环决定，如图6.7左所示。对计算顺序进行调整后，操作上的依赖关系如图6.7 左边所示。在当前的代码中，最后累加求和是一个递归（recurrence ）。当使用浮点数据类型时，这种调整计算顺序的操作可能对程序产生改变，所以Vivado HLS对这种类型的代码不进行操作顺序自动调整。 这个设计可能会被综合、实现如图6.8所示的结果。在这个例子中，S=3S=3与III**I最匹配，乘法器的延迟正好是3。所有的运算过程都是在一个乘法器和加法器上执行。比较这个例子与图6.5中的例子，我们可以发现一些缺点。最明显的是，内层循环的流水线长度很长，实现的时候需要多个更多的周期刷新流水线的输出，才能执行下一次外层L1循环。处理一行中非零元素和执行块S 相同。一行有个3个元素和一行有一个元素计算的时间是相同的。剩下的运算也需要在循环流水线中执行，即使他们的结果没有用。为了严格的比较两个设计的特性，我们需要了解设计对矩阵每行非零元素个数的预期。 12345678910111213141516171819202122#include "spmv.h"const static int S = 7;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123; L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2_1: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k += S) &#123;#pragma HLS pipeline II=S DTYPE yt = values[k] * x[columnIndex[k]]; L2_2: for(int j = 1; j &lt; S; j++) &#123; if(k+j &lt; rowPtr[i+1]) &#123; yt += values[k+j] * x[columnIndex[k+j]]; &#125; &#125; y0 += yt; &#125; y[i] = y0; &#125;&#125; 图6.6 局部展开图6.2中smpv函数 图6.7 针对累加的两种不同方式的局部展开。左边的版本有3个加法器进行递归操作，相反右边的版本只有1个加法器进行递归累加 图6.8 图6.6中 spmv函数基于部分展开和内部流水线处理后执行过程 如果矩阵每行非零元素很少，则采用第一种实现方式较优；如果矩阵中每行非零元素较多，则第二种实现方式更好。 需要注意，这里存在一个关于先有鸡还是先有蛋的问题。我们需要知道目标器件和时钟周期，这样才能确定流水线中加法器能不能满足时序要求。只有在我们知道流水线的级数之后（也许S=1时，Vivado HLS才能识别到加法递归），我们才能选择合适版本的参数S，来满足II=1I**I=1。一旦我们确定了S，我们能通过C/RTL协同仿真来，通过一组测试数据，确定是不是达到了性能上的要求。因为循环边界是可变的，所以得到的性能参数是依赖于数据的，所以我们需要设定不同的S，来找到性能的最大值。改变器件的类型和工作频率会影响之前所有的设计！尽管看来去高层次综合（HLS）对解决问题提供的帮助不多，相比于RTL开发新版本然后进行验证，它开发起来快（代码编写方便）。 图6.8可以实现时，S 与加法器流水线等级相同。如果S设定较大，结果会怎样？如果S 设定较小，结果会怎样？如果目标II小于S会怎样？如果目标II大于S会怎样？ 6.7小结在本章节中，我们介绍了系数矩阵向量乘法（SpMV），这延续了之前对矩阵运算的研究。SpMV 显得很有趣，因为它采用了一种特别的数据结构。为了减少大量的存储，矩阵采用行压缩的方式存储，这样就要求我们以一种非直接的方式对矩阵进行访问。 这一章节首先我们了Vivado®HLS工具测试和仿真的能力。我们采用一个基于SpMV简单的激励文件，讲解HLS工作流程。另外，我们对Vivado®HLS工具中C/RTL 协同仿真进行了讲解。这对我们得到设计准确性能结果是十分重要。矩阵越不稀疏，则更多的计算需要执行。在测试平台确定以后，协同仿真可以提供程序运行的精确仿真。这样就可以达到执行周期和性能结果。最后，我们讨论了采用循环优化和数组分块对代码进行优化。 fpga并行编程]]></content>
      <categories>
        <category>SpMV</category>
      </categories>
      <tags>
        <tag>SpMV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F05%2F19%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx安装及配置 本文参考： Nginx安装配置_菜鸟教程 Nginx中文文档 Nginx简易教程 概述什么是nginx? Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 什么是反向代理？ 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用安装 nginx官网下载地址：http://nginx.org，发布版本分为 Linux 和 windows 版本。 也可以下载源码，编译后运行。 从源代码编译 Nginx 把源码解压缩之后，在终端里运行如下命令： 123$ ./configure$ make$ sudo make install 默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。 Windows 安装 为了安装 Nginx / Win32，需先下载它(Nginx官方下载)。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： 1nginx-0.8.54 start nginx Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。 使用nginx 的使用比较简单，就是几条命令。 常用到的命令如下： nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen ：重新打开日志文件。 nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v：显示 nginx 的版本。 nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下： 123456789101112@echo offrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程nginx.exe -s stoprem 测试配置文件语法正确性nginx.exe -t -c conf/nginx.confrem 显示版本信息nginx.exe -vrem 按照指定配置去启动nginxnginx.exe -c conf/nginx.conf 如果是运行在 Linux 下，写一个 shell 脚本，大同小异。 配置nginx 配置实战我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。 http反向代理配置我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下：注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#运行用户#user somebody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志error_log D:/Tools/nginx-1.10.1/logs/error.log;error_log D:/Tools/nginx-1.10.1/logs/notice.log notice;error_log D:/Tools/nginx-1.10.1/logs/info.log info;#PID文件，记录当前启动的nginx的进程IDpid D:/Tools/nginx-1.10.1/logs/nginx.pid;#工作模式及连接数上限events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型(邮件支持类型),类型由mime.types文件定义 include D:/Tools/nginx-1.10.1/conf/mime.types; default_type application/octet-stream; #设定日志 log_format main &apos;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log D:/Tools/nginx-1.10.1/logs/access.log main; rewrite_log on; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 120; tcp_nodelay on; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream zp_server1&#123; server 127.0.0.1:8089; &#125; #HTTP服务器 server &#123; #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #首页 index index.html #指向webapp的目录 root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp; #编码格式 charset utf-8; #代理配置参数 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 location / &#123; proxy_pass http://zp_server1; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappiews; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; # root html; #&#125; &#125;&#125; 好了，让我们来试试吧： 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host：在 C:WindowsSystem32driversetc 目录下的host文件中添加一条DNS 记录127.0.0.1 http://www.helloworld.com 启动前文中 startup.bat 的命令 在浏览器中访问 http://www.helloworld.com，不出意外，已经可以访问了。 负载均衡配置上一个例子中，代理仅仅指向一个服务器。 但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。 nginx也可以实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 http://www.helloworld.com，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。 nginx.conf 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #设定负载均衡的服务器列表 upstream load_balance_server &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; #HTTP服务器 server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #对所有请求进行负载均衡请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.html index.htm; #定义首页索引文件的名称 proxy_pass http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表 #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $remote_addr; proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125; &#125;&#125; 网站有多个webapp的配置当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。 举个例子：假如 http://www.helloworld.com 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分: http://www.helloworld.com/finance/ http://www.helloworld.com/product/ http://www.helloworld.com/admin/ 我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。 那么，问题来了，用户在实际访问 http://www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。 配置也不难，来看看怎么做吧： 1234567891011121314151617181920212223242526272829303132333435http &#123; #此处省略一些基本配置 upstream product_server&#123; server www.helloworld.com:8081; &#125; upstream admin_server&#123; server www.helloworld.com:8082; &#125; upstream finance_server&#123; server www.helloworld.com:8083; &#125; server &#123; #此处省略一些基本配置 #默认指向product的server location / &#123; proxy_pass http://product_server; &#125; location /product/&#123; proxy_pass http://product_server; &#125; location /admin/ &#123; proxy_pass http://admin_server; &#125; location /finance/ &#123; proxy_pass http://finance_server; &#125; &#125;&#125; https反向代理配置一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点： HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key 其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 12345678910111213141516171819202122232425#HTTP服务器 server &#123; #监听443端口。443为知名端口号，主要用于HTTPS协议 listen 443 ssl; #定义使用www.xx.com访问 server_name www.helloworld.com; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate cert.pem; #ssl证书key位置 ssl_certificate_key cert.key; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #数字签名，此处使用MD5 ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /root; index index.html index.htm; &#125; &#125; 静态站点配置有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。 举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。 配置如下： 123456789101112131415161718192021222324252627worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png; gzip_vary on; server &#123; listen 80; server_name static.zp.cn; location / &#123; root /app/dist; index index.html; #转发任何请求到 index.html &#125; &#125;&#125; 然后，添加 HOST：127.0.0.1 http://static.zp.cn，此时，在本地浏览器访问 http://static.zp.cn ，就可以访问静态站点了。 跨域解决方案web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。 各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路： CORS在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。 jsonp把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。 这两种思路，本文不展开讨论。 需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。 举例：http://www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。 前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧： 首先，在 enable-cors.conf 文件中设置 cors ： 1234567891011121314151617181920212223242526# allow origin listset $ACAO &apos;*&apos;;# set single originif ($http_origin ~* (www.helloworld.com)$) &#123; set $ACAO $http_origin;&#125;if ($cors = &quot;trueget&quot;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;;&#125;if ($request_method = &apos;OPTIONS&apos;) &#123; set $cors &quot;$&#123;cors&#125;options&quot;;&#125;if ($request_method = &apos;GET&apos;) &#123; set $cors &quot;$&#123;cors&#125;get&quot;;&#125;if ($request_method = &apos;POST&apos;) &#123; set $cors &quot;$&#123;cors&#125;post&quot;;&#125; 接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置： 12345678910111213141516171819202122232425262728# ----------------------------------------------------# 此文件为项目 nginx 配置片段# 可以直接在 nginx config 中 include（推荐）# 或者 copy 到现有 nginx 中，自行配置# www.helloworld.com 域名需配合 dns hosts 进行配置# 其中，api 开启了 cors，需配合本目录下另一份配置文件# ----------------------------------------------------upstream front_server&#123; server www.helloworld.com:9000;&#125;upstream api_server&#123; server www.helloworld.com:8080;&#125;server &#123; listen 80; server_name www.helloworld.com; location ~ ^/api/ &#123; include enable-cors.conf; proxy_pass http://api_server; rewrite &quot;^/api/(.*)$&quot; /$1 break; &#125; location ~ ^/ &#123; proxy_pass http://front_server; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+rtmp]]></title>
    <url>%2F2019%2F05%2F17%2Fnginx-rtmp%2F</url>
    <content type="text"><![CDATA[nginx+rtmp 搭建视频直播服务器服务器安装配置 windows安装包(已编译好的版本)参考： nginx for windows windows下搭建基于nginx的rtmp服务器 在Windows下搭建基于nginx的视频直播和点播系统 搬运源码（未编译） Car-eye-RTMP-server(github) car-eye-http-flv-module nginx+rtmp在windows下编译 Windows下编译nginx-rtmp-module windows下编译nginx+nginx_rtmp_modue(vs2013) CentOS搭建nginx+rtmp服务器 nginx+rtmp直播流服务搭建 centos7 centos7 Nginx+rtmp 搭建流媒体服务器 linux下建议将nginx.conf中的http端口改为1024以上，好像是80端口每次运行都需要su权限。 Nginx搭建rtmp流媒体服务器 nginx服务器常用命令12345678910./nginx -v//查看nginx版本号./nginx -V //查看nginx详细的版本信息start ./nginx -c conf/nginx.conf //以nginx.conf的配置启动nginx./nginx -s stop//停止nginx服务器./nginx -s quit//停止nginx服务器./nginx -s reload//重启nginx服务器service nginx reload//重启nginx服务器./nginx -t (-c conf/nginx.conf)//检查配置文件是否正确./nginx -h//显示帮助信息./nginx -?//显示帮助信息 nginx+rtmp加入权限控制 本文参考： *rtmp-module官方wiki *视频直播点播nginx-rtmp开发手册中文版(参考wiki版本粗译) 如何给 nginx rtmp 服务加入鉴权机制(改源码) *「自己开发直播」实现nginx-rtmp-module多频道输入输出与权限控制 nginx-rtmp-module授权机制实现直播推流多房间授权认证 nginx-rtmp-module 权限控制 nginx-rtmp加入权限验证的简单方法 视频直播点播nginx-rtmp开发手册中文版 *nginx.conf中关于nginx-rtmp-module配置指令详解 *nginx-rtmp多房间和授权实现 *博客比较有用 nginx的rtmp-module默认不限制推流权限、播放权限。 想加入权限验证有很多种方法。 其中一个是改源码，一个是利用nginx+rtmp的配置文件调用后台接口进行验证。 第一种方法没成功过，第二种方法比较简单。此文介绍第二种方法，第一种方法可见博客-&gt;如何给 nginx rtmp 服务加入鉴权机制(改源码) 原理主要是利用on_publish跳转到当前配置的一个“location”，在这里进行验证。关键点在于rtmp application节点下面要配置“notify_method get;”为什么呢？因为跳转的时候，默认以POST方式传输参数，修改成GET方式，nginx配置里就可以轻松处理了。（当然nginx通过配置文件也可以处理post，只是复杂一些）。 我们在此使用python的后台框架flask处理on_publish的post请求。 后台返回http200即为通过验证，返回http500即为验证失败，服务器拒绝连接。 nginx的配置文件（位于nginx安装目录下：…/nginx/conf/nginx.conf）修改如下: 12345678910111213141516171819202122rtmp &#123; server &#123; #listen 1935; listen 10077; chunk_size 4000; application live &#123; live on; on_publish http://localhost:10078/user/auth;//后面的url即flask监听的地址 &#125; application hls &#123; live on; hls on; #hls_path ../nginx-1.7.11.3-Gryphon/html/hls; hls_path ../hls; hls_fragment 5s; on_publish http://localhost:10078/user/auth; &#125; &#125;&#125; python的flask后台代码如下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding:utf-8 -*-#https://www.jianshu.com/p/0d14ae8f081c#https://blog.csdn.net/wei389083222/article/details/78721074/#https://blog.csdn.net/weixin_34368949/article/details/85991563#验证只能用post方法#虽然流密钥的格式像是get类型，但是必须使用POST获取参数。from flask import Flask, request, Responseapp = Flask(__name__)#传入url格式为: xx.xx.xx.xx:10078/user/auth?usr=xxx&amp;passWord=xxx@app.route('/user/auth',methods=['POST'])def auth(): usr = request.form['usr']#从url后获取的数据 passWord = request.form['passWord'] print(usr,'\t',passWord) #此处可改为从数据库获取数据 auth_user='abc' auth_passWord='123' if auth_user == usr and auth_passWord ==passWord: return Response(response='success',status=200)#返回200状态码 else: return Response(status=500)#返回500状态码 #Flask.abort(404) return passWordif __name__ == '__main__': app.run(host='0.0.0.0',port=10078,debug=True) 播放权限也可用类似on_publish的验证方法进行控制。 on_play和on_publish 一样，只接受post方法，若需要接受get方法需要在rtmp中application的配置中添加notify_method get;，然后可在http{}部分中处理调用（这部分语法我不太清楚，不详细展开）。 以下是nginx.conf关于on_play的用法 on_play语法：on_play url上下文：rtmp, server, application描述：设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。 HTTP 2XX 返回码的话继续 RTMP 会话。 HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。 其他返回码的话 RTMP 连接丢弃。重定向例子： 123456789101112131415161718192021222324252627 http &#123; location /local_redirect &#123; rewrite ^.*$ newname? permanent; &#125; location /remote_redirect &#123; # no domain name here, only ip rewrite ^.*$ rtmp://192.168.1.123/someapp/somename? permanent; &#125; &#125; rtmp &#123; application myapp1 &#123; live on; # stream will be redirected to &apos;newname&apos; on_play http://localhost:8080/local_redirect; &#125; application myapp2 &#123; live on; # stream will be pulled from remote location # requires nginx &gt;= 1.3.10 on_play http://localhost:8080/remote_redirect; &#125;&#125; HTTP 请求接收到一些个参数。在 application/x-www-form-urlencoded MIME 类型下使用 POST 方法。以下参数会被传送给调用者： call=play。 addr - 客户端 IP 地址。 app - application 名。 flashVer - 客户端 flash 版本。 swfUrl - 客户端 swf url。 tcUrl - tcUrl。 pageUrl - 客户端页面 url。 name - 流名。出了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100&amp;b=face&amp;foo=bar 访问，然后呢 a,b 和 foo 发送回调。on_play http://example.com/my_callback; 过程中使用到的额外软件 obs 手机端:快直播 ffmpeg推流（没用过）]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPages Synchronization]]></title>
    <url>%2F2019%2F05%2F16%2Fhexo-gitPages-Synchronization%2F</url>
    <content type="text"><![CDATA[Hexo+gitPages 的博客多端同步管理及迁移 本文参考 如何解决github+Hexo的博客多终端同步问题 利用Hexo在多台电脑上提交和更新github pages博客 搭建hexo博客并简单的实现多终端同步 hexo博客同步管理及迁移 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件(包括博客内容主题等等)放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。 同步的首次操作在创建了博客的目录下操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上。 只托管部分用于多终端的同步的文件 注意：使用第三方主题时，要删除第三方主题的.git文件夹删除，不然无法push到远程仓库 1234567git init //初始化本地仓库git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示,其实也可以用'git add .'命令，在.gitignore文件中加入不需要同步的文件即可git commit -m "Blog Source Hexo"git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上 多出来的hexo的分支，用于文件同步，原有的master分支用于部署静态博客页面 在新终端进行更新博客先从github中把文件clone到本地，然后安装相应组件。然后通过git的提交同步内容，用hexo的命令部署博客到gitPages里。 12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地cd yourname.github.io //切换到刚刚clone的文件夹内npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再inithexo new post "new blog name" //新建一个.md文件，并编辑完成自己的博客内容git add source //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客，如果更改了主题样式的话还是建议用'git add .'git commit -m "XX"git push origin hexo //更新分支hexo d -g //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master 已有博客的终端更新博客进入相应的文件夹，更新博客直行命令即可。 123456git pull origin hexo//先pull完成本地和远端的融合hexo new post "new blog"git add .git commit -m "Blog update"git push origin hexohexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2019%2F05%2F14%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown Syntax 本文参考 Markdown基本语法(简书) Markdown官方文档 Markdown语法html支持 Markdown部分详细用法 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 12345678Atx形式# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题1234567Setext形式This is an H1=============This is an H2------------- This is an H1This is an H2根据标题生成目录1[TOC] 根据标题自动生成目录 [TOC] 字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 加粗测试 倾斜测试 斜体加粗测试 删除线测试 引用1234&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;多重引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 引用测试一 引用测试二 多重引用 引用测试 分割线1234-------******** 只要三个以上就可以 图片引用1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 插入带有链接的图片1234[[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com)&#123;:target="_blank"&#125; // 内链式[[图片上传失败...(image-4dc956-1542510791300)]][5]&#123;:target="_blank"&#125; // 引用式[5]: http://www.baidu.com [图片上传失败…(image-f83b77-1542510791300)]{:target=”_blank”} 内链式 [图片上传失败…(image-f83b77-1542510791300)]{:target=”blank”} 外链式 超链接引用12[超链接名](超链接地址 "超链接title")title可加可不加 12[简书](http://jianshu.com)[百度](http://baidu.com) baidu 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 简书 视频插入注：Markdown 语法是不支持直接插入视频的 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注：多数第三方平台不支持插入&lt;iframe&gt;视频 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 代码2 1[[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction)&#123;:target="_blank"&#125; 列表1234567无序列表用任一种皆可- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表（-） 列表（-） 列表（+） 列表（*） 1234567有序列表内容1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 第一点 第二点 第三点 12345678910111213141516171819**上一级和下一级之间敲三个空格即可**- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 Typora编辑器中可以直接使用crtl+T，或者在菜单段落中找到表格生成 代码引用单行代码 1`代码内容` int main(){return 0;} 代码块 12345(```)language 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt; "hello markdown"; return 0;&#125; 格式化代码html版123&lt;pre&gt;## 这是一个不起作用的标题&lt;/pre&gt; ## 这是一个不起作用的标题 流程图注： st=&gt;start: 开始 的：后面保持空格 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 6种类型 含义 start 启动 end 结束 operation 程序 subroutine 子程序 condition 条件 inputoutput 输出 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件 (布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 12345678910111213## 选项框```markdown- [x] 选项一- [ ] 选项二 需要注意的是：-、[x]、和选择一之间都要有空格，如果不下x[ ]中也要有空格 选项一 选项二 数学公式支持LaTex的数学公式，参考https://www.jianshu.com/p/2bbec51d756f 数学公式（MathJax)，参考https://www.jianshu.com/p/a0aa94ef8ab2 注：1个$左对齐，2个居中 12$$ x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1 $$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $ $$x \href{why-equal.html}{=} y^2 +1$$ 使用Typora的时候可以直接使用 $$+回车，或者用crtl+shift+M生成公式块（在段落菜单中的公式块） 参考https://blog.csdn.net/mingzhuo_126/article/details/82722455 脚注12Markdown[^1][^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注 Markdown^1 锚点注：只有标题支持锚点， 跳转目录方括号后 保持空格 123[公式标题锚点](#1)### [需要跳转的目录] &#123;#1&#125; // 方括号后保持空格 脚注标题锚点 123由于&#123;# 是hexo的标注语言hexo 中 &#123;# 属于保留字段 &#123;# ... #&#125;属于注释字段把```以外的&#123;#改成&#123;&#123; '&#123;#' &#125;&#125;即可解决 自动邮箱链接1&lt;xxx@outlook.com&gt; &#120;&#x78;&#120;&#x40;&#111;&#117;&#116;&#108;&#x6f;&#x6f;&#107;&#46;&#99;&#111;&#109; 时序图代码1 123456​```sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B--&gt;A: 很高兴认识你​ 12345678910111213141516171819202122**演示**![img](https:////upload-images.jianshu.io/upload_images/6912209-784ce9bb7beb6672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)**代码详解**注：`A-&gt;&gt;B: 你好` 后面可以不写文字，但是一定要在最后加上`：` Note left of A 代表注释在A的左边| 符号 | 含义 || ---- | -------- || `-` | 实线 || `&gt;` | 实心箭头 || `--` | 虚线 || `&gt;&gt;` | 空心箭头 |**代码2** 123456789起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天 演示]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpages]]></title>
    <url>%2F2019%2F05%2F14%2Fhexo-gitpages%2F</url>
    <content type="text"><![CDATA[hexo+gitPages搭建个人博客 本文参考 hexo 博客搭建 hexo官方文档 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 手把手教你搭建自己的个人博客（图文教程） 搭建篇 –使用Github+hexo搭建个人博客教程—总结自己爬过的坑) GitHub+Hexo 搭建个人网站详细教程 史上最详细的Hexo博客搭建图文教程 hexo优化 hexo博客改装和一些细节优化) Hexo NexT 博客后台管理指南 Hexo主题更改以及小功能的添加 hexo-NexT主题配置 NexT官方展示 NexT官方中文文档ReadME NexT源码 NexT文档 Hexo的Next主题详细配置 hexo的next主题个性化教程:打造炫酷网站 hexo的next主题个性化教程：打造炫酷网站 【持续更新】hexo next主题优化手册 可参考博客嘤 yilia主题 yilia主题源码（GitHub） yilia主题展示 hexo博客搭建安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js (Should be at least nodejs 6.9) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 在安装的时候我用的是npm install hexo --save 关于npm命令回顾 npm install 命令最近在写Node程序的时候，突然对 npm install 的-save和-save-dev 这两个参数的使用比较混乱。其实博主在这之前对这两个参数的理解也是模糊的，各种查资料和实践后对它们之间的异同点略有理解。遂写下这篇文章避免自己忘记，同时也给node猿友一点指引。 我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式： 1234npm install moduleName # 安装模块到项目目录下`npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 那么问题来了，在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。 npm install moduleName 命令 安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令 安装模块到全局，不会在项目node_modules目录中保存模块包。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -save moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install -save-dev moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 &lt;folder&gt; 为hexo安装目录 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 12345678910111213141516171819package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 部署当执行完npm install之后即可通过hexo s或者hexo serve通过本地访问hexo博客。 此时博客已搭建在本地了。 方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 （可在github仓库中设置跳转至个人域名） 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 然后添加解析 包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 保存，命名为CNAME ，注意保存成所有文件而不是txt文件。 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 123hexo cleanhexo ghexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 方案四：云服务器 + 域名该方案需要先购买云服务器和域名。 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 12$ yum -y update$ yum install -y git nginx Nginx配置 2.1. 创建文件目录(用于博客站点文件存放) 123cd /usr/local/mkdir hexochmod 775 -R /usr/local/hexo/ 2.2. 添加 index.html(用于检测配置 Nginx 是否成功) 1vim /usr/local/hexo/index.html 添加以下代码，并保存。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 2.3. 配置 Nginx 服务器 1vim /etc/nginx/nginx.conf 修改server_name和root： 123456server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; &#125; 2.4. 启动nginx服务； 1service nginx start 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置 3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 123cd /usr/local/mkdir hexoRepochmod 775 -R /usr/local/hexoRepo/ 3.2. Git 初始化裸库。 12cd hexoRepo/git init --bare hexo.git 3.3. 创建 Git 钩子(hook)。 1vim /usr/local/hexoRepo/hexo.git/hooks/post-receive 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 123#!/bin/bashgit --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f 3.5. 保存并退出后, 给该文件添加可执行权限。 1chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive 本地博客推送到云服务器 4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 4.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 4.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。 Hexo常用命令123456789hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 注：当本地预览和远程部署的浏览结果不同的时候，不妨使用hexo clean &amp;&amp; hexo g -d试试。 创建文章命令： 123$ hexo new [layout] &lt;title&gt;复制代码 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 123$ hexo publish [layout] &lt;title&gt;复制代码 title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” ​ 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 主题配置hexo主题wiki 可以在此处寻找自己喜欢的主题下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~ 主题优化 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 添加个人联系方式 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 添加背景图 修改Logo字体 修改内容区域的宽度 网站标题栏背景颜色 自定义鼠标样式 文章加密访问 实现点击出现桃心效果 静态资源压缩（博文压缩） 修改访问url路径 博文置顶 在右上角或左上角实现fork me on github 主页文章添加边框阴影效果 显示当前浏览记录 常见分类页 加入广告 添加萌萌哒 搜索功能 网易云外链播放器 花里胡哨的玩意儿 修改作者头像并旋转 修改代码块自定义样式 点击爆炸效果 添加萌妹子动图 侧栏设置 透明背景设置 添加阅读全文 设置网站缩略图标 添加站点访问计数 前几个可参考next官方文档配置 （以下用到外部工具） 评论系统 数据统计与分析 内容分享服务 文章加密访问 hexo-blog-encrypt SEOHexo NexT 主题SEO优化指南 seo这东西是使自己的文章能被百度、谷歌搜录，能被搜索到。 因为暂时不想被搜到/doge，所有暂不配置]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
