<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/css/main.css?v=7.1.1"/>




  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="一、引论编译原理是良好的数学基础和好的工程结构功能的结合。 Compiler：编译，述而不作，忠于编写的东西 编译器从逻辑上可以分成若干阶段，每个阶段把源程序从一种表示变换成另一种表示 1.1什么叫编译程序翻译器（翻译程序）：Translater 能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序） 编译器（编译程序）：Compiler 能将一种计算机高级语言程序（源语言程序）">
<meta property="og:type" content="article">
<meta property="og:title" content="Compiler">
<meta property="og:url" content="http://magic-king.net/2019/09/04/Compiler/index.html">
<meta property="og:site_name" content="Hexo&amp;Magic">
<meta property="og:description" content="一、引论编译原理是良好的数学基础和好的工程结构功能的结合。 Compiler：编译，述而不作，忠于编写的东西 编译器从逻辑上可以分成若干阶段，每个阶段把源程序从一种表示变换成另一种表示 1.1什么叫编译程序翻译器（翻译程序）：Translater 能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序） 编译器（编译程序）：Compiler 能将一种计算机高级语言程序（源语言程序）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/1.2_1.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/2.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/8.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/9.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/3.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/10.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/4.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/5.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/5.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/6.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/7.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/7.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/11.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/12.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/13.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/14.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/15.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/16.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/17.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/18.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/19.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/20.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/21.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/22.jpg">
<meta property="og:image" content="http://magic-king.net/2019/09/04/Compiler/23.jpg">
<meta property="article:published_time" content="2019-09-04T15:11:48.000Z">
<meta property="article:modified_time" content="2019-12-24T11:07:47.971Z">
<meta property="article:author" content="Magic King">
<meta property="article:tag" content="StudyNote">
<meta property="article:tag" content="Compilier">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://magic-king.net/2019/09/04/Compiler/1.2_1.jpg">


  


  <link rel="alternate" href="/atom.xml" title="Hexo&Magic" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="http://magic-king.net/2019/09/04/Compiler/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Compiler | Hexo&Magic</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.0"></head>


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo&Magic</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-link">

    
    
    
      
    

    

    <a href="/Link/" rel="section"><i class="menu-item-icon fa fa-fw fa-magic"></i> <br/>Link</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://magic-king.net/2019/09/04/Compiler/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Magic King"/>
      <meta itemprop="description" content="Now You See Me!"/>
      <meta itemprop="image" content="/images/avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo&Magic"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Compiler

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-04 23:11:48" itemprop="dateCreated datePublished" datetime="2019-09-04T23:11:48+08:00">2019-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-24 19:07:47" itemprop="dateModified" datetime="2019-12-24T19:07:47+08:00">2019-12-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、引论"><a href="#一、引论" class="headerlink" title="一、引论"></a>一、引论</h2><p>编译原理是良好的数学基础和好的工程结构功能的结合。</p>
<p>Compiler：编译，述而不作，忠于编写的东西</p>
<p>编译器从<strong>逻辑</strong>上可以分成若干阶段，<strong>每个阶段把源程序从一种表示变换成另一种表示</strong></p>
<h3 id="1-1什么叫编译程序"><a href="#1-1什么叫编译程序" class="headerlink" title="1.1什么叫编译程序"></a>1.1什么叫编译程序</h3><p>翻译器（翻译程序）：Translater</p>
<p>能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序）</p>
<p>编译器（编译程序）：Compiler</p>
<p>能将一种计算机高级语言程序（源语言程序）转换成另一种等价的计算机低级语言程序（目标语言程序）</p>
<p>解释器（解释程序）：Interpreter</p>
<p>也是一种翻译程序，以一种语言写的源程序作为输入，但不产生目标代码，而是边解释边执行</p>
<p>解释器和编译器的区别：</p>
<p>①编译分成两步完成：先翻译，在运行</p>
<p>②解释只用一步就完成：边解释边执行</p>
<p>可变目标编译程序（Retargetable Compiler）</p>
<p>交叉编译程序（Cross Compiler）</p>
<h3 id="1-2编译程序的组成"><a href="#1-2编译程序的组成" class="headerlink" title="1.2编译程序的组成"></a>1.2编译程序的组成</h3><p><img src="/2019/09/04/Compiler/1.2_1.jpg" alt></p>
<p> 词法分析器：读入组成源程序的字符流，并将它们组织成为有意义的词素的序列</p>
<p>语法分析器：使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示，该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法便是语法树，树中的每个内部节点表示一个运算</p>
<p>语义分析器：使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中键代码生成过程中使用。</p>
<p>中间代码生成器：在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。比如语法树是一种中间表示形式，通常在语法分析和语义分析中使用。</p>
<p>代码优化器：机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码</p>
<p>代码生成器：代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。</p>
<p>符号表管理器：记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息。</p>
<blockquote>
<p>Tips:</p>
<p>如何学习构造编译程序</p>
<p>（1）源语言，对被编译的源程序深刻理解其结构和含义</p>
<p>（2）目标语言，假定目标语言是机器语言，就必须搞清楚硬件的系统结构和操作系统的功能</p>
<p>（3）编译方法，把一种语言翻译成另一种语言的方法很多，重点</p>
</blockquote>
<h2 id="二、高级语言及其语法描述"><a href="#二、高级语言及其语法描述" class="headerlink" title="二、高级语言及其语法描述"></a>二、高级语言及其语法描述</h2><h3 id="2-1程序语言的语法和语义"><a href="#2-1程序语言的语法和语义" class="headerlink" title="2.1程序语言的语法和语义"></a>2.1程序语言的语法和语义</h3><h4 id="2-1-1语法"><a href="#2-1-1语法" class="headerlink" title="2.1.1语法"></a>2.1.1语法</h4><p>任何语言均可作一个集合。这个集合中的每个元素都是在一定符号集（字母表）上的一个符号串。</p>
<p>对于自然语言来说，他们是定义在某个字母表上的<strong>句子的集合</strong></p>
<p>对于程序语言来说，他们也是定义在某个字母表上的<strong>句子</strong>的集合。这里的句子，就是一个源程序。</p>
<p>词法规则：单词符号是语言中具有独立意义的最基本单位。语言的单词符号是由词法规则所确定的，即词法规则规定了单词符号的形成规则。</p>
<p>语法规则：上下文无关文法或BNF（Backus-Naur范式）</p>
<h4 id="2-1-2语义"><a href="#2-1-2语义" class="headerlink" title="2.1.2语义"></a>2.1.2语义</h4><p>语义，定义程序的意义</p>
<p>没有公认的形式系统描述语义</p>
<h3 id="2-2程序语言的一般特征"><a href="#2-2程序语言的一般特征" class="headerlink" title="2.2程序语言的一般特征"></a>2.2程序语言的一般特征</h3><h4 id="高级语言的分类"><a href="#高级语言的分类" class="headerlink" title="高级语言的分类"></a>高级语言的分类</h4><ul>
<li>强制性语言（Imperative Language）|过程式语言：Fortran，C，Pascal</li>
<li>应用式语言（Applicative Language）|函数式语言：LISP</li>
<li>基于规则的语言（Ruled-based Language）：Prolog</li>
<li>面向对象语言（Object-oriented Language）：JAVA，c++</li>
</ul>
<h3 id="2-3程序语言的语法描述"><a href="#2-3程序语言的语法描述" class="headerlink" title="2.3程序语言的语法描述"></a>2.3程序语言的语法描述</h3><h4 id="一、字母表和符号串"><a href="#一、字母表和符号串" class="headerlink" title="一、字母表和符号串"></a>一、字母表和符号串</h4><p>  <strong>字母表</strong>：符号的非空有限集合   例：∑ ={a，b，c}</p>
<p>  <strong>符号</strong>：字母表中的元素         例： a，b，c</p>
<p>  <strong>符号串</strong>：符号的有穷序列       例：a, aa, ac, abc，..</p>
<p>  <strong>空符号串</strong>：无任何符号的符号串( ε )    </p>
<p>  <strong>符号串集合</strong>：由符号串构成的集合。</p>
<blockquote>
<p><strong>符号串的形式定义</strong></p>
<p>   有字母表∑，定义：</p>
<p>  （1）ε是∑上的符号串；</p>
<p>  （2）若x是∑上的符号串，且<code>a∈ ∑</code>，则<code>ax</code>或<code>xa</code>是 ∑ 上的符号串；</p>
<p>  （3）y是∑上的符号串，iff（当且仅当）y可由（1）和（2）产生。   </p>
</blockquote>
<h4 id="二、符号串和符号串集合的运算"><a href="#二、符号串和符号串集合的运算" class="headerlink" title="二、符号串和符号串集合的运算"></a>二、符号串和符号串集合的运算</h4><p><strong>符号串相等</strong>：若x、y是集合上的两个符号串，则x＝y，iff（当且仅当）组成x的每一个符号和组成y的<strong>每一个</strong>符号依次相等。</p>
<p><strong>符号串的长度</strong>：若x为符号串，其长度|x|等于组成该符      号串的符号个数。（例：<code>x＝STV， |x|=3</code>）</p>
<p><strong>符号串的连接</strong>：若x、y是定义在Σ是上的符号串，且<code>x＝XY，y＝YX</code>，则x和y的连接 <code>xy ＝ XYYX</code>也是Σ上的符号串。（注意：一般<code>xy ≠ yx</code>，但是<code>εx = xε</code>）</p>
<p><strong>符号串集合的乘积运算</strong>：令A、B为符号串集合，定义<code>AB＝{ xy | x∈A, y∈B}</code></p>
<p><strong>符号串集合的幂运算</strong>：有符号串集合A，定义A<sup>0</sup> ={ε},  A<sup>1</sup>=A,  A<sup>2</sup>=AA,  A<sup>3</sup>=AAA,…… ……,                    A<sup>n</sup>＝A<sup>n-1</sup>A=AA<sup>n-1 </sup> ，n&gt;0</p>
<p><strong>符号串集合的闭包运算</strong>：设A是符号串集合，定义  A<sup>＋</sup>＝ A<sup>1</sup> ∪ A<sup>2</sup> ∪ A<sup>3</sup> ∪……∪ A<sup>n</sup> ∪……  称为集合A的正则闭包。A*＝ A<sup>0</sup> ∪A<sup>＋ </sup>称为集合A的闭包。（A<sup>0</sup> = { ε } ）</p>
<p><strong>为什么对符号、符号串、符号串集合以及它们的运算感兴趣？</strong></p>
<p>若A为某语言的基本字符集</p>
<p>​        A＝{a,b,……z,0,1,……,9, +,－,×,_/, ( , ), =……}</p>
<p>B为单词集</p>
<p>​     B ={begin, end, if, then,else,for,……,&lt;标识符&gt;,&lt;常量&gt;,……}</p>
<p>  则B ⊂  A* 。</p>
<p>语言的句子是定义在B上的符号串。</p>
<p>若令C为句子集合，则C ⊂ B<sup>*</sup>  ,  程序 ⊂ C</p>
<h4 id="三、文法的直观理解"><a href="#三、文法的直观理解" class="headerlink" title="三、文法的直观理解"></a>三、文法的直观理解</h4><p><strong>1.什么是文法</strong>：文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）。</p>
<p><strong>2.语法规则</strong>：我们通过建立一组规则（产生式），来描述句子的语法结构。规定用“<code>::=</code>”表示“由……组成“。</p>
<blockquote>
<p>例如：</p>
<p>&lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt;</p>
<p>&lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt;</p>
<p>&lt;代词&gt; ::=你|我|他</p>
<p>&lt;名词&gt;::= 王民|大学生|工人|英语</p>
<p>&lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt;</p>
<p>&lt;动词&gt;::=是|学习</p>
<p>&lt;直接宾语&gt;::=&lt;代词&gt;|&lt;名词&gt;</p>
</blockquote>
<p><strong>3.由产生式推导句子</strong>：3.有了一组产生式之后，可以按照一定的方式用它们去推导或产生句子。</p>
<p>​    <strong>推导方法</strong>：从一个要识别的符号开始推导，即用相应产生式的<strong>右部</strong>来替代产生式的<strong>左部</strong>，每次仅用一条产生式去进行推导。</p>
<p>&lt;句子&gt;  =&gt; &lt;主语&gt;&lt;谓语&gt;</p>
<p>&lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt; </p>
<p>  …… ……</p>
<p>这种推导一直进行下去，直到所有带&lt; &gt;的符号都由终结符号替代为止。</p>
<blockquote>
<p><strong>说明</strong>：有若干语法成分同时存在时，我们总是从最左的语法成分进行推导，这称之为<strong>最左推导</strong>，类似的有<strong>最右推导</strong>（一般推导）。</p>
</blockquote>
<p><strong>文法</strong>实在<strong>形式上</strong>对句子结构的定义与描述，而未涉及<strong>语义</strong>问题</p>
<p><strong>4.语法树</strong></p>
<p>一般用语法树来描述一个句子的语法结构。</p>
<h4 id="四、文法和语言的形式定义"><a href="#四、文法和语言的形式定义" class="headerlink" title="四、文法和语言的形式定义"></a>四、文法和语言的形式定义</h4><h5 id="1-文法的定义"><a href="#1-文法的定义" class="headerlink" title="1.文法的定义"></a>1.文法的定义</h5><p><strong>定义1:</strong>  文法 G =（V<sub>N</sub>，V<sub>T</sub>，P，Z）</p>
<p>​            V<sub>N</sub> ：    非终结符号集<br>​            V<sub>T</sub> ：     终结符号集<br>​            P：        产生式或规则的集合<br>​            Z：        开始符号（识别符号）  Z∈VN</p>
<blockquote>
<ul>
<li>产生式：产生式是一个有序对(U, x), 通常写为:</li>
</ul>
<p>​       <code>U ::= x</code> 或<code>U ➡ x</code>；   <code>|U| = 1  |x| &gt;= 0</code></p>
<ul>
<li><p>非终结符号：出现在产生式的左部,且能推出符号或符号串的那些符号。其全体构成非终结符号集，记为V<sub>N</sub> </p>
</li>
<li><p>终结符号：不出现在产生式的左部,且不能推出符号或符号串的那些符号。其全体构成终结符号集，记为V<sub>T</sub> </p>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">无符号整数的文法:</span><br><span class="line">G[<span class="xml"><span class="tag">&lt;<span class="name">无符号整数</span>&gt;</span>]=（VN，VT，P，Z）</span></span><br><span class="line"><span class="xml">	VN＝&#123;<span class="tag">&lt;<span class="name">无符号整数</span>&gt;</span>, <span class="tag">&lt;<span class="name">数字串</span>&gt;</span>, <span class="tag">&lt;<span class="name">数字</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">	VT  = &#123;0,1,2,3,4,5,6,7,8,9&#125;</span></span><br><span class="line"><span class="xml">	P = &#123;<span class="tag">&lt;<span class="name">无符号整数</span>&gt;</span> → <span class="tag">&lt;<span class="name">数字串</span>&gt;</span> ;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">数字串</span>&gt;</span> → <span class="tag">&lt;<span class="name">数字串</span>&gt;</span> <span class="tag">&lt;<span class="name">数字</span>&gt;</span> ;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">数字串</span>&gt;</span> → <span class="tag">&lt;<span class="name">数字</span>&gt;</span> ;</span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;<span class="name">数字</span>&gt;</span> →0;    <span class="tag">&lt;<span class="name">数字</span>&gt;</span> →2; 	<span class="tag">&lt;<span class="name">数字</span>&gt;</span> →3;	<span class="tag">&lt;<span class="name">数字</span>&gt;</span> →4;	</span></span><br><span class="line"><span class="xml">    	<span class="tag">&lt;<span class="name">数字</span>&gt;</span> →5;    <span class="tag">&lt;<span class="name">数字</span>&gt;</span> →6;	<span class="tag">&lt;<span class="name">数字</span>&gt;</span> →7;	<span class="tag">&lt;<span class="name">数字</span>&gt;</span> →8;    <span class="tag">&lt;<span class="name">数字</span>&gt;</span> →9; &#125;</span></span><br><span class="line"><span class="xml">	Z = <span class="tag">&lt;<span class="name">无符号整数</span>&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>注：产生式左边符合构成集合V<sub>N</sub>，且Z ∈ V<sub>N</sub></p>
<p>​        有些产生式有相同的左部，可以合在一起</p>
<p>​        给定一个文法，实际上只需给出产生式的集合，并指定识别符号（开始符号）</p>
<h5 id="2-推导与归约"><a href="#2-推导与归约" class="headerlink" title="2.推导与归约"></a>2.推导与归约</h5><p><strong>定义2：</strong>直接推导：</p>
<p>有文法G：<code>v = xUy</code>，<code>w = xuy</code>，其中x、y∈V*，U∈V<sub>N</sub>，u∈V*，</p>
<p>若U ::= u∈P，则v &rArr; w，</p>
<p>若 x = y = ε ， 有 U ::= u， 则U &rArr; u</p>
<p>x和y是符号串，若使用一次产生式可以从x变换出y，则称x直接推导出y(或者说y是x的直接推导），记为x&rArr;y。</p>
<p><strong>定义3：</strong> <code>+</code>推导：x和y是符号串，若使用若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x  =<sup>+</sup>=&rArr;y。</p>
<p>即，若有直接推导序列：x=U0==&gt;U1==&gt;U2==&gt;……==&gt;Un=y,则 x=<sup>+</sup>=&gt;y 。</p>
<p> <strong>定义4：</strong><code>*</code>推导：x和y是符号串，若使用0次或若干次产生式可以从x变换出y，则称x<em>推导出y(或者说y是x的</em>推导），记为x=<sup>*</sup>=&gt;y。</p>
<p>如：N=<sup>*</sup>=&gt;N， N=<sup>*</sup>=&gt;109</p>
<p><strong>定义5：</strong>最右推导&amp;最左推导</p>
<ul>
<li><p><strong>最右推导</strong>：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最右非终结符进行替换，称为最右推导。</p>
</li>
<li><p><strong>最左推导</strong>：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最左非终结符进行替换，称为最左推导。</p>
</li>
</ul>
<p><strong>！！！规范推导＝最右推导</strong></p>
<p><strong>定义6：</strong>推导的逆过程为归约</p>
<p>x==&gt;y，可称为x直接推导出y，也可称为y直接归约出x</p>
<h5 id="3-语言的形式定义"><a href="#3-语言的形式定义" class="headerlink" title="3.语言的形式定义"></a>3.语言的形式定义</h5><p><strong>定义7：</strong>文法G[Z]</p>
<p>​            （1）<strong>句型</strong>：x是句型 &hArr; Z =<sup>*</sup>=&gt;x,且 x∈V<sup>*</sup>；</p>
<p>​            （2）<strong>句子</strong>：x是句子 &hArr; Z =<sup>+</sup>=&gt; x, 且 x∈V<sub>T</sub><sup>*</sup>；</p>
<p>​            （3）<strong>语言</strong>：L（G[Z]）={x| Z=<sup>+</sup>=&gt;x， x∈V<sub>T</sub><sup>*</sup> }；（文法G[z]产生的所有句子的集合）</p>
<p><strong>定义8：</strong>G和G’是两个不同的文法，若L(G) = L(G’)，则G和G’为<strong>等价文法</strong></p>
<p>编译感兴趣的问题如下</p>
<p>给定终极符x，文法G，求x ∈ L(G)？</p>
<p><img src="/2019/09/04/Compiler/2.jpg" alt="编译感兴趣的问题"></p>
<p><strong>4.文法分类</strong></p>
<ul>
<li>形式语言：用文法和自动机所描述的没有语义的语言</li>
</ul>
<p>语言定义： L(G[Z]) = { x | Z=<sup>+</sup>=&gt;x，x∈V<sub>T</sub><sup>*</sup> }</p>
<p>文法定义：乔姆斯基将所有文法定义为一个<strong>四元组</strong>：G = （V<sub>N</sub>，V<sub>T</sub>，P，Z）</p>
<blockquote>
<p>V<sub>N</sub> ：    非终结符号集<br>V<sub>T</sub> ：     终结符号集<br>P：        产生式或规则的集合<br>Z：        开始符号（识别符号）  Z∈VN</p>
</blockquote>
<p>文法和语言的分类：0型、1型、2型、3型</p>
<p><strong>定义9：</strong> 0型文法</p>
<blockquote>
<p>P： u  &rarr; v ，其中 u ∈ V<sup>+</sup>，v ∈ V<sup>*</sup></p>
<p>0型文法称为<strong>短语结构文法</strong>。产生式的左部和右部都可以是符号串，一个短语可以产生另一个短语。</p>
<p>0型语言：L0，这种语言可以用<strong>图灵机（Turing）</strong>接受</p>
</blockquote>
<p><strong>定义10：</strong>1型文法</p>
<blockquote>
<p>P： xUy &rarr; xuy ，其中 U ∈V<sub>N</sub>，x、y、u ∈ V<sup>*</sup></p>
<p>1型文法称为<strong>上下文有关</strong>或上下文敏感。即只有在x、y这样的上下文中才能将U改写为u</p>
<p>1型语言：L1，这种语言可以有一种<strong>线性界限自动机</strong>接受</p>
</blockquote>
<p><strong>定义11：</strong>2型文法</p>
<blockquote>
<p>P： U &rarr; u ，其中 U ∈ V<sub>N</sub> ，u ∈ V<sup>*</sup></p>
<p>2型文法称为<strong>上下文无关文法</strong>。即把U改写为u时，不必考虑上下文。</p>
<p>注意：2型文法与BNF表示相等价。</p>
<p>2型语言：L2，这种语言可以由<strong>下推自动机</strong>接受</p>
</blockquote>
<p><strong>定义12：</strong>3型文法</p>
<blockquote>
<p>（左线型） P： U &rarr; T | U &rarr; wT ，其中 U、w ∈ V<sub>N</sub> ，T ∈ V<sub>T</sub> </p>
<p>（右线性）P： U &rarr; T | U &rarr; Tw ，其中 U、w ∈ V<sub>N</sub> ，T ∈ V<sub>T</sub> </p>
<p>3型文法称为<strong>正则文法</strong>。它是对2型文法进行进一步的限制</p>
<p>3型语言：L3，又称正则语言、正则集合，这种语言可以由<strong>有穷自动机</strong>接受</p>
</blockquote>
<p>由上易知， L0 &sup; L1 &sup; L2 &sup; L3</p>
<p>0型文法可以产生L0、L1、L2、L3，但2型文法只能产生L2，不能产生L1</p>
<h5 id="5-语法树与二义性文法"><a href="#5-语法树与二义性文法" class="headerlink" title="5.语法树与二义性文法"></a>5.语法树与二义性文法</h5><p>1.推导与语法树</p>
<p>语法树：句子结构的图示表示法，通常表示称一棵倒立的树，即</p>
<blockquote>
<p>结点：        符号</p>
<p>根节点：    识别符号</p>
<p>中间节点：非终结符</p>
<p>叶节点：    终结符<del>或非终结符</del></p>
<p>边：表示节点间的派生关系</p>
</blockquote>
<p>句型的推导及语法树的生成（自顶向下）</p>
<p>给定G[Z]，句型w：可建立推导序列，Z =<sup>*</sup>=&gt; w；可建立语法树，以Z为树根节点，每步推导生成语法树的一枝，最终可生成句型的语法树。</p>
<p>语法树的生成规律不同，但最终生成的语法树形状完全相同</p>
<p>一般推导</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">	A[&lt;无符号整数&gt;] --&gt; B[&lt;数字串&gt;]</span><br><span class="line">	B --&gt; C[&lt;数字串&gt;]</span><br><span class="line">	B --&gt; D[&lt;数字&gt;]</span><br><span class="line">	C --&gt; E[&lt;数字&gt;]</span><br><span class="line">	E --&gt; F[1]</span><br><span class="line">	D --&gt; G[0]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/04/Compiler/8.jpg" alt></p>
<p>树与推导：句型推导过程 &hArr; 句型语法树的生长过程</p>
<p>①由推导构造语法树</p>
<p>从<strong>识别符号</strong>开始，<strong>自左向右</strong>建立<strong>推导</strong>序列 &rArr; 由<strong>根节点</strong>开始，<strong>自上而下</strong>建立<strong>语法树</strong></p>
<p>②由语法树构造推导</p>
<p><strong>自叶而根</strong>修剪子树的末端节点，直至把整棵树剪掉（留根），每剪一次对应一次归约 &rArr; 从句型开始，<strong>自右向左</strong>地逐步进行<strong>归约</strong>，建立推导序列</p>
<p>2.文法的二义性</p>
<p><strong>定义：</strong>若对于一个文法的某一句子存在两棵不同的语法树，则该文法是<strong>二义性文法</strong>，否则是无二义性文法</p>
<p>换而言之，无二义性文法的句子<strong>只有一棵语法树</strong>，尽管推导过程可以不同</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如二义性文法: G[<span class="keyword">E</span>]:	<span class="keyword">E</span> := <span class="keyword">E</span>+<span class="keyword">E</span> | <span class="keyword">E</span>*<span class="keyword">E</span> | (<span class="keyword">E</span>) | i</span><br><span class="line">					Vn = &#123;E&#125;</span><br><span class="line">					VT = &#123;+,*,(,),i&#125;</span><br><span class="line"></span><br><span class="line">针对 i+i*i 有两种不同的语法树</span><br></pre></td></tr></table></figure>
<p><strong>定义：</strong>若一个文法的某句子存在两个不同的<strong>规范推导（最右推导）</strong>，则该文法是<strong>二义性</strong>的，否则是无二义性的</p>
<blockquote>
<p>若文法是二义性的，则在编译时就会产生不确定性，遗憾的是在理论上已经证明：文法的二义性是不可判定的，即不可能构造出一个算法，通过有限步骤来判定任一文法是否有二义性</p>
<p>现在的解决办法是：提出一些限制条件，称为无二义性的充分条件，当文法满足这些条件时，就可以判定文法是无二义性的。</p>
<p>由于无二义性文法比较简单，我们也可以采用另一种解决办法：即不改变二义性文法，而是确定一种编译算法，使该算法满足无二义性充分条件。</p>
</blockquote>
<p>句柄：句型的句柄是和某产生式右部匹配的子串。句柄是直接短语，即某产生式的右部，具有最左性</p>
<p>若句柄不存在重复，就说明文法无二义性</p>
<p>如 S &rarr; ABC ，ABC为该句子的句柄</p>
<h2 id="三、词法分析"><a href="#三、词法分析" class="headerlink" title="三、词法分析"></a>三、词法分析</h2><ul>
<li>词法分析 （Lexical Analysis） </li>
</ul>
<p>实现词法分析器的程序称为词法分析程序（扫描器）</p>
<p>词法分析程序的<strong>主要任务</strong>：对构成源程序的字符串<strong>从左到右的扫描</strong>，<strong>逐个字符地</strong>读入源程序字符并按照构词规则切分成一个一个具有独立意义的单词。并确定其属性（如保留字、标识符、运算符、界限符和常量等）。再把它们转换成长度统一的标准形式——属性字（TOKEN）。</p>
<p>词法分析是编译过程中的第一个阶段，在语法分析前进行。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A[源程序] --&gt; B[词法分析程序]</span><br><span class="line">	B -- Token --&gt; C[语法分析程序]</span><br><span class="line">	C -- get token --&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/04/Compiler/9.jpg" alt></p>
<blockquote>
<p>为什么将词法分析工作从语法分析工作中独立出来？</p>
<ul>
<li><p>简化设计</p>
</li>
<li><p>改进编译效率</p>
</li>
<li><p>增加编译系统的可移植性</p>
</li>
</ul>
</blockquote>
<h3 id="3-1-词法分析器的要求"><a href="#3-1-词法分析器的要求" class="headerlink" title="3.1 词法分析器的要求"></a>3.1 词法分析器的要求</h3><ul>
<li><strong>功能：输入源程序，输出单词符号</strong></li>
</ul>
<p><strong>单词符号是一个程序语言的基本语法符号</strong></p>
<ul>
<li><strong>单词的分类</strong>：</li>
</ul>
<blockquote>
<p>1.<strong>关键字：</strong>由程序语言定义的具有固定意义的标识符。也称为保留字或基本字</p>
<p>2.<strong>标识符：</strong>用来表示程序中各种名字的字符串。</p>
<p>3.<strong>常    数：</strong>常数的类型一般有整型、实型、布尔型、文字型。</p>
<p>4.<strong>运算符：</strong>如+、－ 、*、/ 等。</p>
<p>5.<strong>界限符：</strong>如逗号、分号、括号等。</p>
</blockquote>
<p><strong>一个程序语言的关键字、运算符、界限符都是固定的，即数量有限及意义明确；而对于标识符和常数通常是不确定的。</strong></p>
<p>词法分析器所输出的单词符号常常表示为二元式：（单词种别，单词符号的属性值）</p>
<p>单词种别一般将①标识符归为一种，②常数按类型分种（整数实数布尔），③关键字全体视为一种，或者一个一种，④运算符可采用一符一种，⑤界符一般也用一符一种。</p>
<p>如果一个种别只含一个单词符号，那么对于这个单词符号，种别编码可完全代表其自身。若一个种别有多个单词符号，那么，对于每个单词符号，除了给出种别编码外，还应给出有关的单词符号的属性信息。</p>
<p><strong>单词符号的属性</strong>是指单词符号的特性或特征。属性值是反应特性或特征的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&gt;=j)i++;<span class="comment">//以该语句为示例</span></span><br><span class="line"><span class="comment">//该句的单词符号序列如下:</span></span><br><span class="line">&lt;<span class="keyword">while</span>, -&gt;</span><br><span class="line">&lt;(, -&gt;</span><br><span class="line">&lt;id, point(i)&gt;<span class="comment">//存放指向i的指针</span></span><br><span class="line">&lt;&gt;=, -&gt;</span><br><span class="line">&lt;id, point(j)&gt;<span class="comment">//存放指向j的指针</span></span><br><span class="line">&lt;), -&gt;</span><br><span class="line">&lt;id, point(i)&gt;</span><br><span class="line">&lt;--, -&gt;</span><br><span class="line">&lt;;, -&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-词法分析器的设计"><a href="#3-2-词法分析器的设计" class="headerlink" title="3.2 词法分析器的设计"></a>3.2 词法分析器的设计</h3><h4 id="Ⅰ、输入、预处理"><a href="#Ⅰ、输入、预处理" class="headerlink" title="Ⅰ、输入、预处理"></a>Ⅰ、输入、预处理</h4><p>词法分析器工作的第一步是输入源程序文本。输入串一般是放在一个<strong>缓冲区</strong>中，这个缓冲区称<strong>输入缓冲区</strong>。词法分析的工作（单词符号的识别）可以直接在这个缓冲区中进行。但在许多情况下，把输入串<strong>预处理</strong>一下，对单词符号的识别工作将是比较方便的。</p>
<h5 id="预处理的主要工作"><a href="#预处理的主要工作" class="headerlink" title="预处理的主要工作"></a>预处理的主要工作</h5><ul>
<li>某些跳格符、回车符和换行符等编辑性字符，在别处的任何出现都没有意义，预处理时可以将其剔掉</li>
<li>注解部分——仅在于改善程序的易读性和易理解性。对于它们，预处理时可以将其剔掉</li>
<li>空白符（一个或相继数个）用作单词符号之间的间隔，即用作界符。在这种情况下，预处理时可把相继的若干个空白结合成一个。</li>
</ul>
<h4 id="Ⅱ、单词符号的识别：超前搜索"><a href="#Ⅱ、单词符号的识别：超前搜索" class="headerlink" title="Ⅱ、单词符号的识别：超前搜索"></a>Ⅱ、单词符号的识别：超前搜索</h4><p><img src="/2019/09/04/Compiler/3.jpg" alt="词法分析器的结构"></p>
<p>上图为词法分析器结构，当词法分析器调用预处理子程序处理出一串输入字符放进扫描缓冲区之后，分析器就从此缓冲区种逐一识别单词符号。当缓冲区里的字符串被处理完之后，它又调用预处理程序装入新串。</p>
<blockquote>
<p>超前搜索的原因</p>
<ul>
<li>在程序中有一些单词的识别经常需要多读入一些字符才能知道哪些字符组成一个单词</li>
</ul>
</blockquote>
<h4 id="Ⅲ、状态转换图"><a href="#Ⅲ、状态转换图" class="headerlink" title="Ⅲ、状态转换图"></a>Ⅲ、状态转换图</h4><p>状态转换图是一张有限方向图，是设计词法分析器的有效工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	0--字母--&gt;1</span><br><span class="line">	1--字母或数字--&gt;1</span><br><span class="line">	1--其他--&gt;2[*]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/04/Compiler/10.jpg" alt></p>
<p>一个状态转换图可用于识别（或接受）一定的字符串</p>
<h3 id="3-3-正规表达式与有限自动机"><a href="#3-3-正规表达式与有限自动机" class="headerlink" title="3.3 正规表达式与有限自动机"></a>3.3 正规表达式与有限自动机</h3><h4 id="1-正规式与正规集"><a href="#1-正规式与正规集" class="headerlink" title="1.正规式与正规集"></a>1.正规式与正规集</h4><p>正规式也称正则表达式（regular expression），是说明单词的模式（pattern）的一种重要的表示法，是定义正规集的数学工具</p>
<h5 id="正规式及其所表示的正规集的定义："><a href="#正规式及其所表示的正规集的定义：" class="headerlink" title="正规式及其所表示的正规集的定义："></a><strong>正规式及其所表示的正规集的定义：</strong></h5><p>设字母表为∑，辅助字母表∑‘ = { φ，ε， |，&bull;，*，（，）}，</p>
<p>① ε 和 φ 都是 ∑ 上的正规式，他们所表示的正规集分别为 { ε }和 { } ；</p>
<p>② 对任何 a ∈ ∑ ，a 是 ∑ 上的一个正规式，他所表示的正规集为 { a } ；</p>
<p>③ 假定 e<sub>1</sub> 和 e<sub>2</sub> 都是 ∑ 上的正规式他们所表示的正规集分别为 L(e<sub>1</sub>) 和 L(e<sub>2</sub>)，那么，( e<sub>1</sub> ) ，         e<sub>1</sub> | e<sub>2</sub>  ， e<sub>1</sub> &bull; e<sub>2</sub>   ， e<sub>1</sub><sup><em></em></sup> 也都是正规式，他们所表示的正规集分别为 L( e<sub>1</sub> )， L( e<sub>1</sub> ) &cup; L( e<sub>2</sub> )，    L( e<sub>1</sub> ) L( e<sub>2</sub> )  和  ( L( e<sub>1</sub> ) )<sup>\</sup> ；</p>
<p>④仅由有限次使用上述三步骤而定义的表达式才是 ∑ 上的正规式，仅有这些正规式所表示的集合才是 ∑ 上的正规集。</p>
<ul>
<li>注意，| 、 &bull; 、* 、均为正规式的运算符</li>
</ul>
<blockquote>
<p>| 表示或</p>
<p>&bull; 表示连接</p>
<p>* 表示闭包，即任意有限次的自重复连接</p>
<p>在不混淆的情况下，括号可以省去，但规定算符的优先顺序为 *， &bull; ，|。连接符 &bull; 一般可省略不写，三个算符均为左结合的。</p>
</blockquote>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">例:</span></span><br><span class="line"><span class="comment">a						&#123;a&#125;</span></span><br><span class="line"><span class="comment">a|b			</span> <span class="comment">			&#123;a</span><span class="string">,</span><span class="comment">b&#125;</span></span><br><span class="line"><span class="comment">ab						&#123;ab&#125;</span></span><br><span class="line"><span class="comment">(a|b)(a|b)	</span>            <span class="comment">&#123;aa</span><span class="string">,</span><span class="comment">ab</span><span class="string">,</span><span class="comment">ba</span><span class="string">,</span><span class="comment">bb&#125;</span></span><br><span class="line"><span class="comment">a*	</span>            <span class="comment">		&#123;ε</span><span class="string">,</span><span class="comment">a</span><span class="string">,</span><span class="comment">a</span><span class="string">,</span><span class="comment">……</span><span class="string">,</span><span class="comment">任意个a的串&#125;</span></span><br><span class="line"><span class="comment">(a|b)*					&#123;ε</span><span class="string">,</span><span class="comment">a</span><span class="string">,</span><span class="comment">b</span><span class="string">,</span><span class="comment">aa</span><span class="string">,</span><span class="comment">ab</span><span class="string">,</span><span class="comment">bb</span><span class="string">,</span><span class="comment">……</span><span class="string">,</span><span class="comment">所有由a和b组成的串&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结论：程序设计语言的单词都能用正规式来定义</li>
</ul>
<p>正规式的等价性：若两个正规式 e<sub>1</sub> 和 e<sub>2</sub> 所表示的正规集相同，则说 e<sub>1</sub> 和 e<sub>2</sub> 等价，写作 e<sub>1</sub> = e<sub>2</sub> 。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line">e<span class="number">1</span> = <span class="comment">(a|b)</span> , e<span class="number">2</span> = <span class="comment">(b|a)</span> ,e<span class="number">1</span> == e<span class="number">2</span></span><br><span class="line">e<span class="number">1</span> = b<span class="comment">(ab)</span>* , e<span class="number">2</span> = <span class="comment">(ba)</span>*b , e<span class="number">1</span> == e<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>正规式服从的规律有：</p>
<ul>
<li>或服从交换律：U|V = V|U</li>
<li>或的可结合律：U|(V|W) = (U|V)|W</li>
<li>连接的可结合律：(UV)W = U(VW)</li>
<li>分配律：U(V|W) = UV | UW，(V|W)U = VU | WU</li>
<li>ε是连接的恒等律：εU = U，Uε = U</li>
<li>素零一律：U|U = U</li>
<li>或的抽取律： U* = ε|U|UU|…</li>
</ul>
<h4 id="2-确定有限自动机"><a href="#2-确定有限自动机" class="headerlink" title="2.确定有限自动机"></a>2.确定有限自动机</h4><p>确定有限自动机（有穷自动机）作为一种识别装置，能准确地识别正规集，即识别正规文法所定义的语言和正规式所表示的集合，引入有穷自动机这个理论，正是为词法分析程序的自动构造寻找特殊的方法和工具</p>
<p>有穷自动机分两类：确定的有限自动机（deterministic Finite Automata）和不确定的有限自动机（Nondeterministic Finite Automata）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	RE(RE)</span><br><span class="line">	RE --&gt; NFA(NFA)</span><br><span class="line">	NFA --&gt; DFA(DFA)</span><br><span class="line">	DFA --&gt; minDFA(minDFA)</span><br></pre></td></tr></table></figure>
<h5 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h5><p>DFA定义：一个确定的有穷自动机（DFA）M是一个五元组： M = （ S ，∑ ，δ  ，s<sub>0</sub> ，F ）</p>
<blockquote>
<p>其中：</p>
<ul>
<li>S 是一个有穷集，他的每个元素称为一个状态；</li>
<li>Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表</li>
<li>δ 是转换函数，实在 S × Σ &rarr; S 上的单值部分映射，即，如果 δ（s，a）= s‘ ，                     (s ∈ S，s’ ∈ S ) 就意味着，当前状态为s，输入符为a时，将转换至下一个状态s’，s’称作s的一个后继状态</li>
<li>s<sub>0</sub> ∈ S 是唯一的一个初态</li>
<li>F &sub; S 是一个终态集（可空），终态也称可接受状态或结束状态</li>
</ul>
</blockquote>
<p>DFA可以用一个矩阵表示，该矩阵的行表示状态，列表示输入字符，即s行a列的矩阵元素表示  δ（s，a）的值。这个矩阵称为<strong>状态转换矩阵</strong>。</p>
<p>一个DFA也可以表示为一张确定的状态转换图</p>
<blockquote>
<p>假定DFA M含有 m个状态和 n个输入字符，那么，这个图含有m个状态结点，每个结点顶多有n条箭弧射出和别的结点相连接，每条箭弧用Σ中的一个不同输入字符作标记，整张图含有唯一的一个初态结点和若干个（可以是0个）终态结点。</p>
<p>一般来说，初态节点旁边标以 &rArr; ；终态节点用双圈表示。</p>
</blockquote>
<p>例如：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>+S</td>
<td>U</td>
<td>V</td>
</tr>
<tr>
<td>U</td>
<td>Q</td>
<td>V</td>
</tr>
<tr>
<td>V</td>
<td>U</td>
<td>Q</td>
</tr>
<tr>
<td>-Q</td>
<td>Q</td>
<td>Q</td>
</tr>
</tbody>
</table>
<p>如上表，可表示<code>(a|b)*</code>，也可画成如下图</p>
<p><img src="/2019/09/04/Compiler/4.jpg" alt></p>
<p><strong>DFA的确定性</strong></p>
<p>1.映射δ ： S × Σ &rarr; S 是一个单值函数。也就是说，对任何状态s∈S和输入符号 a ∈ Σ ，f（s，a）唯一地确定了下一状态。从转换图的角度来看，假定字母表 Σ 含有n个输入字符，那么，任何一个状态结最多只有n条弧射出，而且每条弧以一个不同的输入字符标记。 </p>
<h5 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h5><p>NFA的定义：一个非确定的有穷自动机（NFA）M是一个五元组：M = （ S ，∑ ，δ  ，S<sub>0</sub> ，F ）</p>
<blockquote>
<p>其中：</p>
<ul>
<li>S 是一个有穷集，他的每个元素称为一个状态；</li>
<li>Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表</li>
<li>δ 是转换函数，实在 S × Σ<sup>*</sup>  &rarr; S 上的单值部分映射，即， δ： S × Σ<sup>*</sup> &rarr; 2<sup>S</sup> 表明在某状态下对于某输入符号可能有多个后继状态</li>
<li>S<sub>0</sub>  &sub; S 是一个非空初态集</li>
<li>F &sub; S 是一个终态集（可空），终态也称可接受状态或结束状态</li>
</ul>
</blockquote>
<p><img src="/2019/09/04/Compiler/5.jpg" alt></p>
<p>如图，为一个NFA</p>
<p>∑<sup>*</sup> 上的符号串 t 被 NFA M 接受也可以这样理解：</p>
<p>对于Σ*中的任何一个串t，若存在一条从某一初态结到某一终态结的道路，且这条道路上所有弧的标记字依序连接成的串(不理采那些标记为ε的弧)等于t，则称t可为NFA M所识别(读出或接受)。若M的某些结既是初态结又是终态结，或者存在一条从某个初态结到某个终态结的道路,其上所有弧的标记均为ε，那么空字可为M所接受。</p>
<p>NFA M所能接受的符号串的全体记为L(M) </p>
<p><strong>结论：</strong> Σ 上一个符号串集 V &sub; Σ<sup>*</sup> 是正规的，当且仅当存在一个 Σ 上的不确定的有穷自动机M，是的 V = L(M)</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NFA构造方法:</span><br><span class="line"></span><br><span class="line">Σ上的字母a是正规式,构造等价的NFA为</span><br><span class="line">	一个初态,一个终态,中间标记ε弧</span><br><span class="line"></span><br><span class="line">正规式<span class="keyword">A</span>和B连接是正规式,构造等价NFA为</span><br><span class="line">	初态是<span class="keyword">A</span>的初态,终态是B的终态,从<span class="keyword">A</span>的终态到B的初态标记为ε弧</span><br><span class="line"></span><br><span class="line"><span class="keyword">A</span>|B是正规式,构造等价的NFA为</span><br><span class="line">	构造新的初态和终态,从初态引ε到<span class="keyword">A</span>和B的初态,从到<span class="keyword">A</span>到B的终态引ε到终态</span><br><span class="line"></span><br><span class="line"><span class="keyword">A</span>*是正规式,构造的等价NFA为</span><br><span class="line">	构造新的初态和终态，从初态引ε到终态和<span class="keyword">A</span>的初态,从<span class="keyword">A</span>的终态引ε到终态和<span class="keyword">A</span>的初态</span><br></pre></td></tr></table></figure>
<h5 id="NFA和DFA的等价性"><a href="#NFA和DFA的等价性" class="headerlink" title="NFA和DFA的等价性"></a>NFA和DFA的等价性</h5><ul>
<li>DFA是NFA的特例</li>
</ul>
<p>对于每个NFA M，存在一个DFA M’ ，使得L( M ) =L( M’ )。对每个NFA M存在着与之等价的DFA M’。即：对于任何两个有穷自动机M和M’，如果L( M )=L( M’ )，则称M与M’是等价的。</p>
<p>有一种算法，将NFA转换成接受同样语言的DFA。这种算法称为<strong>子集法</strong>。</p>
<p>与某一NFA等价的DFA不唯一</p>
<p>从NFA的矩阵表示中，表项通常是一状态的集合，而在DFA的矩阵表示中，表项是一个状态，NFA到相应的DFA的构造的基本思路是： </p>
<ul>
<li><strong>DFA的每一个状态对应NFA的一组状态。</strong></li>
</ul>
<p>DFA使用他的状态去记录在NFA读入的一个输入符号后可能达到的所有状态。</p>
<h5 id="NFA确定化算法（-NFA-rarr-DFA-的转换）"><a href="#NFA确定化算法（-NFA-rarr-DFA-的转换）" class="headerlink" title="NFA确定化算法（ NFA &rarr; DFA  的转换）"></a>NFA确定化算法（ NFA &rarr; DFA  的转换）</h5><p>假设NFA N = （ K， Σ ， f ，K<sub>0</sub>，K<sub>t</sub> ）按如下办法构造一个DFA M=（ S， å，δ，S<sub>0</sub> ，S<sub>t</sub>），使得L(M) = L(N) ：</p>
<ol>
<li><p>M的状态集 S 由 <strong>K 的一些子集</strong>组成。用 [ S<sub>1</sub> ，S<sub>2</sub> ，…，S<sub>j</sub> ] 表示 S 的元素，其中 S<sub>1</sub> ，S<sub>2</sub> ，…，S<sub>j</sub> 是K的状态。并约定， 状态 S<sub>1</sub> ，S<sub>2</sub> ，…，S<sub>j</sub>  是按某种规则排列的，即对于子集{S<sub>1</sub> ，S<sub>2</sub> } = {S<sub>2</sub> ，S<sub>1</sub> }来说，S的状态就是 [S<sub>1</sub> ，S<sub>2 </sub>]</p>
</li>
<li><p>M和N的输入字母表是相同的，即 Σ</p>
</li>
<li>转换函数是这样定义的： δ（ [ S<sub>1</sub> ，S<sub>2</sub> ，…，S<sub>j</sub> ] ，a ） = [ R<sub>1</sub> ，R<sub>2</sub> ，…，R<sub>t</sub> ]  ，其中                      { R<sub>1</sub> ，R<sub>2</sub> ，…，R<sub>t</sub>  } = ε-closure（ move（{S<sub>1</sub> ，S<sub>2</sub> ，…，S<sub>j</sub> } ， a） ）</li>
<li>S<sub>0</sub>  = ε-closure（ K<sub>0</sub> ）为 M 的开始状态</li>
<li>S<sub>t</sub> = {S<sub>i</sub> ，S<sub>k</sub> ，…，S<sub>e</sub> }， 其中  [ S<sub>i</sub> ，S<sub>k</sub> ，…，S<sub>e</sub> ]  ∈ S 且 {S<sub>i</sub> ，S<sub>k</sub> ，…，S<sub>e</sub> } &cap; K<sub>t</sub>  &ne;  &phi; </li>
</ol>
<blockquote>
<ul>
<li><p><strong>状态集合 I 的 ε-闭包</strong>，表示为ε-closure( I )，定义为一状态集，是状态集I中的任何状态S经任意条ε弧而能到达的状态的集合。</p>
<p>状态集合I的任何状态S都属于ε-closure(I)</p>
</li>
<li><p><strong>状态集合 I 的 &alpha; 弧转换</strong>，定义状态集合 J 表示为 J = move(I,a) ，其中J是所有那些可从I中的某一状态经过一条a弧而到达的状态的全体。</p>
<p>I<sub>a</sub>  =  ε-closure( J )  =  ε-closure( move( I , a )  )</p>
</li>
</ul>
</blockquote>
<p><img src="/2019/09/04/Compiler/5.jpg" alt></p>
<p>如之前NFA的例子：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I=&#123;<span class="number">1</span>&#125;,  ε-closure(I) = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;；</span><br><span class="line">I=&#123;<span class="number">5</span>&#125;,  ε-closure(I) = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>&#125;；</span><br><span class="line">move( &#123;<span class="number">1</span>,<span class="number">2</span>&#125; , a ) = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">ε-closure(&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;；</span><br></pre></td></tr></table></figure>
<p>构造NFA N的<strong>状态K的子集</strong>的算法：</p>
<p>​        假定所构造的子集族为C，即 C = （T<sub>1</sub> ，T<sub>2</sub> ，… ， T<sub>I</sub> ），其中 T<sub>1</sub> ，T<sub>2</sub> ，… ， T<sub>I</sub>  为状态K的子集。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>开始，令ε-closure<span class="comment">(K0)</span>为C中的唯一成员，并且他是未被标记的</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">while</span><span class="comment">( C中尚未被标记的子集T )</span><span class="keyword">do</span>&#123;</span><br><span class="line">	标记T;</span><br><span class="line">	for 每个输入字母a <span class="keyword">do</span>&#123;</span><br><span class="line">		U := ε-closure<span class="comment">( move(T, a)</span> );</span><br><span class="line">		<span class="keyword">if</span> U 不在 C 中:</span><br><span class="line">			将U作为未标记的子集Ti加在C中;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<p><img src="/2019/09/04/Compiler/6.jpg" alt></p>
<p>如上图为实例NFA，构造其状态转换表</p>
<table>
<thead>
<tr>
<th style="text-align:center">I</th>
<th style="text-align:center">I<sub>a</sub></th>
<th style="text-align:center">I<sub>b</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">{i，1，2}</td>
<td style="text-align:center">{1，2，3}</td>
<td style="text-align:center">{1，2，4}</td>
</tr>
<tr>
<td style="text-align:center">{1，2，3}</td>
<td style="text-align:center">{1，2，3，5，6，f}</td>
<td style="text-align:center">{1，2，4}</td>
</tr>
<tr>
<td style="text-align:center">{1，2，4}</td>
<td style="text-align:center">{1，2，3}</td>
<td style="text-align:center">{1，2，4，5，6，f}</td>
</tr>
<tr>
<td style="text-align:center">{1，2，3，5，6，f}</td>
<td style="text-align:center">{1，2，3，5，6，f}</td>
<td style="text-align:center">{1，2，4，6，f}</td>
</tr>
<tr>
<td style="text-align:center">{1，2，4，5，6，f}</td>
<td style="text-align:center">{1，2，3，6，f}</td>
<td style="text-align:center">{1，2，4，5，6，f}</td>
</tr>
<tr>
<td style="text-align:center">{1，2，4，6，f}</td>
<td style="text-align:center">{1，2，3，6，f}</td>
<td style="text-align:center">{1，2，4，5，6，f}</td>
</tr>
<tr>
<td style="text-align:center">{1，2，3，6，f}</td>
<td style="text-align:center">{1，2，3，5，6，f}</td>
<td style="text-align:center">{1，2，4，6，f}</td>
</tr>
</tbody>
</table>
<p>将其每个状态确定化，即得到如下等价DFA</p>
<p><img src="/2019/09/04/Compiler/7.jpg" alt="DFA">N</p>
<p>状态转换表如下，将一组状态替换成对应符号。</p>
<table>
<thead>
<tr>
<th style="text-align:center">I</th>
<th style="text-align:center">Ia</th>
<th style="text-align:center">Ib</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">A</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">C</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">A</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">C</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">F</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">F</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">C</td>
<td style="text-align:center">E</td>
</tr>
</tbody>
</table>
<h5 id="minDFA"><a href="#minDFA" class="headerlink" title="minDFA"></a>minDFA</h5><p>说一个有穷自动机是化简了的，即是说，<strong>它没有多余状态并且它的状态中没有两个是互相等价的</strong>。一个有穷自动机可以通过<strong>消除多余状态</strong>和<strong>合并等价状态</strong>而转换成一个最小的与之等价的有穷自动机。即用一个状态代替所有与其等价的状态。</p>
<p>所谓有穷自动机的多余状态，是指这样的状态：从自动机的开始状态出发，任何输入串也不能到达的那个状态；或者从这个状态没有通路到达终态。</p>
<ul>
<li>DFA的最小化就是寻求最小状态DFA</li>
</ul>
<p><strong>最小状态DFA的含义：</strong>①没有多余状态（死状态）；②没有两个状态时互相等价的（不可区别）。</p>
<blockquote>
<p>两个状态s和t可区别：不满足</p>
<ul>
<li>兼容性：同时终态或同时非终态</li>
<li>传播性：从s出发读入某个a（a ∈ Σ ）和从t出发读入某个a到达的状态等价</li>
</ul>
<p>两个状态s和t等价：</p>
<ul>
<li>如果由 s 出发能导出的所有串的集合与 t 出发能导出的所有串的集合相等，我们称状态 s 与状态 t 是等价的。</li>
</ul>
</blockquote>
<p><img src="/2019/09/04/Compiler/7.jpg" alt></p>
<p>如上面示例的DFA，C和F是等价的。</p>
<p>C和F同是终态，读入a到达C和F，C和F同是终态，C和F读入a都到达C，读入b都到达E。</p>
<p>同理D和E也是等价的</p>
<h5 id="DFA最小化的算法：分割法（逐步分组试探法）"><a href="#DFA最小化的算法：分割法（逐步分组试探法）" class="headerlink" title="DFA最小化的算法：分割法（逐步分组试探法）"></a>DFA最小化的算法：分割法（逐步分组试探法）</h5><p>核心思想：把一个DFA的状态分成一些不相交的子集，使得任何不同的两子集的状态都是可区别的，而同一子集中的任何两个状态都是等价的。算法假定每个状态射出的弧都是完全的,否则，引入一个新状态，叫<strong>死状态</strong>，该状态是非终态，将不完全的输入弧都射向该状态，对所有输入，该状态射出的弧还回到自己。</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">设有DFA M = ( s , ∑ , f, s<span class="number">0</span> , sz ),最小状态DFA M<span class="string">'</span></span><br><span class="line"><span class="string">1.  因为不难证明，如果si是非终结状态，而sj是终结状态，那么si和sj一定互不等价(根据等价的定义可知，它们导出的符号串集不同)。所以开始可以把K中的终态和非终态分开，分成两个子集，形成一个基本划分：</span></span><br><span class="line"><span class="string">       P2＝&#123;I1,I2&#125;    (I1∪I2＝K, I1∩I2＝Φ)</span></span><br><span class="line"><span class="string">2. 若此两个子集还可以进行划分，则作进一步的划分，形成Pm ,假定到某个时候Pm已经含有m个子集，记为：Pm＝&#123;I1,I2,…,Im&#125;，设s'</span>和s<span class="string">"是Ii中的任意两个状态，如果对某个a∈Σ,存在Ij ，使  f(s',a), f(s"</span>,a)∈Ij ，则称s<span class="string">'和s"关于a是拟等价的。</span></span><br><span class="line"><span class="string">    如果存在s'</span>，s<span class="string">"∈Ii，使得对字母表Σ中的某个符号a, s'和s"</span>不为拟等价，则我们说Ii是可分的。</span><br><span class="line">    换句话说，令Ii ＝&#123;s<span class="number">1</span>，s<span class="number">2</span>, …，sn&#125; ，如果对某个a∈Σ，使得Ia i＝&#123; f(s<span class="number">1</span>,a)，f(s<span class="number">2</span>,a)，…，f(sn,a)&#125;不全落在现行Pm的某一个子集Ij之中；即Ia i这个集合中的元素分别属于I<span class="number">1</span>，I<span class="number">2</span>，…，Im中的几个不同集合，则Ii可分为几个集合（至少可一分为二）。 </span><br><span class="line"><span class="number">3</span>．转<span class="number">2</span>,上述过程务必一再重复，直到<span class="keyword">P</span>中的每个集合均是不可再分时为止。</span><br><span class="line">此时，<span class="keyword">P</span>所含的集合数不再增加，即<span class="keyword">P</span>中的每个集合中的状态互相等价，而不同集合间的状态互不等价。</span><br><span class="line"><span class="number">4</span>.为<span class="keyword">P</span>中的每一组选一代表，这些代表构成M<span class="string">'的状态。把原来导入非代表状态的弧均导入其代表即可，即若s'</span>是一代表且f(s<span class="string">',a)=t,令r是t组的代表，则M'</span>中有一转换f<span class="string">'(s'</span>,a)=r，M<span class="string">'的开始状态是含有S0的那组的代表，M'</span>的终态是含有F的那组的代表。</span><br><span class="line"><span class="number">5</span>.去掉M<span class="string">'中的死状态。</span></span><br></pre></td></tr></table></figure>
<h5 id="正规式与有穷自动机的等价性（Re-hArr-NFA）"><a href="#正规式与有穷自动机的等价性（Re-hArr-NFA）" class="headerlink" title="正规式与有穷自动机的等价性（Re &hArr; NFA）"></a>正规式与有穷自动机的等价性（Re &hArr; NFA）</h5><p>定理：①对于 Σ 上的NFA M，可以构造一个 Σ 上的正规式R，是的L(R) = L(M)。②对于 Σ 上的任一个正规式R，可以构造一个 Σ 上 的NFA M，是的L(M) = L(R)。</p>
<p>Re &rArr; NFA：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">转换方法：我们把状态转换图的概念拓广，令每条弧可用一个正规式标记。</span></span><br><span class="line"><span class="comment">1</span><span class="string">.</span> <span class="comment">在M的状态图上加进两个结点x、y。从x结点用ε弧</span> <span class="comment">连接到M的所有初态结点，从M的所有终态结点ε弧</span> <span class="comment">连接到y结点。形成一个与M等价的M'，</span> <span class="comment">M'只有一个初态和一个终态。</span></span><br><span class="line"><span class="comment">2</span><span class="string">.</span> <span class="comment">逐步消去M'中的所有结点，直至只剩下x结点和y结点。在消结过程中，逐步用正规式来标记弧，其消结规则如下：</span></span><br><span class="line"><span class="comment">A</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">3			==</span>&gt;<span class="comment">			1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span></span><br><span class="line"><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="string">,</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2			==</span>&gt;<span class="comment">			1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1|R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span></span><br><span class="line"><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R3</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">3	==</span>&gt;<span class="comment">			1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1R2*R3</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span></span><br><span class="line"><span class="comment">最后x结点和y结点之间的弧上的标记就是所求的正规式R</span></span><br></pre></td></tr></table></figure>
<p>NFA &rArr; Re</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">方法如上反转</span></span><br><span class="line"><span class="comment">首先，对正规式R构造如下拓广转换图</span></span><br><span class="line"><span class="comment">然后通过对R进行分裂和加进新结点的办法，逐步把这个图转变为：每条弧标记为中的一个字母或ε</span> <span class="comment">，其转换规则如下:</span></span><br><span class="line"><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2				==</span>&gt;<span class="comment">			A</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">3</span></span><br><span class="line"><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1|R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2			==</span>&gt;<span class="comment">			1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="string">,</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span></span><br><span class="line"><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1R2*R3</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2			==</span>&gt;<span class="comment">			1</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R1</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R2</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">2</span><span class="literal">-</span><span class="literal">-</span><span class="comment">R3</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">3</span></span><br><span class="line"><span class="comment">在整个分裂过程中，所有新结点均采用不同的名字，保留x和y为全图的唯一初态结点和终态结点，至此我们就可以得到一个与R</span> <span class="comment">等价的NFA</span> <span class="comment">M</span></span><br></pre></td></tr></table></figure>
<h5 id="正规文法与有穷自动机的等价性"><a href="#正规文法与有穷自动机的等价性" class="headerlink" title="正规文法与有穷自动机的等价性"></a>正规文法与有穷自动机的等价性</h5><p>定理：①对于给定的正规文法G[R]，可以直接构造一个NFA M，使得L（M）=L（G）。②对于 Σ 上的任一个NFA M ，可以直接构造正规文法G[R] ，使得L（ R ）=L（ M ）。</p>
<p>把给定的正规文法G[R]转换为一个Σ上的NFA M构造规则:</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设G[<span class="keyword">R</span>]=（VN，VT，<span class="keyword">P</span>，<span class="keyword">R</span>）， NFA M=（ K，Σ，f，S，<span class="keyword">Z</span>）</span><br><span class="line"><span class="number">1</span>.令 Σ = VT;</span><br><span class="line"><span class="number">2</span>. K = VN，S = <span class="keyword">R</span>；即对G中的每个非终结符生成M的一个状态（不妨取相同的名字，G的开始符号是M的初态;</span><br><span class="line"><span class="number">3</span>.增加一个新状态<span class="keyword">Z</span>，作为NFA M 的终态，<span class="keyword">Z</span>∈K;</span><br><span class="line"><span class="number">4</span>.对G中的形如A-&gt;tB（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数     f（A，t）=B;</span><br><span class="line"><span class="number">5</span>.对G中的形如A-&gt;t（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数      f（A，t）=<span class="keyword">Z</span>;</span><br></pre></td></tr></table></figure>
<p>把给定的å上的NFA M转换为一个正规文法G[R]的构造规则:</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设NFA M=（ K，Σ，f，S，<span class="keyword">Z</span>）,G[<span class="keyword">R</span>]=（VN，VT，<span class="keyword">P</span>，<span class="keyword">R</span>）,</span><br><span class="line"><span class="number">1</span>.令 VT = Σ ;</span><br><span class="line"><span class="number">2</span>.令VN =  K即对M的每一个状态生成G中的非终结符（不妨取相同的名字，G的开始符号是M的初态;</span><br><span class="line"><span class="number">3</span>.令S=<span class="keyword">R</span>（如果M有多个初态，应先拓广自动机，引入新初态x）;</span><br><span class="line"><span class="number">4</span>.对M 的终态<span class="keyword">Z</span>增加一个产生式： <span class="keyword">Z</span>-&gt;ε;</span><br><span class="line"><span class="number">5</span>.对M的每一个转换函数f（A，t）=B可写G的一个产生式A-&gt;tB（其中t为终结符或ε;A和B为非终结符）;</span><br></pre></td></tr></table></figure>
<h5 id="词法分析程序的自动构造"><a href="#词法分析程序的自动构造" class="headerlink" title="词法分析程序的自动构造"></a>词法分析程序的自动构造</h5><p>​        若对自动机的每一个状态赋予一定的功能，并把其边上的符号视为转移条件，那么自动机就成为一个程序了。</p>
<h2 id="四、语法分析"><a href="#四、语法分析" class="headerlink" title="四、语法分析"></a>四、语法分析</h2><p><strong>语法分析的主要工作</strong>：是识别由词法分析器给出的单词序列是否是给定的正确句子（程序）</p>
<p>语法分析的常用方法：自顶向下的语法分析（Top-Down Parsing）和自底向上的语法分析（Bottom-Up Parsing）两大类</p>
<h3 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h3><p>方法：从文法的开始符号（设为 &lt;程序&gt; ）开始进行分析，逐渐推导的往下构造语法树，使其树叶正好构造所给定的源程序串</p>
<p>关键：是确定在推导过程中选择候选式的问题。当进行推导时，一个非终结符可能对应多个产生式，这样我们就无法事先知道应该用哪个产生式，因此必须对文法做一些限制，以便在任何情况下都唔那个确定应该用的产生式</p>
<p>主要思想：从开始符号出发，导出句型并一个符号一个符号地与给定终结符串进行匹配。如果全部匹配成功，则表示开始符号可推导出给定的终结符串。因此判定给定终结符号串是正确句子。</p>
<p>缺点：若在推导过程中，不对文法进行限制，那么产生式的选择成为无根据的，只好一一去尝试所有可能的产生式，直至成功为止。这种方法致命的地方是不断地回溯，大大影响速度。所以自顶向下分析法分为确定和不确定两种。我们在下面讨论确定的分析方法，这种方法简单直观，便于手工构造或自动生成语法分析器。</p>
<p>在推导过程中，对于产生式相同左部含有非终结符开始的右部时，在推到中选用哪个产生式是不能直接知道的，也就是该语法分析的缺点。</p>
<h4 id="1-首符集、后继符集、选择集（Fisrt-Follow-Select-）"><a href="#1-首符集、后继符集、选择集（Fisrt-Follow-Select-）" class="headerlink" title="1. 首符集、后继符集、选择集（Fisrt(),Follow(),Select()）"></a>1. 首符集、后继符集、选择集（Fisrt(),Follow(),Select()）</h4><h5 id="首符集的定义"><a href="#首符集的定义" class="headerlink" title="首符集的定义"></a>首符集的定义</h5><p>设G = （ V<sub>N</sub> ，V<sub>T</sub> ，P ，S）是上下文无关文法，α 是G的任一符号串，则有 </p>
<p>First(α) = { a | α<sup><em></em></sup>  &rArr; αβ，α ∈ V<sub>T</sub> ，α、β ∈ V<sup>\</sup> }</p>
<p>特别地，若 α  =<sup>*</sup>&rArr; ε，则规定 ε ∈ First(α) </p>
<p>即：Fisrt(α)集是从α出发推导出所有符号串首终结符或可能的ε构成的集合。</p>
<h6 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h6><p>1.求Fisrt(X)</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对每一文法符号<span class="keyword">X</span>∈(VN∪VT），求FIRST(<span class="keyword">X</span>).</span><br><span class="line"></span><br><span class="line">(a)若<span class="keyword">X</span>∈VT,则令FIRST(<span class="keyword">X</span>)=&#123;<span class="keyword">X</span>&#125;;</span><br><span class="line"></span><br><span class="line">(b)若<span class="keyword">X</span>∈VN,且有产生式<span class="keyword">X</span>→a……,(a∈VT)，则令a∈FIRST(<span class="keyword">X</span>);</span><br><span class="line"></span><br><span class="line">(c) 若<span class="keyword">X</span>∈VN,有<span class="keyword">X</span>→ε，则令 ε∈FIRST(<span class="keyword">X</span>);</span><br><span class="line"></span><br><span class="line">(d)若 <span class="keyword">X</span>∈VN, y<span class="number">1</span>, y<span class="number">2</span>,……,yi都∈VN,且有产生式<span class="keyword">X</span>→ y<span class="number">1</span> y<span class="number">2</span>…..yn,      </span><br><span class="line">   当y<span class="number">1</span>, y<span class="number">2</span>,…..yi<span class="number">-1</span> 都 =*=&gt;ε时，（其中<span class="number">1</span>≤i≤n),则FIRST(y<span class="number">1</span>)-ε,</span><br><span class="line">FIRST(y<span class="number">2</span>)-ε,….,FIRST(yi<span class="number">-1</span> )-ε,FIRST(yi)都包含在FIRST(<span class="keyword">X</span>)中。</span><br><span class="line"></span><br><span class="line">(e)当(d)中所有yi =*=&gt; ε(i= <span class="number">1</span>,<span class="number">2</span>,….,n),则FIRST(<span class="keyword">X</span>)=FIRST(y<span class="number">1</span>)∪FIRST(y<span class="number">2</span>)∪….∪FIRST(yn)∪&#123;ε&#125;</span><br><span class="line">反复使用上述（b)～(d) 步直到每个符号的FIRST集合不再增加</span><br><span class="line">为止。</span><br></pre></td></tr></table></figure>
<p>2.求Fisrt(α)</p>
<p> α = x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub> </p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">法<span class="number">1</span>:</span><br><span class="line"><span class="number">1</span>.若n=<span class="number">0</span>,即α=ε,则令FIRST(α)=&#123;ε&#125;<span class="comment">;</span></span><br><span class="line"><span class="comment">2.否则，对1≤i≤n,求FIRST(xi)</span></span><br><span class="line"><span class="comment">3.若n=1,则令 FIRST(α)=FIRST(x1);</span></span><br><span class="line"><span class="comment">4.若n≥2且对一切j=1,2,….,i-1都有ε∈FIRST(xj).</span></span><br><span class="line"><span class="comment">   则令FIRST(xi )-&#123;ε&#125;    FIRST(α),其中2≤i≤n;</span></span><br><span class="line"><span class="comment">   若对一切 j=1,2,…,n都有ε∈FIRST(xj),则令ε∈FIRST(α)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">法2:</span></span><br><span class="line"><span class="comment">1.把FIRST(x1)中所有非ε元素加入到FIRST(α)中，即</span></span><br><span class="line"><span class="comment">                  FIRST(α )=FIRST(x1)-&#123;ε &#125;;</span></span><br><span class="line"><span class="comment">若FIRST(x1)包含有ε，则把FIRST(x2)的所有非ε元素加入到</span></span><br><span class="line"><span class="comment">        FIRST(α)中，即FIRST(α)=FIRST(α)∪ (FIRST(x2)-&#123;ε&#125;);</span></span><br><span class="line"><span class="comment">若FIRST(x1)和FIRST(x2)都包含有 ε，则把FIRST(x3)的所有</span></span><br><span class="line"><span class="comment">        非ε元素加到FIRST(α)中;……</span></span><br><span class="line"><span class="comment">     照此方法继续，一直到考察到xn。</span></span><br><span class="line"><span class="comment">2.若FIRST(xi ),i= 1,2,…,n;即每个FIRST(xi)中都有ε。则将ε加</span></span><br><span class="line"><span class="comment">      到FIRST(α)中。特别地， 若 α=ε ，则FIRST(α)=&#123;ε&#125;.</span></span><br></pre></td></tr></table></figure>
<h5 id="后继符的定义"><a href="#后继符的定义" class="headerlink" title="后继符的定义"></a>后继符的定义</h5><p>设G = （ V<sub>N</sub> ，V<sub>T</sub> ，P ，S）是上下文无关文法，A ∈ V<sub>N</sub> 的后继符集合为</p>
<p>Follow(A) = { a | S =<sup>*</sup>&rArr; μAβ ，a ∈ V<sub>T</sub> ， a ∈ First(β) ， μ ∈ V<sub>T</sub><sup>*</sup>   ，β ∈  V<sup>*</sup>  }</p>
<p>或 Follow(A) = { a | S =<sup>*</sup>&rArr; …Aa…，a ∈ V<sub>T</sub> }</p>
<p>特别地，若S =<sup>*</sup>&rArr; …A ， 则# ∈ Follow(A) 。这里的#是代表一个输入串的结束符</p>
<p>表示所有句型中紧挨着A出现的终结符或#均是Follow(A)的元素</p>
<h6 id="构造算法-1"><a href="#构造算法-1" class="headerlink" title="构造算法"></a>构造算法</h6><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">落#下<span class="selector-tag">S</span></span><br><span class="line">(a)对文法开始符号<span class="selector-tag">S</span>,令# ∈ <span class="selector-tag">FOLLOW</span>(S).</span><br><span class="line"></span><br><span class="line">右部<span class="selector-tag">Follow</span></span><br><span class="line">(b)若<span class="selector-tag">B</span>→α<span class="selector-tag">A</span>β是一个产生式,则令<span class="selector-tag">FIRST</span>(β)<span class="selector-tag">-</span>&#123;ε&#125;</span><br><span class="line">        属于<span class="selector-tag">FOLLOW</span>(A);</span><br><span class="line"></span><br><span class="line">守门员福利</span><br><span class="line">(c) 若<span class="selector-tag">B</span>→α<span class="selector-tag">A</span>是一个产生式，或<span class="selector-tag">B</span>→α<span class="selector-tag">A</span>β是一个产生式且有ε∈<span class="selector-tag">FIRST</span>(β),</span><br><span class="line">	则令<span class="selector-tag">FOLLOW</span>(B)是<span class="selector-tag">FOLLOW</span>(A)的子集。即把<span class="selector-tag">FOLLOW</span>(B)的所有元素加入到<span class="selector-tag">FOLLOW</span>(A)中。</span><br><span class="line"></span><br><span class="line">(d)反复使用(b)直到每个非终结符的 <span class="selector-tag">FOLLOW</span>集合不再增加为止。</span><br></pre></td></tr></table></figure>
<h5 id="选择集的定义"><a href="#选择集的定义" class="headerlink" title="选择集的定义"></a>选择集的定义</h5><p>对于给出的上下文无关的文法产生式 A &rarr; α ， A ∈ V<sub>N</sub> ， α ∈ V<sup>*</sup> ，则</p>
<p>Select(A &rarr; α) = First(α) ，当 α =*&rArr; ε 时</p>
<p>Select(A &rarr; α) = Fisrt(α) &cup; Follow(A) ，其他情况</p>
<h6 id="构造算法-2"><a href="#构造算法-2" class="headerlink" title="构造算法"></a>构造算法</h6><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">(a)</span>求FIRST<span class="comment">(α)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">(b)</span>若ε∈FIRST<span class="comment">(α)</span>,则令SELECT<span class="comment">(A→α)</span>=FIRST<span class="comment">(α)</span></span><br><span class="line">         否则求FOLLOW<span class="comment">(A)</span>,并令 SELECT<span class="comment">(A→α)</span> = FIRST<span class="comment">(α)</span> ∪ FOLLOW<span class="comment">(A)</span>.</span><br></pre></td></tr></table></figure>
<h4 id="2-LL-1-分析法"><a href="#2-LL-1-分析法" class="headerlink" title="2. LL(1)分析法"></a>2. LL(1)分析法</h4><p>当一个文法是LL(1)文法时，则该文法一定能采用确定的自顶向下的分析方法进行分析。</p>
<p><strong>定义</strong>：一个上下文无关文法是LL(1)文法的充分必要条件是每个非终结符A的两个不同产生式，A &rarr; α ，A &rarr; β ，满足  Select(A &rarr; α) &cap; Select(A &rarr; β) = &empty;  ，其中，α和β不能同时 =*&rArr;  ε。</p>
<h4 id="文法的等价变换"><a href="#文法的等价变换" class="headerlink" title="文法的等价变换"></a>文法的等价变换</h4><p>确定的自顶向下分析要求给定语言的文法必须是 LL(1)形式，然而，不一定每个语言都是LL(1)文法，对一个语言的非LL(1)文法是否能变换为等价的LL(1)形式以及如何变换是我们讨论的主要问题。由LL(1)文法的定义可知若文法中<strong>含有左递归</strong>或<strong>含有左公共因子</strong>，则该文法肯定不是LL(1)文法，因而，我们设法消除文法中的左递归，<strong>提取左公共因子</strong>对文法进行等价变换。</p>
<h5 id="Ⅰ提取左公共因子"><a href="#Ⅰ提取左公共因子" class="headerlink" title="Ⅰ提取左公共因子"></a>Ⅰ提取左公共因子</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对A→ αβ1|<span class="string">  αβ2 </span>|<span class="string"> … </span>|<span class="string">  αβn提取左公因子为：</span></span><br><span class="line"><span class="string">　　　A→ α A'      </span></span><br><span class="line"><span class="string">　　　A'→  β1 </span>|<span class="string"> β2 </span>|<span class="string"> … </span>|<span class="string"> βn</span></span><br><span class="line"><span class="string">若在βi , βj , βk…中仍含有左公共因子，可再进行提取，这样反复进行提取直到所引进的新非终结符的有关产生式均无左公共因子为止</span></span><br></pre></td></tr></table></figure>
<p><strong>结论</strong>：一个文法提取了左公共因子后，只解决了相同左部产生式的右部FIRST集不相交问题。当改写后的文法不含有空产生式，且无左递归时，则改写后的文法是LL(1)文法。否则还需用LL(1)文法的判别方法进行判断才能确定是否为LL(1)文法。</p>
<h5 id="Ⅱ消除左递归"><a href="#Ⅱ消除左递归" class="headerlink" title="Ⅱ消除左递归"></a>Ⅱ消除左递归</h5><p>一个文法含有下列形式的产生式之一时：</p>
<blockquote>
<p>1) A→A β, A∈V<sub>N</sub> , β ∈ V*</p>
<p>2) A→B β, B→A α,   A,B∈VN,  α ,β ∈ V*</p>
</blockquote>
<p>则称该文法是左递归的。</p>
<p>含有左递归的文法不能采取自顶向下分析法。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1):把直接左递归改写为右递归</span><br><span class="line"></span><br><span class="line">设有文法产生式: A→Aβ|<span class="string">γ.   其中β非空， γ不以A打头。</span></span><br><span class="line"><span class="string">    可写为:    A → γA'      </span></span><br><span class="line"><span class="string">    		  A' → βA' </span>|<span class="string"> ε</span></span><br><span class="line"><span class="string">    一般情况下，假定关于A的产生式是：</span></span><br><span class="line"><span class="string">    	A→A α1</span>|<span class="string"> A α2 </span>|<span class="string"> … </span>|<span class="string"> A αm </span>|<span class="string"> β1 </span>|<span class="string"> β2 </span>|<span class="string"> …</span>|<span class="string"> βn            </span></span><br><span class="line"><span class="string">    	其中，αi(1≤i≤m)均不为空， βj(1≤j≤n)均不以A打头。</span></span><br><span class="line"><span class="string">	则消除直接左递归后改写为：</span></span><br><span class="line"><span class="string">		A → β1 A' </span>|<span class="string"> β2 A' </span>|<span class="string"> … </span>|<span class="string"> βn A'</span></span><br><span class="line"><span class="string">		A'→ α1 A' </span>|<span class="string"> α2 A' </span>|<span class="string"> … </span>|<span class="string"> αm A' </span>|<span class="string"> ε</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">2):间接消除左递归</span></span><br><span class="line"></span><br><span class="line"><span class="string">对于间接左递归的消除需要先将间接左递归变为直接左递归，然后再按1)清除左递归</span></span><br><span class="line"></span><br><span class="line"><span class="string">哪一步有左递归，就把那一步的间接左递归代入产生式产生直接左递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">----------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="string">3):消除文法中一切左递归的算法</span></span><br><span class="line"></span><br><span class="line"><span class="string">设非终结符按某种规则排序为A1, A2,… An 。</span></span><br><span class="line"><span class="string">For i:=1 to n  do</span></span><br><span class="line"><span class="string">   begin</span></span><br><span class="line"><span class="string">      For j:=1 to i-1 do </span></span><br><span class="line"><span class="string">          begin</span></span><br><span class="line"><span class="string">               若Aj的所有产生式为：</span></span><br><span class="line"><span class="string">                Aj → δ1 </span>|<span class="string"> δ2 </span>|<span class="string"> … </span>|<span class="string"> δn</span></span><br><span class="line"><span class="string">               替换形如Ai → Aj γ的产生式为：</span></span><br><span class="line"><span class="string">                Ai → δ1γ </span>|<span class="string"> δ2γ </span>|<span class="string"> … </span>|<span class="string"> δnγ</span></span><br><span class="line"><span class="string">          end</span></span><br><span class="line"><span class="string">       消除Ai中的一切直接左递归</span></span><br><span class="line"><span class="string">    end</span></span><br></pre></td></tr></table></figure>
<h4 id="递归下降分析程序构造"><a href="#递归下降分析程序构造" class="headerlink" title="递归下降分析程序构造"></a>递归下降分析程序构造</h4><p>在程序语言的语法定义中有许多采用递归定义。我们在对它进行语法分析时，编制的处理程序也采取递归的方式，可使其结构简单易读。但由于频繁地调用子程序大大地降低了分析速度</p>
<p>主要思想：对<strong>每个非终结符</strong>按其<strong>产生式结构</strong>写出相应的语法分析子程序。因为每个文法递归相应子程序也递归，子程序的结构与产生式结构一致。所以称此种方法称为递归子程序法或递归下降法。</p>
<p>用程序表示递归子程序的内部结构：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	设A是一个非终结符：A→β<span class="number">1</span> </span><br><span class="line">					A→β<span class="number">2</span></span><br><span class="line">					 ┊</span><br><span class="line">					A→βn</span><br><span class="line"></span><br><span class="line">	则写     ζ(A) &lt;==&gt; <span class="keyword">if</span> <span class="keyword">char</span>∈<span class="keyword">first</span>(β<span class="number">1</span> )  <span class="keyword">then</span>ζ(β<span class="number">1</span> )</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">char</span> ∈ <span class="keyword">first</span>(β<span class="number">2</span> )  <span class="keyword">then</span> ζ(β<span class="number">2</span> )</span><br><span class="line">                                              <span class="keyword">else</span>…</span><br><span class="line">                                                       <span class="keyword">if</span> <span class="keyword">char</span>∈<span class="keyword">first</span>(βn )</span><br><span class="line">                                                       		<span class="keyword">then</span> ζ(βn)</span><br><span class="line">                                                                <span class="keyword">else</span>    ERROR</span><br><span class="line"></span><br><span class="line">其中ζ(βi)表示调用处理符号串βi的子程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对A的任一右部i 设为：     βi = y1 y2 … yn</span><br><span class="line">则定义ζ( βi) &lt;==&gt; beginζ(y1);ζ(y2);…;ζ(yn) <span class="keyword">end</span></span><br><span class="line">其中yj可分为下列两种情况（j=<span class="number">1</span>,…,n):</span><br><span class="line"><span class="number">1</span>)  yj∈VT,则</span><br><span class="line">     ζ( yj) &lt;==&gt; <span class="keyword">if</span> <span class="keyword">char</span>≠ yj  <span class="keyword">then</span>  ERROR  <span class="keyword">else</span>    READ(<span class="keyword">char</span>)</span><br><span class="line"><span class="number">2</span>)  yj∈VN,则ζ(yj)表示调用关于yj的递归子程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对文法加限制：</span><br><span class="line"><span class="number">1.</span>任一非终结符B都不是左递归的，否则会产生死循环。</span><br><span class="line"><span class="number">2.</span>对A的任意两个右部βi , βj ,有：<span class="keyword">first</span>(βi) ∩ <span class="keyword">first</span>(βj) = φ ,</span><br><span class="line">First(βi)表示βi所能导出串的第一个符号的集合。显然，每个βi的<span class="keyword">first</span>(βi)是互不相同的，否则则无法判断应执行哪个ζ(βi )。</span><br></pre></td></tr></table></figure>
<h4 id="预测分析程序"><a href="#预测分析程序" class="headerlink" title="预测分析程序"></a>预测分析程序</h4><p>LL(k)文法是采取确定的<strong>自左至右扫描</strong>（输入串）和自顶向下分析技术的最大一类文法。</p>
<p><strong>LL系指</strong>：自左向右扫描（输入串），自上而下进行最<strong>左</strong>推导。一般来说，一个文法当其分析器对输入串进行自左至右扫描并采用自顶向下方法进行分析的过程中，如果每步仅利用当前的非终结符（事实上此时它已位于分析栈顶）和至多向前查看k个输入符号就能唯一 决定采取什么动作，那么这个文法称为<strong>LL(K)文法</strong>。</p>
<p>对于大多数程序设计语言而言。K=1就足够了。因此我们将主要讨论k=1的情形。</p>
<h5 id="LL-1-文法的分析过程"><a href="#LL-1-文法的分析过程" class="headerlink" title="LL(1)文法的分析过程"></a>LL(1)文法的分析过程</h5><p>设分析的当前格局为（x1x2 …. xn#, y1y2 …. ym#)</p>
<p>其中xi表示句型的前端部分，诸yj表示输入流的后端部分（终结符串）。则可能有下述动作之一：</p>
<p>1.替代：当x<sub>1</sub>∈V<sub>N</sub>时，则选相应的候选式去替换x<sub>1</sub> 。</p>
<p>2.匹配：当x<sub>1</sub>∈VT时，它与y<sub>1</sub>进行匹配，其结果为两种可能，如</p>
<p>   果匹配成功，则去掉x<sub>1</sub>和y<sub>1</sub>（即指针后移一位）否则报错。</p>
<p>3.接受：当格局为(#, #）时，报告分析成功结束。</p>
<p>从实现的角度来说，上述替换过程需要花较多的时间，因为它除了把一个候选式替换掉x1,还需要x2 … xn统统进行移位处理，这时很麻烦的。我们的处理方法是用栈来保存x1x2 … xn,而且是把xn作为栈底， x1作为栈顶，那么上述的替换动作就简单了，只需在栈顶进行替换。即去掉x1把候选式的符号串按逆序方式压入栈中即可。</p>
<h5 id="LL-1-方法的实现"><a href="#LL-1-方法的实现" class="headerlink" title="LL(1)方法的实现"></a>LL(1)方法的实现</h5><p>LL(1)方法在实现时用到一个LL(1)分析矩阵和一个分析栈以及预测分析程序。</p>
<p>分析矩阵的元素M[A,a]中的下标A为非终结符，a为终结符或句子结束标记”#”，矩阵元素M[A,a]的内容为一条关于A的产生式。</p>
<p>它表明当用非终结符A向下推导而当前输入符为a时，所应采用的候选式。当矩阵元素为空时，则表示用A往下推导时遇到了不应该出现的符号，即A与a不能匹配。因此应该转向出错处理。</p>
<p>预测分析程序如下图</p>
<p><img src="/2019/09/04/Compiler/11.jpg" alt></p>
<p>①判断文法G[E]是否为LL(1)文法，若文法中含有左递归那么要先消除左递归，然后求select集</p>
<p>②构造预测分析表，对每个终结符或’#’号用a表示，则若a∈Select(A&rarr;α)。令 M[A,a]=A&rarr;α</p>
<p>把所有无定义的M[A,a]标上ERROR</p>
<p>伪代码如下：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">其程序维护一个栈Stack用来储存非终结符，一个用于储存源程序的读入字符变量a，一个用于储存栈顶元素XX</span><br><span class="line">其中M[A,a] = &#123;X-&gt;x1x2……xk&#125; 为 <span class="keyword">Select</span>(X-&gt;x1x2……xk)=&#123;a,……&#125;,X为非终结符,a为终结符</span><br><span class="line"></span><br><span class="line">#和开始符合入栈</span><br><span class="line">把第一个输入符号读入a</span><br><span class="line">Flag := <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> Flag <span class="keyword">Do</span>:</span><br><span class="line">	把栈顶元素出栈到X中</span><br><span class="line">	<span class="keyword">if</span> X ∈ VT <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">if</span> X = a <span class="keyword">then</span> 把下一个输入符号读入a</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">ERROR</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> X = <span class="comment">'#' then </span></span><br><span class="line">		     Flag := <span class="literal">False</span> </span><br><span class="line">		  <span class="keyword">else</span> <span class="keyword">ERROR</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> M[X,a] = &#123;X-&gt;x1x2x3……Xxk&#125; <span class="keyword">then</span></span><br><span class="line">			把x1x2x3……xk入栈</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">ERROR</span></span><br><span class="line"><span class="keyword">END</span> of <span class="keyword">while</span></span><br><span class="line"><span class="keyword">STOP</span>/*分析成功，过程完毕*/</span><br></pre></td></tr></table></figure>
<h3 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h3><p><strong>原理</strong>：<strong>自左向右</strong>扫描，<strong>自下而上</strong>分析</p>
<p>从输入符号串入手，通过反复查找当前句型的可归约串，并使用文法的产生式把他归约成相应的非终结符来一步步地进行分析。最终把输入串归约成文法的开始符号，表明分析成功。</p>
<ul>
<li>任何自下而上分析方法的关键就是要找出当前句型的可归约串，然后根据产生式判别将它归约成什么样的非终结符。</li>
</ul>
<h4 id="规范归约基本概念"><a href="#规范归约基本概念" class="headerlink" title="规范归约基本概念"></a>规范归约基本概念</h4><p>G为文法，S为开始符号，假定α，β，δ是G的一个句型，如果 S =*=&gt; αAδ 且 A=+=&gt; β，</p>
<p>则称 β 是句型 α β δ 相对于非终结符A的短语。</p>
<p>如果 A &rArr; β ，则称β是句型 α β δ 相对于A的直接短语。</p>
<p>最左直接短语称为句柄。</p>
<p>从句子到开始符号的归约序列，如果每一步都是把句柄替换为相应产生式的左部符号而得到的，则称为<strong>规范归约</strong>。规范归约是最右推导（规范推导）的逆过程。</p>
<blockquote>
<p>例：：考虑文法G(E)：E→E +T |T<br>                                       T→T*F | F<br>                                        F→i| (E)<br> 并假定输入串为（i+i)*i，考察自下而上的分析过程</p>
<p><img src="/2019/09/04/Compiler/12.jpg" alt></p>
<p><strong>栈上的候选式不一定是句柄</strong>。例如，在第14步对栈顶为T，它是E的一候选式，但它不是句柄，不能归约成E。判定候选式是极为简单的事情，但判定句柄就不那么容易。而不同的自底向上方法给出不同的判定方法。</p>
</blockquote>
<p>自下而上方法包括四个方法：</p>
<ul>
<li>移进(shift)：把输入流的头符读到分析栈中</li>
<li>归约(Reduction)：把分析栈顶的句柄归约为一非终结符</li>
<li>接受：分析成功</li>
<li>报错：处理错误</li>
</ul>
<h4 id="算符优先分析"><a href="#算符优先分析" class="headerlink" title="算符优先分析"></a>算符优先分析</h4><p>首先规定文法符号之间的优先关系和结合性质，然后再利用这种关系，通过比较两个相邻的符号之间的优先顺序来确定可归约串。</p>
<p>算符文法：任何产生式的右部都不含两个相继的非终结符</p>
<blockquote>
<p> 优先关系：</p>
<p>终结符ab的三种优先关系：</p>
<ul>
<li>a = b：当且仅当存在形如下面的产生式 U &rarr; … ab … 或 U &rarr; …aQb …</li>
<li>a &lt; b：当且仅当存在形如下面的产生式 U &rarr; …aW… 的产生式，且有 W =+=&gt; b…</li>
<li>a &gt; b：当且仅当存在形如下面的产生式 U &rarr; …Vb… 的产生式，且有 V=+=&gt;…a 或                V =*=&gt;…aQ</li>
</ul>
</blockquote>
<h5 id="如何从文法构造优先关系表"><a href="#如何从文法构造优先关系表" class="headerlink" title="如何从文法构造优先关系表"></a>如何从文法构造优先关系表</h5><p>检查文法产生式的每个候选，可找出所有满足 = 的终结符对。</p>
<p>对于每个非终结符 P 构造两个集合 FIRSTVT(P) 和 LASTVT(P) </p>
<p>FisrtVt(P) = { a | P =+=&gt; a… 或  P =+=&gt; Qa… ，a ∈ V<sub>T</sub> ，Q ∈ V<sub>N </sub> }</p>
<p>LastVt(P) = { a | P =+=&gt; …a 或 P =+=&gt; …aQ ，a∈V<sub>T</sub> ，Q ∈ V<sub>N</sub>  }</p>
<p>检查每个产生式的候选，若形如 …aP… ，则对任意b ∈ FisrtVt(P) ，我们有 a&lt;b</p>
<p>若形如 …Pb… ，则对任何a ∈ LastVt(P)，我们有 a&gt;b</p>
<p>对表达式文法的非终结符构造 FirstVt 和 LastVt 并建立优先关系表</p>
<h5 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h5><p>素短语：这样的一个短语，他至少包含一个终结符，不含比自身更小的素短语</p>
<p>最左素短语：句型最左边的素短语</p>
<p>定理：算法优先文法的句型 #N<sub>1</sub>a<sub>1</sub>N<sub>2</sub>a<sub>2</sub>……N<sub>n</sub>a<sub>n</sub>N<sub>n+1</sub># 的最左素短语是满足如下条件的最左子串   N<sub>j</sub>a<sub>j</sub>……N<sub>i</sub>a<sub>i</sub>N<sub>i+1</sub> ， a<sub>j-1</sub> &lt; a<sub>j</sub> ， a<sub>j</sub>  =   a<sub>j+1</sub>  =  a<sub>i</sub>   ， a<sub>i</sub>  &gt;  a<sub>i+1</sub>   </p>
<h5 id="优先函数"><a href="#优先函数" class="headerlink" title="优先函数"></a>优先函数</h5><h4 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h4><ul>
<li>LR(K)分析是指<strong>自左向右扫描</strong>和<strong>自下而上</strong>的语法分析，且在分析的每一步，只须根据分析栈中当前<strong>已移进</strong>和<strong>归约</strong>出的<strong>全部文法符号</strong>，并至<strong>多再向前查看K个输入符号</strong>，就能确定相当于某一产生式右部符号的句柄是否已在分析栈的顶部形成。从而也就可以确定所应采取的分析动作（是移进输入符号还是按某产生式进行归约）。</li>
</ul>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># X1X2 …… Xi …… Xn Xn<span class="string">+1</span> Xn<span class="string">+2</span> …… Xn+k Xn+k<span class="string">+1</span> …… #</span><br><span class="line">		  |-------||----------------|</span><br><span class="line">			 栈顶 	  扫描器的缓冲区 </span><br><span class="line">			 扫到Xn<span class="string">+1</span>,向前查看k个符号,来确定是把Xn<span class="string">+1</span>移进栈,还是把Xi…Xn作为句柄进行归约</span><br><span class="line"></span><br><span class="line">1) 要归约时，则根据某产生式 U → XiXi<span class="string">+1</span>……Xn 进行归约: #X1X2 …… Xi<span class="string">-1</span> U Xn<span class="string">+1</span>Xn<span class="string">+2</span> …… Xn+k …… #</span><br><span class="line"></span><br><span class="line">2)要移进时，即把Xn<span class="string">+1</span>进栈，并读入下一符号: #X1X2 …… Xi …… XnXn<span class="string">+1</span>   Xn<span class="string">+2</span> …… Xn+k …… #</span><br><span class="line">											|---|	 |---|   |-|</span><br><span class="line">											栈中Xi  栈顶(Xn<span class="string">+1</span>) 当前扫描符(Xn<span class="string">+2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>LR(0)：表示再每一步分析时都不用向前输入符号</li>
<li>LR(1)：表示再每一步分析时都向前看一个输入符号来决定当前的动作</li>
<li>SLR(1)：表示简单的LR(1)，即只在动作不唯一的地方向前看一个符号，在动作唯一时则不向前看输入符号</li>
</ul>
<h5 id="LR分析器的逻辑结构及工作流程"><a href="#LR分析器的逻辑结构及工作流程" class="headerlink" title="LR分析器的逻辑结构及工作流程"></a>LR分析器的逻辑结构及工作流程</h5><p><img src="/2019/09/04/Compiler/13.jpg" alt></p>
<p>如图为LR分析器的逻辑结构，所有LR分析器的总控程序大致相同，只有分析表（即Go-Action表）不相同。</p>
<ul>
<li><strong>规范LR分析表构造法</strong>：用此法构造的分析表功能最强而且也适合很多文法，但是实现代价较高</li>
<li><strong>简单LR（即SLR）分析表构造法</strong>：比较容易实现的方法，但SLR分析表功能太弱，而且对某些文法可能根本就构造不出相应的SLR分析表</li>
<li><strong>向前LR（即LALR）分析表构造法</strong>：这种方法构造的分析表功能介于规范LR分析表和SLR分析表之间。这种表适用于绝大多数的程序语言文法，而且也可以设法有效实现</li>
</ul>
<h5 id="LR的分析过程"><a href="#LR的分析过程" class="headerlink" title="LR的分析过程"></a>LR的分析过程</h5><p>两个栈：状态栈，符号栈</p>
<p><strong>移进：</strong></p>
<p><img src="/2019/09/04/Compiler/14.jpg" alt></p>
<p><strong>归约：</strong></p>
<p><img src="/2019/09/04/Compiler/15.jpg" alt></p>
<p><strong>接受&amp;报错：</strong></p>
<p><img src="/2019/09/04/Compiler/16.jpg" alt></p>
<p>所以各种LR分析器的最大区别在于其分析表，分析表决定了每一步该如何移进或者归约，直至接受，或者中途报错。</p>
<h5 id="LR-0-分析表的构造"><a href="#LR-0-分析表的构造" class="headerlink" title="LR(0)分析表的构造"></a>LR(0)分析表的构造</h5><p>1.规范句型的活前缀</p>
<p><strong>前缀：</strong>一个符号串的前缀是指该串的任意首部(包括ε)。</p>
<p>​        例：abc的前缀为：ε，a，ab，abc</p>
<p>归约时，归约前和归约后的被归约部分与剩余部分合起来仅构成文法的规范句型，而用哪个产生式归约仅取决于当前句型的前面部分；X1X2…Xn[p]，其中Xi为文法的符号，[p]为第p个产生式序号</p>
<ul>
<li>我们把规范句型的这种前端部分的串称为活前缀。实际上，它们恰好是符号栈栈顶形成句柄时符号栈中的内容。</li>
</ul>
<p><strong>活前缀：</strong>是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。</p>
<ul>
<li>这是因为一旦句型的句柄在符号栈顶形成，将会<strong>立即被归约</strong>之故。所以我们将规范句型具有上述性质（不含句柄之后的任何符号）的前缀称之为活前缀。</li>
</ul>
<p>在规范归约过程中的任何时候只要已分析过的部分即在符号栈中的符号串为规范句型的活前缀，表明输入串的已被分析过的部分是该文法某规范句型的一个正确部分。</p>
<ul>
<li><strong>定义</strong>：若 S=<sup>*</sup><sub>R</sub>&rArr; αAω =<sub>R</sub>&rArr; αβω 是文法G的一个规范推导，如果符号串γ是    αβ 的前缀，则称γ是G的一个<strong>活前缀</strong>。其中S为文法开始符号</li>
</ul>
<h5 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h5><blockquote>
<p> 活前缀和句柄间的关系：</p>
<p> (1) 活前缀中已含有句柄的全部符合（句柄的最后符号就是活前缀的最后符号）</p>
<p> (2) 活前缀只含有句柄的前部分符号（句柄的最左子串为活前缀的最右子串）</p>
<p> (3) 活前缀中全然不包括句柄的任何符号</p>
</blockquote>
<p>(1) 表明：此时某一产生式 A &rarr; β 的右部 β 已出现在符号栈顶，因此此时相应的分析动作应当是用此产生式进行<strong>归约</strong>。</p>
<p>(2) 表明：形如 A &rarr; β<sub>1</sub> β<sub>2</sub>  的产生式的右部子串已在符号栈栈顶了，如 β<sub>1</sub> ，正期待着从余留输入串中能看到由β推出的符号串，即期待 β<sub>2</sub> 进栈以便能进行归约。故此时分析动作是<strong>移进</strong>当前输入符号</p>
<p>(3) 表明：期望从余留输入串中能看到某产生式 A &rarr; α 的右部，即α所代表的符号串（即句柄），所以此时分析的动作也是读输入符进符号栈。</p>
<p>在产生式的右部相应位置上加一个圆点 <code>.</code> ，来指示识别位置，标明在 <code>.</code> 前的部分已被识别</p>
<p>如 (1)  A &rarr; β<code>.</code>          (2)  A &rarr;  β<sub>1</sub><code>.</code>β<sub>2</sub>           (3)  A &rarr; <code>.</code>α</p>
<p>右部某位置上标有圆点的产生式称为LR(0)项目(item)。</p>
<p>不同的LR(0)项目，反映了分析过程中符号栈顶的不同情况。</p>
<p>每个项目的意义与圆点的位置有关</p>
<p>圆点左边的子串表示在分析过程的某一时刻用该产生式归约时句柄中已识别过的部分，圆点右边的子串表示待识别的部分</p>
<p>文法的全部LR(0)项目将是构造他的所有活前缀的有穷自动机的基础</p>
<h6 id="LR-0-项目的分类"><a href="#LR-0-项目的分类" class="headerlink" title="LR(0)项目的分类"></a>LR(0)项目的分类</h6><ul>
<li><code>A → α.</code>：表明右部符号串已出现在栈顶，此时相应的分析动作应当是按此产生式进行归约，此种项目称为<strong>规约项目</strong>。</li>
<li><code>S&#39; → S.</code>：称为<strong>接受项目</strong>。</li>
<li><code>A → α.Xβ</code>：其中α可以为ε，当X为终结符时，相应的分析动作应将当前的符号移入栈中，将此项目称为<strong>移进项目</strong>。</li>
<li><code>A → α.Xβ</code>：其中α可以为ε，当X为非终结符时，期待从余留的输入符中进行归约后而得到X，此类项目称为<strong>待约项目</strong>。</li>
</ul>
<p>把<strong>终结符和非终结符</strong>都可看成一个有限自动机的<strong>输入符号</strong>，每把一个符号进栈相当于已识别过该符号，而状态进行转换（到下一个状态），当识别到可归约前缀时相当于栈顶已形成句柄，则认为达到了识别句柄的终态。、</p>
<p>==&gt;&gt;&gt;<strong>构造识别活前缀的DFA</strong>：DFA中的每一个状态由若干个LR(0)项目所组成的集合(称为项目集)来表示。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">举例：构造识别前缀的DFA</span><br><span class="line">用I0表示这个DFA的初态，</span><br><span class="line">将项目S'→<span class="string">.S</span>列入项目集I0。</span><br><span class="line">将项目S→<span class="string">.A</span>和S→<span class="string">.B</span>加入I0中。</span><br><span class="line">将A→<span class="string">.aAb</span>和A→<span class="string">.c</span>和B→<span class="string">.aBb</span>, B→<span class="string">.d</span>加入I0中。</span><br><span class="line"></span><br><span class="line">项目集I0将由如下项目组成：</span><br><span class="line">I0 :   S'→<span class="string">.S</span>,   S→<span class="string">.A</span>,  S→<span class="string">.B</span>,  A→<span class="string">.aAb</span>, A→<span class="string">.c</span>,   B→<span class="string">.aBd</span>,   B→<span class="string">.d</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; S'→<span class="string">.S</span>称为项目集I0的基本项目，从基本项目出发构造项目集I0的过程，可用closure<span class="params">(&#123;S'→.S&#125;)</span>表示。</span><br></pre></td></tr></table></figure>
<h5 id="closure-I-的定义"><a href="#closure-I-的定义" class="headerlink" title="closure(I)的定义:"></a>closure(I)的定义:</h5><p>Closure(I) = I ∪ { A → .μ | A → μ∈G ∧ K→ α.Aβ∈closure(I) ∧ α∈V<em>∧β∈V</em>}</p>
<p>构造closure(I)的算法:<br>1）I 中的每一个项目都属于 closure(I)<br>2）若形如 K→α.Aβ 的项目属于I，且 A→μ 是文法的一个产生式，任何形如 A→.μ 的项目也应加到 closure(I) 中<br>3）重复上述过程，直至不再有新的项目加入到closure(I)中为止。      </p>
<p>如何确定从I0可能转移到的下一状态？</p>
<p>若I0中有项目 K→a <strong>.</strong>Ab，从输入串识别出A后，进入下一状态。设此状态为 I<sub>i</sub>  ，显然 I<sub>i</sub> 中必含有形如 K→aA <strong>.</strong>b 的项目，称为 K→a <strong>.</strong>Ab 的<strong>后继项目</strong>。后继项目组成集合 J，则J中的每个项目都是项目集 I<sub>i</sub> 的<strong>基本项目</strong>，有： I<sub>i</sub>  =closure( J )</p>
<h5 id="定义状态转移函数：GOTO-I-A-closure-J"><a href="#定义状态转移函数：GOTO-I-A-closure-J" class="headerlink" title="定义状态转移函数：GOTO(I,A)=closure(J)"></a>定义<strong>状态转移函数</strong>：<code>GOTO(I,A)=closure(J)</code></h5><p>其中，I 是当前状态，A为文法符号，J 是 I 中所有形如K→a<strong>.</strong>Ab的项目之后继项目K→aA<strong>.</strong>b所组成的集合，而closure(J)就是项目集 I（即状态I)关于符号A的后继项目集（即后继状态）。</p>
<p>将G[S’]的全部项目集称为文法G[S’]的LR(0)项目集规范族，并记为C=(I<sub>0</sub> ，I<sub>1</sub> ，I<sub>2</sub> ，……，I<sub>n</sub> )</p>
<p>识别文法G[S’]的全部活前缀的DFA为 M = ( C，V，GoTo ， I<sub>0</sub> ， Z )</p>
<p>其中，C：M的状态集，即文法G[S’] 的LR(0) 项目集规范族 I<sub>0</sub> ~~~ I<sub>n</sub> </p>
<p>V：M的字母表，即在M中的所有符号</p>
<p>GoTo：M的状态转换函数，即上述的GoTo函数</p>
<p>I<sub>0</sub> ：M的唯一初态</p>
<p>Z：M的终态集，Z &sub; C 为规范族中所有含有<strong>规约项目</strong>的那些项目集</p>
<p>例如下图：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文法G<span class="string">':</span></span><br><span class="line"><span class="string">(0) S'</span> → S</span><br><span class="line">(<span class="number">1</span>) S → A</span><br><span class="line">(<span class="number">2</span>) S → <span class="keyword">B</span></span><br><span class="line"><span class="keyword">(3) </span>A → aAb</span><br><span class="line">(<span class="number">4</span>) A → c</span><br><span class="line">(<span class="number">5</span>) <span class="keyword">B </span>→ aBd</span><br><span class="line">(<span class="number">6</span>) <span class="keyword">B </span>→ d</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/04/Compiler/17.jpg" alt></p>
<p>如上为一个DFA，通过读入字符进行状态转换，以及在每个状态内进行closure闭包。</p>
<h4 id="LR-0-分析表构造"><a href="#LR-0-分析表构造" class="headerlink" title="LR(0)分析表构造"></a>LR(0)分析表构造</h4><p>要求每一个项目集中的的诸项目<strong>不出现</strong>下列的情况：</p>
<ul>
<li><p>（1）移进项目和归约项目并存，即存在<strong>移进—归约冲突</strong>；</p>
</li>
<li><p>（2）多个归约项目并存，即存在<strong>归约—归约冲突</strong>。</p>
</li>
</ul>
<p>​          如果一个文法G满足上述条件，也就是它的每个LR(0)项目集中都不含有冲突的项目，则称G为LR(0)文法。</p>
<p>只有当一个文法是LR(0)文法时，才能对它构造不含冲突动作的LR(0)分析表。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">构造LR<span class="params">(0)</span>分析表的算法为：</span><br><span class="line">     <span class="params">(1)</span>对于每一项目集Ii中形如A→α<span class="string">.X</span>β的项目，且有GO<span class="params">(Ii,X)</span>=Ij,</span><br><span class="line">			若X为一终结符号 a 时，则置ACTION[i,a]=Sj;</span><br><span class="line">			若X为一非终结符号时，则置GOTO[i,X]=j</span><br><span class="line">     <span class="params">(2)</span>若Ii中有归约项目A→α. ,设A→α为文法第j个产生式，则对文法的任何终结符和“<span class="comment">#”（均记为a）,置ACTION[i,a]=Rj</span></span><br><span class="line">     <span class="params">(3)</span>若接受项目S'→S .属于Ii ,则置ACTION[i,<span class="comment">#]=acc。</span></span><br><span class="line">	 <span class="params">(4)</span>在分析表中,凡不能按上述规则填入信息的元素,均置为“出错”。</span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">如上图的DFA可构造分析表为:</span><br><span class="line"></span><br><span class="line">                 ACTION											GOTO</span><br><span class="line">		a		b		c		d		<span class="comment">#					S    A    B</span></span><br><span class="line">0		S4				S5		S6							1    2    3</span><br><span class="line">1										Acc</span><br><span class="line">2		R1		R1		R1		R1		R1</span><br><span class="line">3		R2		R2		R2		R2		R2</span><br><span class="line">4		S4				S5		S6								  7	  9</span><br><span class="line">5		R4		R4		R4		R4		R4</span><br><span class="line">6		R6		R6		R6		R6		R6</span><br><span class="line">7				S8</span><br><span class="line">8		R3		R3		R3		R3		R3</span><br><span class="line">9								S10</span><br><span class="line">10		R5		R5		R5		R5		R5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 表中Ri代表用第i个产生式归约,Si代表移进Action表的第i行</span><br></pre></td></tr></table></figure>
<p>分析器的工作过程如下：</p>
<p><strong>根据输入串当前符号 a 和 分析栈栈顶状态 i 查找分析表应采取的动作：</strong></p>
<p>1）若ACTION[i,a]=Sj, a∈V<sub>T</sub> ,则把 a <strong>移进</strong>符号栈， j <strong>移进</strong>状态栈。</p>
<p>2）若ACTION[i,a]=Rj，a∈V<sub>T</sub> 或 # ，则用第j个产生式<strong>归约</strong>。并将两个栈的指针减去K(其中，<strong>K为第j 个产生式右部的串长度</strong>），并把产生式的左部符号A压入符号栈，同时用符号对（ S<sub>i-k</sub> , A )去查GOTO表（其中S<sub>i-k</sub> 为状态栈当前栈顶元素，若 GOTO[S<sub>i-k</sub> ,A] = j ,则j压入状态栈，使得两个栈内的元素一样多。</p>
<p>3）若ACTION[i,a]=Acc,（此时a应为“#”号），则表明<strong>分析成功</strong>，结束分析。</p>
<p>4）若ACTION[i,a]=空白，转<strong>出错处理</strong>。</p>
<h4 id="SLR分析表构造"><a href="#SLR分析表构造" class="headerlink" title="SLR分析表构造"></a>SLR分析表构造</h4><p>大多数程序设计语言的文法不是LR(0)文法。</p>
<p>对LR(0)规范族中有冲突的项目集（状态）用向前查 看一个（输入）符号的办法进行处理，以解决冲突。即为SLR(1)。</p>
<p>SLR(1) 分析表构造与LR(0) 分析表构造基本相同</p>
<p>SLR(1) 之所以是1，是因为向前看了一步Follow集。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假定有一个LR(<span class="number">0</span>)规范族中含有如下项目集(状态)I:</span><br><span class="line"></span><br><span class="line">I=&#123;X→<span class="selector-tag">a</span>.bβ , A→g. , B→d.&#125;其中<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,g,d为符号串，b∈VT ,I中含有移进—归约和归约—归约冲突。</span><br><span class="line"></span><br><span class="line">只要FOLLOW(A)和FOLLOW(B)互不相交，且都不包含<span class="selector-tag">b</span>,即:</span><br><span class="line"><span class="function"><span class="title">FOLLOW</span><span class="params">(A)</span></span>∩FOLLOW(B)=φ</span><br><span class="line"><span class="function"><span class="title">FOLLOW</span><span class="params">(A)</span></span>∩&#123;b&#125;=φ</span><br><span class="line"><span class="function"><span class="title">FOLLOW</span><span class="params">(B)</span></span>∩&#123;b&#125;=φ</span><br><span class="line"></span><br><span class="line">当状态I面临某输入符号a时，则动作为：</span><br><span class="line"><span class="number">1</span>）若<span class="selector-tag">a</span> = <span class="selector-tag">b</span>,则移进。</span><br><span class="line"><span class="number">2</span>）若<span class="selector-tag">a</span> ∈ FOLLOW(A),则用产生式A→g归约。</span><br><span class="line"><span class="number">3</span>）若<span class="selector-tag">a</span> ∈ FOLLOW(B),则用产生式B→d归约。</span><br></pre></td></tr></table></figure>
<p>一般地，对于LR(0)规范族的一个项目集I可能含有多个移进项目和多个归约项目，我们可假设项目集I中有m个移进项目： A1→a1<strong>.</strong> b1b1, A2→ a2<strong>.</strong> b2b2, …, Am→ am<strong>.</strong> bmbm;同时含有n个归约项目：B1→g1<strong>.</strong> , B2→ g2<strong>.</strong> ,…, Bn→ gn<strong>.</strong> ,只要集合{b1, b2,…bm}和FOLLOW(B1),FOLLOW(B2),…,FOLLOW(Bn) 两两交集都为空，则我们仍可用上述归则来解决冲突：</p>
<p> 1）若a∈{b1, b2,…,bm},则移进。</p>
<p> 2）若a∈FOLLOW(Bi),i=1,…,n，则用 Bi→ gi 进行归约。</p>
<p> 3）此外，则报错。</p>
<h5 id="SLR分析表构造方法"><a href="#SLR分析表构造方法" class="headerlink" title="SLR分析表构造方法"></a>SLR分析表构造方法</h5><p>(1) 对于每一项目集Ii中形如A.X的项目，且有GOTO(Ii,X)=Ij,   若X为一终结符号a时，则置ACTION[I,a]=S;   若X为一非终结符号时，则仅置GOTO[i,X]=j；</p>
<p>(2) 若归约项目A→α<strong>.</strong> 属于Ii,设A→α为文法第j个行产生式，则对任何属于FOLLOW(A)的输入符号a,置ACTION[i,a]=Rj；</p>
<p>(3) 若接受项目S’ → S<strong>.</strong>属于Ii ,则置ACTION[i,#]=acc。</p>
<p>(4) 在分析表,凡不能按上述规则填入信息的元素,均置为“出错”。</p>
<p>（例：TODO：后面补充，ppt–Bottom-Up–P42-47）</p>
<h5 id="规范LR分析表构造"><a href="#规范LR分析表构造" class="headerlink" title="规范LR分析表构造"></a>规范LR分析表构造</h5><p>SLR(1) 方法：若状态K含有 <code>A ➡ α.</code>，若 α ∈ Follow(A) ，则用 <code>A ➡ α.</code> 归约</p>
<p>当状态Ix下，有产生式<code>A ➡ α.</code> 和<code>A ➡ α. = …</code>，此时，SLR(0)不知道是将此归约成A还是移进至=，若没有其他情况能产生=，则这里产生移进归约冲突，导致错误！！！</p>
<h5 id="LR-1-项目"><a href="#LR-1-项目" class="headerlink" title="LR(1)项目"></a>LR(1)项目</h5><p>(A→a<strong>.</strong> β，x) 表示： a在栈顶，输入串头部可由βx导出。</p>
<p>LR(1)的状态：LR(1)项目的集合</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">该算法为:</span><br><span class="line">      令初态: Closure( (S’→.S，<span class="comment">#) )</span></span><br><span class="line">      </span><br><span class="line">Closure(I)=</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">for</span> any <span class="built_in">item</span>( A→α.Xβ ，z) <span class="keyword">in</span> I</span><br><span class="line">            <span class="keyword">for</span> any production X →γ</span><br><span class="line">                <span class="keyword">for</span> any w∈FIRST(βz)</span><br><span class="line">                          I←I∪&#123;X → .γ, w&#125;</span><br><span class="line">    <span class="keyword">until</span> I <span class="keyword">does</span> <span class="keyword">not</span> change</span><br><span class="line"></span><br><span class="line">GO (I,X)=</span><br><span class="line">    J ←&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> any <span class="built_in">item</span>(A→α.Xβ，z) <span class="keyword">in</span> I</span><br><span class="line">        add ( A→αX.β，z )  <span class="keyword">to</span> J</span><br><span class="line"><span class="built_in">    return</span> Closure(J)</span><br></pre></td></tr></table></figure>
<h5 id="LALR分析表的构造"><a href="#LALR分析表的构造" class="headerlink" title="LALR分析表的构造"></a>LALR分析表的构造</h5><p>同心项目集：除去搜索符之外都相同的LR(1)项目集</p>
<p>合并同心项目集不会产生新的移进-归约冲突</p>
<p>将 LR(1) 合并同心项目集，如果没有归约-归约冲突，则为LALR(1)文法。</p>
<p><img src="/2019/09/04/Compiler/18.jpg" alt></p>
<blockquote>
<p><a href="https://www.cnblogs.com/henuliulei/p/10872483.html" target="_blank" rel="noopener">参考，各语法分析器的区别</a></p>
</blockquote>
<blockquote>
<p> 各文法的区别：</p>
<ul>
<li>LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow集</li>
<li>>&gt;&gt;见到First集就移进，见到Follow集就归约。</li>
<li>LR(0):见到<strong>First集就移进</strong>，见到终态就归约</li>
<li>SLR(1)见到<strong>First集就移进</strong>，见到<strong>终态先看Follow集</strong>，与Follow集<strong>对应的项目归约</strong>，其它报错。</li>
<li>>&gt;&gt;SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突</li>
<li>SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。</li>
<li>LALR同心集合并不会产生“移进－归约”冲突 ，但会产生“归约－归约”冲突</li>
<li>LR(1)</li>
</ul>
</blockquote>
<h2 id="语法制导的翻译（Syntax-Directed-Translation）"><a href="#语法制导的翻译（Syntax-Directed-Translation）" class="headerlink" title="语法制导的翻译（Syntax-Directed Translation）"></a>语法制导的翻译（Syntax-Directed Translation）</h2><p>一种语义描述方法：语法制导的翻译</p>
<p>语法制导翻译采用上下文无关文法来引导对语言的翻译，是一种<strong>面向文法</strong>的翻译技术</p>
<p>语法制导翻译=语法分析+语义分析+中间代码生成</p>
<p>语义翻译 = 语义分析 + 中间代码生成</p>
<h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><p>如何表示语义信息？为文法符号设置语义属性，用来表示语法成分对应的语义信息。</p>
<p>语法制导定义：是对上下文无关文法的推广，将每个文法符号和一个语义属性集合相关联，将每个产生式和一组语义规则相关联，这些用于计算该产生式中各文法符号的属性值</p>
<h4 id="属性文法定义的形式"><a href="#属性文法定义的形式" class="headerlink" title="属性文法定义的形式"></a>属性文法定义的形式</h4><ul>
<li>基础文法</li>
<li>每个文法符号有一组属性</li>
<li><p>每个文法产生式 <code>A ➡ α</code> 有一组形式为 <code>b := f(c1,c2,……,ck)</code> 的语义规则，其中 f 是函数，b和c1,c2,……,ck是该产生式文法符号的属性</p>
<blockquote>
<ul>
<li><p>综合属性：如果b是A的属性，c1,c2……,ck是产生式右部文法符号的属性或A的其他属性</p>
</li>
<li><p>继承属性：如果b是产生式右部某个文法符号X的属性</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>文法符号的属性分为：综合属性和继承属性。</p>
<h4 id="综合属性（Synthesized-Attribute）"><a href="#综合属性（Synthesized-Attribute）" class="headerlink" title="综合属性（Synthesized Attribute）"></a>综合属性（Synthesized Attribute）</h4><p><strong>S属性定义</strong>：仅仅使用综合属性的语法制导定义</p>
<p>例：</p>
<p><img src="/2019/09/04/Compiler/19.jpg" alt></p>
<p>语法分析树如下</p>
<p><img src="/2019/09/04/Compiler/20.jpg" alt></p>
<p>分析树的各节点属性的计算自下而上完成</p>
<h4 id="继承属性（Inherited-Attribute）"><a href="#继承属性（Inherited-Attribute）" class="headerlink" title="继承属性（Inherited Attribute）"></a>继承属性（Inherited Attribute）</h4><p>例：语法规则如下：</p>
<p><img src="/2019/09/04/Compiler/21.jpg" alt></p>
<p>分析树如下：</p>
<p><img src="/2019/09/04/Compiler/22.jpg" alt></p>
<p>分析树的依赖图如下</p>
<p><img src="/2019/09/04/Compiler/23.jpg" alt></p>
<p>其中，L ➡ L<sub>1</sub> ，id ； L<sub>1</sub>.in := L.in；addtype(id.entry , L.in)；</p>
<h3 id="基于属性文法的处理方法"><a href="#基于属性文法的处理方法" class="headerlink" title="基于属性文法的处理方法"></a>基于属性文法的处理方法</h3><h4 id="属性计算次序"><a href="#属性计算次序" class="headerlink" title="属性计算次序"></a>属性计算次序</h4><p>拓扑排序：节点的一种顺序，是的边只会从该次序中先出现的节点到后出现的节点</p>
<p>①构造输入的分析树，②构造属性依赖图，③对节点进行拓扑排序，④按拓扑排序的次序计算属性。</p>
<p>当然，也可以多次扫描分析树，如果属性文法不存在循环依赖，每次至少会计算出一个属性值，但是编译更偏向于一边扫描的处理方法。</p>
<h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><ul>
<li><p>语法分析与语义处理阶段分离</p>
</li>
<li><p>语法分析树不适合语义处理的因素：</p>
<blockquote>
<ul>
<li>提取公共左因子</li>
<li>消除左递归等引入新的产生式和符号、标点等语法要素不含任何语义信息</li>
</ul>
</blockquote>
</li>
<li><p>抽象语法树是语法分析和后续阶段的接口</p>
</li>
</ul>
<h4 id="S属性文法的自下而上的计算"><a href="#S属性文法的自下而上的计算" class="headerlink" title="S属性文法的自下而上的计算"></a>S属性文法的自下而上的计算</h4><p>将LR分析器增加一个域来保存综合属性值</p>
<h4 id="L属性文法的自上而下的计算"><a href="#L属性文法的自上而下的计算" class="headerlink" title="L属性文法的自上而下的计算"></a>L属性文法的自上而下的计算</h4><blockquote>
<p>—边分析边翻译的方式能否用于继承属性</p>
<p>属性的计算次序一定受分析方法所限定的分析树结点建立次序的限制</p>
<p>分析树的节点是自左向右生成</p>
<p>如果属性信息是自左向右流动，那么有可能在分析的同时完成属性计算。</p>
</blockquote>
<h5 id="L属性的定义"><a href="#L属性的定义" class="headerlink" title="L属性的定义"></a>L属性的定义</h5><p>如果每个产生式 A ➡ X<sub>1</sub>X<sub>2</sub>…X<sub>n</sub> 的每条语义规则计算的属性是A的综合属性；或者X<sub>j</sub> (1≤j≤n)的继承属性，但他仅依赖①该产生式中X<sub>j</sub> 左边符号 X<sub>1</sub>X<sub>2</sub>…X<sub>j-1</sub> 的属性；②A的继承属性</p>
<p>变量类型声明的语法制导定义是一个L属性定义</p>
<p>翻译方案，例：把有加减的中缀表达式翻译成后缀表达式，如果是<code>8+5-2</code>，则输出<code>8 5 + 2 -</code></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E ➡ T R</span><br><span class="line">R ➡ addop T &#123;<span class="keyword">print</span>(addop.lexeme)&#125; R1 | ε</span><br><span class="line">T ➡ num &#123;<span class="keyword">print</span>(num.val)&#125;</span><br><span class="line"></span><br><span class="line">如 <span class="number">8</span>+<span class="number">5</span><span class="number">-2</span>可翻译成:</span><br><span class="line">	E ⇒ T R ⇒ num &#123;<span class="keyword">print</span> (<span class="number">8</span>)&#125; R</span><br><span class="line">	   ⇒ num&#123;<span class="keyword">print</span> (<span class="number">8</span>)&#125;addop T&#123;<span class="keyword">print</span> (+)&#125;R</span><br><span class="line">	   ⇒ num&#123;<span class="keyword">print</span>(<span class="number">8</span>)&#125;addop num&#123;<span class="keyword">print</span>(<span class="number">5</span>)&#125;&#123;<span class="keyword">print</span> (+)&#125;R</span><br><span class="line">	   … &#123;<span class="keyword">print</span>(<span class="number">8</span>)&#125;&#123;<span class="keyword">print</span>(<span class="number">5</span>)&#125;&#123;<span class="keyword">print</span>(+)&#125;addop T&#123;<span class="keyword">print</span>(-)&#125; R</span><br><span class="line">       … &#123;<span class="keyword">print</span>(<span class="number">8</span>)&#125;&#123;<span class="keyword">print</span>(<span class="number">5</span>)&#125;&#123;<span class="keyword">print</span>(+)&#125;&#123;<span class="keyword">print</span>(<span class="number">2</span>)&#125;&#123;<span class="keyword">print</span>(-)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="预测翻译器的设计"><a href="#预测翻译器的设计" class="headerlink" title="预测翻译器的设计"></a>预测翻译器的设计</h5><p>把预测分析器的构造方法推广到翻译方案的实现</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如:产生式R ➡ +TR | ε 的分析过程</span><br><span class="line"></span><br><span class="line">procedure R;</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">if</span> lookahead = <span class="string">'+'</span> <span class="keyword">then</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">match</span> (<span class="string">'+'</span>);T;R;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">/*Do nothing*/</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>语义规则的两种描述方法：属性文法和翻译方案</p>
<ul>
<li>S属性的自下而上计算（边分析便计算）</li>
<li>L属性的自上而下计算（边分析便计算）</li>
<li>L属性的自下而上计算（边分析便计算）</li>
</ul>
<h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><strong>代码改进变换的原则</strong></p>
<ul>
<li><p>（1）<strong>等价原则</strong>。经过优化后不应改变程序运行的结果。</p>
</li>
<li><p>（2）<strong>有效原则</strong>。使优化后所产生的目标代码运行时间较短，占用的存储空间较小。</p>
</li>
<li><p>（3）<strong>合算原则</strong>。应尽可能以较低的代价取得较好的优化效果。</p>
</li>
</ul>
<p>优化：①公共子表达式删除②复写传播③死代码删除④代码外提⑤强度削弱和归纳变量删除</p>
<p>基本块：连续的语句序列，控制流从他的开始进入，并从他的末尾离开</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/StudyNote/" rel="tag"># StudyNote</a>
          
            <a href="/tags/Compilier/" rel="tag"># Compilier</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/22/Linux-Command/" rel="next" title="Linux Note">
                <i class="fa fa-chevron-left"></i> Linux Note
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/22/re/" rel="prev" title="Regular Expression">
                Regular Expression <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Magic King"/>
            
              <p class="site-author-name" itemprop="name">Magic King</p>
              <div class="site-description motion-element" itemprop="description">Now You See Me!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/%20%7C%7C%20th">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/%20%7C%7C%20tags">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Magic-King" title="GitHub &rarr; https://github.com/Magic-King" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、引论"><span class="nav-number">1.</span> <span class="nav-text">一、引论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1什么叫编译程序"><span class="nav-number">1.1.</span> <span class="nav-text">1.1什么叫编译程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2编译程序的组成"><span class="nav-number">1.2.</span> <span class="nav-text">1.2编译程序的组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、高级语言及其语法描述"><span class="nav-number">2.</span> <span class="nav-text">二、高级语言及其语法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1程序语言的语法和语义"><span class="nav-number">2.1.</span> <span class="nav-text">2.1程序语言的语法和语义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1语法"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2语义"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2语义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2程序语言的一般特征"><span class="nav-number">2.2.</span> <span class="nav-text">2.2程序语言的一般特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高级语言的分类"><span class="nav-number">2.2.1.</span> <span class="nav-text">高级语言的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3程序语言的语法描述"><span class="nav-number">2.3.</span> <span class="nav-text">2.3程序语言的语法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、字母表和符号串"><span class="nav-number">2.3.1.</span> <span class="nav-text">一、字母表和符号串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、符号串和符号串集合的运算"><span class="nav-number">2.3.2.</span> <span class="nav-text">二、符号串和符号串集合的运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、文法的直观理解"><span class="nav-number">2.3.3.</span> <span class="nav-text">三、文法的直观理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、文法和语言的形式定义"><span class="nav-number">2.3.4.</span> <span class="nav-text">四、文法和语言的形式定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-文法的定义"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">1.文法的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-推导与归约"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">2.推导与归约</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-语言的形式定义"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">3.语言的形式定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-语法树与二义性文法"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">5.语法树与二义性文法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、词法分析"><span class="nav-number">3.</span> <span class="nav-text">三、词法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-词法分析器的要求"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 词法分析器的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-词法分析器的设计"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 词法分析器的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ⅰ、输入、预处理"><span class="nav-number">3.2.1.</span> <span class="nav-text">Ⅰ、输入、预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#预处理的主要工作"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">预处理的主要工作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ⅱ、单词符号的识别：超前搜索"><span class="nav-number">3.2.2.</span> <span class="nav-text">Ⅱ、单词符号的识别：超前搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ⅲ、状态转换图"><span class="nav-number">3.2.3.</span> <span class="nav-text">Ⅲ、状态转换图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-正规表达式与有限自动机"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 正规表达式与有限自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-正规式与正规集"><span class="nav-number">3.3.1.</span> <span class="nav-text">1.正规式与正规集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#正规式及其所表示的正规集的定义："><span class="nav-number">3.3.1.1.</span> <span class="nav-text">正规式及其所表示的正规集的定义：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-确定有限自动机"><span class="nav-number">3.3.2.</span> <span class="nav-text">2.确定有限自动机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DFA"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">DFA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NFA"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">NFA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NFA和DFA的等价性"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">NFA和DFA的等价性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NFA确定化算法（-NFA-rarr-DFA-的转换）"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">NFA确定化算法（ NFA &amp;rarr; DFA  的转换）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#minDFA"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">minDFA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DFA最小化的算法：分割法（逐步分组试探法）"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">DFA最小化的算法：分割法（逐步分组试探法）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#正规式与有穷自动机的等价性（Re-hArr-NFA）"><span class="nav-number">3.3.2.7.</span> <span class="nav-text">正规式与有穷自动机的等价性（Re &amp;hArr; NFA）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#正规文法与有穷自动机的等价性"><span class="nav-number">3.3.2.8.</span> <span class="nav-text">正规文法与有穷自动机的等价性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#词法分析程序的自动构造"><span class="nav-number">3.3.2.9.</span> <span class="nav-text">词法分析程序的自动构造</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、语法分析"><span class="nav-number">4.</span> <span class="nav-text">四、语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自顶向下语法分析"><span class="nav-number">4.1.</span> <span class="nav-text">自顶向下语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-首符集、后继符集、选择集（Fisrt-Follow-Select-）"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. 首符集、后继符集、选择集（Fisrt(),Follow(),Select()）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#首符集的定义"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">首符集的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#构造算法"><span class="nav-number">4.1.1.1.1.</span> <span class="nav-text">构造算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#后继符的定义"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">后继符的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#构造算法-1"><span class="nav-number">4.1.1.2.1.</span> <span class="nav-text">构造算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择集的定义"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">选择集的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#构造算法-2"><span class="nav-number">4.1.1.3.1.</span> <span class="nav-text">构造算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-LL-1-分析法"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. LL(1)分析法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文法的等价变换"><span class="nav-number">4.1.3.</span> <span class="nav-text">文法的等价变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ⅰ提取左公共因子"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">Ⅰ提取左公共因子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Ⅱ消除左递归"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">Ⅱ消除左递归</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归下降分析程序构造"><span class="nav-number">4.1.4.</span> <span class="nav-text">递归下降分析程序构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预测分析程序"><span class="nav-number">4.1.5.</span> <span class="nav-text">预测分析程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LL-1-文法的分析过程"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">LL(1)文法的分析过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LL-1-方法的实现"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">LL(1)方法的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自底向上语法分析"><span class="nav-number">4.2.</span> <span class="nav-text">自底向上语法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#规范归约基本概念"><span class="nav-number">4.2.1.</span> <span class="nav-text">规范归约基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算符优先分析"><span class="nav-number">4.2.2.</span> <span class="nav-text">算符优先分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何从文法构造优先关系表"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">如何从文法构造优先关系表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算符优先分析算法"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">算符优先分析算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先函数"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">优先函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LR分析法"><span class="nav-number">4.2.3.</span> <span class="nav-text">LR分析法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LR分析器的逻辑结构及工作流程"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">LR分析器的逻辑结构及工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LR的分析过程"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">LR的分析过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LR-0-分析表的构造"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">LR(0)分析表的构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LR-0-项目"><span class="nav-number">4.2.3.4.</span> <span class="nav-text">LR(0)项目</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#LR-0-项目的分类"><span class="nav-number">4.2.3.4.1.</span> <span class="nav-text">LR(0)项目的分类</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#closure-I-的定义"><span class="nav-number">4.2.3.5.</span> <span class="nav-text">closure(I)的定义:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定义状态转移函数：GOTO-I-A-closure-J"><span class="nav-number">4.2.3.6.</span> <span class="nav-text">定义状态转移函数：GOTO(I,A)&#x3D;closure(J)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LR-0-分析表构造"><span class="nav-number">4.2.4.</span> <span class="nav-text">LR(0)分析表构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SLR分析表构造"><span class="nav-number">4.2.5.</span> <span class="nav-text">SLR分析表构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SLR分析表构造方法"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">SLR分析表构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#规范LR分析表构造"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">规范LR分析表构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LR-1-项目"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">LR(1)项目</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LALR分析表的构造"><span class="nav-number">4.2.5.4.</span> <span class="nav-text">LALR分析表的构造</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语法制导的翻译（Syntax-Directed-Translation）"><span class="nav-number">5.</span> <span class="nav-text">语法制导的翻译（Syntax-Directed Translation）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性文法"><span class="nav-number">5.1.</span> <span class="nav-text">属性文法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性文法定义的形式"><span class="nav-number">5.1.1.</span> <span class="nav-text">属性文法定义的形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#综合属性（Synthesized-Attribute）"><span class="nav-number">5.1.2.</span> <span class="nav-text">综合属性（Synthesized Attribute）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承属性（Inherited-Attribute）"><span class="nav-number">5.1.3.</span> <span class="nav-text">继承属性（Inherited Attribute）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于属性文法的处理方法"><span class="nav-number">5.2.</span> <span class="nav-text">基于属性文法的处理方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性计算次序"><span class="nav-number">5.2.1.</span> <span class="nav-text">属性计算次序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象语法树"><span class="nav-number">5.2.2.</span> <span class="nav-text">抽象语法树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S属性文法的自下而上的计算"><span class="nav-number">5.2.3.</span> <span class="nav-text">S属性文法的自下而上的计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L属性文法的自上而下的计算"><span class="nav-number">5.2.4.</span> <span class="nav-text">L属性文法的自上而下的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#L属性的定义"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">L属性的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#预测翻译器的设计"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">预测翻译器的设计</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中间代码生成"><span class="nav-number">6.</span> <span class="nav-text">中间代码生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码优化"><span class="nav-number">7.</span> <span class="nav-text">代码优化</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Magic King</span>

  

  
</div>



  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0 </div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-2' count='666' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

  
  
	<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
